# Comparing `tmp/jarvis_ironman-3.0a0-py3-none-any.whl.zip` & `tmp/jarvis_ironman-3.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,148 +1,145 @@
-Zip file size: 3462714 bytes, number of entries: 146
--rw-r--r--  2.0 unx     1090 b- defN 23-May-08 23:12 jarvis/__init__.py
--rw-r--r--  2.0 unx     9396 b- defN 23-May-08 23:12 jarvis/main.py
--rw-r--r--  2.0 unx     2642 b- defN 23-May-08 23:12 jarvis/_preexec/keywords_handler.py
--rw-r--r--  2.0 unx     1911 b- defN 23-May-08 23:12 jarvis/api/fast.py
--rw-r--r--  2.0 unx     2444 b- defN 23-May-08 23:12 jarvis/api/server.py
--rw-r--r--  2.0 unx     2388 b- defN 23-May-08 23:12 jarvis/api/modals/authenticator.py
--rw-r--r--  2.0 unx     1133 b- defN 23-May-08 23:12 jarvis/api/modals/models.py
--rw-r--r--  2.0 unx     2422 b- defN 23-May-08 23:12 jarvis/api/modals/settings.py
--rw-r--r--  2.0 unx     1968 b- defN 23-May-08 23:12 jarvis/api/routers/basics.py
--rw-r--r--  2.0 unx     3098 b- defN 23-May-08 23:12 jarvis/api/routers/fileio.py
--rw-r--r--  2.0 unx     6069 b- defN 23-May-08 23:12 jarvis/api/routers/investment.py
--rw-r--r--  2.0 unx     7843 b- defN 23-May-08 23:12 jarvis/api/routers/offline.py
--rw-r--r--  2.0 unx     2086 b- defN 23-May-08 23:12 jarvis/api/routers/secure_send.py
--rw-r--r--  2.0 unx     4334 b- defN 23-May-08 23:12 jarvis/api/routers/speech_synthesis.py
--rw-r--r--  2.0 unx    13659 b- defN 23-May-08 23:12 jarvis/api/routers/stock_monitor.py
--rw-r--r--  2.0 unx    12943 b- defN 23-May-08 23:12 jarvis/api/routers/surveillance.py
--rw-r--r--  2.0 unx     2668 b- defN 23-May-08 23:12 jarvis/api/squire/discover.py
--rw-r--r--  2.0 unx    15406 b- defN 23-May-08 23:12 jarvis/api/squire/favicon.ico
--rw-r--r--  2.0 unx     1283 b- defN 23-May-08 23:12 jarvis/api/squire/logger.py
--rw-r--r--  2.0 unx     2879 b- defN 23-May-08 23:12 jarvis/api/squire/scheduler.py
--rw-r--r--  2.0 unx     6487 b- defN 23-May-08 23:12 jarvis/api/squire/stockmonitor_squire.py
--rw-r--r--  2.0 unx     5237 b- defN 23-May-08 23:12 jarvis/api/squire/surveillance_squire.py
--rw-r--r--  2.0 unx      740 b- defN 23-May-08 23:12 jarvis/api/squire/timeout_otp.py
--rw-r--r--  2.0 unx    11313 b- defN 23-May-08 23:12 jarvis/api/triggers/stock_monitor.py
--rw-r--r--  2.0 unx    11491 b- defN 23-May-08 23:12 jarvis/api/triggers/stock_report.py
--rw-r--r--  2.0 unx     8213 b- defN 23-May-08 23:12 jarvis/executors/alarm.py
--rw-r--r--  2.0 unx     5531 b- defN 23-May-08 23:12 jarvis/executors/automation.py
--rw-r--r--  2.0 unx     5093 b- defN 23-May-08 23:12 jarvis/executors/background_task.py
--rw-r--r--  2.0 unx    24756 b- defN 23-May-08 23:12 jarvis/executors/car.py
--rw-r--r--  2.0 unx     8533 b- defN 23-May-08 23:12 jarvis/executors/comm_squire.py
--rw-r--r--  2.0 unx     6554 b- defN 23-May-08 23:12 jarvis/executors/commander.py
--rw-r--r--  2.0 unx     5238 b- defN 23-May-08 23:12 jarvis/executors/communicator.py
--rw-r--r--  2.0 unx     3876 b- defN 23-May-08 23:12 jarvis/executors/conditions.py
--rw-r--r--  2.0 unx     2305 b- defN 23-May-08 23:12 jarvis/executors/connection.py
--rw-r--r--  2.0 unx    12870 b- defN 23-May-08 23:12 jarvis/executors/controls.py
--rw-r--r--  2.0 unx     1156 b- defN 23-May-08 23:12 jarvis/executors/crontab.py
--rw-r--r--  2.0 unx     2584 b- defN 23-May-08 23:12 jarvis/executors/date_time.py
--rw-r--r--  2.0 unx     1069 b- defN 23-May-08 23:12 jarvis/executors/display_functions.py
--rw-r--r--  2.0 unx     3922 b- defN 23-May-08 23:12 jarvis/executors/face.py
--rw-r--r--  2.0 unx     4063 b- defN 23-May-08 23:12 jarvis/executors/files.py
--rw-r--r--  2.0 unx     3680 b- defN 23-May-08 23:12 jarvis/executors/functions.py
--rw-r--r--  2.0 unx     4025 b- defN 23-May-08 23:12 jarvis/executors/github.py
--rw-r--r--  2.0 unx    10642 b- defN 23-May-08 23:12 jarvis/executors/guard.py
--rw-r--r--  2.0 unx     7183 b- defN 23-May-08 23:12 jarvis/executors/internet.py
--rw-r--r--  2.0 unx     6229 b- defN 23-May-08 23:12 jarvis/executors/ios_functions.py
--rw-r--r--  2.0 unx    10053 b- defN 23-May-08 23:12 jarvis/executors/lights.py
--rw-r--r--  2.0 unx     5170 b- defN 23-May-08 23:12 jarvis/executors/lights_squire.py
--rw-r--r--  2.0 unx     2466 b- defN 23-May-08 23:12 jarvis/executors/listener_controls.py
--rw-r--r--  2.0 unx    13475 b- defN 23-May-08 23:12 jarvis/executors/location.py
--rw-r--r--  2.0 unx     3297 b- defN 23-May-08 23:12 jarvis/executors/myq_controller.py
--rw-r--r--  2.0 unx    15775 b- defN 23-May-08 23:12 jarvis/executors/offline.py
--rw-r--r--  2.0 unx    22859 b- defN 23-May-08 23:12 jarvis/executors/others.py
--rw-r--r--  2.0 unx     2878 b- defN 23-May-08 23:12 jarvis/executors/port_handler.py
--rw-r--r--  2.0 unx     8485 b- defN 23-May-08 23:12 jarvis/executors/processor.py
--rw-r--r--  2.0 unx     7282 b- defN 23-May-08 23:12 jarvis/executors/remind.py
--rw-r--r--  2.0 unx     3278 b- defN 23-May-08 23:12 jarvis/executors/robinhood.py
--rw-r--r--  2.0 unx     3604 b- defN 23-May-08 23:12 jarvis/executors/simulator.py
--rw-r--r--  2.0 unx     3351 b- defN 23-May-08 23:12 jarvis/executors/static_responses.py
--rw-r--r--  2.0 unx     8545 b- defN 23-May-08 23:12 jarvis/executors/system.py
--rw-r--r--  2.0 unx     1717 b- defN 23-May-08 23:12 jarvis/executors/telegram.py
--rw-r--r--  2.0 unx     5269 b- defN 23-May-08 23:12 jarvis/executors/todo_list.py
--rw-r--r--  2.0 unx     6640 b- defN 23-May-08 23:12 jarvis/executors/tv.py
--rw-r--r--  2.0 unx     6305 b- defN 23-May-08 23:12 jarvis/executors/tv_controls.py
--rw-r--r--  2.0 unx     4850 b- defN 23-May-08 23:12 jarvis/executors/unconditional.py
--rw-r--r--  2.0 unx     2294 b- defN 23-May-08 23:12 jarvis/executors/volume.py
--rw-r--r--  2.0 unx     5727 b- defN 23-May-08 23:12 jarvis/executors/vpn_server.py
--rw-r--r--  2.0 unx    12435 b- defN 23-May-08 23:12 jarvis/executors/weather.py
--rw-r--r--  2.0 unx     3215 b- defN 23-May-08 23:12 jarvis/executors/weather_monitor.py
--rw-r--r--  2.0 unx     2272 b- defN 23-May-08 23:12 jarvis/executors/wiki.py
--rw-r--r--  2.0 unx     1809 b- defN 23-May-08 23:12 jarvis/executors/word_match.py
--rw-r--r--  2.0 unx     9239 b- defN 23-May-08 23:12 jarvis/indicators/acknowledgement.mp3
--rw-r--r--  2.0 unx  3087321 b- defN 23-May-08 23:12 jarvis/indicators/alarm.mp3
--rw-r--r--  2.0 unx    17350 b- defN 23-May-08 23:12 jarvis/indicators/coin.mp3
--rwxr-xr-x  2.0 unx     9448 b- defN 23-May-08 23:12 jarvis/indicators/end.mp3
--rw-r--r--  2.0 unx    88953 b- defN 23-May-08 23:12 jarvis/indicators/exhaust.mp3
--rwxr-xr-x  2.0 unx    11538 b- defN 23-May-08 23:12 jarvis/indicators/start.mp3
--rw-r--r--  2.0 unx    30208 b- defN 23-May-08 23:12 jarvis/indicators/tv_connect.mp3
--rw-r--r--  2.0 unx    54740 b- defN 23-May-08 23:12 jarvis/indicators/tv_scan.mp3
--rw-r--r--  2.0 unx     8062 b- defN 23-May-08 23:12 jarvis/lib/install.sh
--rw-r--r--  2.0 unx     1021 b- defN 23-May-08 23:12 jarvis/lib/version_locked_requirements.txt
--rw-r--r--  2.0 unx      107 b- defN 23-May-08 23:12 jarvis/lib/version_upgrade_requirements.txt
--rw-r--r--  2.0 unx     1076 b- defN 23-May-08 23:12 jarvis/modules/auth_bearer.py
--rw-r--r--  2.0 unx     3488 b- defN 23-May-08 23:12 jarvis/modules/builtin_overrides.py
--rw-r--r--  2.0 unx     4322 b- defN 23-May-08 23:12 jarvis/modules/exceptions.py
--rw-r--r--  2.0 unx     1401 b- defN 23-May-08 23:12 jarvis/modules/peripherals.py
--rw-r--r--  2.0 unx     2424 b- defN 23-May-08 23:12 jarvis/modules/audio/listener.py
--rw-r--r--  2.0 unx     6132 b- defN 23-May-08 23:12 jarvis/modules/audio/speaker.py
--rw-r--r--  2.0 unx     4829 b- defN 23-May-08 23:12 jarvis/modules/audio/speech_synthesis.py
--rw-r--r--  2.0 unx     2963 b- defN 23-May-08 23:12 jarvis/modules/audio/tts_stt.py
--rw-r--r--  2.0 unx     2628 b- defN 23-May-08 23:12 jarvis/modules/audio/voices.py
--rw-r--r--  2.0 unx     7098 b- defN 23-May-08 23:12 jarvis/modules/camera/camera.py
--rw-r--r--  2.0 unx     9371 b- defN 23-May-08 23:12 jarvis/modules/car/connector.py
--rw-r--r--  2.0 unx    30523 b- defN 23-May-08 23:12 jarvis/modules/car/controller.py
--rw-r--r--  2.0 unx     2762 b- defN 23-May-08 23:12 jarvis/modules/conditions/conversation.py
--rw-r--r--  2.0 unx      194 b- defN 23-May-08 23:12 jarvis/modules/conditions/keywords.py
--rw-r--r--  2.0 unx     5504 b- defN 23-May-08 23:12 jarvis/modules/conditions/keywords_base.py
--rw-r--r--  2.0 unx    12259 b- defN 23-May-08 23:12 jarvis/modules/crontab/expression.py
--rw-r--r--  2.0 unx     4143 b- defN 23-May-08 23:12 jarvis/modules/database/database.py
--rw-r--r--  2.0 unx     1645 b- defN 23-May-08 23:12 jarvis/modules/dictionary/dictionary.py
--rw-r--r--  2.0 unx     7228 b- defN 23-May-08 23:12 jarvis/modules/facenet/face.py
--rw-r--r--  2.0 unx      639 b- defN 23-May-08 23:12 jarvis/modules/lights/preset_values.py
--rw-r--r--  2.0 unx     7734 b- defN 23-May-08 23:12 jarvis/modules/lights/smart_lights.py
--rw-r--r--  2.0 unx     3645 b- defN 23-May-08 23:12 jarvis/modules/logger/config.py
--rw-r--r--  2.0 unx     4109 b- defN 23-May-08 23:12 jarvis/modules/logger/custom_logger.py
--rw-r--r--  2.0 unx     7940 b- defN 23-May-08 23:12 jarvis/modules/meetings/events.py
--rw-r--r--  2.0 unx     4356 b- defN 23-May-08 23:12 jarvis/modules/meetings/ics.py
--rw-r--r--  2.0 unx     8109 b- defN 23-May-08 23:12 jarvis/modules/meetings/ics_meetings.py
--rw-r--r--  2.0 unx     8208 b- defN 23-May-08 23:12 jarvis/modules/microphone/graph_mic.py
--rw-r--r--  2.0 unx     2848 b- defN 23-May-08 23:12 jarvis/modules/microphone/recognizer.py
--rw-r--r--  2.0 unx    20547 b- defN 23-May-08 23:12 jarvis/modules/models/classes.py
--rw-r--r--  2.0 unx    12736 b- defN 23-May-08 23:12 jarvis/modules/models/models.py
--rw-r--r--  2.0 unx     4503 b- defN 23-May-08 23:12 jarvis/modules/myq/myq.py
--rw-r--r--  2.0 unx     2712 b- defN 23-May-08 23:12 jarvis/modules/retry/retry.py
--rw-r--r--  2.0 unx     5352 b- defN 23-May-08 23:12 jarvis/modules/speaker/speak.py
--rw-r--r--  2.0 unx     2050 b- defN 23-May-08 23:12 jarvis/modules/telegram/audio_handler.py
--rw-r--r--  2.0 unx    27804 b- defN 23-May-08 23:12 jarvis/modules/telegram/bot.py
--rw-r--r--  2.0 unx     2969 b- defN 23-May-08 23:12 jarvis/modules/telegram/file_handler.py
--rw-r--r--  2.0 unx     1616 b- defN 23-May-08 23:12 jarvis/modules/temperature/temperature.py
--rw-r--r--  2.0 unx     2821 b- defN 23-May-08 23:12 jarvis/modules/templates/car_report.html
--rw-r--r--  2.0 unx    25812 b- defN 23-May-08 23:12 jarvis/modules/templates/email.html
--rw-r--r--  2.0 unx     3383 b- defN 23-May-08 23:12 jarvis/modules/templates/email_OTP.html
--rw-r--r--  2.0 unx      367 b- defN 23-May-08 23:12 jarvis/modules/templates/email_stock_alert.html
--rw-r--r--  2.0 unx      127 b- defN 23-May-08 23:12 jarvis/modules/templates/email_threat_audio.html
--rw-r--r--  2.0 unx      135 b- defN 23-May-08 23:12 jarvis/modules/templates/email_threat_image.html
--rw-r--r--  2.0 unx      179 b- defN 23-May-08 23:12 jarvis/modules/templates/email_threat_image_audio.html
--rw-r--r--  2.0 unx     2284 b- defN 23-May-08 23:12 jarvis/modules/templates/robinhood.html
--rw-r--r--  2.0 unx     2370 b- defN 23-May-08 23:12 jarvis/modules/templates/surveillance.html
--rw-r--r--  2.0 unx     2059 b- defN 23-May-08 23:12 jarvis/modules/templates/templates.py
--rw-r--r--  2.0 unx      637 b- defN 23-May-08 23:12 jarvis/modules/templates/win_wifi_config.xml
--rw-r--r--  2.0 unx     2070 b- defN 23-May-08 23:12 jarvis/modules/timeout/timeout.py
--rw-r--r--  2.0 unx     6988 b- defN 23-May-08 23:12 jarvis/modules/transformer/gpt.py
--rw-r--r--  2.0 unx     8036 b- defN 23-May-08 23:12 jarvis/modules/tv/lg.py
--rw-r--r--  2.0 unx     7675 b- defN 23-May-08 23:12 jarvis/modules/tv/roku.py
--rw-r--r--  2.0 unx      468 b- defN 23-May-08 23:12 jarvis/modules/utils/shared.py
--rw-r--r--  2.0 unx    19007 b- defN 23-May-08 23:12 jarvis/modules/utils/support.py
--rw-r--r--  2.0 unx     9800 b- defN 23-May-08 23:12 jarvis/modules/utils/util.py
--rw-r--r--  2.0 unx     2169 b- defN 23-May-08 23:12 jarvis/modules/wakeonlan/wakeonlan.py
--rwxr-xr-x  2.0 unx     1044 b- defN 23-May-08 23:12 jarvis/scripts/applauncher.scpt
--rwxr-xr-x  2.0 unx     2750 b- defN 23-May-08 23:12 jarvis/scripts/calendar.scpt
--rwxr-xr-x  2.0 unx     2504 b- defN 23-May-08 23:12 jarvis/scripts/outlook.scpt
--rwxr-xr-x  2.0 unx     8062 b- defN 23-May-08 23:12 jarvis_ironman-3.0a0.data/scripts/install.sh
--rw-r--r--  2.0 unx     1078 b- defN 23-May-08 23:13 jarvis_ironman-3.0a0.dist-info/LICENSE
--rw-r--r--  2.0 unx    31575 b- defN 23-May-08 23:13 jarvis_ironman-3.0a0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-08 23:13 jarvis_ironman-3.0a0.dist-info/WHEEL
--rw-r--r--  2.0 unx        7 b- defN 23-May-08 23:13 jarvis_ironman-3.0a0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    12976 b- defN 23-May-08 23:13 jarvis_ironman-3.0a0.dist-info/RECORD
-146 files, 4135832 bytes uncompressed, 3442208 bytes compressed:  16.8%
+Zip file size: 3293702 bytes, number of entries: 143
+-rw-r--r--  2.0 unx     1089 b- defN 23-Jul-01 14:59 jarvis/__init__.py
+-rw-r--r--  2.0 unx     9166 b- defN 23-Jul-01 14:59 jarvis/main.py
+-rw-r--r--  2.0 unx     2069 b- defN 23-Jul-01 14:59 jarvis/_preexec/keywords_handler.py
+-rw-r--r--  2.0 unx     1911 b- defN 23-Jul-01 14:59 jarvis/api/fast.py
+-rw-r--r--  2.0 unx     2444 b- defN 23-Jul-01 14:59 jarvis/api/server.py
+-rw-r--r--  2.0 unx     2388 b- defN 23-Jul-01 14:59 jarvis/api/modals/authenticator.py
+-rw-r--r--  2.0 unx     1133 b- defN 23-Jul-01 14:59 jarvis/api/modals/models.py
+-rw-r--r--  2.0 unx     2422 b- defN 23-Jul-01 14:59 jarvis/api/modals/settings.py
+-rw-r--r--  2.0 unx     1959 b- defN 23-Jul-01 14:59 jarvis/api/routers/basics.py
+-rw-r--r--  2.0 unx     3098 b- defN 23-Jul-01 14:59 jarvis/api/routers/fileio.py
+-rw-r--r--  2.0 unx     6069 b- defN 23-Jul-01 14:59 jarvis/api/routers/investment.py
+-rw-r--r--  2.0 unx     7867 b- defN 23-Jul-01 14:59 jarvis/api/routers/offline.py
+-rw-r--r--  2.0 unx     2086 b- defN 23-Jul-01 14:59 jarvis/api/routers/secure_send.py
+-rw-r--r--  2.0 unx     4334 b- defN 23-Jul-01 14:59 jarvis/api/routers/speech_synthesis.py
+-rw-r--r--  2.0 unx    13659 b- defN 23-Jul-01 14:59 jarvis/api/routers/stock_monitor.py
+-rw-r--r--  2.0 unx    12943 b- defN 23-Jul-01 14:59 jarvis/api/routers/surveillance.py
+-rw-r--r--  2.0 unx     2668 b- defN 23-Jul-01 14:59 jarvis/api/squire/discover.py
+-rw-r--r--  2.0 unx    15406 b- defN 23-Jul-01 14:59 jarvis/api/squire/favicon.ico
+-rw-r--r--  2.0 unx     1283 b- defN 23-Jul-01 14:59 jarvis/api/squire/logger.py
+-rw-r--r--  2.0 unx     2879 b- defN 23-Jul-01 14:59 jarvis/api/squire/scheduler.py
+-rw-r--r--  2.0 unx     6487 b- defN 23-Jul-01 14:59 jarvis/api/squire/stockmonitor_squire.py
+-rw-r--r--  2.0 unx     5237 b- defN 23-Jul-01 14:59 jarvis/api/squire/surveillance_squire.py
+-rw-r--r--  2.0 unx      740 b- defN 23-Jul-01 14:59 jarvis/api/squire/timeout_otp.py
+-rw-r--r--  2.0 unx    11313 b- defN 23-Jul-01 14:59 jarvis/api/triggers/stock_monitor.py
+-rw-r--r--  2.0 unx    11491 b- defN 23-Jul-01 14:59 jarvis/api/triggers/stock_report.py
+-rw-r--r--  2.0 unx     8213 b- defN 23-Jul-01 14:59 jarvis/executors/alarm.py
+-rw-r--r--  2.0 unx     6130 b- defN 23-Jul-01 14:59 jarvis/executors/automation.py
+-rw-r--r--  2.0 unx     5400 b- defN 23-Jul-01 14:59 jarvis/executors/background_task.py
+-rw-r--r--  2.0 unx    25356 b- defN 23-Jul-01 14:59 jarvis/executors/car.py
+-rw-r--r--  2.0 unx     8539 b- defN 23-Jul-01 14:59 jarvis/executors/comm_squire.py
+-rw-r--r--  2.0 unx     6578 b- defN 23-Jul-01 14:59 jarvis/executors/commander.py
+-rw-r--r--  2.0 unx     5238 b- defN 23-Jul-01 14:59 jarvis/executors/communicator.py
+-rw-r--r--  2.0 unx     4482 b- defN 23-Jul-01 14:59 jarvis/executors/conditions.py
+-rw-r--r--  2.0 unx     2305 b- defN 23-Jul-01 14:59 jarvis/executors/connection.py
+-rw-r--r--  2.0 unx    13219 b- defN 23-Jul-01 14:59 jarvis/executors/controls.py
+-rw-r--r--  2.0 unx     1156 b- defN 23-Jul-01 14:59 jarvis/executors/crontab.py
+-rw-r--r--  2.0 unx     1863 b- defN 23-Jul-01 14:59 jarvis/executors/custom_conditions.py
+-rw-r--r--  2.0 unx     2584 b- defN 23-Jul-01 14:59 jarvis/executors/date_time.py
+-rw-r--r--  2.0 unx     1069 b- defN 23-Jul-01 14:59 jarvis/executors/display_functions.py
+-rw-r--r--  2.0 unx     3922 b- defN 23-Jul-01 14:59 jarvis/executors/face.py
+-rw-r--r--  2.0 unx     6596 b- defN 23-Jul-01 14:59 jarvis/executors/files.py
+-rw-r--r--  2.0 unx     3577 b- defN 23-Jul-01 14:59 jarvis/executors/functions.py
+-rw-r--r--  2.0 unx     4028 b- defN 23-Jul-01 14:59 jarvis/executors/github.py
+-rw-r--r--  2.0 unx    10657 b- defN 23-Jul-01 14:59 jarvis/executors/guard.py
+-rw-r--r--  2.0 unx     7180 b- defN 23-Jul-01 14:59 jarvis/executors/internet.py
+-rw-r--r--  2.0 unx     6235 b- defN 23-Jul-01 14:59 jarvis/executors/ios_functions.py
+-rw-r--r--  2.0 unx     9710 b- defN 23-Jul-01 14:59 jarvis/executors/lights.py
+-rw-r--r--  2.0 unx     5170 b- defN 23-Jul-01 14:59 jarvis/executors/lights_squire.py
+-rw-r--r--  2.0 unx     2595 b- defN 23-Jul-01 14:59 jarvis/executors/listener_controls.py
+-rw-r--r--  2.0 unx    13475 b- defN 23-Jul-01 14:59 jarvis/executors/location.py
+-rw-r--r--  2.0 unx     3297 b- defN 23-Jul-01 14:59 jarvis/executors/myq_controller.py
+-rw-r--r--  2.0 unx    15444 b- defN 23-Jul-01 14:59 jarvis/executors/offline.py
+-rw-r--r--  2.0 unx    22874 b- defN 23-Jul-01 14:59 jarvis/executors/others.py
+-rw-r--r--  2.0 unx     2878 b- defN 23-Jul-01 14:59 jarvis/executors/port_handler.py
+-rw-r--r--  2.0 unx     8485 b- defN 23-Jul-01 14:59 jarvis/executors/processor.py
+-rw-r--r--  2.0 unx     7282 b- defN 23-Jul-01 14:59 jarvis/executors/remind.py
+-rw-r--r--  2.0 unx     3278 b- defN 23-Jul-01 14:59 jarvis/executors/robinhood.py
+-rw-r--r--  2.0 unx     3604 b- defN 23-Jul-01 14:59 jarvis/executors/simulator.py
+-rw-r--r--  2.0 unx     3401 b- defN 23-Jul-01 14:59 jarvis/executors/static_responses.py
+-rw-r--r--  2.0 unx     8370 b- defN 23-Jul-01 14:59 jarvis/executors/system.py
+-rw-r--r--  2.0 unx     1742 b- defN 23-Jul-01 14:59 jarvis/executors/telegram.py
+-rw-r--r--  2.0 unx     5272 b- defN 23-Jul-01 14:59 jarvis/executors/todo_list.py
+-rw-r--r--  2.0 unx     6854 b- defN 23-Jul-01 14:59 jarvis/executors/tv.py
+-rw-r--r--  2.0 unx     6327 b- defN 23-Jul-01 14:59 jarvis/executors/tv_controls.py
+-rw-r--r--  2.0 unx     4862 b- defN 23-Jul-01 14:59 jarvis/executors/unconditional.py
+-rw-r--r--  2.0 unx     2294 b- defN 23-Jul-01 14:59 jarvis/executors/volume.py
+-rw-r--r--  2.0 unx     5727 b- defN 23-Jul-01 14:59 jarvis/executors/vpn_server.py
+-rw-r--r--  2.0 unx    12438 b- defN 23-Jul-01 14:59 jarvis/executors/weather.py
+-rw-r--r--  2.0 unx     3216 b- defN 23-Jul-01 14:59 jarvis/executors/weather_monitor.py
+-rw-r--r--  2.0 unx     2275 b- defN 23-Jul-01 14:59 jarvis/executors/wiki.py
+-rw-r--r--  2.0 unx     1809 b- defN 23-Jul-01 14:59 jarvis/executors/word_match.py
+-rw-r--r--  2.0 unx     9239 b- defN 23-Jul-01 14:59 jarvis/indicators/acknowledgement.mp3
+-rw-r--r--  2.0 unx  3087321 b- defN 23-Jul-01 14:59 jarvis/indicators/alarm.mp3
+-rw-r--r--  2.0 unx    17350 b- defN 23-Jul-01 14:59 jarvis/indicators/coin.mp3
+-rwxr-xr-x  2.0 unx     9448 b- defN 23-Jul-01 14:59 jarvis/indicators/end.mp3
+-rwxr-xr-x  2.0 unx    11538 b- defN 23-Jul-01 14:59 jarvis/indicators/start.mp3
+-rw-r--r--  2.0 unx     8114 b- defN 23-Jul-01 14:59 jarvis/lib/install.sh
+-rw-r--r--  2.0 unx     1021 b- defN 23-Jul-01 14:59 jarvis/lib/version_locked_requirements.txt
+-rw-r--r--  2.0 unx      107 b- defN 23-Jul-01 14:59 jarvis/lib/version_upgrade_requirements.txt
+-rw-r--r--  2.0 unx     1076 b- defN 23-Jul-01 14:59 jarvis/modules/auth_bearer.py
+-rw-r--r--  2.0 unx     3488 b- defN 23-Jul-01 14:59 jarvis/modules/builtin_overrides.py
+-rw-r--r--  2.0 unx     4322 b- defN 23-Jul-01 14:59 jarvis/modules/exceptions.py
+-rw-r--r--  2.0 unx     1401 b- defN 23-Jul-01 14:59 jarvis/modules/peripherals.py
+-rw-r--r--  2.0 unx     2515 b- defN 23-Jul-01 14:59 jarvis/modules/audio/listener.py
+-rw-r--r--  2.0 unx     6216 b- defN 23-Jul-01 14:59 jarvis/modules/audio/speaker.py
+-rw-r--r--  2.0 unx     5122 b- defN 23-Jul-01 14:59 jarvis/modules/audio/speech_synthesis.py
+-rw-r--r--  2.0 unx     2963 b- defN 23-Jul-01 14:59 jarvis/modules/audio/tts_stt.py
+-rw-r--r--  2.0 unx     2638 b- defN 23-Jul-01 14:59 jarvis/modules/audio/voices.py
+-rw-r--r--  2.0 unx     7098 b- defN 23-Jul-01 14:59 jarvis/modules/camera/camera.py
+-rw-r--r--  2.0 unx     9371 b- defN 23-Jul-01 14:59 jarvis/modules/car/connector.py
+-rw-r--r--  2.0 unx    30523 b- defN 23-Jul-01 14:59 jarvis/modules/car/controller.py
+-rw-r--r--  2.0 unx     2762 b- defN 23-Jul-01 14:59 jarvis/modules/conditions/conversation.py
+-rw-r--r--  2.0 unx     5606 b- defN 23-Jul-01 14:59 jarvis/modules/conditions/keywords.py
+-rw-r--r--  2.0 unx    12259 b- defN 23-Jul-01 14:59 jarvis/modules/crontab/expression.py
+-rw-r--r--  2.0 unx     4143 b- defN 23-Jul-01 14:59 jarvis/modules/database/database.py
+-rw-r--r--  2.0 unx     1645 b- defN 23-Jul-01 14:59 jarvis/modules/dictionary/dictionary.py
+-rw-r--r--  2.0 unx     7228 b- defN 23-Jul-01 14:59 jarvis/modules/facenet/face.py
+-rw-r--r--  2.0 unx      639 b- defN 23-Jul-01 14:59 jarvis/modules/lights/preset_values.py
+-rw-r--r--  2.0 unx     7743 b- defN 23-Jul-01 14:59 jarvis/modules/lights/smart_lights.py
+-rw-r--r--  2.0 unx     3645 b- defN 23-Jul-01 14:59 jarvis/modules/logger/config.py
+-rw-r--r--  2.0 unx     4109 b- defN 23-Jul-01 14:59 jarvis/modules/logger/custom_logger.py
+-rw-r--r--  2.0 unx     7951 b- defN 23-Jul-01 14:59 jarvis/modules/meetings/events.py
+-rw-r--r--  2.0 unx     4356 b- defN 23-Jul-01 14:59 jarvis/modules/meetings/ics.py
+-rw-r--r--  2.0 unx     8109 b- defN 23-Jul-01 14:59 jarvis/modules/meetings/ics_meetings.py
+-rw-r--r--  2.0 unx     8208 b- defN 23-Jul-01 14:59 jarvis/modules/microphone/graph_mic.py
+-rw-r--r--  2.0 unx     2848 b- defN 23-Jul-01 14:59 jarvis/modules/microphone/recognizer.py
+-rw-r--r--  2.0 unx    20533 b- defN 23-Jul-01 14:59 jarvis/modules/models/classes.py
+-rw-r--r--  2.0 unx    12626 b- defN 23-Jul-01 14:59 jarvis/modules/models/models.py
+-rw-r--r--  2.0 unx     4503 b- defN 23-Jul-01 14:59 jarvis/modules/myq/myq.py
+-rw-r--r--  2.0 unx     2712 b- defN 23-Jul-01 14:59 jarvis/modules/retry/retry.py
+-rw-r--r--  2.0 unx     5352 b- defN 23-Jul-01 14:59 jarvis/modules/speaker/speak.py
+-rw-r--r--  2.0 unx     2050 b- defN 23-Jul-01 14:59 jarvis/modules/telegram/audio_handler.py
+-rw-r--r--  2.0 unx    27802 b- defN 23-Jul-01 14:59 jarvis/modules/telegram/bot.py
+-rw-r--r--  2.0 unx     2969 b- defN 23-Jul-01 14:59 jarvis/modules/telegram/file_handler.py
+-rw-r--r--  2.0 unx     1616 b- defN 23-Jul-01 14:59 jarvis/modules/temperature/temperature.py
+-rw-r--r--  2.0 unx     2821 b- defN 23-Jul-01 14:59 jarvis/modules/templates/car_report.html
+-rw-r--r--  2.0 unx    25812 b- defN 23-Jul-01 14:59 jarvis/modules/templates/email.html
+-rw-r--r--  2.0 unx     3383 b- defN 23-Jul-01 14:59 jarvis/modules/templates/email_OTP.html
+-rw-r--r--  2.0 unx      367 b- defN 23-Jul-01 14:59 jarvis/modules/templates/email_stock_alert.html
+-rw-r--r--  2.0 unx      127 b- defN 23-Jul-01 14:59 jarvis/modules/templates/email_threat_audio.html
+-rw-r--r--  2.0 unx      135 b- defN 23-Jul-01 14:59 jarvis/modules/templates/email_threat_image.html
+-rw-r--r--  2.0 unx      179 b- defN 23-Jul-01 14:59 jarvis/modules/templates/email_threat_image_audio.html
+-rw-r--r--  2.0 unx     2284 b- defN 23-Jul-01 14:59 jarvis/modules/templates/robinhood.html
+-rw-r--r--  2.0 unx     2370 b- defN 23-Jul-01 14:59 jarvis/modules/templates/surveillance.html
+-rw-r--r--  2.0 unx     2059 b- defN 23-Jul-01 14:59 jarvis/modules/templates/templates.py
+-rw-r--r--  2.0 unx      637 b- defN 23-Jul-01 14:59 jarvis/modules/templates/win_wifi_config.xml
+-rw-r--r--  2.0 unx     2070 b- defN 23-Jul-01 14:59 jarvis/modules/timeout/timeout.py
+-rw-r--r--  2.0 unx     6988 b- defN 23-Jul-01 14:59 jarvis/modules/transformer/gpt.py
+-rw-r--r--  2.0 unx     8996 b- defN 23-Jul-01 14:59 jarvis/modules/tv/lg.py
+-rw-r--r--  2.0 unx     7675 b- defN 23-Jul-01 14:59 jarvis/modules/tv/roku.py
+-rw-r--r--  2.0 unx      468 b- defN 23-Jul-01 14:59 jarvis/modules/utils/shared.py
+-rw-r--r--  2.0 unx    19258 b- defN 23-Jul-01 14:59 jarvis/modules/utils/support.py
+-rw-r--r--  2.0 unx    10261 b- defN 23-Jul-01 14:59 jarvis/modules/utils/util.py
+-rw-r--r--  2.0 unx     2169 b- defN 23-Jul-01 14:59 jarvis/modules/wakeonlan/wakeonlan.py
+-rwxr-xr-x  2.0 unx     1044 b- defN 23-Jul-01 14:59 jarvis/scripts/applauncher.scpt
+-rwxr-xr-x  2.0 unx     2750 b- defN 23-Jul-01 14:59 jarvis/scripts/calendar.scpt
+-rwxr-xr-x  2.0 unx     2504 b- defN 23-Jul-01 14:59 jarvis/scripts/outlook.scpt
+-rwxr-xr-x  2.0 unx     8114 b- defN 23-Jul-01 14:59 jarvis_ironman-3.1.data/scripts/install.sh
+-rw-r--r--  2.0 unx     1078 b- defN 23-Jul-01 14:59 jarvis_ironman-3.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx    32471 b- defN 23-Jul-01 14:59 jarvis_ironman-3.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-01 14:59 jarvis_ironman-3.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Jul-01 14:59 jarvis_ironman-3.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    12696 b- defN 23-Jul-01 14:59 jarvis_ironman-3.1.dist-info/RECORD
+143 files, 3970247 bytes uncompressed, 3273638 bytes compressed:  17.5%
```

## zipnote {}

```diff
@@ -102,14 +102,17 @@
 
 Filename: jarvis/executors/controls.py
 Comment: 
 
 Filename: jarvis/executors/crontab.py
 Comment: 
 
+Filename: jarvis/executors/custom_conditions.py
+Comment: 
+
 Filename: jarvis/executors/date_time.py
 Comment: 
 
 Filename: jarvis/executors/display_functions.py
 Comment: 
 
 Filename: jarvis/executors/face.py
@@ -216,26 +219,17 @@
 
 Filename: jarvis/indicators/coin.mp3
 Comment: 
 
 Filename: jarvis/indicators/end.mp3
 Comment: 
 
-Filename: jarvis/indicators/exhaust.mp3
-Comment: 
-
 Filename: jarvis/indicators/start.mp3
 Comment: 
 
-Filename: jarvis/indicators/tv_connect.mp3
-Comment: 
-
-Filename: jarvis/indicators/tv_scan.mp3
-Comment: 
-
 Filename: jarvis/lib/install.sh
 Comment: 
 
 Filename: jarvis/lib/version_locked_requirements.txt
 Comment: 
 
 Filename: jarvis/lib/version_upgrade_requirements.txt
@@ -279,17 +273,14 @@
 
 Filename: jarvis/modules/conditions/conversation.py
 Comment: 
 
 Filename: jarvis/modules/conditions/keywords.py
 Comment: 
 
-Filename: jarvis/modules/conditions/keywords_base.py
-Comment: 
-
 Filename: jarvis/modules/crontab/expression.py
 Comment: 
 
 Filename: jarvis/modules/database/database.py
 Comment: 
 
 Filename: jarvis/modules/dictionary/dictionary.py
@@ -414,26 +405,26 @@
 
 Filename: jarvis/scripts/calendar.scpt
 Comment: 
 
 Filename: jarvis/scripts/outlook.scpt
 Comment: 
 
-Filename: jarvis_ironman-3.0a0.data/scripts/install.sh
+Filename: jarvis_ironman-3.1.data/scripts/install.sh
 Comment: 
 
-Filename: jarvis_ironman-3.0a0.dist-info/LICENSE
+Filename: jarvis_ironman-3.1.dist-info/LICENSE
 Comment: 
 
-Filename: jarvis_ironman-3.0a0.dist-info/METADATA
+Filename: jarvis_ironman-3.1.dist-info/METADATA
 Comment: 
 
-Filename: jarvis_ironman-3.0a0.dist-info/WHEEL
+Filename: jarvis_ironman-3.1.dist-info/WHEEL
 Comment: 
 
-Filename: jarvis_ironman-3.0a0.dist-info/top_level.txt
+Filename: jarvis_ironman-3.1.dist-info/top_level.txt
 Comment: 
 
-Filename: jarvis_ironman-3.0a0.dist-info/RECORD
+Filename: jarvis_ironman-3.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## jarvis/__init__.py

```diff
@@ -1,11 +1,11 @@
 import os
 from multiprocessing import current_process
 
-version = "3.0a"
+version = "3.1"
 
 install_script = os.path.join(os.path.dirname(__file__), 'lib', 'install.sh')
 
 try:
     import cv2  # noqa: F401
     import face_recognition  # noqa: F401
     import playsound  # noqa: F401
```

## jarvis/main.py

```diff
@@ -7,21 +7,21 @@
 import pvporcupine
 import pyaudio
 import yaml
 from playsound import playsound
 from pywifi import ControlConnection, ControlPeripheral
 
 from jarvis.executors import (commander, controls, internet, listener_controls,
-                              location, processor, system)
+                              location, processor)
 from jarvis.modules.audio import listener, speaker
 from jarvis.modules.exceptions import StopSignal
 from jarvis.modules.logger.custom_logger import custom_handler, logger
 from jarvis.modules.models import models
 from jarvis.modules.peripherals import audio_engine
-from jarvis.modules.utils import shared, support, util
+from jarvis.modules.utils import shared, support
 
 
 def restart_checker() -> NoReturn:
     """Operations performed during internal/external request to restart."""
     if flag := support.check_restart():
         logger.info("Restart condition is set to %s by %s", flag[0], flag[1])
         if flag[1] == "OFFLINE":
@@ -100,49 +100,50 @@
             input=True,
             frames_per_buffer=self.detector.frame_length,
             input_device_index=models.env.microphone_index
         )
 
     def executor(self) -> NoReturn:
         """Calls the listener for actionable phrase and runs the speaker node for response."""
-        logger.debug("Detected %s at %s", models.settings.bot, datetime.now())
+        logger.debug("Wake word detected at %s", datetime.now().strftime('%c'))
         if listener_controls.get_listener_state():
             playsound(sound=models.indicators.acknowledgement, block=False)
         audio_engine.close(stream=self.audio_stream)
         if phrase := listener.listen(sound=False):
             try:
                 commander.initiator(phrase=phrase)
             except Exception as error:
                 logger.critical(error)
                 logger.error(traceback.format_exc())
                 speaker.speak(text=f"I'm sorry {models.env.title}! I ran into an unknown error. "
                                    "Please check the logs for more information.")
             speaker.speak(run=True)
         self.audio_stream = self.open_stream()
+        support.write_screen(text=self.label)
 
     def start(self) -> NoReturn:
         """Runs ``audio_stream`` in a forever loop and calls ``initiator`` when the phrase ``Jarvis`` is heard."""
         try:
             wake_len = len(models.env.wake_words)
+            support.write_screen(text=self.label)
             while True:
-                util.write_screen(text=self.label)
-                pcm = struct.unpack_from("h" * self.detector.frame_length,
-                                         self.audio_stream.read(num_frames=self.detector.frame_length,
-                                                                exception_on_overflow=False))
-                result = self.detector.process(pcm=pcm)
+                result = self.detector.process(
+                    pcm=struct.unpack_from(
+                        "h" * self.detector.frame_length, self.audio_stream.read(
+                            num_frames=self.detector.frame_length, exception_on_overflow=False
+                        )
+                    )
+                )
                 if models.settings.legacy:
                     if wake_len == 1 and result:
-                        models.settings.bot = models.env.wake_words[0]
                         self.executor()
                     elif wake_len > 1 and result >= 0:
-                        models.settings.bot = models.env.wake_words[result]
                         self.executor()
                 else:
                     if result >= 0:
-                        models.settings.bot = models.env.wake_words[result]
                         self.executor()
                 if models.settings.limited:
                     continue
                 restart_checker()
                 if flag := support.check_stop():
                     logger.info("Stopper condition is set to %s by %s", flag[0], flag[1])
                     self.stop()
@@ -176,25 +177,24 @@
 
 
 def start() -> NoReturn:
     """Starts main process to activate Jarvis after checking internet connection and initiating background processes."""
     logger.info("Current Process ID: %d", models.settings.pid)
     controls.starter()
     if internet.ip_address() and internet.public_ip_info():
-        util.write_screen(text=f"INTERNET::Connected to {internet.get_connection_info() or 'the internet'}.")
+        support.write_screen(text=f"INTERNET::Connected to {internet.get_connection_info() or 'the internet'}.")
     else:
         ControlPeripheral(logger=logger).enable()
         if models.env.wifi_ssid and models.env.wifi_password and not \
                 ControlConnection(wifi_ssid=models.env.wifi_ssid, wifi_password=models.env.wifi_password,
                                   logger=logger).wifi_connector():
-            util.write_screen(text="BUMMER::Unable to connect to the Internet")
+            support.write_screen(text="BUMMER::Unable to connect to the Internet")
             speaker.speak(text=f"I was unable to connect to the internet {models.env.title}! "
                                "Please check your connection.", run=True)
-    util.write_screen(text=f"Current Process ID: {models.settings.pid}\tCurrent Volume: {models.env.volume}")
-    shared.hosted_device = system.hosted_device_info()
+    support.write_screen(text=f"Current Process ID: {models.settings.pid}\tCurrent Volume: {models.env.volume}")
     if models.settings.limited:
         # Write processes mapping file before calling start_processes with func_name flag,
         # as passing the flag will look for the file's presence
         with open(models.fileio.processes, 'w') as file:
             yaml.dump(stream=file, data={"jarvis": [models.settings.pid, ["Main Process"]]})
         if models.settings.os != models.supported_platforms.macOS:
             shared.processes = processor.start_processes(func_name="speech_synthesizer")
```

## jarvis/_preexec/keywords_handler.py

```diff
@@ -2,62 +2,49 @@
 import warnings
 from collections import OrderedDict
 from typing import NoReturn
 
 import yaml
 
 from jarvis.modules.builtin_overrides import ordered_dump, ordered_load
-from jarvis.modules.conditions import conversation, keywords, keywords_base
-from jarvis.modules.utils import util
+from jarvis.modules.conditions import conversation, keywords
+from jarvis.modules.models import models
 
 # Used by docs
-if not os.path.isdir('fileio'):
-    os.makedirs(name='fileio')
+if not os.path.isdir(models.fileio.root):
+    os.makedirs(name=models.fileio.root)
 
-_updated = {'time': 0.0}  # Instantiate a dict to store last updated time
 
-
-def rewrite_keywords(init: bool = False) -> NoReturn:
-    """Loads keywords.yaml file if available, else loads the base keywords module as an object.
-
-    Args:
-        init: Takes a boolean flag to suppress logging when triggered for the first time.
-    """
-    get_time = lambda file: os.stat(file).st_mtime  # noqa: E731
-    keywords_src = OrderedDict(**keywords_base.keyword_mapping(), **conversation.conversation_mapping())
-    keywords_dst = os.path.join('fileio', 'keywords.yaml')
-    if os.path.isfile(keywords_dst):
-        modified = get_time(keywords_dst)
-        if _updated['time'] == modified:
-            return  # Avoid reading when there are clearly no changes made
-        _updated['time'] = modified
-        with open(keywords_dst) as dst_file:
+def rewrite_keywords() -> NoReturn:
+    """Loads keywords.yaml file if available, else loads the base keywords module as an object."""
+    keywords_src = OrderedDict(**keywords.keyword_mapping(), **conversation.conversation_mapping())
+    if os.path.isfile(models.fileio.keywords):
+        with open(models.fileio.keywords) as dst_file:
             try:
                 data = ordered_load(stream=dst_file, Loader=yaml.SafeLoader) or {}
             except yaml.YAMLError as error:
                 warnings.warn(message=str(error))
                 data = None
 
         if not data:  # Either an error occurred when reading or a manual deletion
-            if data is {} and not init:  # ignore when None, since a warning would have been displayed already
+            if data is {}:
                 warnings.warn(
-                    f"\nSomething went wrong. {keywords_dst!r} appears to be empty."
-                    f"\nRe-sourcing {keywords_dst!r} from base."
+                    f"\nSomething went wrong. {models.fileio.keywords!r} appears to be empty."
+                    f"\nRe-sourcing {models.fileio.keywords!r} from base."
                 )
+        # compare as sorted, since this will allow changing the order of keywords in the yaml file
         elif sorted(list(data.keys())) == sorted(list(keywords_src.keys())) and data.values() and all(data.values()):
-            keywords.keywords = util.Dict2Class(data)
+            keywords.keywords = data
             return
         else:  # Mismatch in keys
-            if not init:
-                warnings.warn(
-                    "\nData mismatch between base keywords and custom keyword mapping."
-                    "\nPlease note: This mapping file is only to change the value for keywords, not the key(s) itself."
-                    f"\nRe-sourcing {keywords_dst!r} from base."
-                )
+            warnings.warn(
+                "\nData mismatch between base keywords and custom keyword mapping."
+                "\nPlease note: This mapping file is only to change the value for keywords, not the key(s) itself."
+                f"\nRe-sourcing {models.fileio.keywords!r} from base."
+            )
 
-    with open(keywords_dst, 'w') as dst_file:
+    with open(models.fileio.keywords, 'w') as dst_file:
         ordered_dump(stream=dst_file, data=keywords_src, indent=4)
-    _updated['time'] = get_time(keywords_dst)
-    keywords.keywords = util.Dict2Class(keywords_src)
+    keywords.keywords = keywords_src
 
 
-rewrite_keywords(init=True)
+rewrite_keywords()
```

## jarvis/api/routers/basics.py

```diff
@@ -56,8 +56,8 @@
     """Converts the keywords and conversations into a dictionary of key-value pairs.
 
     Returns:
 
         Dict[str, List[str]]:
         Key-value pairs of the keywords file.
     """
-    return {k: v for k, v in keywords_mod.keywords.__dict__.items() if isinstance(v, list)}
+    return {k: v for k, v in keywords_mod.keywords.items() if isinstance(v, list)}
```

## jarvis/api/routers/offline.py

```diff
@@ -98,46 +98,46 @@
         command = command.lower()
     else:
         command = command.translate(str.maketrans('', '', string.punctuation))  # Remove punctuations from string
     if command.lower() == 'test':
         logger.info("Test message received.")
         raise APIResponse(status_code=HTTPStatus.OK.real, detail="Test message received.")
 
-    if word_match.word_match(phrase=command, match_list=keywords.keywords.kill) and 'override' in command.lower():
+    if word_match.word_match(phrase=command, match_list=keywords.keywords['kill']) and 'override' in command.lower():
         logger.info("STOP override has been requested.")
         Thread(target=kill_power).start()
         return await process_ok_response(response=f"Shutting down now {models.env.title}!\n{support.exit_message()}",
                                          input_data=input_data)
 
-    if word_match.word_match(phrase=command, match_list=keywords.keywords.secrets) and \
+    if word_match.word_match(phrase=command, match_list=keywords.keywords['secrets']) and \
             word_match.word_match(phrase=command, match_list=('list', 'get')):
         response = others.secrets(phrase=command)
         if len(response.split()) == 1:
             response = "The secret requested can be accessed from 'secure-send' endpoint using the token below.\n" \
                        "Note that the secret cannot be retrieved again using the same token and the token will " \
                        f"expire in 5 minutes.\n\n{response}"
         raise APIResponse(status_code=HTTPStatus.OK.real, detail=response)
 
     # Keywords for which the ' and ' split should not happen.
-    ignore_and = keywords.keywords.send_notification + keywords.keywords.reminder + \
-        keywords.keywords.distance + keywords.keywords.avoid
+    ignore_and = keywords.keywords['send_notification'] + keywords.keywords['reminder'] + \
+        keywords.keywords['distance'] + keywords.keywords['avoid']
     if ' and ' in command and not word_match.word_match(phrase=command, match_list=ignore_and):
         and_response = ""
         for each in command.split(' and '):
             try:
                 and_response += f"{offline.offline_communicator(command=each)}\n"
             except Exception as error:
                 logger.error(error)
                 logger.error(traceback.format_exc())
                 and_response += error.__str__()
         logger.info("Response: %s", and_response.strip())
         return await process_ok_response(response=and_response, input_data=input_data)
 
     # Keywords for which the ' after ' split should not happen.
-    ignore_after = keywords.keywords.meetings + keywords.keywords.avoid
+    ignore_after = keywords.keywords['meetings'] + keywords.keywords['avoid']
     if ' after ' in command.lower() and not word_match.word_match(phrase=command, match_list=ignore_after):
         if delay_info := commander.timed_delay(phrase=command):
             logger.info("%s will be executed after %s", delay_info[0], support.time_converter(second=delay_info[1]))
             return await process_ok_response(response='I will execute it after '
                                                       f'{support.time_converter(second=delay_info[1])} '
                                                       f'{models.env.title}!', input_data=input_data)
     try:
```

## jarvis/executors/automation.py

```diff
@@ -1,16 +1,16 @@
 import os
+import string
 import warnings
-from datetime import datetime
-from string import punctuation
+from datetime import datetime, timedelta
 from typing import NoReturn, Union
 
-import yaml
 from deepdiff import DeepDiff
 
+from jarvis.executors import files
 from jarvis.modules.audio import speaker
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
 
 
 def automation_handler(phrase: str) -> NoReturn:
     """Handles automation file resets by renaming it to tmp if requested to disable.
@@ -39,43 +39,52 @@
 def rewrite_automator(write_data: dict) -> NoReturn:
     """Rewrites the automation file with the updated dictionary.
 
     Args:
         write_data: Takes the new dictionary as an argument.
     """
     logger.info("Data has been modified. Rewriting automation data into YAML file.")
-    with open(models.fileio.automation) as file:
-        try:
-            read_data = yaml.load(stream=file, Loader=yaml.FullLoader) or {}
-        except yaml.YAMLError as error:
-            logger.error(error)
-            read_data = {}
+    read_data = files.get_automation()
     logger.debug(DeepDiff(read_data, write_data, ignore_order=True))
-    with open(models.fileio.automation, 'w') as file:
-        yaml.dump(data=write_data, stream=file, indent=2, sort_keys=False)
+    files.put_automation(data=write_data)
+
+
+def validate_weather_alert() -> NoReturn:
+    """Adds the env var for weather alert (if present) to automation feed file."""
+    if models.env.weather_alert:
+        automation_data = files.get_automation()
+        if task_overlap := automation_data.get(models.env.weather_alert):
+            if "weather" in task_overlap.get("task"):
+                logger.info("Redundancy found in env var and automation. Skipping..")
+            else:
+                logger.warning("%s was found at '%s', appending a minute to weather alert",
+                               task_overlap, models.env.weather_alert)
+                time_overlap = datetime.strptime(models.env.weather_alert, '%I:%M %p')
+                models.env.weather_alert = (time_overlap + timedelta(minutes=1)).strftime('%I:%M %p')
+                automation_data[models.env.weather_alert] = {"task": "weather alert"}
+                files.put_automation(data=automation_data)
 
 
 def auto_helper() -> Union[str, None]:
     """Runs in a thread to help the automator function in the main module.
 
     Returns:
         str:
         Task to be executed.
     """
-    try:
-        with open(models.fileio.automation) as read_file:
-            automation_data = yaml.load(stream=read_file, Loader=yaml.FullLoader) or {}
-    except yaml.YAMLError as error:
-        logger.error(error)
+    automation_data = files.get_automation()
+    if automation_data is None:
         warnings.warn(
             "AUTOMATION FILE :: Invalid file format."
         )
         logger.error("Invalid file format. Logging automation data and renaming the file to avoid repeated errors in a "
                      "loop.\n%s\n\n%s\n\n%s" %
-                     (''.join(['*' for _ in range(120)]), read_file.read(), ''.join(['*' for _ in range(120)])))
+                     (''.join(['*' for _ in range(120)]),
+                      open(models.fileio.automation).read(),
+                      ''.join(['*' for _ in range(120)])))
         os.rename(src=models.fileio.automation, dst=models.fileio.tmp_automation)
         return
 
     for automation_time, automation_info in automation_data.items():
         if not (exec_task := automation_info.get("task")):
             logger.error("Following entry doesn't have a task.")
             logger.error("%s - %s", automation_time, automation_info)
@@ -113,11 +122,11 @@
                 logger.info("Reverting execution status flag for task: %s runs at %s", exec_task, automation_time)
                 del automation_data[automation_time]["status"]
                 rewrite_automator(write_data=automation_data)
             continue
 
         if automation_info.get("status"):
             continue
-        exec_task = exec_task.translate(str.maketrans("", "", punctuation))  # Remove punctuations from the str
+        exec_task = exec_task.translate(str.maketrans('', '', string.punctuation))  # Remove punctuations from the str
         automation_data[automation_time]["status"] = True
         rewrite_automator(write_data=automation_data)
         return exec_task
```

## jarvis/executors/background_task.py

```diff
@@ -105,11 +105,15 @@
         for t in task_info:
             try:
                 task = BackgroundTask(seconds=t.get('seconds'), task=t.get('task'), ignore_hours=t.get('ignore_hours'))
             except ValidationError as error:
                 logger.error(error)
                 remove_corrupted(t)
                 continue
+            if "restart" in task.task.lower():
+                logger.warning("Unsupervised restarts are not allowed via background tasks. Use automation instead.")
+                warnings.warn("Unsupervised restarts are not allowed via background tasks. Use automation instead.")
+                continue
             if log:
                 logger.info("'%s' will be executed every %s",
                             task.task, support.time_converter(second=task.seconds))
             yield task
```

## jarvis/executors/car.py

```diff
@@ -28,15 +28,15 @@
     if AUTHORIZATION.refresh_token and time.time() - AUTHORIZATION.expiration <= 86_400:
         # this might never happen, as the connection and vin are reused until auth expiry anyway
         connection = connector.Connect(username=models.env.car_email, refresh_token=AUTHORIZATION.refresh_token,
                                        device_id=AUTHORIZATION.device_id)
         logger.info("Using refresh token to create a connection with JLR API")
     else:
         connection = connector.Connect(username=models.env.car_email, password=models.env.car_pass,
-                                       auth_expiry=time.time() + 86_400)
+                                       auth_expiry=time.time() + 86_400)  # local epoch time
         logger.info("Using password to create a connection with JLR API")
     try:
         connection.connect()
     except EgressErrors as error:
         logger.error(error)
         connection.head = None
     if connection.head:
@@ -403,16 +403,22 @@
 
     Returns:
         str:
         Returns the vehicle's name.
     """
     control = None
     try:
-        # no need to check for expiration as connection will be reset in connector module
-        if not CONNECTION.connection:
+        # check for expiration as connection reset in connector module appears to be flaky
+        if AUTHORIZATION.refresh_token and time.time() - AUTHORIZATION.expiration <= 86_400 and CONNECTION.connection:
+            logger.info("Reusing refresh token, valid until: %s",
+                        util.epoch_to_datetime(seconds=AUTHORIZATION.expiration, format_="%B %d, %Y - %I:%M %p"))
+        else:
+            if AUTHORIZATION.expiration and time.time() - AUTHORIZATION.expiration >= 86_400:
+                logger.info("Creating a new connection since refresh token expired at: %s",
+                            util.epoch_to_datetime(seconds=AUTHORIZATION.expiration, format_="%B %d, %Y - %I:%M %p"))
             create_connection()
         control = controller.Control(connection=CONNECTION.connection, vin=CONNECTION.vin)
         attributes = ThreadPool(processes=1).apply_async(func=control.get_attributes)
         response = {}
         if operation == "LOCK":
             response = control.lock(pin=models.env.car_pin)
         elif operation == "UNLOCK":
```

## jarvis/executors/comm_squire.py

```diff
@@ -136,15 +136,15 @@
         speaker.speak(text=f"What would you like to send {models.env.title}?", run=True)
         if not (body := listener.listen()):
             return
         if 'exit' in body or 'quit' in body or 'Xzibit' in body:
             return
     speaker.speak(text=f'{body} to {number}. Do you want me to proceed?', run=True)
     if converted := listener.listen():
-        if word_match.word_match(phrase=converted, match_list=keywords.keywords.ok):
+        if word_match.word_match(phrase=converted, match_list=keywords.keywords['ok']):
             logger.info("{body} -> {number}".format(body=body, number=number))
             sms_response = communicator.send_sms(user=models.env.gmail_user, password=models.env.gmail_pass,
                                                  number=number, body=body)
             if sms_response is True:
                 speaker.speak(text=f"Message has been sent {models.env.title}!")
             else:
                 speaker.speak(text=f"I'm sorry {models.env.title}! I wasn't able to send the email. "
@@ -187,15 +187,15 @@
         if not (body := listener.listen()):
             return
         if 'exit' in body or 'quit' in body or 'Xzibit' in body:
             return
 
     speaker.speak(text=f'{body} to {to}. Do you want me to proceed?', run=True)
     if converted := listener.listen():
-        if word_match.word_match(phrase=converted, match_list=keywords.keywords.ok):
+        if word_match.word_match(phrase=converted, match_list=keywords.keywords['ok']):
             logger.info("'%s' -> '%s'", body, to)
             mail_response = communicator.send_email(body=body, recipient=to)
             if mail_response is True:
                 speaker.speak(text=f"Email has been sent {models.env.title}!")
             else:
                 speaker.speak(text=f"I'm sorry {models.env.title}! I wasn't able to send the email. "
                                    f"{mail_response}")
```

## jarvis/executors/commander.py

```diff
@@ -23,24 +23,24 @@
     Returns:
         conditions.conditions:
         Return value from ``conditions()``
     """
     exit_check = False  # this is specifically to catch the sleep command which should break the loop in renew()
 
     # Keywords for which the ' after ' split should not happen.
-    ignore_after = keywords.keywords.meetings + keywords.keywords.avoid
+    ignore_after = keywords.keywords['meetings'] + keywords.keywords['avoid']
     if ' after ' in phrase and not word_match.word_match(phrase=phrase, match_list=ignore_after):
         if delay_info := timed_delay(phrase=phrase):
             speaker.speak(text=f"I will execute it after {support.time_converter(second=delay_info[1])} "
                                f"{models.env.title}!")
             return False
 
     # Keywords for which the ' and ' split should not happen.
-    ignore_and = keywords.keywords.send_notification + keywords.keywords.reminder + \
-        keywords.keywords.distance + keywords.keywords.avoid
+    ignore_and = keywords.keywords['send_notification'] + keywords.keywords['reminder'] + \
+        keywords.keywords['distance'] + keywords.keywords['avoid']
     if ' and ' in phrase and not word_match.word_match(phrase=phrase, match_list=ignore_and):
         for each in phrase.split(' and '):
             exit_check = conditions.conditions(phrase=each.strip())
             speaker.speak(run=True)
     else:
         exit_check = conditions.conditions(phrase=phrase.strip())
     return exit_check
@@ -69,16 +69,16 @@
     Args:
         phrase: Takes the phrase spoken as an argument.
 
     Returns:
         bool:
         Returns a boolean flag whether the time delay should be applied.
     """
-    if not word_match.word_match(phrase=phrase, match_list=keywords.keywords.set_alarm) and \
-            not word_match.word_match(phrase=phrase, match_list=keywords.keywords.reminder):
+    if not word_match.word_match(phrase=phrase, match_list=keywords.keywords['set_alarm']) and \
+            not word_match.word_match(phrase=phrase, match_list=keywords.keywords['reminder']):
         split_ = phrase.split('after')
         if task := split_[0].strip():
             delay = util.delay_calculator(phrase=split_[1].strip())
             Process(target=delay_condition, kwargs={'phrase': task, 'delay': delay}).start()
             return task, delay
```

## jarvis/executors/communicator.py

```diff
@@ -6,37 +6,37 @@
 
 from jarvis.executors import word_match
 from jarvis.modules.audio import listener, speaker
 from jarvis.modules.conditions import keywords
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
 from jarvis.modules.templates import templates
-from jarvis.modules.utils import shared, support, util
+from jarvis.modules.utils import shared, support
 
 
 def read_gmail(*args) -> None:
     """Reads unread emails from the gmail account for which the credentials are stored in env variables."""
     if not all([models.env.gmail_user, models.env.gmail_pass]):
         logger.warning("Gmail username and password not found.")
         support.no_env_vars()
         return
 
-    util.write_screen(text="Fetching unread emails..")
+    support.write_screen(text="Fetching unread emails..")
     reader = gmailconnector.ReadEmail(gmail_user=models.env.gmail_user, gmail_pass=models.env.gmail_pass)
     response = reader.instantiate()
     if response.ok:
         if shared.called_by_offline:
             speaker.speak(text=f'You have {response.count} unread email {models.env.title}.') if response.count == 1 \
                 else speaker.speak(text=f'You have {response.count} unread emails {models.env.title}.')
             return
         speaker.speak(text=f'You have {response.count} unread emails {models.env.title}. Do you want me to check it?',
                       run=True)
         if not (confirmation := listener.listen()):
             return
-        if not word_match.word_match(phrase=confirmation, match_list=keywords.keywords.ok):
+        if not word_match.word_match(phrase=confirmation, match_list=keywords.keywords['ok']):
             return
         for mail in reader.read_mail(messages=response.body, humanize_datetime=True):
             speaker.speak(text=f"You have an email from, {mail.sender}, with subject, "
                                f"{mail.subject}, {mail.date_time}", run=True)
     elif response.status == 204:
         speaker.speak(text=f"You don't have any emails to catch up {models.env.title}!")
     else:
```

## jarvis/executors/conditions.py

```diff
@@ -1,13 +1,14 @@
 import warnings
 from multiprocessing import current_process
 from threading import Thread
 
-from jarvis.executors import (functions, listener_controls, others,
-                              static_responses, unconditional, word_match)
+from jarvis.executors import (custom_conditions, functions, listener_controls,
+                              others, static_responses, unconditional,
+                              word_match)
 from jarvis.modules.conditions import keywords
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.transformer import gpt
 from jarvis.modules.utils import shared, support
 
 
 def conditions(phrase: str) -> bool:
@@ -23,49 +24,57 @@
         When requested to stop Jarvis.
 
     Returns:
         bool:
         Boolean True only when asked to sleep for conditioned sleep message.
     """
     # Allow conditions during offline communication
-    if not listener_controls.get_listener_state() and not shared.called_by_offline:
+    if not shared.called_by_offline and \
+            not listener_controls.get_listener_state() and \
+            not all(("activate" in phrase or "enable" in phrase,  # WATCH OUT: "activate" and "enable" are hard coded
+                     word_match.word_match(phrase=phrase, match_list=keywords.keywords['listener_control']))):
         logger.info("Ignoring '%s' since listener is deactivated.", phrase)
         return False
     if "*" in phrase:
         others.abusive(phrase)
         return False
 
-    # # Re-sort the keyword dict object per the order in base keywords - Required only if OrderedDict is removed in base
-    # keyword_dict = {}
-    # for key, value in keywords_base.keyword_mapping().items():
-    #     keyword_dict[key] = existing_kw_dict[key]
     function_map = functions.function_mapping()
-    for category, identifiers in keywords.keywords.__dict__.items():
+    if custom_conditions.custom_conditions(phrase=phrase, function_map=function_map):
+        return False
+
+    for category, identifiers in keywords.keywords.items():
         if word_match.word_match(phrase=phrase, match_list=identifiers):
 
             # custom rules for additional keyword matching
             if category == "send_notification":
                 if "send" not in phrase.lower():
                     continue
             if category in ("distance", "kill"):
-                if word_match.word_match(phrase=phrase, match_list=keywords.keywords.avoid):
+                if word_match.word_match(phrase=phrase, match_list=keywords.keywords['avoid']):
                     continue
             if category == "speed_test":
                 if not ('internet' in phrase.lower() or 'connection' in phrase.lower() or 'run' in phrase.lower()):
                     continue
 
             # Stand alone - Internally used [skip for both main and offline processes]
-            if category in ("avoid", "ok", "exit_", "avoid", "ngrok", "secrets"):
+            if category in ("avoid", "ok", "exit_", "ngrok", "secrets"):
                 continue
 
             # Requires manual intervention [skip for offline communicator]
             if shared.called_by_offline and category in ('kill', 'report', 'repeat', 'directions', 'notes',
                                                          'music', 'voice_changer', 'restart_control', 'shutdown'):
-                static_responses.not_allowed_offline()
-                return False
+                # WATCH OUT: for changes in function name
+                if current_process().name == "background_tasks" and category == "restart_control":
+                    # Eg: Allowing 'restart' through the category 'restart_control' for the process 'background_tasks'
+                    logger.info("Allowing '%s' through the category '%s', for the process: '%s'",
+                                phrase, category, current_process().name)
+                else:
+                    static_responses.not_allowed_offline()
+                    return False
 
             if function_map.get(category):  # keyword category matches function name
                 function_map[category](phrase)  # call function with phrase as arg by default
                 if category in ("sleep_control", "sentry"):
                     return True  # repeat listeners are ended and wake word detection is activated
             else:
                 # edge case scenario if a category has matched but the function name is incorrect or not imported
```

## jarvis/executors/controls.py

```diff
@@ -10,22 +10,22 @@
 from typing import NoReturn
 
 import docker
 import psutil
 import pybrightness
 import pywslocker
 
-from jarvis.executors import listener_controls, volume, word_match
+from jarvis.executors import listener_controls, system, volume, word_match
 from jarvis.modules.audio import listener, speaker, voices
 from jarvis.modules.conditions import conversation, keywords
 from jarvis.modules.database import database
 from jarvis.modules.exceptions import StopSignal
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import shared, support, util
+from jarvis.modules.utils import shared, support
 
 db = database.Database(database=models.fileio.base_db)
 
 
 def restart(ask: bool = True) -> NoReturn:
     """Restart the host machine.
 
@@ -44,15 +44,15 @@
     if ask:
         speaker.speak(text=f"{random.choice(conversation.confirmation)} restart your "
                            f"{shared.hosted_device.get('device', 'machine')}?",
                       run=True)
         converted = listener.listen()
     else:
         converted = 'yes'
-    if word_match.word_match(phrase=converted, match_list=keywords.keywords.ok):
+    if word_match.word_match(phrase=converted, match_list=keywords.keywords['ok']):
         stop_terminals()
         if models.settings.os == models.supported_platforms.macOS:
             subprocess.call(['osascript', '-e', 'tell app "System Events" to restart'])
         elif models.settings.os == models.supported_platforms.windows:
             os.system("shutdown /r /t 1")
         else:
             os.system(f"echo {models.env.root_password} | sudo -S reboot")
@@ -84,16 +84,16 @@
     if reminders or alarms:
         speaker.speak(text="This will not be executed while I'm deactivated!")
     speaker.speak(text=f"Shutting down now {models.env.title}!")
     try:
         speaker.speak(text=support.exit_message(), run=True)
     except RuntimeError as error:
         logger.critical("ATTENTION::Received a RuntimeError while self terminating.\n%s", error)
-    util.write_screen(f"Memory consumed: {support.size_converter(0)}"
-                      f"\nTotal runtime: {support.time_converter(second=time.time() - shared.start_time)}")
+    support.write_screen(f"Memory consumed: {support.size_converter(0)}"
+                         f"\nTotal runtime: {support.time_converter(second=time.time() - shared.start_time)}")
 
 
 def sleep_control(*args) -> bool:
     """Locks the screen and reduces brightness to bare minimum."""
     Thread(target=pybrightness.decrease).start()
     pywslocker.lock()
     if not (shared.called['report'] or shared.called['time_travel']):
@@ -115,39 +115,51 @@
     Raises:
         StopSignal:
         To stop main process.
     """
     raise StopSignal
 
 
+def db_restart_entry(caller: str) -> NoReturn:
+    """Writes an entry to the DB to restart the caller.
+
+    Args:
+        caller: Name of the process that has to be restarted.
+    """
+    with db.connection:
+        cursor = db.connection.cursor()
+        cursor.execute("INSERT or REPLACE INTO restart (flag, caller) VALUES (?,?);", (True, caller))
+        cursor.connection.commit()
+
+
 def restart_control(phrase: str = None, quiet: bool = False) -> NoReturn:
     """Controls the restart functions based on the user request.
 
     Args:
         phrase: Takes the phrase spoken as an argument.
         quiet: Take a boolean flag to restart without warning.
     """
+    if quiet:  # restarted by child processes due internal errors
+        caller = sys._getframe(1).f_code.co_name  # noqa
+        logger.info("Restarting '%s'", caller)
+        db_restart_entry(caller=caller)
+        return
+    if shared.called_by_offline:  # restarted ONLY via automation.yaml
+        logger.info("Restarting all background processes!")
+        db_restart_entry(caller="OFFLINE")
+        speaker.speak(text="Restarting all background processes!")  # this is only to log the response
+        return
     if phrase:
+        if not shared.hosted_device.get('device'):
+            system.hosted_device_info()
         logger.info("Restart for %s has been requested.", shared.hosted_device.get('device'))
         restart()
     else:
-        caller = sys._getframe(1).f_code.co_name  # noqa
-        logger.info("Called by '%s'", caller)
-        if quiet:  # restarted by child processes due internal errors
-            logger.info("Restarting '%s'", caller)
-        elif shared.called_by_offline:  # restarted via automator to restart all background processes
-            logger.info("Restarting all background processes!")
-            caller = "OFFLINE"
-        else:
-            speaker.speak(text="I didn't quite get that. Did you mean restart your computer?")
-            return
-        with db.connection:
-            cursor = db.connection.cursor()
-            cursor.execute("INSERT or REPLACE INTO restart (flag, caller) VALUES (?,?);", (True, caller))
-            cursor.connection.commit()
+        speaker.speak(text="I didn't quite get that. Did you mean restart your computer?")
+        return
 
 
 def stop_terminals(apps: tuple = ("iterm", "terminal")) -> NoReturn:
     """Stops background processes.
 
     Args:
         apps: Default apps that have to be shutdown when ``deep`` argument is not set.
@@ -231,15 +243,15 @@
         StopSignal: To stop Jarvis' PID.
     """
     if not proceed:
         speaker.speak(text=f"{random.choice(conversation.confirmation)} turn off the machine?", run=True)
         converted = listener.listen()
     else:
         converted = 'yes'
-    if word_match.word_match(phrase=converted, match_list=keywords.keywords.ok):
+    if word_match.word_match(phrase=converted, match_list=keywords.keywords['ok']):
         stop_terminals()
         if models.settings.os == models.supported_platforms.macOS:
             subprocess.call(['osascript', '-e', 'tell app "System Events" to shut down'])
         elif models.settings.os == models.supported_platforms.windows:
             os.system("shutdown /s /t 1")
         else:
             os.system(f"echo {models.env.root_password} | sudo -S shutdown -P now")
```

## jarvis/executors/face.py

```diff
@@ -8,23 +8,23 @@
 
 from jarvis.executors import word_match
 from jarvis.modules.audio import listener, speaker
 from jarvis.modules.exceptions import CameraError
 from jarvis.modules.facenet.face import FaceNet
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import support, util
+from jarvis.modules.utils import support
 
 TRAINING_DIR = os.path.realpath("train")
 FACE_DETECTION_TEMP_FILE = 'cv2_open.jpg'
 
 
 def detected_face() -> NoReturn:
     """Captures a picture, shows a preview and stores it for future recognition."""
-    util.write_screen(text='New face has been detected. Like to give it a name?')
+    support.write_screen(text='New face has been detected. Like to give it a name?')
     speaker.speak(text='I was able to detect a face, but was unable to recognize it.')
     Image.open(FACE_DETECTION_TEMP_FILE).show()
     speaker.speak(text=f"I've taken a photo of you. Preview on your screen {models.env.title}! "
                        "Please tell me a name if you'd like to recognize this face in the future, or simply say exit.",
                   run=True)
     phrase = listener.listen()
     if not phrase or 'exit' in phrase or 'quit' in phrase or 'Xzibit' in phrase:
@@ -47,15 +47,15 @@
     if word_match.word_match(phrase=phrase, match_list=("detect", "detection", "faces", "look")):
         if FaceNet().face_detection(retry_count=5):
             detected_face()
     else:
         if os.path.isdir(TRAINING_DIR) and \
                 set(os.path.dirname(p) for p in glob.glob(os.path.join(TRAINING_DIR, "*", ""), recursive=True)):
             speaker.speak(text='Initializing facial recognition. Please smile at the camera for me.', run=True)
-            util.write_screen(text='Looking for faces to recognize.')
+            support.write_screen(text='Looking for faces to recognize.')
             try:
                 result = FaceNet().face_recognition(location=TRAINING_DIR)
             except CameraError:
                 support.flush_screen()
                 logger.error('Unable to access the camera.')
                 speaker.speak(text="I was unable to access the camera. Facial recognition can work only when a camera "
                                    "is present and accessible.")
```

## jarvis/executors/files.py

```diff
@@ -109,7 +109,79 @@
     """
     existing = get_secure_send()
     with open(models.fileio.secure_send, 'w') as file:
         yaml.dump(data={**existing, **data}, stream=file, Dumper=yaml.SafeDumper)
         file.flush()  # Write buffer to file immediately
     logger.info("Secure dict for [%s] will be cleared after 5 minutes", [*[*data.values()][0].keys()][0])
     Timer(function=delete_secure_send, args=data.keys(), interval=300).start()
+
+
+def get_custom_conditions() -> Dict[str, Dict[str, str]]:
+    """Custom conditions to map specific keywords to one or many functions.
+
+    Returns:
+        A unique key value pair of custom phrase as key and an embedded dict of function name and phrase.
+    """
+    if models.fileio.conditions:
+        with open(models.fileio.conditions) as file:
+            try:
+                return yaml.load(stream=file, Loader=yaml.SafeLoader)
+            except yaml.YAMLError as error:
+                logger.error(error)
+
+
+def get_automation() -> Dict[str, Dict[str, Union[str, bool]]]:
+    """Load automation data from feed file.
+
+    Returns:
+        Dict[str, Dict[str, Union[str, bool]]]:
+        Returns the automation data in the feed file.
+    """
+    if os.path.isfile(models.fileio.automation):
+        try:
+            with open(models.fileio.automation) as read_file:
+                return yaml.load(stream=read_file, Loader=yaml.FullLoader) or {}
+        except yaml.YAMLError as error:
+            logger.error(error)
+
+
+def put_automation(data: Dict[str, Dict[str, Union[str, bool]]]) -> NoReturn:
+    """Dumps automation data into feed file.
+
+    Args:
+        data: Data that has to be dumped into the automation feed file.
+    """
+    with open(models.fileio.automation, 'w') as file:
+        yaml.dump(data=data, stream=file, indent=2, sort_keys=False)
+        file.flush()  # Write buffer to file immediately
+
+
+def get_smart_devices() -> Union[dict, bool]:
+    """Load smart devices' data from feed file.
+
+    Returns:
+        Union[dict, bool]:
+        Returns the smart devices' data in the feed file.
+    """
+    if os.path.isfile(models.fileio.smart_devices):
+        try:
+            with open(models.fileio.smart_devices) as file:
+                if smart_devices := yaml.load(stream=file, Loader=yaml.FullLoader):
+                    return smart_devices
+                else:
+                    logger.warning("'%s' is empty.", models.fileio.smart_devices)
+        except yaml.YAMLError as error:
+            logger.error(error)
+            return False
+    else:
+        logger.warning("%s not found.", models.fileio.smart_devices)
+
+
+def put_smart_devices(data: dict) -> NoReturn:
+    """Dumps smart devices' data into feed file.
+
+    Args:
+        data: Data that has to be dumped into the smart devices' feed file.
+    """
+    with open(models.fileio.smart_devices, 'w') as file:
+        yaml.dump(data=data, stream=file, indent=2, sort_keys=False)
+        file.flush()  # Write buffer to file immediately
```

## jarvis/executors/functions.py

```diff
@@ -1,14 +1,13 @@
 # noinspection PyUnresolvedReferences
 """Creates a dictionary with the keyword category as key and the function to be called as value.
 
 >>> Functions
 
 """
-# todo: remove converting keyword dict as an object (that's unnecessary as dicts have lesser overhead)
 
 from collections import OrderedDict
 from typing import Callable
 
 from jarvis.executors import (alarm, automation, background_task, car,
                               comm_squire, communicator, controls, date_time,
                               display_functions, face, github, guard, internet,
```

## jarvis/executors/github.py

```diff
@@ -63,15 +63,15 @@
         cloned = target[0].split('/')[-1].replace('.git', '')
         speaker.speak(text=f"I've cloned {cloned} on your home directory {models.env.title}!")
         return
     elif len(target) <= 3:
         speaker.speak(text=f"I found {len(target)} results. On your screen {models.env.title}! "
                            "Which one shall I clone?", run=True)
         if not (converted := listener.listen()):
-            if word_match.word_match(phrase=converted, match_list=keywords.keywords.exit_):
+            if word_match.word_match(phrase=converted, match_list=keywords.keywords['exit_']):
                 return
             if 'first' in converted.lower():
                 item = 1
             elif 'second' in converted.lower():
                 item = 2
             elif 'third' in converted.lower():
                 item = 3
```

## jarvis/executors/guard.py

```diff
@@ -14,15 +14,15 @@
 from jarvis.modules.conditions import keywords
 from jarvis.modules.database import database
 from jarvis.modules.facenet import face
 from jarvis.modules.logger.config import multiprocessing_logger
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
 from jarvis.modules.templates import templates
-from jarvis.modules.utils import shared, util
+from jarvis.modules.utils import shared, support, util
 
 db = database.Database(database=models.fileio.base_db)
 TRACE = {"status": False}
 
 
 def get_state(log: bool = True) -> Tuple[int, str]:
     """Reads the state of guard column in the base db.
@@ -127,19 +127,19 @@
     """Enables microphone and camera to watch and listen for potential threats. Notifies if any."""
     if offline:
         multiprocessing_logger(filename=os.path.join('logs', 'guardian_mode_%d-%m-%Y.log'))
     notified, converted = None, None
     face_object = face.FaceNet()
     while True:
         # Listens for any recognizable speech and saves it to a notes file
-        util.write_screen(text="SECURITY MODE")
+        support.write_screen(text="SECURITY MODE")
         converted = listener.listen(sound=False)
         face_detected = datetime.now().strftime('%B_%d_%Y_%I_%M_%S_%p.jpg')
         if not get_state(log=False) or word_match.word_match(phrase=converted,
-                                                             match_list=keywords.keywords.guard_disable):
+                                                             match_list=keywords.keywords['guard_disable']):
             guard_disable()
             break
         elif converted:
             logger.info("Conversation::%s", converted)
         try:
             if not models.env.debug:  # Skip face recognition when DEBUG mode is enabled
                 if recognized := face_object.face_recognition(location=os.path.realpath("train"), retry_count=1):
```

## jarvis/executors/internet.py

```diff
@@ -9,15 +9,15 @@
 import psutil
 from speedtest import ConfigRetrievalError, Speedtest
 
 from jarvis.executors import location
 from jarvis.modules.audio import speaker
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import shared, support, util
+from jarvis.modules.utils import shared, support
 
 
 def ip_address() -> Union[str, None]:
     """Uses simple check on network id to see if it is connected to local host or not.
 
     Returns:
         str:
@@ -166,11 +166,11 @@
     if not shared.called_by_offline:
         speaker.speak(text=f"Starting speed test {models.env.title}! I.S.P: {isp}. Location: {city} {state}", run=True)
     upload_process.join()
     download_process.join()
     ping = round(st.results.ping)
     download = support.size_converter(byte_size=st.results.download)
     upload = support.size_converter(byte_size=st.results.upload)
-    util.write_screen(text=f"Ping: {ping}m/s\tDownload: {download}\tUpload: {upload}")
+    support.write_screen(text=f"Ping: {ping}m/s\tDownload: {download}\tUpload: {upload}")
     speaker.speak(text=f"Ping rate: {ping} milli seconds. "
                        f"Download speed: {download} per second. "
                        f"Upload speed: {upload} per second.")
```

## jarvis/executors/ios_functions.py

```diff
@@ -124,19 +124,19 @@
         after_keyword = after_keyword.replace(f"{models.env.name}s", "").replace(f"{models.env.name}'s", "").strip()
         speaker.speak(text=f"I've located your {after_keyword} {models.env.title}!")
     else:
         speaker.speak(text=f"Your {before_keyword} should be ringing now {models.env.title}!")
     speaker.speak(text="Would you like to get the location details?", run=True)
     if not (phrase_location := listener.listen()):
         return
-    elif not word_match.word_match(phrase=phrase_location, match_list=keywords.keywords.ok):
+    elif not word_match.word_match(phrase=phrase_location, match_list=keywords.keywords['ok']):
         return
 
     locate_device(target_device=target_device)
     if models.env.icloud_recovery:
         speaker.speak(text="I can also enable lost mode. Would you like to do it?", run=True)
         phrase_lost = listener.listen()
-        if word_match.word_match(phrase=phrase_lost, match_list=keywords.keywords.ok):
+        if word_match.word_match(phrase=phrase_lost, match_list=keywords.keywords['ok']):
             target_device.lost_device(number=models.env.icloud_recovery, text="Return my phone immediately.")
             speaker.speak(text="I've enabled lost mode on your phone.")
         else:
             speaker.speak(text=f"No action taken {models.env.title}!")
```

## jarvis/executors/lights.py

```diff
@@ -1,19 +1,16 @@
-import os
 import random
 import time
 from concurrent.futures import ThreadPoolExecutor, as_completed
 from ipaddress import IPv4Address
 from multiprocessing.pool import ThreadPool
 from threading import Thread
 from typing import Callable, Dict, List, NoReturn, Union
 
-import yaml
-
-from jarvis.executors import internet
+from jarvis.executors import files, internet
 from jarvis.executors import lights_squire as squire
 from jarvis.executors import word_match
 from jarvis.modules.audio import speaker
 from jarvis.modules.conditions import conversation
 from jarvis.modules.lights import preset_values
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
@@ -87,32 +84,24 @@
 
     Args:
         phrase: Takes the phrase spoken as an argument.
     """
     if not internet.vpn_checker():
         return
 
-    if not os.path.isfile(models.fileio.smart_devices):
-        logger.warning("%s not found.", models.fileio.smart_devices)
-        support.no_env_vars()
+    smart_devices = files.get_smart_devices()
+    if smart_devices is False:
+        speaker.speak(text=f"I'm sorry {models.env.title}! I wasn't able to read the source information.")
         return
-
-    try:
-        with open(models.fileio.smart_devices) as file:
-            lights_mapping = yaml.load(stream=file, Loader=yaml.FullLoader) or {}
-            lights_mapping = {key: value for key, value in lights_mapping.items()
-                              if 'tv' not in key.lower() and isinstance(value, list)}
-    except yaml.YAMLError as error:
-        logger.error(error)
-        speaker.speak(text=f"I'm sorry {models.env.title}! I wasn't able to read the source information. "
-                           "Please check the logs.")
-        return
-
-    if not any(lights_mapping):
-        logger.warning("'%s' is empty for lights.", models.fileio.smart_devices)
+    if smart_devices:
+        if not (lights_mapping := {key: value for key, value in smart_devices.items()
+                                   if 'tv' not in key.lower() and isinstance(value, list)}):
+            logger.warning("%s is empty for lights.", models.fileio.smart_devices)
+            return
+    else:
         support.no_env_vars()
         return
 
     phrase = phrase.lower()
 
     if 'all' in phrase.split():
         light_location = ""
```

## jarvis/executors/listener_controls.py

```diff
@@ -1,13 +1,15 @@
+import sqlite3
 from typing import NoReturn
 
 from jarvis.modules.audio import speaker
 from jarvis.modules.database import database
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
+from jarvis.modules.retry import retry
 
 db = database.Database(database=models.fileio.base_db)
 
 
 def listener_control(phrase: str) -> NoReturn:
     """Controls the listener table in base db.
 
@@ -47,14 +49,15 @@
     if state and state[0]:
         logger.debug("Listener is currently enabled")
         return True
     else:
         logger.debug("Listener is currently disabled")
 
 
+@retry.retry(attempts=3, interval=2, exclude_exc=sqlite3.OperationalError)
 def put_listener_state(state: bool) -> NoReturn:
     """Updates the state of the listener.
 
     Args:
         state: Takes the boolean value to be inserted.
     """
     logger.info("Current listener status: '%s'", get_listener_state())
```

## jarvis/executors/location.py

```diff
@@ -14,15 +14,15 @@
 from speedtest import ConfigRetrievalError, Speedtest
 from timezonefinder import TimezoneFinder
 
 from jarvis.executors import files, internet
 from jarvis.modules.audio import listener, speaker
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import shared, support, util
+from jarvis.modules.utils import shared, support
 
 # stores necessary values for geolocation to receive the latitude, longitude and address
 options.default_ssl_context = ssl.create_default_context(cafile=certifi.where())
 geo_locator = Nominatim(scheme="http", user_agent="test/1", timeout=3)
 
 
 def get_coordinates_from_ip() -> Union[Tuple[float, float], Tuple[float, ...]]:
@@ -35,16 +35,16 @@
     if (info := internet.public_ip_info()) and info.get('lcc'):
         return tuple(map(float, info.get('loc').split(',')))
     try:
         if results := Speedtest().results:
             return float(results.client["lat"]), float(results.client["lon"])
     except ConfigRetrievalError as error:
         logger.error(error)
-        util.write_screen(text="Failed to get location based on IP. Hand modify it at "
-                               f"'{os.path.abspath(models.fileio.location)}'")
+        support.write_screen(text="Failed to get location based on IP. Hand modify it at "
+                                  f"'{os.path.abspath(models.fileio.location)}'")
         time.sleep(5)
     return 37.230881, -93.3710393  # Default to SGF latitude and longitude
 
 
 def get_location_from_coordinates(coordinates: tuple) -> Dict[str, str]:
     """Uses the latitude and longitude information to get the address information.
```

## jarvis/executors/offline.py

```diff
@@ -7,89 +7,98 @@
 from typing import AnyStr, List, NoReturn, Union
 
 import requests
 from deepdiff import DeepDiff
 from pydantic import HttpUrl
 
 from jarvis.executors import (alarm, automation, background_task, conditions,
-                              crontab, listener_controls, others, remind,
-                              weather_monitor, word_match)
+                              controls, crontab, listener_controls, others,
+                              remind, weather_monitor, word_match)
 from jarvis.modules.auth_bearer import BearerAuth
 from jarvis.modules.conditions import keywords
 from jarvis.modules.database import database
 from jarvis.modules.exceptions import EgressErrors
 from jarvis.modules.logger import config
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.meetings import events, ics_meetings
 from jarvis.modules.models import classes, models
 from jarvis.modules.utils import shared, support, util
 
 db = database.Database(database=models.fileio.base_db)
 
 
 def background_tasks() -> NoReturn:
+    """Initiate the runner function for background tasks."""
+    try:
+        background_task_runner()
+    except Exception as error:
+        logger.critical("ATTENTION: %s", error.__str__())
+        controls.restart_control(quiet=True)
+
+
+def background_task_runner() -> NoReturn:
     """Trigger for background tasks, cron jobs, automation, alarms, reminders, events and meetings sync."""
     config.multiprocessing_logger(filename=os.path.join('logs', 'background_tasks_%d-%m-%Y.log'))
+    # Since env vars are loaded only during startup, validate weather alert only then
+    automation.validate_weather_alert()
     tasks: List[classes.BackgroundTask] = list(background_task.validate_tasks())
     meeting_muter = []
     if models.settings.os == models.supported_platforms.macOS:
         events.event_app_launcher()
     start_events = start_meetings = start_cron = time.time()
     task_dict = {i: time.time() for i in range(len(tasks))}  # Creates a start time for each task
     dry_run = True
     smart_listener = Queue()
-    w_alert = {'time': ''}
     while True:
         now = datetime.now()
         # Trigger background tasks
         for i, task in enumerate(tasks):
             if task_dict[i] + task.seconds <= time.time() or dry_run:  # Checks a particular tasks' elapsed time
                 task_dict[i] = time.time()  # Updates that particular tasks' start time
                 if now.hour in task.ignore_hours:
                     logger.debug("'%s' skipped honoring ignore hours", task)
                 else:
-                    logger.debug("Executing %s", task.task)
+                    logger.debug("Executing: '%s'", task.task)
                     try:
-                        response = offline_communicator(task.task) or "No response for background task"
-                        logger.debug("Response %s", response)
+                        response = offline_communicator(command=task.task) or "No response for background task"
+                        logger.debug("Response: '%s'", response)
                     except Exception as error:
                         logger.error(error)
                         logger.warning("Removing %s from background tasks.", task)
                         background_task.remove_corrupted(task=task)
 
         # Trigger cron jobs once during start up (regardless of schedule) and follow schedule after that
         if start_cron + 60 <= time.time() or dry_run:  # Condition passes every minute
             start_cron = time.time()
             for job in models.env.crontab:
                 if job.check_trigger() or dry_run:
                     if dry_run:
-                        logger.info("Executing cron job: %s during startup", job.comment)
+                        logger.info("Executing cron job: '%s' during startup", job.comment)
                     else:
-                        logger.debug("Executing cron job: %s", job.comment)
+                        logger.debug("Executing cron job: '%s'", job.comment)
                     cron_process = Process(target=crontab.crontab_executor, args=(job.comment,))
                     cron_process.start()
                     with db.connection:
                         cursor = db.connection.cursor()
                         cursor.execute("INSERT or REPLACE INTO children (crontab) VALUES (?);", (cron_process.pid,))
                         db.connection.commit()
 
         # Trigger automation
         if os.path.isfile(models.fileio.automation):
             if exec_task := automation.auto_helper():
-                # Check and trigger monitor only if it wasn't run previously, avoid duplicate check within a minute
-                if "weather" in exec_task.lower() and w_alert['time'] != now.strftime('%H:%M'):
+                # Check and trigger weather alert monitoring system
+                if "weather" in exec_task.lower():
                     # run as daemon and not store in children table as this won't take long
-                    logger.info("Initiating weather alert monitor")
+                    logger.debug("Initiating weather alert monitor")
                     Process(target=weather_monitor.monitor, daemon=True).start()
-                    w_alert['time'] = now.strftime('%H:%M')
                 else:
-                    logger.debug("Executing %s", exec_task)
+                    logger.debug("Executing: '%s'", exec_task)
                     try:
                         response = offline_communicator(command=exec_task) or "No response for automated task"
-                        logger.info("Response %s", response)
+                        logger.debug("Response: '%s'", response)
                     except Exception as error:
                         logger.error(error)
                         logger.error(traceback.format_exc())
 
         # Sync events from the event app specified (calendar/outlook)
         # Run either for macOS or during the initial run so the response gets stored in the DB
         if dry_run or models.settings.os == models.supported_platforms.macOS:
@@ -175,27 +184,18 @@
                     remind_msg = remind_msg.replace('.lock', '')
                 remind_msg = remind_msg.replace('_', ' ')
                 if remind_time == now.strftime("%I_%M_%p"):
                     logger.info("Executing reminder: %s", each_reminder)
                     Thread(target=remind.executor, kwargs={'message': remind_msg, 'contact': name}).start()
                     os.remove(os.path.join("reminder", reminder_file))
 
-        # Trigger weather alert system
-        # If a weather alert time is given and the current time matches with the given time proceed
-        if models.env.weather_alert and now.strftime('%H:%M') == models.env.weather_alert.strftime('%H:%M'):
-            # Check and trigger monitor only if it wasn't run previously, avoid duplicate check within a minute
-            if w_alert['time'] != now.strftime('%H:%M'):
-                logger.info("Initiating weather alert monitor")
-                Process(target=weather_monitor.monitor, daemon=True).start()
-                w_alert['time'] = now.strftime('%H:%M')
-
-        # Re-check for tasks
+        # Re-check for any newly added tasks with logger disabled
         new_tasks: List[classes.BackgroundTask] = list(background_task.validate_tasks(log=False))
         if new_tasks != tasks:
-            logger.warning("New task list found! Re-starting background tasks.")
+            logger.warning("Tasks list has been updated.")
             logger.debug(DeepDiff(tasks, new_tasks, ignore_order=True))
             tasks = new_tasks
             task_dict = {i: time.time() for i in range(len(tasks))}  # Re-create start time for each task
 
         dry_run = False
         time.sleep(0.5)  # Reduces CPU utilization as constant fileIO operations spike CPU %
 
@@ -278,20 +278,20 @@
 
     Returns:
         AnyStr:
         Response from Jarvis.
     """
     shared.called_by_offline = True
     # Specific for offline communication and not needed for live conversations
-    if word_match.word_match(phrase=command, match_list=keywords.keywords.ngrok):
+    if word_match.word_match(phrase=command, match_list=keywords.keywords['ngrok']):
         if public_url := get_tunnel():
             return public_url
         else:
             raise LookupError("Failed to retrieve the public URL")
-    if word_match.word_match(phrase=command, match_list=keywords.keywords.photo):
+    if word_match.word_match(phrase=command, match_list=keywords.keywords['photo']):
         return others.photo()
     # Call condition instead of split_phrase as the 'and' and 'also' filter will overwrite the first response
     conditions.conditions(phrase=command)
     shared.called_by_offline = False
     if response := shared.text_spoken:
         shared.text_spoken = None
         return response
```

## jarvis/executors/others.py

```diff
@@ -163,15 +163,15 @@
         - This can simply be ignored or handled adding the code below in socket module (NOT PREFERRED).
 
         .. code-block:: python
 
             except IOError as error:
                 import errno
                 if error.errno != errno.EPIPE:
-                    util.write_screen(error)
+                    support.write_screen(error)
 
     Args:
         device: Name of the Google home device on which the music has to be played.
         file: Scanned audio file to be played.
     """
     if not (network_id := internet.vpn_checker()):
         return
@@ -255,15 +255,15 @@
     Args:
         phrase: Takes the phrase spoken as an argument.
     """
     keyword = phrase.split()[-1] if phrase else None
     if not keyword or keyword == 'word':
         speaker.speak(text="Please tell a keyword.", run=True)
         response = listener.listen()
-        if not response or word_match.word_match(phrase=response, match_list=keywords.keywords.exit_):
+        if not response or word_match.word_match(phrase=response, match_list=keywords.keywords['exit_']):
             return
         meaning(phrase=response)
     else:
         if definition := dictionary.meaning(term=keyword):
             n = 0
             vowel = ['A', 'E', 'I', 'O', 'U']
             for key, value in definition.items():
@@ -272,15 +272,15 @@
                 n += 1
                 mean = ', '.join(value[:2])
                 speaker.speak(text=f'{keyword} is{repeated}{insert} {key}, which means {mean}.')
             if shared.called_by_offline:
                 return
             speaker.speak(text=f'Do you wanna know how {keyword} is spelled?', run=True)
             response = listener.listen()
-            if word_match.word_match(phrase=response, match_list=keywords.keywords.ok):
+            if word_match.word_match(phrase=response, match_list=keywords.keywords['ok']):
                 for letter in list(keyword.lower()):
                     speaker.speak(text=letter)
                 speaker.speak(run=True)
         else:
             speaker.speak(text=f"I'm sorry {models.env.title}! I was unable to get meaning for the word: {keyword}")
 
 
@@ -327,15 +327,15 @@
 
     if shared.called['report'] or shared.called['time_travel']:
         speaker.speak(run=True)
 
 
 def report(*args) -> NoReturn:
     """Initiates a list of functions, that I tend to check first thing in the morning."""
-    util.write_screen(text="Starting today's report")
+    support.write_screen(text="Starting today's report")
     shared.called['report'] = True
     date_time.current_date()
     date_time.current_time()
     weather.weather()
     todo_list.get_todo()
     communicator.read_gmail()
     robinhood.robinhood()
@@ -366,15 +366,15 @@
         # Use f-string or %s as table names cannot be parametrized
         event_status = cursor.execute(f"SELECT info, date FROM {models.env.event_app}").fetchone()
     if event_status and event_status[0].startswith('You'):
         speaker.speak(text=event_status[0])
     todo_list.get_todo()
     communicator.read_gmail()
     speaker.speak(text='Would you like to hear the latest news?', run=True)
-    if word_match.word_match(phrase=listener.listen(), match_list=keywords.keywords.ok):
+    if word_match.word_match(phrase=listener.listen(), match_list=keywords.keywords['ok']):
         news()
 
 
 def abusive(phrase: str) -> NoReturn:
     """Response for abusive phrases.
 
     Args:
```

## jarvis/executors/static_responses.py

```diff
@@ -1,55 +1,55 @@
 import random
 from datetime import datetime
 from typing import NoReturn
 
 from dateutil.relativedelta import relativedelta
 
-from jarvis.modules.audio.speaker import speak
-from jarvis.modules.models.models import settings
+from jarvis.modules.audio import speaker
 
 
 def form(*args) -> NoReturn:
     """Response for form."""
-    speak(text="I am a program, I'm without form.")
+    speaker.speak(text="I am a program, I'm without form.")
 
 
 def greeting(*args) -> NoReturn:
     """Response for greeting."""
-    speak(text=random.choice(['I am spectacular. I hope you are doing fine too.', 'I am doing well. Thank you.',
-                              'I am great. Thank you.']))
+    speaker.speak(text=random.choice(['I am spectacular. I hope you are doing fine too.', 'I am doing well. Thank you.',
+                                      'I am great. Thank you.']))
 
 
 def capabilities(*args) -> NoReturn:
     """Response for capabilities."""
-    speak(text='There is a lot I can do. For example: I can get you the weather at any location, news around '
-               'you, meanings of words, launch applications, create a to-do list, check your emails, get your '
-               'system configuration, tell your investment details, locate your phone, find distance between '
-               'places, set an alarm, play music on smart devices around you, control your TV, tell a joke, send'
-               ' a message, set reminders, scan and clone your GitHub repositories, and much more. Time to ask,.')
+    speaker.speak(text='There is a lot I can do. For example: I can get you the weather at any location, news around '
+                       'you, meanings of words, launch applications, create a to-do list, check your emails, get your '
+                       'system configuration, tell your investment details, locate your phone, find distance between '
+                       'places, set an alarm, play music on smart devices around you, control your TV, tell a joke, '
+                       'send a message, set reminders, scan and clone your GitHub repositories, and much more. '
+                       'Time to ask,.')
 
 
 def languages(*args) -> NoReturn:
     """Response for languages."""
-    speak(text="Tricky question!. I'm configured in python, and I can speak English.")
+    speaker.speak(text="Tricky question!. I'm configured in python, and I can speak English.")
 
 
 def whats_up(*args) -> NoReturn:
     """Response for what's up."""
-    speak(text="My listeners are up. There is nothing I cannot process. So ask me anything..")
+    speaker.speak(text="My listeners are up. There is nothing I cannot process. So ask me anything..")
 
 
 def what(*args) -> NoReturn:
     """Response for what."""
-    speak(text=f"The name is {settings.bot}. I'm just a pre-programmed virtual assistant.")
+    speaker.speak(text="The name is Jarvis. I'm just a pre-programmed virtual assistant.")
 
 
 def who(*args) -> NoReturn:
     """Response for whom."""
-    speak(text=f"I am {settings.bot}. A virtual assistant designed by Mr.Raauv.")
+    speaker.speak(text="I am Jarvis. A virtual assistant designed by Mr.Raauv.")
 
 
 def age(*args) -> NoReturn:
     """Response for age."""
     relative_date = relativedelta(dt1=datetime.strptime(datetime.strftime(datetime.now(), "%Y-%m-%d"), "%Y-%m-%d"),
                                   dt2=datetime.strptime("2020-09-06", "%Y-%m-%d"))
     statement = f"{relative_date.years} years, {relative_date.months} months and {relative_date.days} days"
@@ -61,20 +61,20 @@
         statement = statement.replace(f"{relative_date.months} months", "")
     elif relative_date.months == 1:
         statement = statement.replace("months", "month")
     if not relative_date.days:
         statement = statement.replace(f"{relative_date.days} days", "")
     elif relative_date.days == 1:
         statement = statement.replace("days", "day")
-    speak(text=f"I'm {statement} old.")
+    speaker.speak(text=f"I'm {statement} old.")
 
 
 def about_me(*args) -> NoReturn:
     """Response for about me."""
-    speak(text=f"I am {settings.bot}. A virtual assistant designed by Mr.Raauv. "
-               "I'm just a pre-programmed virtual assistant, trying to become a natural language UI. "
-               "I can seamlessly take care of your daily tasks, and also help with most of your work!")
+    speaker.speak(text="I am Jarvis. I am a virtual assistant designed by Mr. Raauv. "
+                       "Given enough access I can be your home assistant. "
+                       "I can seamlessly take care of your daily tasks, and also help with most of your work!")
 
 
 def not_allowed_offline() -> NoReturn:
     """Response for tasks not supported via offline communicator."""
-    speak(text="That's not supported via offline communicator.")
+    speaker.speak(text="That's not supported via offline communicator.")
```

## jarvis/executors/system.py

```diff
@@ -29,16 +29,15 @@
     system = None
     if models.settings.os == models.supported_platforms.linux:
         mapping = get_distributor_info_linux()
         if mapping.get('distributor_id') and mapping.get('release'):
             system = f"{mapping['distributor_id']} {mapping['release']}"
     if not system:
         if not shared.hosted_device.get('os_version'):
-            logger.warning("hosted_device information was not loaded during startup. Reloading now.")
-            shared.hosted_device = hosted_device_info()
+            hosted_device_info()
         system = f"{shared.hosted_device.get('os_name', models.settings.os)} " \
                  f"{shared.hosted_device.get('os_version', '')}"
     speaker.speak(text=f"You're running {system}, with {models.settings.physical_cores} "
                        f"physical cores, and {models.settings.logical_cores} logical cores. Your physical drive "
                        f"capacity is {total}. You have used up {used} of space. Your free space is {free}. Your "
                        f"RAM capacity is {ram}. You are currently utilizing {ram_used} of your memory.")
 
@@ -58,16 +57,15 @@
             return
 
         logger.info('Fetching system vitals')
         cpu_temp, gpu_temp, fan_speed, output = None, None, None, ""
 
         # Tested on 10.13, 10.14, 11.6 and 12.3 versions
         if not shared.hosted_device.get('os_version'):
-            logger.warning("hosted_device information was not loaded during startup. Reloading now.")
-            shared.hosted_device = hosted_device_info()
+            hosted_device_info()
         if packaging.version.parse(shared.hosted_device.get('os_version')) > packaging.version.parse('10.14'):
             critical_info = [each.strip() for each in (os.popen(
                 f'echo {models.env.root_password} | sudo -S powermetrics --samplers smc -i1 -n1'
             )).read().split('\n') if each != '']
             support.flush_screen()
 
             for info in critical_info:
@@ -108,25 +106,25 @@
     second = (datetime.now() - restart_time).total_seconds()
     restart_time = datetime.strftime(restart_time, "%A, %B %d, at %I:%M %p")
     restart_duration = support.time_converter(second=second)
     output += f'Restarted on: {restart_time} - {restart_duration} ago from now.'
     if shared.called_by_offline:
         speaker.speak(text=output)
         return
-    util.write_screen(text=output)
+    support.write_screen(text=output)
     speaker.speak(text=f"Your {shared.hosted_device.get('device')} was last booted on {restart_time}. "
                        f"Current boot time is: {restart_duration}.")
     if second >= 259_200:  # 3 days
         if boot_extreme := re.search('(.*) days', restart_duration):
             warn = int(boot_extreme.group().replace(' days', '').strip())
             speaker.speak(text=f"{models.env.title}! your {shared.hosted_device.get('device')} has been running for "
                                f"more than {warn} days. You must consider a reboot for better performance. Would you "
                                f"like me to restart it for you {models.env.title}?",
                           run=True)
-            if word_match.word_match(phrase=listener.listen(), match_list=keywords.keywords.ok):
+            if word_match.word_match(phrase=listener.listen(), match_list=keywords.keywords['ok']):
                 logger.info("Restarting %s", shared.hosted_device.get('device'))
                 controls.restart(ask=False)
 
 
 def get_distributor_info_linux() -> Dict[str, str]:
     """Returns distributor information (i.e., Ubuntu) for Linux based systems.
 
@@ -159,8 +157,10 @@
         device = util.extract_str(system_kernel[0].split(':')[1])
     elif models.settings.os == models.supported_platforms.windows:
         device = subprocess.getoutput("WMIC CSPRODUCT GET VENDOR").replace('Vendor', '').strip()
     else:
         device = subprocess.check_output("cat /sys/devices/virtual/dmi/id/product_name",
                                          shell=True).decode('utf-8').strip()
     platform_info = platform.platform(terse=True).split('-')
-    return {'device': device, 'os_name': platform_info[0], 'os_version': platform_info[1]}
+    device_data = {'device': device, 'os_name': platform_info[0], 'os_version': platform_info[1]}
+    shared.hosted_device = device_data
+    return device_data
```

## jarvis/executors/telegram.py

```diff
@@ -39,10 +39,10 @@
         if FAILED_CONNECTIONS['count'] > 3:
             logger.critical("ATTENTION::Couldn't recover from connection error. Restarting current process.")
             controls.restart_control(quiet=True)
         else:
             logger.info("Restarting in %d seconds.", FAILED_CONNECTIONS['count'] * 10)
             time.sleep(FAILED_CONNECTIONS['count'] * 10)
             telegram_api()
-    except RecursionError as error:
-        logger.error(error)
+    except Exception as error:
+        logger.critical("ATTENTION: %s", error.__str__())
         controls.restart_control(quiet=True)
```

## jarvis/executors/todo_list.py

```diff
@@ -87,15 +87,15 @@
                 return
     with tdb.connection:
         cursor = tdb.connection.cursor()
         cursor.execute("INSERT or REPLACE INTO tasks (category, item) VALUES (?,?)", (category, item))
     speaker.speak(text=f"I've added the item: {item} to the category: {category}. "
                        "Do you want to add anything else to your to-do list?", run=True)
     category_continue = listener.listen()
-    if word_match.word_match(phrase=category_continue.lower(), match_list=keywords.keywords.ok):
+    if word_match.word_match(phrase=category_continue.lower(), match_list=keywords.keywords['ok']):
         add_todo()
     else:
         speaker.speak(text='Alright')
 
 
 def delete_todo_items() -> None:
     """Deletes items from an existing to-do list."""
```

## jarvis/executors/tv.py

```diff
@@ -1,15 +1,13 @@
 import os
 import time
 from concurrent.futures import ThreadPoolExecutor
 from threading import Thread
 
-import yaml
-
-from jarvis.executors import internet, tv_controls, word_match
+from jarvis.executors import files, internet, tv_controls, word_match
 from jarvis.modules.audio import speaker
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
 from jarvis.modules.utils import shared, support
 from jarvis.modules.wakeonlan import wakeonlan
 
 
@@ -51,99 +49,100 @@
         speaker.speak(text=f"I didn't quite get that {models.env.title}! What do you want me to do to your tv?")
         Thread(target=support.unrecognized_dumper, args=[{'TV': phrase}]).start()
         return
 
     if not internet.vpn_checker():
         return
 
-    if not os.path.isfile(models.fileio.smart_devices):
-        logger.warning("%s not found.", models.fileio.smart_devices)
-        support.no_env_vars()
-        return
-
-    try:
-        with open(models.fileio.smart_devices) as file:
-            smart_devices = yaml.load(stream=file, Loader=yaml.FullLoader) or {}
-            if smart_devices:
-                smart_devices = {key: value for key, value in smart_devices.items() if 'tv' in key.lower()}
-    except yaml.YAMLError as error:
-        logger.error(error)
-        speaker.speak(text=f"I'm sorry {models.env.title}! I was unable to read your TV's source information.")
-        return
-
-    if not any(smart_devices):
-        logger.warning("%s is empty for TV.", models.fileio.smart_devices)
+    smart_devices = files.get_smart_devices()
+    if smart_devices is False:
+        speaker.speak(text=f"I'm sorry {models.env.title}! I wasn't able to read the source information.")
+        return
+    if smart_devices:
+        if not (smart_devices := {key: value for key, value in smart_devices.items() if 'tv' in key.lower()}):
+            logger.warning("%s is empty for TV.", models.fileio.smart_devices)
+            return
+    else:
         support.no_env_vars()
         return
 
     tvs = list(smart_devices.keys())
-    if len(tvs) == 1:
-        target_tv = tvs[0]
-    elif not (target_tv := word_match.word_match(phrase=phrase, match_list=tvs)):
+    if "all" in phrase:
+        tv_iterate = tvs
+    elif selected := word_match.word_match(phrase=phrase, match_list=tvs):
+        tv_iterate = [selected]
+    else:
         speaker.speak(text=f"You have {len(tvs)} TVs added {models.env.title}! "
                            "Please specify which TV I should access.")
         return
 
-    tv_name = smart_devices[target_tv].get('hostname')
-    tv_mac = smart_devices[target_tv].get('mac_address')
-    tv_client_key = smart_devices[target_tv].get('client_key')
+    logger.info("Chosen TVs: %s", tv_iterate)
+    for target_tv in tv_iterate:
+        logger.info("Iterating over: %s", target_tv)
+        tv_name = smart_devices[target_tv].get('hostname')
+        tv_mac = smart_devices[target_tv].get('mac_address')
+        tv_client_key = smart_devices[target_tv].get('client_key')
+
+        if not all((tv_name, tv_mac)):
+            speaker.speak(text=f"I'm sorry {models.env.title}! "
+                               f"I was unable to find the {target_tv}'s name or MAC address.")
+            continue
 
-    if not all((tv_name, tv_mac)):
-        speaker.speak(text=f"I'm sorry {models.env.title}! I was unable to find the {target_tv}'s name or MAC address.")
-        return
-
-    if 'lg' in tv_name.lower() or 'roku' in tv_name.lower():
-        logger.debug("'%s' is supported.", tv_name)
-    else:
-        logger.error("tv's name [%s] is not supported.", tv_name)
-        speaker.speak(text=f"I'm sorry {models.env.title}! Your {target_tv}'s name is neither LG or Roku."
-                           "So, I will not be able to control the television.")
-        return
-
-    if 'lg' in tv_name.lower() and not tv_client_key:
-        speaker.speak(text="LG televisions require a client key, but that seems to be missing. "
-                           "Proceeding without it, user confirmation on TV screen may be required, for the first time.")
-
-    tv_ip_list = support.hostname_to_ip(hostname=tv_name)
-    tv_ip_list = list(filter(None, tv_ip_list))
-    if not tv_ip_list:
-        speaker.speak(text=f"I'm sorry {models.env.title}! I wasn't able to get the IP address of your {target_tv}.")
-        return
-
-    if isinstance(tv_mac, str):
-        tv_mac = [tv_mac]
-
-    if 'turn off' in phrase.lower() or 'shutdown' in phrase.lower() or 'shut down' in phrase.lower():
-        if not (tv_ip := tv_status(tv_ip_list=tv_ip_list)):
-            speaker.speak(text=f"I wasn't able to connect to your {target_tv} {models.env.title}! "
-                               "I guess your TV is powered off already.")
-            return
-    elif not (tv_ip := tv_status(tv_ip_list=tv_ip_list)):
-        logger.info("Trying to power on the device using the mac addresses: %s", tv_mac)
-        power_controller = wakeonlan.WakeOnLan()
-        for _ in range(3):  # REDUNDANT-Roku: Send magic packets thrice to ensure device wakes up from sleep
-            with ThreadPoolExecutor(max_workers=len(tv_mac)) as executor:
-                executor.map(power_controller.send_packet, tv_mac)
-        if not shared.called_by_offline:
-            speaker.speak(text=f"Looks like your {target_tv} is powered off {models.env.title}! "
-                               "Let me try to turn it back on!", run=True)
-
-    if not tv_ip:
-        for i in range(5):
-            if tv_ip := tv_status(tv_ip_list=tv_ip_list, attempt=i):
-                break
-            time.sleep(0.5)
+        if 'lg' in tv_name.lower() or 'roku' in tv_name.lower():
+            logger.debug("'%s' is supported.", tv_name)
         else:
-            speaker.speak(text=f"I wasn't able to connect to your {target_tv} {models.env.title}! "
-                               "Please make sure you are on the same network as your TV, and "
-                               "your TV is connected to a power source.")
-            return
-
-    # Instantiate dictionary if not present
-    if not shared.tv.get(target_tv):
-        shared.tv[target_tv] = None
-    logger.debug("TV database: %s", shared.tv)
-    if 'lg' in tv_name.lower():
-        tv_controls.tv_controller(phrase=phrase, tv_ip=tv_ip, identifier='LG',
-                                  client_key=tv_client_key, nickname=target_tv)
-    else:
-        tv_controls.tv_controller(phrase=phrase, tv_ip=tv_ip, identifier='ROKU', nickname=target_tv)
+            logger.error("tv's name [%s] is not supported.", tv_name)
+            speaker.speak(text=f"I'm sorry {models.env.title}! Your {target_tv}'s name is neither LG or Roku."
+                               "So, I will not be able to control the television.")
+            continue
+
+        if 'lg' in tv_name.lower() and not tv_client_key:
+            speaker.speak(text="LG televisions require a client key, but that seems to be missing. "
+                               "Proceeding without it. User confirmation on TV screen may be required.")
+
+        tv_ip_list = support.hostname_to_ip(hostname=tv_name)
+        tv_ip_list = list(filter(None, tv_ip_list))
+        if not tv_ip_list:
+            speaker.speak(
+                text=f"I'm sorry {models.env.title}! I wasn't able to get the IP address of your {target_tv}."
+            )
+            continue
+
+        if isinstance(tv_mac, str):
+            tv_mac = [tv_mac]
+
+        if 'turn off' in phrase.lower() or 'shutdown' in phrase.lower() or 'shut down' in phrase.lower():
+            if not (tv_ip := tv_status(tv_ip_list=tv_ip_list)):
+                # WARNING: TV that was turned off recently might still respond to ping
+                speaker.speak(text=f"I wasn't able to connect to your {target_tv} {models.env.title}! "
+                                   "I guess your TV is powered off already.")
+                continue
+        elif not (tv_ip := tv_status(tv_ip_list=tv_ip_list)):
+            logger.info("Trying to power on the device using the mac addresses: %s", tv_mac)
+            power_controller = wakeonlan.WakeOnLan()
+            for _ in range(3):  # REDUNDANT-Roku: Send magic packets thrice to ensure device wakes up from sleep
+                with ThreadPoolExecutor(max_workers=len(tv_mac)) as executor:
+                    executor.map(power_controller.send_packet, tv_mac)
+            if not shared.called_by_offline:
+                speaker.speak(text=f"Looks like your {target_tv} is powered off {models.env.title}! "
+                                   "Let me try to turn it back on!", run=True)
+
+        if not tv_ip:
+            for i in range(5):
+                if tv_ip := tv_status(tv_ip_list=tv_ip_list, attempt=i):
+                    break
+                time.sleep(0.5)
+            else:
+                speaker.speak(text=f"I wasn't able to connect to your {target_tv} {models.env.title}! "
+                                   "Please make sure you are on the same network as your TV, and "
+                                   "your TV is connected to a power source.")
+                continue
+
+        # Instantiate dictionary if not present
+        if not shared.tv.get(target_tv):
+            shared.tv[target_tv] = None
+        logger.debug("TV database: %s", shared.tv)
+        if 'lg' in tv_name.lower():
+            tv_controls.tv_controller(phrase=phrase, tv_ip=tv_ip, identifier='LG',
+                                      client_key=tv_client_key, nickname=target_tv)
+        else:
+            tv_controls.tv_controller(phrase=phrase, tv_ip=tv_ip, identifier='ROKU', nickname=target_tv)
```

## jarvis/executors/tv_controls.py

```diff
@@ -22,15 +22,15 @@
         client_key: Client key to connect to the LG WebOS tv.
     """
     phrase_lower = phrase.replace('TV', '').lower()
 
     if not shared.tv[nickname]:
         try:
             if identifier == 'LG':
-                shared.tv[nickname] = lg.LGWebOS(ip_address=tv_ip, client_key=client_key)
+                shared.tv[nickname] = lg.LGWebOS(ip_address=tv_ip, client_key=client_key, nickname=nickname)
             elif identifier == 'ROKU':
                 shared.tv[nickname] = roku.RokuECP(ip_address=tv_ip)
                 if not shared.tv[nickname].current_app():
                     for _ in range(3):  # REDUNDANT-Roku: Launch home thrice to ensure device wakes up from sleep
                         shared.tv[nickname].startup()
         except TVError as error:
             logger.error("Failed to connect to the TV. %s", error)
@@ -79,15 +79,15 @@
                 speaker.speak(text=f"Requested volume doesn't match the right format {models.env.title}!")
             else:
                 shared.tv[nickname].set_volume(target=vol)
                 speaker.speak(text=f"I've set the volume to {vol}% {models.env.title}.")
         elif 'volume' in phrase_lower:
             speaker.speak(text=f"The current volume on your {nickname} is, {shared.tv[nickname].get_volume()}%")
         elif 'app' in phrase_lower or 'application' in phrase_lower:
-            util.write_screen(text=list(shared.tv[nickname].get_apps()))
+            support.write_screen(text=list(shared.tv[nickname].get_apps()))
             speaker.speak(text=f'App list on your screen {models.env.title}!', run=True)
             time.sleep(5)
         elif 'open' in phrase_lower or 'launch' in phrase_lower:
             cleaned = ' '.join([w for w in phrase.split() if w not in ['launch', 'open', 'tv', 'on', 'my', 'the']])
             app_name = util.get_closest_match(text=cleaned, match_list=list(shared.tv[nickname].get_apps()))
             logger.info("%s -> %s", phrase, app_name)
             shared.tv[nickname].launch_app(app_name=app_name)
```

## jarvis/executors/unconditional.py

```diff
@@ -7,15 +7,15 @@
 
 from jarvis.executors import files, word_match
 from jarvis.modules.audio import listener, speaker
 from jarvis.modules.conditions import keywords
 from jarvis.modules.exceptions import EgressErrors
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import util
+from jarvis.modules.utils import support
 
 
 def google_maps(query: str) -> bool:
     """Uses google's places api to get places nearby or any particular destination.
 
     This function is triggered when the words in user's statement doesn't match with any predefined functions.
 
@@ -88,20 +88,20 @@
             next_val = "Would you like to try that?"
         else:
             option = 'other'
             next_val = 'How about that?'
         speaker.speak(text=f"The {option}, {item['Name']}, with {item['Rating']} rating, "
                            f"on{''.join([j for j in item['Address'] if not j.isdigit()])}, which is approximately "
                            f"{dist} away. {next_val}", run=True)
-        util.write_screen(text=f"{item['Name']} -- {item['Rating']} -- "
-                               f"{''.join([j for j in item['Address'] if not j.isdigit()])}")
+        support.write_screen(text=f"{item['Name']} -- {item['Rating']} -- "
+                                  f"{''.join([j for j in item['Address'] if not j.isdigit()])}")
         if converted := listener.listen():
             if 'exit' in converted or 'quit' in converted or 'Xzibit' in converted:
                 break
-            elif word_match.word_match(phrase=converted.lower(), match_list=keywords.keywords.ok):
+            elif word_match.word_match(phrase=converted.lower(), match_list=keywords.keywords['ok']):
                 maps_url = f'https://www.google.com/maps/dir/{start}/{end}/'
                 webbrowser.open(url=maps_url)
                 speaker.speak(text=f"Directions on your screen {models.env.title}!")
                 return True
             elif results == 1:
                 return True
             elif n == results:
```

## jarvis/executors/weather.py

```diff
@@ -59,15 +59,15 @@
         return
 
     place = None
     if phrase:
         # ignore days in week and the keywords for weather as they are guaranteed to not be places
         place = support.get_capitalized(phrase=phrase,
                                         ignore=support.days_in_week +
-                                        tuple(string.capwords(w) for w in keywords.keywords.weather))
+                                        tuple(string.capwords(w) for w in keywords.keywords['weather']))
         phrase = phrase.lower()
     if place:
         logger.info("Identified place: %s", place)
         desired_location = location.geo_locator.geocode(place)
         if not desired_location:
             logger.error("Failed to get coordinates for the place: '%s'", place)
             speaker.speak(text=f"I'm sorry {models.env.title}! "
```

## jarvis/executors/weather_monitor.py

```diff
@@ -11,15 +11,15 @@
     """Weather monitoring system to trigger notifications for high, low weather and severe weather alert."""
     logger = custom_logger.logger
     config.multiprocessing_logger(filename=os.path.join('logs', 'background_tasks_%d-%m-%Y.log'))
     low_threshold = 36
     high_threshold = 100
     condition, high, low, temp_f, alert = weather.weather(monitor=True)
     if not any((high >= high_threshold, low <= low_threshold, alert)):
-        logger.info(dict(condition=condition, high=high, low=low, temperature=temp_f, alert=alert))
+        logger.debug(dict(condition=condition, high=high, low=low, temperature=temp_f, alert=alert))
         logger.info("No alerts to report")
         return
     title = "Weather Alert"
     sender = "Jarvis Weather Alert System"
     subject = title + " " + datetime.now().strftime('%c')
     body = f"Highest Temperature: {high}\N{DEGREE SIGN}F\n" \
            f"Lowest Temperature: {low}\N{DEGREE SIGN}F\n" \
```

## jarvis/executors/wiki.py

```diff
@@ -45,9 +45,9 @@
     formatted = ". ".join(result.split(". ")[:2]) + "."
     if shared.called_by_offline:
         # No long messages via offline communicators as Telegram API returns 400, too hard to read on FastAPI interfaces
         speaker.speak(text=formatted)
         return
     speaker.speak(text=f"{formatted}. Do you want me to continue {models.env.title}?", run=True)
     if response := listener.listen():
-        if word_match.word_match(phrase=response, match_list=keywords.keywords.ok):
+        if word_match.word_match(phrase=response, match_list=keywords.keywords['ok']):
             speaker.speak(text=". ".join(result.split(". ")[3:]))
```

## jarvis/lib/install.sh

```diff
@@ -1,13 +1,13 @@
 #!/bin/bash
 # 'set -e' stops the execution of a script if a command or pipeline has an error.
 # This is the opposite of the default shell behaviour, which is to ignore errors in scripts.
 set -e
 
-OSName=$(uname)
+OSName=$(python -c "import platform; print(platform.system())")
 ver=$(python -c "import sys; print(f'{sys.version_info.major}{sys.version_info.minor}')")
 echo_ver=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
 
 if [ "$ver" -ge 38 ] && [ "$ver" -le 311 ]; then
   pyaudio="PyAudio-0.2.11-cp$ver-cp$ver-win_amd64.whl"
 else
   echo "Python version $echo_ver is unsupported for Jarvis. Please use any python version between 3.8.* and 3.11.*"
@@ -85,15 +85,15 @@
       python -m pip install pvporcupine==1.6.0 dlib==19.21.0 opencv-python==4.4.0.44
     else
       python -m pip install pvporcupine==1.9.5 dlib==19.24.0 opencv-python==4.5.5.64
     fi
 
     # Install as stand alone as face recognition depends on dlib
     python -m pip install face-recognition==1.3.0
-elif [[ "$OSName" == MSYS* ]]; then
+elif [[ "$OSName" == "Windows" ]]; then
     clear
     echo "*****************************************************************************************************************"
     echo "*****************************************************************************************************************"
     echo ""
     echo "Make sure Git, Anaconda (or Miniconda) and VS C++ BuildTools are installed."
     echo ""
     echo "Refer the below links for:"
```

## jarvis/modules/audio/listener.py

```diff
@@ -1,34 +1,35 @@
 # noinspection PyUnresolvedReferences
 """Module for speech recognition listener.
 
 >>> Listener
 
 """
+from multiprocessing import current_process
 from typing import Union
 
 from playsound import playsound
 from speech_recognition import (Microphone, Recognizer, RequestError,
                                 UnknownValueError, WaitTimeoutError)
 
 from jarvis.modules.exceptions import EgressErrors
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import support, util
+from jarvis.modules.utils import support
 
 recognizer = Recognizer()
 microphone = Microphone(device_index=models.env.microphone_index)
 
-if models.env.recognizer_settings:
+if models.env.recognizer_settings and current_process().name == "JARVIS":
+    logger.debug("Overriding recognizer settings: %s", models.env.recognizer_settings.__dict__)
     recognizer.energy_threshold = models.env.recognizer_settings.energy_threshold
     recognizer.pause_threshold = models.env.recognizer_settings.pause_threshold
     recognizer.phrase_threshold = models.env.recognizer_settings.phrase_threshold
     recognizer.dynamic_energy_threshold = models.env.recognizer_settings.dynamic_energy_threshold
     recognizer.non_speaking_duration = models.env.recognizer_settings.non_speaking_duration
-    models.env.phrase_limit = 10  # Override voice phrase limit when recognizer settings are available
 
 
 def listen(sound: bool = True, stdout: bool = True) -> Union[str, None]:
     """Function to activate listener, this function will be called by most upcoming functions to listen to user input.
 
     Args:
         sound: Flag whether to play the listener indicator sound. Defaults to True unless set to False.
@@ -37,17 +38,17 @@
     Returns:
         str:
          - Returns recognized statement from the microphone.
     """
     with microphone as source:
         try:
             playsound(sound=models.indicators.start, block=False) if sound else None
-            util.write_screen(text="Listener activated...") if stdout else None
-            listened = recognizer.listen(source=source, timeout=models.env.timeout,
-                                         phrase_time_limit=models.env.phrase_limit)
+            support.write_screen(text="Listener activated...") if stdout else None
+            listened = recognizer.listen(source=source, timeout=models.env.listener_timeout,
+                                         phrase_time_limit=models.env.listener_phrase_limit)
             playsound(sound=models.indicators.end, block=False) if sound else None
             support.flush_screen()
             recognized = recognizer.recognize_google(audio_data=listened)
             logger.info(recognized)
             return recognized
         except (UnknownValueError, RequestError, WaitTimeoutError):
             return
```

## jarvis/modules/audio/speaker.py

```diff
@@ -15,15 +15,15 @@
 import requests
 from playsound import playsound
 
 from jarvis.executors import files
 from jarvis.modules.exceptions import EgressErrors
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import shared, support, util
+from jarvis.modules.utils import shared, support
 
 SS_HEADERS = {
     "Content-Type": "text/plain"
 }
 
 
 def speech_synthesizer(text: str,
@@ -86,24 +86,25 @@
         text: Takes the text that has to be spoken as an argument.
         run: Takes a boolean flag to choose whether to run the ``audio_driver.say`` loop.
         block: Takes a boolean flag to await other tasks while speaking. [Applies only for speech-synthesis on docker]
     """
     if not models.audio_driver:
         models.env.speech_synthesis_timeout = 10
     caller = sys._getframe(1).f_code.co_name  # noqa: PyProtectedMember,PyUnresolvedReferences
-    if caller != 'conditions':  # function where all the magic happens
+    if caller not in ('conditions', 'custom_conditions'):  # function where all the magic happens
         Thread(target=frequently_used, kwargs={"function_name": caller}).start()
     if text:
         text = text.replace('\n', '\t').strip()
         shared.text_spoken = text
         if shared.called_by_offline:
+            logger.debug("Speaker called by: '%s'", caller)
             shared.offline_caller = caller
             return
         logger.info("Response: %s", text)
-        util.write_screen(text=text)
+        support.write_screen(text=text)
         if models.env.speech_synthesis_timeout and \
                 speech_synthesizer(text=text) and \
                 os.path.isfile(models.fileio.speech_synthesis_wav):
             playsound(sound=models.fileio.speech_synthesis_wav, block=block)
             os.remove(models.fileio.speech_synthesis_wav)
         elif models.audio_driver:
             models.audio_driver.say(text=text)
```

## jarvis/modules/audio/speech_synthesis.py

```diff
@@ -9,15 +9,15 @@
 import subprocess
 import traceback
 from typing import NoReturn
 
 import docker
 import requests
 
-from jarvis.executors import port_handler
+from jarvis.executors import controls, port_handler
 from jarvis.modules.exceptions import EgressErrors
 from jarvis.modules.logger import config
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
 
 DOCKER_CMD = """echo {PASSWORD} | sudo -S \
 docker run \
@@ -53,14 +53,23 @@
         except EgressErrors as error:
             logger.error(error)
             if not port_handler.kill_port_pid(port=models.env.speech_synthesis_port):
                 logger.critical('ATTENTION::Failed to kill existing PID. Attempting to re-create session.')
 
 
 def speech_synthesizer() -> NoReturn:
+    """Initiate the runner function for speech-synthesis."""
+    try:
+        speech_synthesis_runner()
+    except Exception as error:
+        logger.critical("ATTENTION: %s", error.__str__())
+        controls.restart_control(quiet=True)
+
+
+def speech_synthesis_runner() -> NoReturn:
     """Initiates speech synthesizer using docker.
 
     See Also:
         - Initiates docker container using ``docker-py`` module for Windows and macOS.
         - Initiates container using traditional commandline for Linux.
         - Stores the container ID in a .cid file, to later stop and remove the container.
     """
```

## jarvis/modules/audio/voices.py

```diff
@@ -11,26 +11,26 @@
 from pyttsx3.engine import Engine
 
 from jarvis.executors import word_match
 from jarvis.modules.audio import listener, speaker
 from jarvis.modules.conditions import conversation, keywords
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import util
+from jarvis.modules.utils import support
 
 
 def voice_default() -> Engine:
     """Sets voice module to default."""
     if models.settings.invoker != "sphinx-build":
         for voice in models.voices:
             if voice.name == models.env.voice_name or models.env.voice_name in voice.name:
                 if current_process().name == 'JARVIS':
                     logger.debug(voice.__dict__)
                 models.audio_driver.setProperty("voice", voice.id)
-                models.audio_driver.setProperty("rate", models.env.voice_rate)
+                models.audio_driver.setProperty("rate", models.env.speech_rate)
                 break
     return models.audio_driver
 
 
 def voice_changer(phrase: str = None) -> None:
     """Speaks to the user with available voices and prompts the user to choose one.
 
@@ -44,24 +44,24 @@
     choices_to_say = ["My voice module has been reconfigured. Would you like me to retain this?",
                       "Here's an example of one of my other voices. Would you like me to use this one?",
                       "How about this one?"]
 
     for ind, voice in enumerate(models.voices):
         models.audio_driver.setProperty("voice", models.voices[ind].id)
         speaker.speak(text=f"I am {voice.name} {models.env.title}!")
-        util.write_screen(f"Voice module has been re-configured to {ind}::{voice.name}")
+        support.write_screen(f"Voice module has been re-configured to {ind}::{voice.name}")
         if ind < len(choices_to_say):
             speaker.speak(text=choices_to_say[ind])
         else:
             speaker.speak(text=random.choice(choices_to_say))
         speaker.speak(run=True)
         if not (keyword := listener.listen()):
             voice_default()
             speaker.speak(text=f"Sorry {models.env.title}! I had trouble understanding. I'm back to my default voice.")
             return
         elif "exit" in keyword or "quit" in keyword or "Xzibit" in keyword:
             voice_default()
             speaker.speak(text=f"Reverting the changes to default voice module {models.env.title}!")
             return
-        elif word_match.word_match(phrase=keyword, match_list=keywords.keywords.ok):
+        elif word_match.word_match(phrase=keyword, match_list=keywords.keywords['ok']):
             speaker.speak(text=random.choice(conversation.acknowledgement))
             return
```

## jarvis/modules/conditions/keywords.py

```diff
@@ -1,16 +1,110 @@
-"""Module to instantiate the Keywords object.
+# noinspection PyUnresolvedReferences
+"""List of keywords for each variable which is condition matched in the main module.
 
->>> Keywords
+>>> KeywordsBase
 
 """
 
+from collections import OrderedDict
+from typing import List
 
-class Keywords:
-    """Class to load the keywords as members of the object.
+keywords: OrderedDict = OrderedDict()
 
-    >>> Keywords
 
-    """
+def keyword_mapping() -> OrderedDict[str, List[str]]:
+    """Returns an ordered dictionary of base keywords mapping.
+
+    See Also:
+        - Keywords should have both singular and plural forms wherever possible.
+        - An alternate is to use
+
+        .. code-block:: python
 
+            import inflect
+            engine = inflect.engine()
+            engine.plural(phrase)
+            engine.singular_noun(phrase)
 
-keywords = Keywords()
+        - But the approach is time taking and inconsistent.
+
+    Returns:
+        OrderedDict:
+        OrderedDict of category and keywords as key-value pairs.
+    """
+    return OrderedDict(
+        listener_control=['listener'],
+        send_notification=['message', 'text', 'sms', 'mail', 'email', 'messages', 'mails', 'emails'],
+        lights=['light', 'party mode', 'lights'],
+        television=['tv', 'television', 'tvs', 'televisions', "tv's", "television's"],
+        volume=['volume', 'mute'],
+        car=['car', 'vehicle'],
+        garage=['garage'],
+        weather=['weather', 'temperature', 'sunrise', 'sun rise', 'sunset', 'sun set'],
+
+        # ORDER OF THE ABOVE SHOULD BE RETAINED, AS THE CONDITION LOOP WILL RUN IN THE SAME ORDER
+        # internal
+
+        meetings=['meeting', 'meetings'],
+        events=['event', 'events'],
+        current_date=["today's date", 'current date', 'what is the date', "what's the date", 'todays date',
+                      'whats the date'],
+        current_time=['current time', 'time now', 'time in', 'what is the time', "what's the time", 'whats the time'],
+        system_info=['configuration', 'system config'],
+        ip_info=['address'],
+        wikipedia_=['wikipedia', 'info', 'information'],
+        news=['news'],
+        report=['report'],
+        robinhood=['robinhood', 'investment', 'portfolio', 'summary'],
+        repeat=['repeat'],
+        location=['location', 'where are you'],
+        locate=['locate', 'where is my', "where's my", 'wheres my'],
+        read_gmail=['email', 'mail', 'mails', 'emails'],
+        meaning=['meaning', 'dictionary', 'definition', 'meanings', 'definitions'],
+        todo=['plan', 'to do', 'to-do', 'todo', 'plans'],
+        kill_alarm=['stop alarm', 'stop my alarm', 'stop another alarm', 'stop an alarm', 'stop timer', 'stop my timer',
+                    'stop another timer', 'stop an timer', 'turn off my alarm', 'turn my alarm off',
+                    'stop another alarm', 'turn off alarm', 'turn off my timer', 'turn my timer off',
+                    'stop another timer', 'turn off timer', 'delete alarm', 'delete my alarm', 'delete another alarm',
+                    'delete an alarm', 'delete timer', 'delete my timer', 'delete another timer', 'delete an timer',
+                    'stop all my alarms', 'turn off all my alarms', 'delete all my alarms'],
+        set_alarm=['alarm', 'wake me', 'timer'],
+        google_home=['google home', 'googlehome'],
+        jokes=['joke', 'jokes', 'make me laugh'],
+        reminder=['remind', 'reminder', 'reminders'],
+        distance=['far', 'distance', 'miles', 'kilometers', 'mile', 'kilometer'],
+        locate_places=['where is', "where's", 'which city', 'which state', 'which country', 'which county', 'wheres'],
+        directions=['take me', 'directions'],
+        notes=['notes', 'note'],
+        github=['git', 'github', 'clone', 'GitHub'],
+        apps=['launch'],
+        music=['music', 'songs', 'play', 'song'],
+        faces=['face', 'recognize', 'who am i', 'detect', 'facial', 'recognition', 'detection', 'faces'],
+        speed_test=['speed', 'fast'],
+        brightness=['brightness', 'bright', 'dim'],
+        guard_enable=['turn on security mode', 'enable security mode', 'turn on guardian mode', 'enable guardian mode'],
+        guard_disable=['turn off security mode', 'disable security mode', 'turn off guardian mode',
+                       'disable guardian mode'],
+        flip_a_coin=['head', 'tail', 'flip', 'heads', 'tails'],
+        facts=['fact', 'facts'],
+        voice_changer=['voice', 'voices'],
+        system_vitals=['vitals', 'statistics', 'readings', 'stats'],
+        vpn_server=['vpn'],
+        automation_handler=['automation'],
+        background_task_handler=['background'],
+        photo=['picture', 'snap', 'photo', 'pictures', 'photos'],
+        version=['version'],
+        simulation=['simulator', 'variation', 'simulation', 'variations'],
+        sleep_control=['lock', 'screen', 'pc', 'computer'],
+        sentry=['sleep', 'activate sentry mode'],
+        restart_control=['restart', 'reboot'],
+        shutdown=['shutdown', 'shut down', 'terminate'],
+        ok=['yeah', 'yes', 'yep', 'go ahead', 'proceed', 'continue', 'carry on', 'please', 'keep going'],
+        exit_=['exit', 'quit', 'no', 'nope', 'thank you', 'Xzibit', 'bye', 'good bye', 'see you later',
+               'talk to you later', "that's it", 'that is it', 'never mind', 'nevermind', 'thats it'],
+        kill=['kill', 'terminate yourself', 'stop running'],
+        avoid=['sun', 'moon', 'mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune', 'pluto',
+               'a.m.', 'p.m.', 'update my to do list', 'launch', 'safari', 'body', 'human', 'centimeter', 'server',
+               'cloud', 'update'],
+        ngrok=['ngrok', 'public url'],
+        secrets=['secret', 'secrets', 'param', 'params', 'parameter', 'parameters']
+    )
```

## jarvis/modules/lights/smart_lights.py

```diff
@@ -7,15 +7,15 @@
 
 import socket
 import struct
 import time
 from typing import NoReturn
 
 from jarvis.modules.logger.custom_logger import logger
-from jarvis.modules.utils import util
+from jarvis.modules.utils import support
 
 
 def check_number_range(number: int) -> int:
     """Check if the given number is in the allowed range.
 
     Args:
         number: Takes integer value for RGB value [0-255] check.
@@ -171,15 +171,15 @@
                 message = [0x56,
                            check_number_range(r),
                            check_number_range(g),
                            check_number_range(b),
                            0x00, 0xf0, 0xaa]
                 self.send_bytes(*(message + [calculate_checksum(message)]))
         else:
-            util.write_screen(text="Incompatible device type received.")
+            support.write_screen(text="Incompatible device type received.")
 
     def send_preset_function(self, preset_number: int, speed: int) -> NoReturn:
         """Send a preset command to a device.
 
         Args:
             preset_number: Takes preset value as argument.
             speed: Rate at which the colors should change. Integer in rage 0-100.
@@ -209,15 +209,15 @@
 
         Args:
             *bytes_: Takes a tuple value as argument.
         """
         check_connection_time = time.time() - self.latest_connection
         try:
             if check_connection_time >= 290:
-                util.write_screen(text="Connection timed out, re-establishing.")
+                support.write_screen(text="Connection timed out, re-establishing.")
                 self.sock.connect((self.device_ip, self.API_PORT))
             message_length = len(bytes_)
             self.sock.send(struct.pack("B" * message_length, *bytes_))
         except socket.error as error:
             error_msg = f"Socket error on {self.device_ip}: {error}"
             logger.error("%s while performing '%s'", error_msg, self.operation)
         self.sock.close()
```

## jarvis/modules/meetings/events.py

```diff
@@ -71,15 +71,15 @@
         return f"Reading events from {models.env.event_app} is currently possible only on macOS, " \
                f"but the host machine is currently running {models.settings.os}."
     failure = None
     process = subprocess.Popen(["/usr/bin/osascript", models.fileio.event_script] + [str(arg) for arg in [1, 3]],
                                stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     out, err = process.communicate()
     # Undo unspecified changes done by ScriptEditor (should only be necessary when package is not pip installed)
-    os.system(f"git reset {models.fileio.event_script} >/dev/null 2>&1")
+    os.system(f"git checkout HEAD -- {models.fileio.event_script} >/dev/null 2>&1")
     # noinspection GrazieInspection
     if error := process.returncode:  # stores non zero error
         err_msg = err.decode("UTF-8")
         err_code = err_msg.split()[-1].strip()
         if err_code == "(-1728)":  # If 'Jarvis' is unavailable in calendar/outlook application
             logger.warning("'Jarvis' is unavailable in %s.", models.env.event_app)
             return f"Jarvis is unavailable in your {models.env.event_app} {models.env.title}!"
```

## jarvis/modules/models/classes.py

```diff
@@ -66,16 +66,14 @@
     else:
         interactive = False
     pid: PositiveInt = os.getpid()
     ram: Union[PositiveInt, PositiveFloat] = psutil.virtual_memory().total
     physical_cores: PositiveInt = psutil.cpu_count(logical=False)
     logical_cores: PositiveInt = psutil.cpu_count(logical=True)
     limited: bool = True if physical_cores < 4 else False
-    wake_words: Optional[List[str]]
-    bot: str = "jarvis"
     invoker: str = pathlib.PurePath(sys.argv[0]).stem
 
     os: str = platform.system()
     if os not in (supported_platforms.macOS, supported_platforms.linux, supported_platforms.windows):
         raise UnsupportedOS(
             f"\n{''.join('*' for _ in range(80))}\n\n"
             "Currently Jarvis can run only on Linux, Mac and Windows OS.\n\n"
@@ -89,24 +87,24 @@
 if settings.os.startswith('Windows'):
     settings.os = "Windows"
 
 
 class VehicleAuthorization(BaseModel):
     """Wrapper to store vehicle authorization."""
 
-    device_id: Optional[str]
-    expiration: Optional[float]
-    refresh_token: Optional[Union[str, UUID]]
+    device_id: Optional[str] = None
+    expiration: Optional[float] = None
+    refresh_token: Optional[Union[str, UUID]] = None
 
 
 class VehicleConnection(BaseModel):
     """Module to create vehicle connection."""
 
-    vin: Optional[str]
-    connection: Optional[Callable]
+    vin: Optional[str] = None
+    connection: Optional[Callable] = None
 
 
 def import_module() -> NoReturn:
     """Instantiates pyttsx3 after importing ``nsss`` drivers beforehand."""
     if settings.os == "Darwin":
         importlib.import_module("pyttsx3.drivers.nsss")
     module['pyttsx3'] = pyttsx3.init()
@@ -299,15 +297,15 @@
 
     # Mute during meetings
     mute_for_meetings: bool = Field(default=False, env='MUTE_FOR_MEETINGS')
 
     # Built-in speaker config
     voice_name: str = Field(default=None, env='VOICE_NAME')
     _rate = audio_driver.getProperty("rate") if audio_driver else dynamic_rate()
-    voice_rate: Union[PositiveInt, PositiveFloat] = Field(default=_rate, env='VOICE_RATE')
+    speech_rate: Union[PositiveInt, PositiveFloat] = Field(default=_rate, env='SPEECH_RATE')
 
     # Peripheral config
     camera_index: Union[int, PositiveInt] = Field(default=None, ge=0, env='CAMERA_INDEX')
     speaker_index: Union[int, PositiveInt] = Field(default=None, ge=0, env='SPEAKER_INDEX')
     microphone_index: Union[int, PositiveInt] = Field(default=None, ge=0, env='MICROPHONE_INDEX')
 
     # Log config
@@ -386,16 +384,16 @@
 
     # Garage door config
     myq_username: EmailStr = Field(default=None, env='MYQ_USERNAME')
     myq_password: str = Field(default=None, env='MYQ_PASSWORD')
 
     # Listener config
     sensitivity: Union[Sensitivity, List[Sensitivity]] = Field(default=0.5, le=1, ge=0, env='SENSITIVITY')
-    timeout: Union[PositiveFloat, PositiveInt] = Field(default=3, env='TIMEOUT')
-    phrase_limit: Union[PositiveFloat, PositiveInt] = Field(default=None, env='PHRASE_LIMIT')
+    listener_timeout: Union[PositiveFloat, PositiveInt] = Field(default=3, env='LISTENER_TIMEOUT')
+    listener_phrase_limit: Union[PositiveFloat, PositiveInt] = Field(default=None, env='LISTENER_PHRASE_LIMIT')
     recognizer_settings: RecognizerSettings = Field(default=None, env='RECOGNIZER_SETTINGS')
 
     # Telegram config
     bot_token: str = Field(default=None, env='BOT_TOKEN')
     bot_chat_ids: List[int] = Field(default=[], env='BOT_CHAT_IDS')
     bot_users: List[str] = Field(default=[], env='BOT_USERS')
 
@@ -469,18 +467,19 @@
     # noinspection PyMethodParameters
     @validator("weather_alert", pre=True, allow_reuse=True)
     def parse_weather_alert(cls, value: str) -> Union[str, None, datetime]:
         """Validates date value to be in DD-MM format."""
         if not value:
             return
         try:
-            if val := datetime.strptime(value, '%H:%M'):
-                return val
+            # Convert datetime to string as the '07' for '%I' will pass validation but fail comparison
+            if val := datetime.strptime(value, '%I:%M %p'):
+                return val.strftime('%I:%M %p')
         except ValueError:
-            raise InvalidEnvVars("format should be 'HH:MM'")
+            raise InvalidEnvVars("format should be '%I:%M %p'")
 
 
 env = EnvConfig()
 
 
 class FileIO(BaseModel):
     """Loads all the files' path required/created by Jarvis.
@@ -489,55 +488,59 @@
 
     """
 
     # Directories
     root: DirectoryPath = os.path.realpath('fileio')
 
     # Home automation
-    automation: FilePath = os.path.join('fileio', 'automation.yaml')
-    tmp_automation: FilePath = os.path.join('fileio', 'tmp_automation.yaml')
-    background_tasks: FilePath = os.path.join('fileio', 'background_tasks.yaml')
-    tmp_background_tasks: FilePath = os.path.join('fileio', 'tmp_background_tasks.yaml')
-    smart_devices: FilePath = os.path.join('fileio', 'smart_devices.yaml')
-    contacts: FilePath = os.path.join('fileio', 'contacts.yaml')
+    automation: FilePath = os.path.join(root, 'automation.yaml')
+    tmp_automation: FilePath = os.path.join(root, 'tmp_automation.yaml')
+    background_tasks: FilePath = os.path.join(root, 'background_tasks.yaml')
+    tmp_background_tasks: FilePath = os.path.join(root, 'tmp_background_tasks.yaml')
+    smart_devices: FilePath = os.path.join(root, 'smart_devices.yaml')
+    contacts: FilePath = os.path.join(root, 'contacts.yaml')
 
     # Simulation
-    simulation: FilePath = os.path.join('fileio', 'simulation.yaml')
+    simulation: FilePath = os.path.join(root, 'simulation.yaml')
+
+    # Custom keyword-function map
+    keywords: FilePath = os.path.join(root, 'keywords.yaml')
+    conditions: FilePath = os.path.join(root, 'conditions.yaml')
 
     # Databases
-    base_db: FilePath = os.path.join('fileio', 'database.db')
-    task_db: FilePath = os.path.join('fileio', 'tasks.db')
-    stock_db: FilePath = os.path.join('fileio', 'stock.db')
+    base_db: FilePath = os.path.join(root, 'database.db')
+    task_db: FilePath = os.path.join(root, 'tasks.db')
+    stock_db: FilePath = os.path.join(root, 'stock.db')
 
     # API used
-    stock_list_backup: FilePath = os.path.join('fileio', 'stock_list_backup.yaml')
-    robinhood: FilePath = os.path.join('fileio', 'robinhood.html')
+    stock_list_backup: FilePath = os.path.join(root, 'stock_list_backup.yaml')
+    robinhood: FilePath = os.path.join(root, 'robinhood.html')
 
     # Future useful
-    frequent: FilePath = os.path.join('fileio', 'frequent.yaml')
-    training_data: FilePath = os.path.join('fileio', 'training_data.yaml')
-    gpt_data: FilePath = os.path.join('fileio', 'gpt_history.yaml')
+    frequent: FilePath = os.path.join(root, 'frequent.yaml')
+    training_data: FilePath = os.path.join(root, 'training_data.yaml')
+    gpt_data: FilePath = os.path.join(root, 'gpt_history.yaml')
 
     # Jarvis internal
-    location: FilePath = os.path.join('fileio', 'location.yaml')
-    notes: FilePath = os.path.join('fileio', 'notes.txt')
-    processes: FilePath = os.path.join('fileio', 'processes.yaml')
+    location: FilePath = os.path.join(root, 'location.yaml')
+    notes: FilePath = os.path.join(root, 'notes.txt')
+    processes: FilePath = os.path.join(root, 'processes.yaml')
 
     # macOS specifics
     app_launcher: FilePath = os.path.join(scripts.__path__[0], 'applauncher.scpt')
     event_script: FilePath = os.path.join(scripts.__path__[0], f'{env.event_app}.scpt')
 
     # Speech Synthesis
-    speech_synthesis_wav: FilePath = os.path.join('fileio', 'speech_synthesis.wav')
+    speech_synthesis_wav: FilePath = os.path.join(root, 'speech_synthesis.wav')
     # Store log file name in a variable as it is used in multiple modules with file IO
     speech_synthesis_log: FilePath = datetime.now().strftime(os.path.join('logs', 'speech_synthesis_%d-%m-%Y.log'))
-    speech_synthesis_id: FilePath = datetime.now().strftime(os.path.join('fileio', 'speech_synthesis_%d-%m-%Y.cid'))
+    speech_synthesis_id: FilePath = datetime.now().strftime(os.path.join(root, 'speech_synthesis_%d-%m-%Y.cid'))
 
     # Secure Send
-    secure_send: FilePath = os.path.join('fileio', 'secure_send.yaml')
+    secure_send: FilePath = os.path.join(root, 'secure_send.yaml')
 
 
 fileio = FileIO()
 
 
 class Indicators(BaseModel):
     """Loads all the mp3 files' path required by Jarvis.
@@ -546,11 +549,8 @@
 
     """
 
     acknowledgement: FilePath = os.path.join(indicators.__path__[0], 'acknowledgement.mp3')
     alarm: FilePath = os.path.join(indicators.__path__[0], 'alarm.mp3')
     coin: FilePath = os.path.join(indicators.__path__[0], 'coin.mp3')
     end: FilePath = os.path.join(indicators.__path__[0], 'end.mp3')
-    exhaust: FilePath = os.path.join(indicators.__path__[0], 'exhaust.mp3')
     start: FilePath = os.path.join(indicators.__path__[0], 'start.mp3')
-    tv_connect: FilePath = os.path.join(indicators.__path__[0], 'tv_connect.mp3')
-    tv_scan: FilePath = os.path.join(indicators.__path__[0], 'tv_scan.mp3')
```

## jarvis/modules/models/models.py

```diff
@@ -248,16 +248,16 @@
                     warnings.warn(
                         f"{env.speech_synthesis_voice} is not available.\n"
                         f"Available Voices for Speech Synthesis: {', '.join(available_voices).replace('/', '_')}"
                     )
     except EgressErrors:
         if not audio_driver:
             raise SegmentationError(
-                f"\n\n{settings.bot} needs either an audio driver OR speech-synthesis to run in Docker container\n"
-                f"normally {settings.bot} will try to launch the Docker container to run speech-synthesis.\n"
+                "\n\nEither an audio driver OR speech-synthesis running in Docker container is required\n"
+                "Normally Jarvis will try to launch the Docker container to run speech-synthesis.\n"
                 "However if audio driver is unavailable, the docker container should be launched manually or "
                 "the audio driver should be fixed.\n"
                 "Refer:\n"
                 "   https://github.com/thevickypedia/Jarvis/wiki#os-agnostic-voice-model\n"
                 "   https://stackoverflow.com/a/76050539/13691532"
             )
     _distance_temperature_brute_force()
@@ -265,10 +265,9 @@
 
 _global_validations()
 # Required at top level to let other modules access it
 if env.temperature_unit == TemperatureUnits.IMPERIAL:
     temperature_symbol = "F"
 elif env.temperature_unit == TemperatureUnits.METRIC:
     temperature_symbol = "C"
-# settings.bot is initiated with "jarvis" but later changed when custom wake words are used
 if current_process().name == "JARVIS":
     _main_process_validations()
```

## jarvis/modules/telegram/bot.py

```diff
@@ -6,14 +6,15 @@
 """
 
 import json
 import logging
 import os
 import random
 import secrets
+import string
 import sys
 import time
 import traceback
 from typing import NoReturn, Union
 
 import requests
 from pydantic import FilePath
@@ -348,15 +349,15 @@
         """
         if int(time.time()) - payload['date'] < 60:
             return True
         request_time = time.strftime('%m-%d-%Y %H:%M:%S', time.localtime(payload['date']))
         logger.warning("Request timed out when %s requested %s", payload['from']['username'], payload.get('text'))
         logger.warning("Request time: %s", request_time)
         if "override" in payload.get('text', '').lower() and not \
-                word_match.word_match(phrase=payload.get('text', ''), match_list=keywords.keywords.kill):
+                word_match.word_match(phrase=payload.get('text', ''), match_list=keywords.keywords['kill']):
             logger.info("%s requested a timeout override.", payload['from']['username'])
             return True
         else:
             self.reply_to(payload=payload,
                           response=f"Request timed out\nRequested: {request_time}\n"
                                    f"Processed: {time.strftime('%m-%d-%Y %H:%M:%S', time.localtime(time.time()))}")
 
@@ -366,15 +367,15 @@
         Args:
             payload: Payload received, to extract information from.
 
         Returns:
             bool:
             Boolean flag to indicate whether to proceed.
         """
-        if not word_match.word_match(phrase=payload.get('text', ''), match_list=keywords.keywords.kill):
+        if not word_match.word_match(phrase=payload.get('text', ''), match_list=keywords.keywords['kill']):
             return True
         if "override" in payload.get('text', '').lower():
             logger.info("%s requested a STOP override.", payload['from']['username'])
             self.reply_to(payload=payload, response=f"Shutting down now {models.env.title}!\n{support.exit_message()}")
             with db.connection:
                 cursor = db.connection.cursor()
                 cursor.execute("INSERT or REPLACE INTO stopper (flag, caller) VALUES (?,?);", (True, 'TelegramAPI'))
@@ -512,15 +513,15 @@
                 else:
                     self.reply_to(payload=payload, response=response['msg'], parse_mode=None)
             else:
                 self.reply_to(payload=payload, response="No filename was received. "
                                                         "Please include only the filename after the keyword 'file'.")
             return
         # this feature for telegram bot relies on Jarvis API to function
-        if word_match.word_match(phrase=payload['text'], match_list=keywords.keywords.secrets) and \
+        if word_match.word_match(phrase=payload['text'], match_list=keywords.keywords['secrets']) and \
                 word_match.word_match(phrase=payload['text'], match_list=('list', 'get')):
             res = others.secrets(phrase=payload['text'])
             if len(res.split()) == 1:
                 res = "The secret requested can be accessed from '_secure-send_' endpoint using the token below.\n\n" \
                       "*Note* that the secret cannot be retrieved again using the same token and the token will " \
                       f"expire in 5 minutes.\n\n{res}"
                 self.send_message(chat_id=payload['from']['id'], response=res)
@@ -535,31 +536,30 @@
         Args:
             payload: Payload received, to extract information from.
         """
         command = payload['text']
         command_lower = command.lower()
         if 'alarm' in command_lower or 'remind' in command_lower:
             command = command_lower
-        # todo: Check if this required
-        # else:
-        #     command = command.translate(str.maketrans('', '', string.punctuation))  # Remove punctuations from string
+        else:
+            command = command.translate(str.maketrans('', '', string.punctuation))  # Remove punctuations from string
         if command_lower == 'test':
             self.send_message(chat_id=payload['from']['id'], response="Test message received.")
             return
 
         # Keywords for which the ' and ' split should not happen.
-        ignore_and = keywords.keywords.send_notification + keywords.keywords.reminder + \
-            keywords.keywords.distance + keywords.keywords.avoid
+        ignore_and = keywords.keywords['send_notification'] + keywords.keywords['reminder'] + \
+            keywords.keywords['distance'] + keywords.keywords['avoid']
         if ' and ' in command and not word_match.word_match(phrase=command, match_list=ignore_and):
             for each in command.split(' and '):
                 self.executor(command=each, payload=payload)
             return
 
         # Keywords for which the ' after ' split should not happen.
-        ignore_after = keywords.keywords.meetings + keywords.keywords.avoid
+        ignore_after = keywords.keywords['meetings'] + keywords.keywords['avoid']
         if ' after ' in command_lower and not word_match.word_match(phrase=command, match_list=ignore_after):
             if delay_info := commander.timed_delay(phrase=command):
                 logger.info("Request: %s", delay_info[0])
                 self.process_response(payload=payload,
                                       response="I will execute it after "
                                                f"{support.time_converter(second=delay_info[1])} {models.env.title}!")
                 logger.info("Response: Task will be executed after %d seconds", delay_info[1])
```

## jarvis/modules/tv/lg.py

```diff
@@ -6,43 +6,45 @@
 """
 
 import socket
 import time
 from collections.abc import Generator
 from typing import List, NoReturn
 
-from playsound import playsound
 from pywebostv.connection import WebOSClient
 from pywebostv.controls import (ApplicationControl, AudioOutputSource,
                                 MediaControl, SourceControl, SystemControl)
 
+from jarvis.executors import files
+from jarvis.modules.audio import speaker
 from jarvis.modules.exceptions import TVError
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
-from jarvis.modules.utils import shared, util
+from jarvis.modules.utils import shared, support
 
 
 class LGWebOS:
     """Wrapper for ``LGWebOS`` TVs.
 
     >>> LGWebOS
 
     """
 
     _init_status = False
     _reconnect = False
 
-    def __init__(self, ip_address: str, client_key: str):
+    def __init__(self, ip_address: str, client_key: str, nickname: str):
         """Instantiates the ``WebOSClient`` and connects to the TV.
 
         Using TV's ip makes the initial response much quicker, but it can also scan the network for the TV's ip.
 
         Args:
             ip_address: IP address of the TV.
             client_key: Client Key to authenticate connection.
+            nickname: Identifier name for the TV as stored in the yaml file.
 
         Raises:
             TVError:
             - If unable to connect to the TV.
             - If no TV was found in the IP range.
             - If a connection timeout occurs (usually because of unstable internet or multiple connection types)
         """
@@ -51,15 +53,16 @@
         try:
             self.client = WebOSClient(ip_address)
             self.client.connect()
         except (socket.gaierror, ConnectionRefusedError) as error:
             logger.error(error)
             self._reconnect = True
             if not shared.called_by_offline:
-                playsound(sound=models.indicators.tv_scan, block=False)
+                speaker.speak(f"The TV's IP has either changed or unreachable {models.env.title}! "
+                              "Scanning your IP range now.", run=True)
             if discovered := WebOSClient.discover():
                 self.client = discovered[0]
                 try:
                     self.client.connect()
                 except (TimeoutError, BrokenPipeError) as error:
                     logger.error(error)
                     raise TVError
@@ -67,26 +70,34 @@
                 raise TVError
         except (TimeoutError, BrokenPipeError) as error:
             logger.error(error)
             raise TVError
 
         for status in self.client.register(store):
             if status == WebOSClient.REGISTERED and not self._init_status:
-                util.write_screen(text='Connected to the TV.')
+                support.write_screen(text='Connected to the TV.')
                 break
             elif status == WebOSClient.PROMPTED:
-                playsound(sound=models.indicators.tv_connect, block=False)
+                if shared.called_by_offline:
+                    logger.info("Connection request sent to '%s'", nickname)
+                else:
+                    speaker.speak(text=f"Please accept the connection request on your TV {models.env.title}!", run=True)
                 self._reconnect = True
-                util.write_screen(text='Please accept the connection request on your TV.')
+                support.write_screen(text='Please accept the connection request on your TV.')
 
         if self._reconnect:
             self._reconnect = False
-            logger.critical("ATTENTION::Client key has been generated. Store it in '%s' to re-use." %
-                            models.fileio.smart_devices)
-            logger.critical(str(store))
+            if (smart_devices := files.get_smart_devices()) and store.get('client_key'):
+                smart_devices[nickname]['client_key'] = store['client_key']
+                files.put_smart_devices(data=smart_devices)
+                logger.info("Client key '%s' has been stored in '%s'", store['client_key'], models.fileio.smart_devices)
+            else:
+                logger.critical("ATTENTION::Client key has been generated. Store it in '%s' to re-use." %
+                                models.fileio.smart_devices)
+                logger.critical(str(store))
 
         self.system = SystemControl(self.client)
         self.system.notify("Jarvis is controlling the TV now.") if not self._init_status else None
         self.media = MediaControl(self.client)
         self.app = ApplicationControl(self.client)
         self.source_control = SourceControl(self.client)
         self._init_status = True
@@ -224,10 +235,14 @@
 
     def set_audio_output_source(self) -> NoReturn:
         """Sets to a particular AudioOutputSource instance."""
         self.media.set_audio_output(self.audio_output_source[0])  # noqa
 
     def shutdown(self) -> NoReturn:
         """Notifies the TV about shutdown and shuts down after 3 seconds."""
-        self.system.notify('Jarvis::SHUTTING DOWN now')
+        try:
+            self.system.notify('Jarvis::SHUTTING DOWN now')
+        except AttributeError as error:  # Happens when TV is already powered off
+            logger.error(error)
+            return
         time.sleep(3)
         self.system.power_off()
```

## jarvis/modules/utils/support.py

```diff
@@ -10,31 +10,31 @@
 import socket
 import string
 import sys
 import time
 from datetime import datetime, timedelta, timezone
 from http.client import HTTPSConnection
 from multiprocessing import current_process
-from typing import Dict, Iterable, List, NoReturn, Tuple, Union
+from typing import Any, Dict, Iterable, List, NoReturn, Tuple, Union
 
 import dateutil.tz
 import inflect
 import psutil
 import pytz
 import yaml
 from holidays import country_holidays
 
 from jarvis.executors import files, internet, word_match
 from jarvis.modules.audio import speaker
 from jarvis.modules.conditions import keywords
 from jarvis.modules.database import database
 from jarvis.modules.logger.custom_logger import logger
 from jarvis.modules.models import models
+from jarvis.modules.utils import shared
 
-inflect_engine = inflect.engine()
 days_in_week = ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")
 db = database.Database(database=models.fileio.base_db)
 
 
 def hostname_to_ip(hostname: str, localhost: bool = True) -> List[str]:
     """Uses ``socket.gethostbyname_ex`` to translate a host name to IPv4 address format, extended interface.
 
@@ -120,15 +120,15 @@
         dot: Takes a boolean flag whether to include words separated by (.) dot.
 
     Returns:
         str:
         Returns the upper case words if skimmed.
     """
     # Set ignore as a tuple with avoid keywords regardless of current state
-    ignore = tuple(ignore or ()) + tuple(keywords.keywords.avoid)
+    ignore = tuple(ignore or ()) + tuple(keywords.keywords['avoid'])
     place = ""
     for word in phrase.split():
         if word[0].isupper() and word.lower() not in map(lambda x: x.lower(), ignore):  # convert iterable to lowercase
             place += word + " "
         elif "." in word and dot:
             place += word + " "
     return place.strip() if place.strip() else None
@@ -377,14 +377,25 @@
 
 def unsupported_features() -> NoReturn:
     """Says a message about unsupported features."""
     logger.error("Called by: %s", sys._getframe(1).f_code.co_name)  # noqa
     speaker.speak(text=f"I'm sorry {models.env.title}! This feature is yet to be implemented on {models.settings.os}!")
 
 
+def write_screen(text: Any) -> NoReturn:
+    """Write text on screen that can be cleared later.
+
+    Args:
+        text: Text to be written.
+    """
+    if shared.called_by_offline:
+        return
+    sys.stdout.write(f"\r{text}")
+
+
 def flush_screen() -> NoReturn:
     """Flushes the screen output.
 
     See Also:
         Writes new set of empty strings for the size of the terminal if ran using one.
     """
     if models.settings.interactive:
@@ -400,30 +411,30 @@
         input_: Takes the integer version of a number as an argument.
         capitalize: Boolean flag to capitalize the first letter.
 
     Returns:
         str:
         String version of the number.
     """
-    result = inflect_engine.number_to_words(num=input_)
+    result = inflect.engine().number_to_words(num=input_)
     return result[0].upper() + result[1:] if capitalize else result
 
 
 def pluralize(count: int, word: str) -> str:
     """Helper for ``time_converter`` function.
 
     Args:
         count: Number based on which plural form should be determined.
         word: Word for which the plural form should be converted.
 
     Returns:
         str:
         String formatted time in singular or plural.
     """
-    return f"{count} {inflect_engine.plural(text=word, count=count)}"
+    return f"{count} {inflect.engine().plural(text=word, count=count)}"
 
 
 def time_converter(second: float) -> str:
     """Modifies seconds to appropriate days/hours/minutes/seconds.
 
     Args:
         second: Takes number of seconds as argument.
```

## jarvis/modules/utils/util.py

```diff
@@ -11,41 +11,49 @@
 import os
 import random
 import re
 import socket
 import string
 import sys
 import uuid
-from datetime import datetime
-from typing import Any, Hashable, List, NoReturn, Union
-
-
-class Dict2Class:
-    """Turns a dictionary into an object."""
-
-    def __init__(self, dictionary: dict):
-        """Creates an object and inserts the key value pairs as members of the class.
-
-        Args:
-            dictionary: Takes the dictionary to be converted as an argument.
-        """
-        for key in dictionary:
-            setattr(self, key, dictionary[key])
+from datetime import datetime, timezone
+from typing import Any, Dict, Hashable, List, NoReturn, Union
 
 
 def get_timezone() -> str:
     """Get local timezone using datetime module.
 
     Returns:
         str:
         Returns local timezone abbreviation.
     """
     return datetime.utcnow().astimezone().tzname()
 
 
+def epoch_to_datetime(seconds: Union[int, float], format_: str = None, zone: timezone = None) -> Union[datetime, str]:
+    """Convert epoch time to datetime.
+
+    Args:
+        seconds: Epoch timestamp.
+        format_: Custom datetime string format.
+        zone: Timezone of epoch.
+
+    Returns:
+        Union[datetime, str]:
+        Returns either a datetime object or a string formatted datetime.
+    """
+    if zone:
+        datetime_obj = datetime.fromtimestamp(seconds, zone)
+    else:
+        datetime_obj = datetime.fromtimestamp(seconds)
+    if format_:
+        datetime_obj.strftime(format_)
+    return datetime_obj
+
+
 def miles_to_kms(miles: Union[int, float]) -> float:
     """Takes miles as an argument and returns it in kilometers."""
     return round(miles / 0.621371, 2)
 
 
 def kms_to_miles(kms: Union[int, float]) -> float:
     """Takes kilometers as an argument and returns it in miles."""
@@ -65,47 +73,50 @@
     if 12 <= current_hour <= 15:
         return "Afternoon"
     if 16 <= current_hour <= 19:
         return "Evening"
     return "Night"
 
 
-def get_closest_match(text: str, match_list: list) -> str:
+def get_closest_match(text: str, match_list: list, get_ratio: bool = False) -> Union[Dict[str, float], str]:
     """Get the closest matching word from a list of words.
 
     Args:
         text: Text to look for in the matching list.
         match_list: List to be compared against.
+        get_ratio: Boolean flag to return the closest match along with the ratio, as a dict.
 
     Returns:
-        str:
-        Returns the text that matches closest in the list.
+        Union[Dict[str, float], str]:
+        Returns the text that matches closest in the list or a dictionary of the closest match and the match ratio.
     """
-    closest_match = [{"key": key, "val": difflib.SequenceMatcher(a=text, b=key).ratio()} for key in match_list]
-    return sorted(closest_match, key=lambda d: d["val"], reverse=True)[0].get("key")
+    closest_match = [{"text": key, "ratio": difflib.SequenceMatcher(a=text, b=key).ratio()} for key in match_list]
+    if get_ratio:
+        return sorted(closest_match, key=lambda d: d["ratio"], reverse=True)[0]
+    return sorted(closest_match, key=lambda d: d["ratio"], reverse=True)[0].get("text")
 
 
 def hashed(key: uuid.UUID) -> Hashable:
     """Generates sha from UUID.
 
     Args:
         key: Takes the UUID generated as an argument.
 
     Returns:
-        str:
+        Hashable:
         Hashed value of the UUID received.
     """
     return hashlib.sha1(key.bytes + bytes(key.hex, "utf-8")).digest().hex()
 
 
 def token() -> Hashable:
     """Generates a token using hashed uuid4.
 
     Returns:
-        str:
+        Hashable:
         Returns hashed UUID as a string.
     """
     return hashed(key=uuid.uuid4())
 
 
 def keygen_str(length: int, punctuation: bool = False) -> str:
     """Generates random key.
@@ -208,15 +219,15 @@
 def extract_time(input_: str) -> List[str]:
     """Extracts 12-hour time value from a string.
 
     Args:
         input_: Int if found, else returns the received float value.
 
     Returns:
-        list:
+        List[str]:
         Extracted time from the string.
     """
     input_ = input_.lower()
     return re.findall(r'(\d+:\d+\s?(?:a.m.|p.m.:?))', input_) or \
         re.findall(r'(\d+\s?(?:a.m.|p.m.:?))', input_) or \
         re.findall(r'(\d+:\d+\s?(?:am|pm:?))', input_) or \
         re.findall(r'(\d+\s?(?:am|pm:?))', input_)
@@ -225,15 +236,15 @@
 def delay_calculator(phrase: str) -> Union[int, float]:
     """Calculates the delay in phrase (if any).
 
     Args:
         phrase: Takes the phrase spoken as an argument.
 
     Returns:
-        int:
+        Union[int, float]:
         Seconds of delay.
     """
     if not (count := extract_nos(input_=phrase)):
         count = 1
     if 'hour' in phrase:
         delay = 3_600
     elif 'minute' in phrase:
@@ -247,15 +258,15 @@
     """Extracts number part from a string.
 
     Args:
         input_: Takes string as an argument.
         method: Takes a type to return a float or int value.
 
     Returns:
-        float:
+        Union[int, float]:
         Float values.
     """
     if value := re.findall(r"\d+", input_):
         if method == float:
             try:
                 return method(".".join(value))
             except ValueError:
@@ -308,28 +319,28 @@
 def remove_none(input_: List[Any]) -> List[Any]:
     """Removes None values from a list.
 
     Args:
         input_: Takes a list as an argument.
 
     Returns:
-        list:
+        List[Any]:
         Clean list without None values.
     """
     return list(filter(None, input_))
 
 
 def remove_duplicates(input_: List[Any]) -> List[Any]:
     """Remove duplicate values from a list.
 
     Args:
         input_: Takes a list as an argument.
 
     Returns:
-        list:
+        List[Any]:
         Returns a cleaned up list.
     """
     # return list(set(input_))
     return [i for n, i in enumerate(input_) if i not in input_[n + 1:]]
 
 
 def block_print() -> NoReturn:
@@ -347,31 +358,22 @@
 
     Instead of binding to a specific port, ``sock.bind(('', 0))`` is used to bind to 0.
 
     See Also:
         - The port number chosen can be found using ``sock.getsockname()[1]``
         - Passing it on to the slaves so that they can connect back.
         - ``sock`` is the socket that was created, returned by socket.socket.
+        - The OS will then pick an available port.
 
     Notes:
         - Well-Known ports: 0 to 1023
         - Registered ports: 1024 to 49151
         - Dynamically available: 49152 to 65535
-        - The OS will then pick an available port.
 
     Returns:
         int:
         Randomly chosen port number that is not in use.
     """
     with contextlib.closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
         sock.bind(('', 0))
         sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
         return sock.getsockname()[1]
-
-
-def write_screen(text: Any) -> NoReturn:
-    """Write text to a screen that can be cleared later.
-
-    Args:
-        text: Text to be written.
-    """
-    sys.stdout.write(f"\r{text}")
```

## Comparing `jarvis_ironman-3.0a0.data/scripts/install.sh` & `jarvis_ironman-3.1.data/scripts/install.sh`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 #!/bin/bash
 # 'set -e' stops the execution of a script if a command or pipeline has an error.
 # This is the opposite of the default shell behaviour, which is to ignore errors in scripts.
 set -e
 
-OSName=$(uname)
+OSName=$(python -c "import platform; print(platform.system())")
 ver=$(python -c "import sys; print(f'{sys.version_info.major}{sys.version_info.minor}')")
 echo_ver=$(python -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
 
 if [ "$ver" -ge 38 ] && [ "$ver" -le 311 ]; then
   pyaudio="PyAudio-0.2.11-cp$ver-cp$ver-win_amd64.whl"
 else
   echo "Python version $echo_ver is unsupported for Jarvis. Please use any python version between 3.8.* and 3.11.*"
@@ -85,15 +85,15 @@
       python -m pip install pvporcupine==1.6.0 dlib==19.21.0 opencv-python==4.4.0.44
     else
       python -m pip install pvporcupine==1.9.5 dlib==19.24.0 opencv-python==4.5.5.64
     fi
 
     # Install as stand alone as face recognition depends on dlib
     python -m pip install face-recognition==1.3.0
-elif [[ "$OSName" == MSYS* ]]; then
+elif [[ "$OSName" == "Windows" ]]; then
     clear
     echo "*****************************************************************************************************************"
     echo "*****************************************************************************************************************"
     echo ""
     echo "Make sure Git, Anaconda (or Miniconda) and VS C++ BuildTools are installed."
     echo ""
     echo "Refer the below links for:"
```

## Comparing `jarvis_ironman-3.0a0.dist-info/LICENSE` & `jarvis_ironman-3.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `jarvis_ironman-3.0a0.dist-info/METADATA` & `jarvis_ironman-3.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: jarvis-ironman
-Version: 3.0a0
+Version: 3.1
 Summary: Fully Functional Voice Based Natural Language UI
 Author-email: Vignesh Sivanandha Rao <svignesh1793@gmail.com>
 License: MIT License
         
         Copyright (c) 2020 Vignesh Sivanandha Rao
         
         Permission is hereby granted, free of charge, to any person obtaining a copy
@@ -265,76 +265,76 @@
 
 ## ENV Variables
 Environment variables are loaded from a `.env` file and validated using `pydantic`
 
 <details>
 <summary><strong>More on Environment variables</strong></summary>
 
-- **ROOT_PASSWORD** - System password to get the system vitals and run other `sudo` commands. Mandatory for `Linux`
+- **ROOT_PASSWORD** - System password to get the system vitals and run other `sudo` commands. (_mandatory for `Linux`_)
 - **NAME** - Name which Jarvis should address the user by. Defaults to `Vignesh`
 - **TITLE** - Title which Jarvis should address the user by. Defaults to `sir`
-- **DISTANCE_UNIT** - Unit in which speed/distance should be measured. Defaults to `miles`
-- **TEMPERATURE_UNIT** - Unit in which temperature should be measured. Defaults to `fahrenheit`
-- **PLOT_MIC** - Boolean value whether to show microphone usage in realtime. Defaults to `True`
-- **LOG_RETENTION** - Number of days to store the logs. Defaults to `10`
-- **WAKE_WORDS** - List of wake words to initiate Jarvis' listener. Defaults to `['jarvis']` (Defaults to `['alexa']` in legacy macOS)<br>
+- **LIMITED** - Boolean flag to run only the main version of `Jarvis` skipping background processes. Defaults to `False` (_enforced based on the number of CPU cores_)
+- **PLOT_MIC** - Boolean value to show microphone usage in realtime. Defaults to `True`
+
+### Audio
+- **WAKE_WORDS** - List of wake words to initiate Jarvis. Defaults to `['jarvis']` (Defaults to `['alexa']` in legacy macOS)<br>
 :warning: Jarvis has limitations on the wake words as it relies on ML libraries for wake word detection.
 
 - **VOICE_NAME** - Name of the voice supported by the OperatingSystem. Defaults to the author's favorite.
-- **VOICE_RATE** - Speed/rate at which the text should be spoken. Defaults to the value from `pyttsx3` module. Typically `200`
+- **SPEECH_RATE** - Speed/rate at which the text should be spoken. Defaults to the value from `pyttsx3` module. Typically `200`
 
     <details>
     <summary><strong><i>To add more voices</i></strong></summary>
 
     **macOS**:
     >   - System Preferences  Accessibility  Spoken Content  System voice  Manage Voices...
 
     **Windows**:
     >   - Settings  Time & Language  Speech  Manage voices  Add voices
 
     </details>
 
 - **SENSITIVITY** - Hot word detection sensitivity. Allowed range: [0-1] Defaults to `0.5`
-- **TIMEOUT** - Timeout in seconds until which the listener should wait for speech. Defaults to `3`
-- **PHRASE_LIMIT** - Timeout in seconds until which the listener will remain active. Defaults to `None`
-- **LIMITED** - Boolean flag to run only the main version of `Jarvis` skipping background processes. Defaults to `False` Enforced based on the number of CPU cores.
-- **DEBUG** - Boolean flag to enable debug level for logging. Defaults to `False`
-- **RECOGNIZER_SETTINGS** - A JSON object that has with customized speech recognition settings.
+- **LISTENER_TIMEOUT** - Timeout in seconds until which the listener should wait for speech. Defaults to `3`
+- **LISTENER_PHRASE_LIMIT** - Timeout in seconds until which the listener will remain active. Defaults to `None`
+- **RECOGNIZER_SETTINGS** - A JSON object with customized speech recognition settings.
 
     <details>
     <summary><strong><i>Custom settings for speech recognition</i></strong></summary>
 
     These are customized according to the author's voice pitch.
     Please use [recognizer.py](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/modules/microphone/recognizer.py) to figure out the suitable values on a trial and error basis.
 
-    > These settings are added (optionally), to avoid the hard coded `PHRASE_LIMIT`
-    > <br>
-    > Cons in using hard coded `PHRASE_LIMIT`:
-    >   - Disables the listener after the set limit even the speaker is actively talking.
-    >   - Listener will be active until the set limit even after the speaker has stopped talking.
-
     Sample settings (formatted as JSON object)
     - `RECOGNIZER_SETTINGS`: `'{"energy_threshold": 1100, "dynamic_energy_threshold": false, "pause_threshold": 2, "phrase_threshold": 0.1, "non_speaking_duration": 2}'`
 
     **Description**
-    - `energy_threshold`: Minimum audio energy to consider for recording. Greater the value, louder the speech should be.
+    - `energy_threshold`: Minimum audio energy to consider for recording. Greater the value, louder the voice should be.
     - `dynamic_energy_threshold`: Change considerable audio energy threshold dynamically.
     - `pause_threshold`: Seconds of non-speaking audio before a phrase is considered complete.
     - `phrase_threshold`: Minimum seconds of speaking audio before it can be considered a phrase - values below this are ignored. This helps to filter out clicks and pops.
     - `non_speaking_duration`: Seconds of non-speaking audio to keep on both sides of the recording.
 
     </details>
 
 ---
 
 ### Peripherals
 - **CAMERA_INDEX** - Camera index that has to be used. Run [camera.py](https://github.com/thevickypedia/Jarvis/tree/master/jarvis/modules/camera/camera.py) to get the index value of each camera.
 - **SPEAKER_INDEX** - Speaker index that has to be used. Run [peripherals.py](https://github.com/thevickypedia/Jarvis/tree/master/jarvis/modules/peripherals.py) to get the index value of each speaker.
 - **MICROPHONE_INDEX** - Microphone index that has to be used. Run [peripherals.py](https://github.com/thevickypedia/Jarvis/tree/master/jarvis/modules/peripherals.py) to get the index value of each microphone.
 
+### Logging
+- **DEBUG** - Boolean flag to enable debug level for logging. Defaults to `False`
+- **LOG_RETENTION** - Number of days to store the logs. Defaults to `10`
+
+### Units
+- **DISTANCE_UNIT** - Unit in which speed/distance should be measured. Defaults to `miles`
+- **TEMPERATURE_UNIT** - Unit in which temperature should be measured. Defaults to `fahrenheit`
+
 ### Features
 - **GIT_USER** - GitHub Username
 - **GIT_PASS** - GitHub Token
 - **BIRTHDAY** - Birth date in the format DD-MM - Example: `24-April`
 - **WEATHER_API** - API Key from [openweathermap](https://openweathermap.org/) 
 - **NEWS_API** - API Key from [newsapi](https://newsapi.org/docs/client-libraries/python)
 - **MAPS_API** - API Key for maps from [Google](https://developers.google.com/maps/documentation/maps-static/get-api-key)
@@ -364,18 +364,29 @@
 - **EVENT_APP** - To read events from `outlook` or `calendar` application in `macOS`. Defaults to `calendar` <br>
 :bulb: &nbsp; When `calender` is used, the name of the _calendar_ within the `Calendar.app` should be **Jarvis** <br>
 
 **Background scans [Defaults to 1 hour]**
 - **SYNC_MEETINGS** - Interval in seconds to generate ``meetings`` information using an `ics` URL.
 - **SYNC_EVENTS** - Interval in seconds to generate ``events`` information using `calendar` or `outlook` application.
 
-**Scheduled Weather Alert**
+**Scheduled**
 - **WEATHER_ALERT** - Time (in 24h `HH:MM` format) when the weather alert should be fired - Example: `09:00`
-> Alerts in SMS and Email if temperature is higher than 100 or lower than 36 or severe weather warnings.<br>
-> This feature can also be enabled from `automation.yaml` by using the keyword `weather` in phrase for the `task`
+  > Alerts in SMS and Email if temperature is higher than 100 or lower than 36 or severe weather warnings.<br>
+  > This feature can also be enabled from `automation.yaml` by using the keyword `weather` in phrase for the `task`
+- **CRONTAB** - Runs external tasks using cron expressions. Needs to be stored as env var.
+  <details>
+  <summary><strong><i>Sample value</i></strong></summary>
+
+  ```yaml
+  [
+    "0 0 * * 1-5/2 find /var/log -delete",
+    "0 5 * * 1 tar -zcf /var/backups/home.tgz /home/"
+  ]
+  ```
+  </details>
 
 **[Wi-Fi Controls](https://github.com/thevickypedia/pywifi-controls)**
 - **WIFI_SSID** - SSID of the wireless connection.
 - **WIFI_PASSWORD** - Password for the wireless connection.
 - **CONNECTION_RETRY** - Frequency in seconds to check for an active internet connection. Defaults to 10 seconds.
 
 **[VPNServer](https://github.com/thevickypedia/vpn-server) integration**
@@ -461,16 +472,16 @@
 email:
   Eddard: ned@gmail.com
   Aegon: egg@yahoo.com
 ```
 </details>
 
 ### Smart Devices [Optional]
-A source file `smart_devices.yaml` is used to store smart devices' hostnames.
 Jarvis supports `MagicHome` for [lights](https://www.amazon.com/gp/product/B08C7GY43L), `LGWebOS` and `Roku` for TVs.
+> This feature requires a `smart_devices.yaml` file which should be stored within the `fileio` directory.
 
 - TV hostnames should include the brand name [`LG`/`Roku`] to distinguish the modules accordingly.
   - This will be set by default, if yours doesn't include the brand name change it in the TV settings.
 
 - To wake up `Roku` TVs using MAC address, make sure the `Bandwidth saver` feature is turned off under,
     ```text
     Settings/Network/Bandwidth saver >> Off
@@ -508,18 +519,18 @@
   - 'WIRELESS_MAC_ADDRESS'
 bedroom tv:
   hostname: 'HOSTNAME'
   mac_address: 'MAC_ADDRESS'
 ```
 </details>
 
-### Automation Setup [Optional]
-Jarvis can execute [offline compatible](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/modules/offline/compatibles.py) tasks 
-at pre-defined times without any user interaction. Uses an `automation.yaml` file as source which should be stored 
-within the directory `fileio`
+### Automation [Optional]
+Jarvis can execute [offline compatible](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/executors/conditions.py) tasks 
+at pre-defined times without any user interaction.
+> This feature requires an `automation.yaml` file which should be stored within the `fileio` directory.
 
 <details>
 <summary><strong><i>Setup Instructions</i></strong></summary>
 
 The YAML file should be a dictionary within a dictionary that looks like the below.
 
 **OPTIONAL:** The key, `day` can be a `list` of days, or a `str` of a specific day or simply a `str` saying `weekday` or
@@ -545,61 +556,78 @@
   task: set my bedroom lights to 5%
 12:00 AM:  # Even performs tasks that are not supported via voice commands
   task: restart all background processes
 ```
 </details>
 
 ### Background Tasks [Optional]
-There are two options to run background tasks on Jarvis.
-
-- Jarvis can run internal tasks (offline communicator compatible) at certain intervals using a `background_tasks.yaml` file stored in `fileio` directory.
-    <details>
-    <summary><strong><i>Setup Instructions</i></strong></summary>
+Jarvis supports both internal and external background tasks to be scheduled.
 
-  This is the sample content of `background_tasks.yaml`
+- Jarvis can run internal tasks at certain intervals.
+> This feature requires a `background_tasks.yaml` file which should be stored within the `fileio` directory.
 
-    ```yaml
-    - seconds: 1_800
-      task: just turn off all lights  # Runs every 30 minutes - 'just' flag retains the lights' last setting (eg: brightness or color)
-      ignore_hours:  # Ignore the schedule at 5 AM and 10 PM
-        - 5
-        - 22
-    - seconds: 10_800
-      task: remind me to drink water  # Runs every 3 hours ignoring the hours specified
-      ignore_hours: "21-6"  # Ignore the schedule between 9 PM and 6 AM
-    ```
-    </details>
-
-- **CRONTAB** - Runs external tasks using cron expressions. Needs to be stored as env var.
-    <details>
-    <summary><strong><i>Sample value</i></strong></summary>
+<details>
+<summary><strong><i>Setup Instructions</i></strong></summary>
 
-    ```yaml
-    [
-      "0 0 * * 1-5/2 find /var/log -delete",
-      "0 5 * * 1 tar -zcf /var/backups/home.tgz /home/"
-    ]
-    ```
-    </details>
+```yaml
+- seconds: 1_800
+  task: just turn off all lights  # Runs every 30 minutes - 'just' flag retains the lights' last setting (eg: brightness or color)
+  ignore_hours:  # Ignore the schedule at 5 AM and 10 PM
+    - 5
+    - 22
+- seconds: 10_800
+  task: remind me to drink water  # Runs every 3 hours ignoring the hours specified
+  ignore_hours: "21-6"  # Ignore the schedule between 9 PM and 6 AM
+```
+</details>
 
-### Simulation Setup [Optional]
-Jarvis can execute [offline compatible](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/modules/offline/compatibles.py) tasks 
-as a simulation to test the required functions and send an email with the results. Uses a `simulation.yaml` file as source which should be stored
-within the directory `fileio`
+### Simulation [Optional]
+Jarvis can execute tasks as a simulation to test the required functions and send an email with the results.
+> This feature requires a `simulation.yaml` file which should be stored within the `fileio` directory.
 
 <details>
 <summary><strong><i>Setup Instructions</i></strong></summary>
 
 The YAML file should be a list of phrases within a dictionary that looks like the below.
 
 ```yaml
 meeting_event:
 - get me the events from my calendar
 - what meetings do I have today
 ```
+</details>
+
+### Custom Conditions [Optional]
+Jarvis can execute function(s) directly based on a [custom condition](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/executors/custom_conditions.py) map,
+via both voice and offline communicators.
+
+- The condition mapping may contain one or more functions to be executed for a single keyword/phrase.
+- These functions are executed as ordered in the mapping file and responses will be delivered as each task is done.
+- For offline communicators, in case of multi-function mapping, the responses are gathered and then delivered at once.
+
+> This feature requires a `conditions.yaml` file which should be stored within the `fileio` directory.
+
+<details>
+<summary><strong><i>Setup Instructions</i></strong></summary>
+
+The YAML file should be a dictionary within a dictionary that looks like the below.
+
+```yaml
+lumos:  # custom keyword
+  lights: turn on all lights  # function_name: phrase passed as argument
+knox:
+  lights: turn off all lights
+  television: turn off bedroom tv
+fire up the chopper:  # custom phrase
+  garage: open garage
+  car: lock start car
+```
+
+:warning: This is a direct mapping to the [functions](https://github.com/thevickypedia/Jarvis/blob/master/jarvis/executors/functions.py), 
+so the input phrases are not validated by Jarvis. This may cause `RuntimeError`s if invalid phrases are entered in the mapping file.
 
 </details>
 
 ## Guide
 Please refer to the [wiki](https://github.com/thevickypedia/Jarvis/wiki) page for API usage, access controls, env variables, features' overview and demo videos.
 
 ## FAQs
```

## Comparing `jarvis_ironman-3.0a0.dist-info/RECORD` & `jarvis_ironman-3.1.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,123 +1,120 @@
-jarvis/__init__.py,sha256=1b792H4gCkr5R0ovnfZ7sRB2DLv2vj22C11TqnGdr9s,1090
-jarvis/main.py,sha256=qCPZCi_qURAXXrEvF_6HIensRKEzsOZsB-CbroRuRz4,9396
-jarvis/_preexec/keywords_handler.py,sha256=AsP9mKCALDk2BcAPPHp3l2e_nSxUZA0CHYwaMqXr3q0,2642
+jarvis/__init__.py,sha256=uZfe7y9V924Cwh0LsDGlpYzBuMSTmg2AWu7fR2nNEy8,1089
+jarvis/main.py,sha256=mWhep_zrfSMZOSdU9CSSjILMQdSTh7Noa3eScsBP7nQ,9166
+jarvis/_preexec/keywords_handler.py,sha256=gxciHuE5_wPv62z07xcoLJfWXIdW1qopfgS5UE1-FLE,2069
 jarvis/api/fast.py,sha256=JmfNTwBLTBkMyM7qk7WA4VVCYCYWpdLPDEw4PpHyx-Q,1911
 jarvis/api/server.py,sha256=9g7-rkYKJLDyGHtvS3pbhQEzYWh5Hguvyy7UvtO5REk,2444
 jarvis/api/modals/authenticator.py,sha256=tPY22FM2wIJ2t8DWnN71jlSiT8Rf6W9cadK4DC2O3t0,2388
 jarvis/api/modals/models.py,sha256=y9K0FuwUCmi_UASRLfptjxAQGNCaFWt4SKF6WU2lA7k,1133
 jarvis/api/modals/settings.py,sha256=icAUX-PZ2MxuBsc4pa6AB261AaX2LLtq3C21C2Pox7M,2422
-jarvis/api/routers/basics.py,sha256=CPAfy02YYoW_SAkgXpY-tWlK0xpm7Ees4eSibC3qczo,1968
+jarvis/api/routers/basics.py,sha256=RCo_ILdkP7BoS7xwcWcufxMecIwYFw2fnnkclXwegxQ,1959
 jarvis/api/routers/fileio.py,sha256=PlzBj1fSilTpVHAakUjkgaXNRSca-NFkGqn1iOFToIE,3098
 jarvis/api/routers/investment.py,sha256=LKYFqzAksXm71hoTzmo1loMiCZxCp_pqkp63BOhxEDs,6069
-jarvis/api/routers/offline.py,sha256=JcuYleRWY63ewMuYDmll0qzzJX0fPme1JcqUVevJeIE,7843
+jarvis/api/routers/offline.py,sha256=w1ay93mXuA5F6oEyeCeEQsqrOlM1ZCm-OYszTOioVaU,7867
 jarvis/api/routers/secure_send.py,sha256=Fa6xPumqzirBu0Ad5W1fpQdsPyF5Dw02TXSBA7F7GqY,2086
 jarvis/api/routers/speech_synthesis.py,sha256=BLUJ2x7rELAv5H1Q-jfkl8wplhbn1Xkoh01BZeYnijY,4334
 jarvis/api/routers/stock_monitor.py,sha256=Od5NchFYaZecIoDIaHDBZAV4sYRgsdIH6jFRj7V-YqI,13659
 jarvis/api/routers/surveillance.py,sha256=I8hamoanBVPk6zrfwSpTB1YQ_2WLfwHAd8KEmV-K25c,12943
 jarvis/api/squire/discover.py,sha256=Jjq6ViTpyzckuhC_GNlUVwJ45i07XyBW7IquyRF4UOA,2668
 jarvis/api/squire/favicon.ico,sha256=WMmt7kTMDjd0HmR4sFloGQm0WohOPVry9ivdK40AAqc,15406
 jarvis/api/squire/logger.py,sha256=UFMEHrgTl0do-Do_Q66MmP4Rh1dFJOM0OXeg3sRCqyY,1283
 jarvis/api/squire/scheduler.py,sha256=MtlHaMK3Hs1z1spojrUjRhM9wKopk61cSi2ceJfda80,2879
 jarvis/api/squire/stockmonitor_squire.py,sha256=1mLvZUKgqTqUEi6kqgKGYGyx3gSK4wo4wR9KTr2nelE,6487
 jarvis/api/squire/surveillance_squire.py,sha256=AUPxRpHZsVYNSObD9-JI43YBIYVOb1yUMO07AovX7lQ,5237
 jarvis/api/squire/timeout_otp.py,sha256=rmUgoGPZ3kuePIJcajmuoO5jQJRUbovEUlGIW8oLkQo,740
 jarvis/api/triggers/stock_monitor.py,sha256=PIjl7zrB4_MDYLArNBE8friW2mg4SieLp1anjFxaW5k,11313
 jarvis/api/triggers/stock_report.py,sha256=_5rOYxA7at16IPhQqNW6c_DgF5_ktViBD2OfTFeXTIQ,11491
 jarvis/executors/alarm.py,sha256=Zo59izi752dzIGcgNIant5Tfy2nDLHymO_uMndWMyRU,8213
-jarvis/executors/automation.py,sha256=8wkomzOcHZyDauaEmUWZmBW1F7juYZUOWuhhpPjUrtA,5531
-jarvis/executors/background_task.py,sha256=6lT90FxmnBS8WdNATV-XR8uzGVt9lgU3vf_rVYEtgwE,5093
-jarvis/executors/car.py,sha256=5pKinhsiES5kpJ-g-o2UZ4NECFi25RvVDGxlxPddKnQ,24756
-jarvis/executors/comm_squire.py,sha256=nOA_75CBsbereBscZkvUR_RoK3p3RyvF7n9NQpf2rKY,8533
-jarvis/executors/commander.py,sha256=dg3w8EKNaGrINEO6EqVs3TvoeCal6wg1BJAhW7-1hdQ,6554
-jarvis/executors/communicator.py,sha256=HuRGr4epwhRpzKyPVgTVvpN02Pv9Vr7zQ25XLxHCEUw,5238
-jarvis/executors/conditions.py,sha256=TSULx8DJUBsrf_QCi2PwDfAK7DEcN_pynYh34ZzvZBU,3876
+jarvis/executors/automation.py,sha256=7Dd4ezokc6ZHWcept3jaHvINgStyG2x8cE4I533dbe8,6130
+jarvis/executors/background_task.py,sha256=aI7ROK217aHI-qkCSq4opm04FM8H5XhLrtoYWL7Qi0g,5400
+jarvis/executors/car.py,sha256=hL9XOm7WkOfWRuOxfSzXuaK7jvFSCjBCB1ySyTvRP1A,25356
+jarvis/executors/comm_squire.py,sha256=CsewmNqBkAQsflcGKXqfpOaoKaP3OXasWBX7aRIh_5U,8539
+jarvis/executors/commander.py,sha256=oYhJjzs4MRhXPts7I67DImq0m-WAqifz_TVHfbqKqNU,6578
+jarvis/executors/communicator.py,sha256=0_9EWLIdZpZ2kU_55-WGHu_rZ8cuQkugQzejyroPT7k,5238
+jarvis/executors/conditions.py,sha256=NxO5Cyb3tFiOUbIFjwtz1625CqMI99V-wrkHY5Yk0A8,4482
 jarvis/executors/connection.py,sha256=tFmbSW1bDkw20_ixZI2sjMJD8tbLLAcCTi5YcOPQj8c,2305
-jarvis/executors/controls.py,sha256=-pRKlfw5Qd4BxYVw-ibDt1TRo8HwXH1eWcFYZBYR24w,12870
+jarvis/executors/controls.py,sha256=0ivxXu_PgL7u6_sYB3Jw2N20jWLLDZljKAxdf80kWd4,13219
 jarvis/executors/crontab.py,sha256=9FqPSD7xFz_sbipbcIsVbdqd6DjdabbmjwoDtUkhzJw,1156
+jarvis/executors/custom_conditions.py,sha256=2XhYOUrAbH9HDqzsAX8KkDouGyGWhIfav6qgu7qlUJ8,1863
 jarvis/executors/date_time.py,sha256=YXyqqgssYf5rCoT0TINDDXd7OvuXZuLZUUAuwSaUin4,2584
 jarvis/executors/display_functions.py,sha256=lyBDTqbV0v39Z0ejPgsPIyUnQguIiBrhUR5-PwR7d7I,1069
-jarvis/executors/face.py,sha256=GZJWiwmviYEi_aHmTHUlOBSHUJFbP9tUqeuWUlQx0PU,3922
-jarvis/executors/files.py,sha256=EsP7pzSi6HE3dioI0ljj85xljA27IVJGNgLsb7x4UFU,4063
-jarvis/executors/functions.py,sha256=EEFScwqLxN8w59A_szt4l8rxuLqROBH-49mOKTLcSlk,3680
-jarvis/executors/github.py,sha256=Bkpx_91AoJom0I8qxCPeRiKqfk_MtyGONHgnVXw5uw4,4025
-jarvis/executors/guard.py,sha256=t_BVuWQAHnxUvzYmepxJXRroeEPlXwvwo19zo6LP1Ys,10642
-jarvis/executors/internet.py,sha256=gPU-dN_6-QJf31eaPIsOWFUn7KOsuHJUky1BzJ-_62E,7183
-jarvis/executors/ios_functions.py,sha256=lWZCKEGJ9hmJ5GjDPoMkrdpyqcqXSQ0St4E023NAF4M,6229
-jarvis/executors/lights.py,sha256=9NLBXYRcE_tq_93dt1FYkbCZpK4oFWUjcpOnfwVtC4o,10053
+jarvis/executors/face.py,sha256=xBZLj9gzZGGmpP6oUSDD4XhiunLwdl55FTlTscH0uxI,3922
+jarvis/executors/files.py,sha256=7vWDGk1PbP5ZJrPTHQ7eDDbjG8aOyrIuwFXMp4vbVgk,6596
+jarvis/executors/functions.py,sha256=uEK0rrLRTbG9xG5I91LDZPyTNgGspsirMXT31XamKwc,3577
+jarvis/executors/github.py,sha256=Sw_yO8A8zelVzJXczfYrBZTRUGovOksvCemmVQWjpj0,4028
+jarvis/executors/guard.py,sha256=_swNnJNRhhioD8nvNB-MZyRIW9ilJCBgm5Qe-xIi-mc,10657
+jarvis/executors/internet.py,sha256=BWvDon75Q2oZlGD8b8aX1zoz4Cre0_73fJCOHvSYHEM,7180
+jarvis/executors/ios_functions.py,sha256=Dt9Hm2xURL4EtGdZuVmZZA1U4dDwzWJ9HiB0a9n9Qw8,6235
+jarvis/executors/lights.py,sha256=AzAFS--LjfYg7u2MTUSuQ1sChUYjUTIXZN7gahpIRQU,9710
 jarvis/executors/lights_squire.py,sha256=y9raOMXmT0egFSNgW0wVg0HWQmeLLalU1rk1oxM5DK8,5170
-jarvis/executors/listener_controls.py,sha256=2fHPgSG-23UDp-OQoRYuzb5nD8UIjHbDGsXI__XQlOE,2466
-jarvis/executors/location.py,sha256=dVdzmFlS_0hVIs7hTiyeOEsDAZ5GrDeXlAWiW9YJWfs,13475
+jarvis/executors/listener_controls.py,sha256=B30SsXHKfE9fLMxER3A5Zv8pv2pi8bmI_YNSmuZvIgU,2595
+jarvis/executors/location.py,sha256=D3lInZ9hB3ljyXKEbRKgnjTLj_yD0-MlFshOsgurDbA,13475
 jarvis/executors/myq_controller.py,sha256=k5qPSHnc8k8LaQQxV6qMfuliu6_jzhZarBfukqr_2a0,3297
-jarvis/executors/offline.py,sha256=ug4faaLBIrHbFBwoyhBnZv5Iu8t9yBqC3u1LaKh7Jo0,15775
-jarvis/executors/others.py,sha256=FIz3sEKkh3zdeoSaKsS2hTaVEBD6hy3wmdnPX77bxKE,22859
+jarvis/executors/offline.py,sha256=QHibfAt1BNDeSH0vslXRoyR26mfl-ms5KcUnRAk7SA4,15444
+jarvis/executors/others.py,sha256=FKRE6HqnRxhLEepC8llEfQKjUBJmDSBIvRWPEBbMkRM,22874
 jarvis/executors/port_handler.py,sha256=3eB1_jBDeP-JW-DYyp3ENP07Vis-poqCW0xnzxw8vAE,2878
 jarvis/executors/processor.py,sha256=BH2xWTGjPhtwFaiIiPCUjue8zAbcpeDuixRgsh8xCC8,8485
 jarvis/executors/remind.py,sha256=IjAtAeJymdOShTZ8c7RuCcvce6icnENOmGZQUPGDFqI,7282
 jarvis/executors/robinhood.py,sha256=mYx22aLSLUhuggYKPEEn0_Ga-AyjsH7zw6PU8F7e_ew,3278
 jarvis/executors/simulator.py,sha256=3UmRuz04UdSuT7oPVHBboY7bkZq71GK92jZSChg_sJw,3604
-jarvis/executors/static_responses.py,sha256=FKdP238KHj-M9WTeZw4MYTphRCq0_xSlf0MDOMIjCto,3351
-jarvis/executors/system.py,sha256=TMe6SHWdBJVHr7oTmNoUSsFNlD71t4OOsWUhxoBeDZM,8545
-jarvis/executors/telegram.py,sha256=jukISBjUtBA9T2eMV0RcF29h5gFDgKYvuWgVHBvt9bA,1717
-jarvis/executors/todo_list.py,sha256=vN2UOGJfK-vzR1JoQawm7KhfESqC_QGD3pj_ESOUEnI,5269
-jarvis/executors/tv.py,sha256=yP4REp13q0wp3WocXbjYkBw_zkkTbdIyEnDv-WUZaEE,6640
-jarvis/executors/tv_controls.py,sha256=9feo1cohBHYxH-mvw_d6fYOpULsURZes45ESmb4AfwQ,6305
-jarvis/executors/unconditional.py,sha256=vOJ_6NBxR8RJPU5DdpLUJ82LqGqtzcmPOSpnzHPt8jI,4850
+jarvis/executors/static_responses.py,sha256=aQ0pBHb4cTx14nIfme0asxGwlKVQNrJQ8Cuy9WP5hQY,3401
+jarvis/executors/system.py,sha256=AwmEBP-fFMyzpki96Is1eoBhB3Oo_VbW2YKQpl-R-k4,8370
+jarvis/executors/telegram.py,sha256=hGi8nXIQnQafL93OqYxKCSnn9PeiB-ugeEseM6Iuo6M,1742
+jarvis/executors/todo_list.py,sha256=C2LXxWayLre8MWRfPvDmI0xpzcdNdU80NcKrdF9K1xE,5272
+jarvis/executors/tv.py,sha256=Hy11Xf_J3Siji9bk_OZkj5bPKW4Bf-Txgnh-ZE-1DHk,6854
+jarvis/executors/tv_controls.py,sha256=SHc3vq4yhTPNYcv1sdZ_Rb2q8HQIYYbosYlCiudN19w,6327
+jarvis/executors/unconditional.py,sha256=bF3MoZ_mtLfFOSBQRT3nIXJWoywj_Z2hSnYOci5soYY,4862
 jarvis/executors/volume.py,sha256=YmyzTjQN6l1VQNeKrFPcAnKfM8fdwdg7i-OtNDWWHtY,2294
 jarvis/executors/vpn_server.py,sha256=i8uwqgBgfFGgAZAV2pe71m6NXsEzDfiiT0gsuHNG63o,5727
-jarvis/executors/weather.py,sha256=ciqB33YtdJRzpN-6fZPZ4DI_F4TM3JNJh-pV3MZYZ4Q,12435
-jarvis/executors/weather_monitor.py,sha256=NhcM33dodUyFlwokDvcFKCJ064XZMSYcBKOr7RKXh8Y,3215
-jarvis/executors/wiki.py,sha256=oD4KcKJi9RsUsMJECKarEev0ZmdtyyfuJYu4imBV-tk,2272
+jarvis/executors/weather.py,sha256=9P6WxBYFXrpemOsm63KvdJNtZcec_vutgNUq9_hAhF8,12438
+jarvis/executors/weather_monitor.py,sha256=Z7xZ4nIR2eepdTgROBqJ_FmnsLDkDRjTKLHe72QIIag,3216
+jarvis/executors/wiki.py,sha256=hqWd4gzfG1FxEg5bbKpeMlr4WYSCUb0CP3DDhbxp5zc,2275
 jarvis/executors/word_match.py,sha256=REtKpZEeI2GLpo3FQb5E3hgP_O99IpVcztrT6WVxe6Y,1809
 jarvis/indicators/acknowledgement.mp3,sha256=P-S3PFZIeiJFqA2C5ZKtrs8mcmLEVF8nJUXyl0uetv4,9239
 jarvis/indicators/alarm.mp3,sha256=Owyx3lMW4TFcqu0RzHSfATtisCO-X2wTr5aSNOPLOO8,3087321
 jarvis/indicators/coin.mp3,sha256=aanaWMluO1qkRDUGJTSjIuhsStkuNgUxyWcI6F_AP5Q,17350
 jarvis/indicators/end.mp3,sha256=2JRvDqzUoHtKIUmK7avk6ZzkGhPXCwbkJpNPJ29saAA,9448
-jarvis/indicators/exhaust.mp3,sha256=7AuR6yNqQGiFMDwklkhzrnGIn-p2ruq-9XngnpEPYcs,88953
 jarvis/indicators/start.mp3,sha256=MbMvddN-d4RTTAXS3Hv71i3uQgpHbOB0qhK_odDDrnw,11538
-jarvis/indicators/tv_connect.mp3,sha256=2h_TCialYtFlox3sV48oCvQ1isRIECZQrvLI2vapVSk,30208
-jarvis/indicators/tv_scan.mp3,sha256=tbLY6NZUiXgO-HfGw1TPogFoVHXEsz7_ZRytuWeE1Co,54740
-jarvis/lib/install.sh,sha256=rEv4cireRScABobkHmoht1iqUz3N6AWP0b_stcBuUTk,8062
+jarvis/lib/install.sh,sha256=p-IPD6CbK9pyHBIFNSbo09m91sEs2Ybhv62ejCBY7uM,8114
 jarvis/lib/version_locked_requirements.txt,sha256=e7I3q_qC9H_TrvybhzSsrOZugPpXiDipV2jwfk8Kk1A,1021
 jarvis/lib/version_upgrade_requirements.txt,sha256=J4lMLHV1x9Jn2lzixdsJJbutH7teROHLHT-U2FZkhvE,107
 jarvis/modules/auth_bearer.py,sha256=9oAERfASspVERGo80gLRjec8MnAThHpi8JGdGfvJEWw,1076
 jarvis/modules/builtin_overrides.py,sha256=0oz0cl-b2lQxyzgm62dJPcGwLVuIh93K_NzfoA1FrKQ,3488
 jarvis/modules/exceptions.py,sha256=fV6fwuKxRI1Jl_Ri_zFkSZZ0l7wLW-Bj-hwOJi7sXzg,4322
 jarvis/modules/peripherals.py,sha256=CZVHz1QTr5v8RDDuhcf54M1qAaXqL9X0qzuT2YLgMAo,1401
-jarvis/modules/audio/listener.py,sha256=PTeXC82P_PkRW0AHFiSX2Ngd4ZhgelMJ0aghRLugxXU,2424
-jarvis/modules/audio/speaker.py,sha256=FGx3YbdzgmYKUI-VUU2izPSaaYPZwc7GHUPlnFx2-1I,6132
-jarvis/modules/audio/speech_synthesis.py,sha256=uf9SFFsjtH5oCnDkFlv4dUrCSaJmjO4CHalU46tTvfY,4829
+jarvis/modules/audio/listener.py,sha256=XhBPFucRw4zI9WsoQJl8rjKiCYioRftPyfMseRAUQ2g,2515
+jarvis/modules/audio/speaker.py,sha256=sJ42DRjmGB8xZKWxFybSIiMH0xsyXxS9CwRzMY_cOgQ,6216
+jarvis/modules/audio/speech_synthesis.py,sha256=Wvlk2iuR8-BiM_0Cle0-bNg5Jl8ca7V0sETYm90HmlI,5122
 jarvis/modules/audio/tts_stt.py,sha256=l0pDYOkSSrLfdpleRJCwpYomZuFYw3TYv7LJbIYKcEQ,2963
-jarvis/modules/audio/voices.py,sha256=KlDFIRlavXO9oIpOK3EJlJWdRENvahEAyHPRJmxaHLU,2628
+jarvis/modules/audio/voices.py,sha256=5z5Uz4AsZGoyRPYQP79YNgxj_9xCR56d3l37ec_oqmc,2638
 jarvis/modules/camera/camera.py,sha256=FV_CNAUzAjixKKJyj37HD0qmP9EVuLgl_xhfAxfTn5c,7098
 jarvis/modules/car/connector.py,sha256=YPzaT3VF5RhFKJD16LdQTbfX3YGtQETTabPA1dFT7LU,9371
 jarvis/modules/car/controller.py,sha256=PMuTkR7jE4p3MhdOUHYsw67KlqfBmDn_8tmjO8Ebk2E,30523
 jarvis/modules/conditions/conversation.py,sha256=OrNxaLCpvR8nvC67KzNSIcN9Ti5nWKVA1nQi5GNWKZk,2762
-jarvis/modules/conditions/keywords.py,sha256=yOeO-detaui--ZGd-eYjQc0r4FNht09SzOAs9yyhGrg,194
-jarvis/modules/conditions/keywords_base.py,sha256=lLAflMvBVjiHevEsMfMiaWYw3Nz_mgcEjRlBR4QlFbw,5504
+jarvis/modules/conditions/keywords.py,sha256=CJIVXX3zhaMlLvG5CvUVKrMwgp0HQqMH4TrhzhuCaIY,5606
 jarvis/modules/crontab/expression.py,sha256=KiumyRpk2HQbg6aAA_w94BqmMJZpAovHGYhPqivaF3E,12259
 jarvis/modules/database/database.py,sha256=1sQZDcsgiS5guFpOUGbruGBXvpf6Tn-ipkuuJ_jEyNQ,4143
 jarvis/modules/dictionary/dictionary.py,sha256=Ljn7Na4-F34emCxzTWXUbJsT2XMN8d2eyFZxmLVScxU,1645
 jarvis/modules/facenet/face.py,sha256=joQdu41qQPJrmfntQ-x2ZWThdeoh95u1zuIHKTLH6qA,7228
 jarvis/modules/lights/preset_values.py,sha256=DH_Ss-8voNvyE48jSiqRQDnJK9GijX8Y-QU6vsIMfQU,639
-jarvis/modules/lights/smart_lights.py,sha256=O3RKS8YpTj85RQzKdqr9QZyA7XjxkfP77QgAK03Zhw0,7734
+jarvis/modules/lights/smart_lights.py,sha256=5qQT9VlSf_-d-NWYVq8-bgwjj8DWx4bbPu8eWI7tm1s,7743
 jarvis/modules/logger/config.py,sha256=BaJ-FdWzArPLqo-psi8joZbeVBUr1RrZ2L9yg4WVfXU,3645
 jarvis/modules/logger/custom_logger.py,sha256=NTH6LAQXIYG6RJ_IT_kA2_Rf4LzAHl_zm1LPEzqywl8,4109
-jarvis/modules/meetings/events.py,sha256=wM7LjHSlKD9IY3MsbRXX6kzN7oqzcwT2rlJYo6CMoPU,7940
+jarvis/modules/meetings/events.py,sha256=xCL6KGazEFdaXdFYFNnn9VkTiCfxxMeeZB3jXcLyYEQ,7951
 jarvis/modules/meetings/ics.py,sha256=AB0_mTN1Mib0vHb04nbi5MDRqG-_vzmy-e0JhVWmhw0,4356
 jarvis/modules/meetings/ics_meetings.py,sha256=DCKI3ezls1HbmNRKL7eoIU8E-ysY1ZuPiDbFppXYfxo,8109
 jarvis/modules/microphone/graph_mic.py,sha256=nhhVSqHl2h6P3-T_Ph89Bl1gpEkIsUDDNDnxpqMlbGA,8208
 jarvis/modules/microphone/recognizer.py,sha256=mDE6NaGylzj1BtnKES-6T4bDyp5ASSylWmivr3DD1MI,2848
-jarvis/modules/models/classes.py,sha256=KfxB08FjhY11Cj1_VgI4eEYiAE4ySa9durphMlN8o9Y,20547
-jarvis/modules/models/models.py,sha256=SyDq7IIjfMMfxGNBbbGzid7LL_hkzORqwgDQjtjrebE,12736
+jarvis/modules/models/classes.py,sha256=hrf7d4oEuqZmDunXG6kcALDnsG2aohvpsFEtUwTbASI,20533
+jarvis/modules/models/models.py,sha256=39afBRuAGEfNMgJeV1EN1hBX_QRZRbuZ-DURptSMi2w,12626
 jarvis/modules/myq/myq.py,sha256=fJkyOlrzQg7C1BXoflhTgHmilFehvkqczkLzDD49hJw,4503
 jarvis/modules/retry/retry.py,sha256=IMCATivgdk50m36pCeNoVDDfSuGCz_jJqDZZBCkvxhY,2712
 jarvis/modules/speaker/speak.py,sha256=rXjkkCB2ZZ15J691xliR0VpCZ3ulh5OiF-dUnmgWPMc,5352
 jarvis/modules/telegram/audio_handler.py,sha256=9XPxF3qgUFq9f0GchprdSbCQUkJT7R16UYOqGHV6KkI,2050
-jarvis/modules/telegram/bot.py,sha256=lS48GAsU523tLl2GqE_oInsdsczRwM84fn6pkcb_gTU,27804
+jarvis/modules/telegram/bot.py,sha256=E03YXCRv_pnA9c5dc-wUfdFSd90LYnAVp0P0fTdHIw4,27802
 jarvis/modules/telegram/file_handler.py,sha256=_amPR-mxugUzmntXmrvMsGm6akSYcI7ObS_vFFfRvsA,2969
 jarvis/modules/temperature/temperature.py,sha256=Za53mzAr-IEtupRVJcKKwvi64t4KeFhWVTSBzRJcH6Q,1616
 jarvis/modules/templates/car_report.html,sha256=lkt3N2yUT4xurzBy4q-aFhcEjnX2eWOMqx-zU0BMfxo,2821
 jarvis/modules/templates/email.html,sha256=EoF5gZfeC9soJrW7pTPQo2ZtXYhTP0Zy9OxsqRZhBMA,25812
 jarvis/modules/templates/email_OTP.html,sha256=2mv0mFTNZI3xdph3f_gG2mRSx9VciZ1r-eVsC0gBOGU,3383
 jarvis/modules/templates/email_stock_alert.html,sha256=tb69-t_HgycK6KHkv7H_Ypxr0Bs69oiImPmcOswsa9Q,367
 jarvis/modules/templates/email_threat_audio.html,sha256=AoA_JfczBo2eWohwRRydjgZ1ecihcZZRXkwKvqJCKPg,127
@@ -125,22 +122,22 @@
 jarvis/modules/templates/email_threat_image_audio.html,sha256=IidTWShspeMIn9-MOLrOaBHMW2MoXKwcB_n6sCRnKxI,179
 jarvis/modules/templates/robinhood.html,sha256=PS9IqlYVkfJQFHSvScaT2hFJPET6tnyx0rEeZNkIKjI,2284
 jarvis/modules/templates/surveillance.html,sha256=x3II9a41avWeJQ071dBmamnz0VQ_TzjsexRGNPzTlBg,2370
 jarvis/modules/templates/templates.py,sha256=TnJ39GHVMrQaFIlLm_ltyEIVzNbTr2Y6cXt3vo8h9xs,2059
 jarvis/modules/templates/win_wifi_config.xml,sha256=m8b_rkpgKpXn2NfP_qRYJY2oJ5DLzlwKcYJKClL1dlM,637
 jarvis/modules/timeout/timeout.py,sha256=IJNmE_XdyN3to4JTse14ux-Yao5USR_fvLLNoN9WglQ,2070
 jarvis/modules/transformer/gpt.py,sha256=l2EqFlafHZxW1UcyVaBRG1zwU3gWzOq3TgLRPKL2tdA,6988
-jarvis/modules/tv/lg.py,sha256=gThth7vxUQknb4AASi9s535DmnAHJdvNh_4NizeuxQU,8036
+jarvis/modules/tv/lg.py,sha256=scqT4luG11OOJq6f27GyncWpKSm64iPiz7ybWQe8az4,8996
 jarvis/modules/tv/roku.py,sha256=HuFvEPtYgYPoghFEStv2_1WNWCCBGC0S9KIklpZNX3g,7675
 jarvis/modules/utils/shared.py,sha256=R8EzHEqno0pW-Tf0QmnGubeMfVWVsLzRJQeZhMKlGE0,468
-jarvis/modules/utils/support.py,sha256=QzZdAh9pqiBveTnDX16zCcGIherOvSM3_SrJ1d0dKdg,19007
-jarvis/modules/utils/util.py,sha256=0n2zVeG-4w4q4FOKMADgmN4IfEmw3EsGRoFSat5Sy8Y,9800
+jarvis/modules/utils/support.py,sha256=P-PR8JdQfFw5XvXQEtAhk1gAs2aDzUrmwrlL1TAE7mI,19258
+jarvis/modules/utils/util.py,sha256=YiZT7p6MajG64F7Ey65k8_sqIdXq7iRXbJ6NCXkJFGs,10261
 jarvis/modules/wakeonlan/wakeonlan.py,sha256=7Rg2IS91ReQyRqqIfhW4v_LUsMFkttdOedilRZimDeI,2169
 jarvis/scripts/applauncher.scpt,sha256=CMi4ym4LTMNi3Ln7TmclfWK4enWE3PY2S1BXmJDGi1s,1044
 jarvis/scripts/calendar.scpt,sha256=c9CNVYXGpwShrGNi1OjCQNSKy__j-MQdNxTdWwFtFCg,2750
 jarvis/scripts/outlook.scpt,sha256=e0HyaQYrCiqszI65hGNLq_H2978GngUEG-CsMCfLqp4,2504
-jarvis_ironman-3.0a0.data/scripts/install.sh,sha256=rEv4cireRScABobkHmoht1iqUz3N6AWP0b_stcBuUTk,8062
-jarvis_ironman-3.0a0.dist-info/LICENSE,sha256=khwb-_X88C6Va_FZB_sJgB-xukCrEvkq8C3P_IGzysE,1078
-jarvis_ironman-3.0a0.dist-info/METADATA,sha256=Ue2wrXuP_ioxwFJtfIyapE1jNzz7CKmgtXmF02110rk,31575
-jarvis_ironman-3.0a0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-jarvis_ironman-3.0a0.dist-info/top_level.txt,sha256=1BOxyWfzOP_ZXj8rVTDnNCJ92bBGB0rwq8N1PCpoMIs,7
-jarvis_ironman-3.0a0.dist-info/RECORD,,
+jarvis_ironman-3.1.data/scripts/install.sh,sha256=p-IPD6CbK9pyHBIFNSbo09m91sEs2Ybhv62ejCBY7uM,8114
+jarvis_ironman-3.1.dist-info/LICENSE,sha256=khwb-_X88C6Va_FZB_sJgB-xukCrEvkq8C3P_IGzysE,1078
+jarvis_ironman-3.1.dist-info/METADATA,sha256=AjVUfKdXBkkCxrRN8JED0v8W7GUiHpnAyl-rAQNJWZo,32471
+jarvis_ironman-3.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+jarvis_ironman-3.1.dist-info/top_level.txt,sha256=1BOxyWfzOP_ZXj8rVTDnNCJ92bBGB0rwq8N1PCpoMIs,7
+jarvis_ironman-3.1.dist-info/RECORD,,
```

