# Comparing `tmp/burnman-1.1.0.tar.gz` & `tmp/burnman-1.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "burnman-1.1.0.tar", last modified: Wed Sep 14 23:11:28 2022, max compression
+gzip compressed data, was "burnman-1.2.0.tar", max compression
```

## Comparing `burnman-1.1.0.tar` & `burnman-1.2.0.tar`

### file list

```diff
@@ -1,189 +1,299 @@
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.042954 burnman-1.1.0/
--rw-r--r--   0 root         (0) staff       (20)      708 2022-09-14 23:11:28.042756 burnman-1.1.0/PKG-INFO
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:27.963819 burnman-1.1.0/burnman/
--rw-r--r--   0 root         (0) staff       (20)    10716 2022-09-14 23:11:07.000000 burnman-1.1.0/burnman/__init__.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:27.973167 burnman-1.1.0/burnman/calibrants/
--rw-r--r--   0 root         (0) staff       (20)     2151 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/calibrants/Decker_1971.py
--rw-r--r--   0 root         (0) staff       (20)      326 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/calibrants/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     1505 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/calibrants/tools.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:27.985732 burnman-1.1.0/burnman/classes/
--rw-r--r--   0 root         (0) staff       (20)      627 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    24489 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/anisotropicmineral.py
--rw-r--r--   0 root         (0) staff       (20)    17879 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/anisotropy.py
--rw-r--r--   0 root         (0) staff       (20)    22239 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/averaging_schemes.py
--rw-r--r--   0 root         (0) staff       (20)     6953 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/calibrant.py
--rw-r--r--   0 root         (0) staff       (20)     8535 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/combinedmineral.py
--rw-r--r--   0 root         (0) staff       (20)    26814 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/composite.py
--rw-r--r--   0 root         (0) staff       (20)    12648 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/composition.py
--rw-r--r--   0 root         (0) staff       (20)    31357 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/elasticsolution.py
--rw-r--r--   0 root         (0) staff       (20)    34105 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/elasticsolutionmodel.py
--rw-r--r--   0 root         (0) staff       (20)    36384 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/layer.py
--rw-r--r--   0 root         (0) staff       (20)    23843 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/material.py
--rw-r--r--   0 root         (0) staff       (20)    12915 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/mineral.py
--rw-r--r--   0 root         (0) staff       (20)     5974 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/mineral_helpers.py
--rw-r--r--   0 root         (0) staff       (20)    14348 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/perplex.py
--rw-r--r--   0 root         (0) staff       (20)    25972 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/planet.py
--rw-r--r--   0 root         (0) staff       (20)    14930 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/polytope.py
--rw-r--r--   0 root         (0) staff       (20)    19283 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/seismic.py
--rw-r--r--   0 root         (0) staff       (20)    24309 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/solution.py
--rw-r--r--   0 root         (0) staff       (20)    39288 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/classes/solutionmodel.py
--rw-r--r--   0 root         (0) staff       (20)      836 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/constants.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:27.959454 burnman-1.1.0/burnman/data/
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:27.986294 burnman-1.1.0/burnman/data/input_compositions/
--rw-r--r--   0 root         (0) staff       (20)      369 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_compositions/dhz_mineral_compositions.dat
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.002364 burnman-1.1.0/burnman/data/input_figures/
--rw-r--r--   0 root         (0) staff       (20)   171285 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/AA1994_liq_iron_PTrho_reference_isentrope.png
--rw-r--r--   0 root         (0) staff       (20)   168727 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/AA1994_liq_iron_TCv_different_densities.png
--rw-r--r--   0 root         (0) staff       (20)   104900 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/AA1994_liq_iron_Trho_1bar.png
--rw-r--r--   0 root         (0) staff       (20)    35398 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/Ahmad.png
--rw-r--r--   0 root         (0) staff       (20)   149499 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/Avseth_et_al_2010_fig3_K.png
--rw-r--r--   0 root         (0) staff       (20)   165107 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/Dewaele.png
--rw-r--r--   0 root         (0) staff       (20)    43826 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig1_K.png
--rw-r--r--   0 root         (0) staff       (20)    52707 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig2_G.png
--rw-r--r--   0 root         (0) staff       (20)    63529 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig3_E.png
--rw-r--r--   0 root         (0) staff       (20)     9750 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/berryman_fig4.png
--rw-r--r--   0 root         (0) staff       (20)    53273 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/matas_vp_forcomparison.png
--rw-r--r--   0 root         (0) staff       (20)    55032 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/matas_vs_forcomparison.png
--rw-r--r--   0 root         (0) staff       (20)    83274 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/murakami_book_chapter.png
--rw-r--r--   0 root         (0) staff       (20)    37258 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/murakami_book_chapter_b.png
--rw-r--r--   0 root         (0) staff       (20)    40985 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/murakami_vs_cmp.png
--rw-r--r--   0 root         (0) staff       (20)    41393 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig1.png
--rw-r--r--   0 root         (0) staff       (20)    93593 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig10a.png
--rw-r--r--   0 root         (0) staff       (20)    23587 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig3.png
--rw-r--r--   0 root         (0) staff       (20)    46799 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig7_Cp.png
--rw-r--r--   0 root         (0) staff       (20)    34954 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig7_G.png
--rw-r--r--   0 root         (0) staff       (20)    32230 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig7_K.png
--rw-r--r--   0 root         (0) staff       (20)    31896 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/slb_fig7_vol.png
--rw-r--r--   0 root         (0) staff       (20)    10985 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/watt_1976_a1.png
--rw-r--r--   0 root         (0) staff       (20)    11576 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_figures/watt_1976_a2.png
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.004621 burnman-1.1.0/burnman/data/input_fitting/
--rw-r--r--   0 root         (0) staff       (20)     6260 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_fitting/Bertka_Fei_1997_mars_mantle.dat
--rw-r--r--   0 root         (0) staff       (20)      802 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_fitting/Dubrovinsky_Saxena_1997_TV_periclase.dat
--rw-r--r--   0 root         (0) staff       (20)      415 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_fitting/Hazen_1976_TV_periclase.dat
--rw-r--r--   0 root         (0) staff       (20)     2507 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_fitting/PVT_MgO_Dewaele_et_al_2000.dat
--rw-r--r--   0 root         (0) staff       (20)      413 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_fitting/Pearson_York.dat
--rw-r--r--   0 root         (0) staff       (20)      676 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_fitting/Victor_Douglas_1963_deltaH_MgO.dat
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.006689 burnman-1.1.0/burnman/data/input_geotherm/
--rw-r--r--   0 root         (0) staff       (20)     1027 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_geotherm/Stacey_1977_continents.txt
--rw-r--r--   0 root         (0) staff       (20)     1027 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_geotherm/Stacey_1977_oceans.txt
--rw-r--r--   0 root         (0) staff       (20)      787 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_geotherm/anderson_82.txt
--rw-r--r--   0 root         (0) staff       (20)      890 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_geotherm/brown_81.txt
--rw-r--r--   0 root         (0) staff       (20)       70 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_geotherm/example_geotherm.txt
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.007416 burnman-1.1.0/burnman/data/input_masses/
--rw-r--r--   0 root         (0) staff       (20)     1239 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_masses/atomic_masses.dat
--rw-r--r--   0 root         (0) staff       (20)      991 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_masses/atomic_numbers.dat
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.008286 burnman-1.1.0/burnman/data/input_minphys/
--rw-r--r--   0 root         (0) staff       (20)      299 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_minphys/Murakami_periclase.txt
--rw-r--r--   0 root         (0) staff       (20)      364 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_minphys/Murakami_perovskite.txt
--rw-r--r--   0 root         (0) staff       (20)     3354 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_minphys/slb_fig7.txt
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.010458 burnman-1.1.0/burnman/data/input_perplex/
--rw-r--r--   0 root         (0) staff       (20)      527 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_perplex/fo50_HP2011_params.dat
--rw-r--r--   0 root         (0) staff       (20)      702 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_perplex/fo_HP2011_params.dat
--rw-r--r--   0 root         (0) staff       (20)      701 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_perplex/fo_SLB2011_params.dat
--rw-r--r--   0 root         (0) staff       (20)   295306 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_perplex/in23_1.tab
--rw-r--r--   0 root         (0) staff       (20)      879 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_perplex/test_SLB_entropy_and_landau.dat
--rw-r--r--   0 root         (0) staff       (20)        0 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_perplex/test_entropy_and_landau.dat
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.013774 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/
--rw-r--r--   0 root         (0) staff       (20)    11821 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/HGP633data_to_burnman.py
--rw-r--r--   0 root         (0) staff       (20)     4692 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/HHPH2013_endmembers.dat
--rw-r--r--   0 root         (0) staff       (20)     3168 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/HHPH2013data_to_burnman.py
--rw-r--r--   0 root         (0) staff       (20)    11835 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/HPdata_to_burnman.py
--rw-r--r--   0 root         (0) staff       (20)     6872 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/SLBdata_to_burnman.py
--rw-r--r--   0 root         (0) staff       (20)      891 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/perplex_slb_2011_names.txt
--rw-r--r--   0 root         (0) staff       (20)     4829 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011.txt
--rw-r--r--   0 root         (0) staff       (20)     1787 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011_aliases.txt
--rw-r--r--   0 root         (0) staff       (20)      292 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011_landau.txt
--rw-r--r--   0 root         (0) staff       (20)     5510 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011_solutions.txt
--rw-r--r--   0 root         (0) staff       (20)      940 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_raw_endmember_datasets/tc-ds62_solutions.txt
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.017337 burnman-1.1.0/burnman/data/input_seismic/
--rw-r--r--   0 root         (0) staff       (20)    60900 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/STW105.txt
--rw-r--r--   0 root         (0) staff       (20)    13305 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/ak135.txt
--rw-r--r--   0 root         (0) staff       (20)     4191 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/ak135_lowermantle.txt
--rw-r--r--   0 root         (0) staff       (20)    69814 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/axisem_prem_ani_noocean.txt
--rw-r--r--   0 root         (0) staff       (20)     7971 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/iasp91.txt
--rw-r--r--   0 root         (0) staff       (20)    15268 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/mineos_prem_noocean.txt
--rw-r--r--   0 root         (0) staff       (20)     9949 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/prem.txt
--rw-r--r--   0 root         (0) staff       (20)     4233 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/pwave_fast.txt
--rw-r--r--   0 root         (0) staff       (20)     4233 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/pwave_slow.txt
--rw-r--r--   0 root         (0) staff       (20)     4122 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/swave_fast.txt
--rw-r--r--   0 root         (0) staff       (20)     4122 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/data/input_seismic/swave_slow.txt
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.024275 burnman-1.1.0/burnman/eos/
--rw-r--r--   0 root         (0) staff       (20)      953 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    15748 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/aa.py
--rw-r--r--   0 root         (0) staff       (20)     8821 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/birch_murnaghan.py
--rw-r--r--   0 root         (0) staff       (20)     7259 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/birch_murnaghan_4th.py
--rw-r--r--   0 root         (0) staff       (20)    17868 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/brosh_calphad.py
--rw-r--r--   0 root         (0) staff       (20)     7960 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/cork.py
--rw-r--r--   0 root         (0) staff       (20)     4960 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/debye.py
--rw-r--r--   0 root         (0) staff       (20)    24441 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/dks_liquid.py
--rw-r--r--   0 root         (0) staff       (20)    12752 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/dks_solid.py
--rw-r--r--   0 root         (0) staff       (20)     1181 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/einstein.py
--rw-r--r--   0 root         (0) staff       (20)    12207 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/equation_of_state.py
--rw-r--r--   0 root         (0) staff       (20)     2993 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/helper.py
--rw-r--r--   0 root         (0) staff       (20)    37804 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/hp.py
--rw-r--r--   0 root         (0) staff       (20)    12207 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/mie_grueneisen_debye.py
--rw-r--r--   0 root         (0) staff       (20)     7756 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/modified_tait.py
--rw-r--r--   0 root         (0) staff       (20)     7014 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/morse_potential.py
--rw-r--r--   0 root         (0) staff       (20)     5676 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/murnaghan.py
--rw-r--r--   0 root         (0) staff       (20)    16029 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/property_modifiers.py
--rw-r--r--   0 root         (0) staff       (20)    10651 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/reciprocal_kprime.py
--rw-r--r--   0 root         (0) staff       (20)    18509 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/slb.py
--rw-r--r--   0 root         (0) staff       (20)     6164 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/eos/vinet.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.034829 burnman-1.1.0/burnman/minerals/
--rw-r--r--   0 root         (0) staff       (20)     9881 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/DKS_2013_liquids.py
--rw-r--r--   0 root         (0) staff       (20)     3533 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/DKS_2013_solids.py
--rw-r--r--   0 root         (0) staff       (20)   195377 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/HGP_2018_ds633.py
--rw-r--r--   0 root         (0) staff       (20)  1430044 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/HGP_2018_ds633_cov.py
--rw-r--r--   0 root         (0) staff       (20)    30681 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/HHPH_2013.py
--rw-r--r--   0 root         (0) staff       (20)   164881 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/HP_2011_ds62.py
--rw-r--r--   0 root         (0) staff       (20)  1121646 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/HP_2011_ds62_cov.py
--rw-r--r--   0 root         (0) staff       (20)     5210 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/HP_2011_fluids.py
--rw-r--r--   0 root         (0) staff       (20)     1527 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/ICL_2018.py
--rw-r--r--   0 root         (0) staff       (20)    14800 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/JH_2015.py
--rw-r--r--   0 root         (0) staff       (20)     6983 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/KMFBZ_2017.py
--rw-r--r--   0 root         (0) staff       (20)     3145 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/Matas_etal_2007.py
--rw-r--r--   0 root         (0) staff       (20)     2395 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/Murakami_2013.py
--rw-r--r--   0 root         (0) staff       (20)     5043 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/Murakami_etal_2012.py
--rw-r--r--   0 root         (0) staff       (20)     1840 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/RS_2014_liquids.py
--rw-r--r--   0 root         (0) staff       (20)     6297 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/SE_2015.py
--rw-r--r--   0 root         (0) staff       (20)     3049 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/SLB_2005.py
--rw-r--r--   0 root         (0) staff       (20)    60914 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/SLB_2011.py
--rw-r--r--   0 root         (0) staff       (20)     4329 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/SLB_2011_ZSB_2013.py
--rw-r--r--   0 root         (0) staff       (20)     2202 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/Sundman_1991.py
--rw-r--r--   0 root         (0) staff       (20)     1601 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     5131 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/minerals/other.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.036992 burnman-1.1.0/burnman/optimize/
--rw-r--r--   0 root         (0) staff       (20)      413 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/optimize/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     6529 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/optimize/composition_fitting.py
--rw-r--r--   0 root         (0) staff       (20)    22933 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/optimize/eos_fitting.py
--rw-r--r--   0 root         (0) staff       (20)     3580 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/optimize/linear_fitting.py
--rw-r--r--   0 root         (0) staff       (20)    21481 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/optimize/nonlinear_fitting.py
--rw-r--r--   0 root         (0) staff       (20)    15071 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/optimize/nonlinear_solvers.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.040269 burnman-1.1.0/burnman/tools/
--rw-r--r--   0 root         (0) staff       (20)      673 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/__init__.py
--rw-r--r--   0 root         (0) staff       (20)     8056 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/chemistry.py
--rw-r--r--   0 root         (0) staff       (20)     9849 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/eos.py
--rw-r--r--   0 root         (0) staff       (20)    40322 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/equilibration.py
--rw-r--r--   0 root         (0) staff       (20)    12213 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/output_seismo.py
--rw-r--r--   0 root         (0) staff       (20)     2271 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/partitioning.py
--rw-r--r--   0 root         (0) staff       (20)     4109 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/plot.py
--rw-r--r--   0 root         (0) staff       (20)     9998 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/polytope.py
--rw-r--r--   0 root         (0) staff       (20)    12973 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/solution.py
--rw-r--r--   0 root         (0) staff       (20)      334 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/tools/unitcell.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:28.042446 burnman-1.1.0/burnman/utils/
--rw-r--r--   0 root         (0) staff       (20)      590 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/__init__.py
--rw-r--r--   0 root         (0) staff       (20)    22579 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/chemistry.py
--rw-r--r--   0 root         (0) staff       (20)     5559 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/geotherm.py
--rw-r--r--   0 root         (0) staff       (20)    17683 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/math.py
--rw-r--r--   0 root         (0) staff       (20)     6599 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/misc.py
--rw-r--r--   0 root         (0) staff       (20)     9832 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/reductions.py
--rw-r--r--   0 root         (0) staff       (20)     3500 2022-09-14 23:10:37.000000 burnman-1.1.0/burnman/utils/unitcell.py
--rw-r--r--   0 root         (0) staff       (20)       42 2022-09-14 23:11:07.000000 burnman-1.1.0/burnman/version.py
-drwxr-xr-x   0 root         (0) staff       (20)        0 2022-09-14 23:11:27.968762 burnman-1.1.0/burnman.egg-info/
--rw-r--r--   0 root         (0) staff       (20)      708 2022-09-14 23:11:27.000000 burnman-1.1.0/burnman.egg-info/PKG-INFO
--rw-r--r--   0 root         (0) staff       (20)     6424 2022-09-14 23:11:27.000000 burnman-1.1.0/burnman.egg-info/SOURCES.txt
--rw-r--r--   0 root         (0) staff       (20)        1 2022-09-14 23:11:27.000000 burnman-1.1.0/burnman.egg-info/dependency_links.txt
--rw-r--r--   0 root         (0) staff       (20)       29 2022-09-14 23:11:27.000000 burnman-1.1.0/burnman.egg-info/requires.txt
--rw-r--r--   0 root         (0) staff       (20)        8 2022-09-14 23:11:27.000000 burnman-1.1.0/burnman.egg-info/top_level.txt
--rw-r--r--   0 root         (0) staff       (20)       38 2022-09-14 23:11:28.043020 burnman-1.1.0/setup.cfg
--rw-r--r--   0 root         (0) staff       (20)     2016 2022-09-14 23:10:37.000000 burnman-1.1.0/setup.py
+-rw-r--r--   0        0        0     7916 2023-07-01 16:07:58.571093 burnman-1.2.0/Readme.md
+-rw-r--r--   0        0        0    11383 2023-07-01 16:12:31.000189 burnman-1.2.0/burnman/__init__.py
+-rw-r--r--   0        0        0     1822 2023-06-19 18:33:34.776074 burnman-1.2.0/burnman/calibrants/Decker_1971.py
+-rw-r--r--   0        0        0      326 2022-09-23 21:19:22.370764 burnman-1.2.0/burnman/calibrants/__init__.py
+-rw-r--r--   0        0        0     1567 2023-06-19 18:33:34.779288 burnman-1.2.0/burnman/calibrants/tools.py
+-rw-r--r--   0        0        0      627 2023-06-15 12:20:08.807970 burnman-1.2.0/burnman/classes/__init__.py
+-rw-r--r--   0        0        0    24352 2023-06-19 18:33:34.783630 burnman-1.2.0/burnman/classes/anisotropicmineral.py
+-rw-r--r--   0        0        0    16546 2023-06-19 18:33:34.786612 burnman-1.2.0/burnman/classes/anisotropy.py
+-rw-r--r--   0        0        0    23930 2023-06-19 18:33:34.789782 burnman-1.2.0/burnman/classes/averaging_schemes.py
+-rw-r--r--   0        0        0     6711 2023-06-19 18:33:34.792499 burnman-1.2.0/burnman/classes/calibrant.py
+-rw-r--r--   0        0        0     8631 2023-06-16 16:57:32.347589 burnman-1.2.0/burnman/classes/combinedmineral.py
+-rw-r--r--   0        0        0    26607 2023-06-19 18:33:34.795957 burnman-1.2.0/burnman/classes/composite.py
+-rw-r--r--   0        0        0    12709 2023-06-19 18:33:34.799281 burnman-1.2.0/burnman/classes/composition.py
+-rw-r--r--   0        0        0    26849 2023-06-19 18:33:34.801775 burnman-1.2.0/burnman/classes/elasticsolution.py
+-rw-r--r--   0        0        0    32484 2023-06-19 18:33:34.804720 burnman-1.2.0/burnman/classes/elasticsolutionmodel.py
+-rw-r--r--   0        0        0    35674 2023-06-19 18:33:34.807599 burnman-1.2.0/burnman/classes/layer.py
+-rw-r--r--   0        0        0    23964 2023-06-19 18:33:34.809797 burnman-1.2.0/burnman/classes/material.py
+-rw-r--r--   0        0        0    13546 2023-06-16 16:57:32.369648 burnman-1.2.0/burnman/classes/mineral.py
+-rw-r--r--   0        0        0     6110 2023-06-19 18:33:34.812161 burnman-1.2.0/burnman/classes/mineral_helpers.py
+-rw-r--r--   0        0        0    16165 2023-06-19 18:33:34.814994 burnman-1.2.0/burnman/classes/perplex.py
+-rw-r--r--   0        0        0    25555 2023-06-19 18:33:34.817112 burnman-1.2.0/burnman/classes/planet.py
+-rw-r--r--   0        0        0    15283 2023-06-19 18:33:34.819360 burnman-1.2.0/burnman/classes/polytope.py
+-rw-r--r--   0        0        0    19164 2023-06-19 18:33:34.821512 burnman-1.2.0/burnman/classes/seismic.py
+-rw-r--r--   0        0        0    22231 2023-06-27 13:24:15.339494 burnman-1.2.0/burnman/classes/solution.py
+-rw-r--r--   0        0        0    54612 2023-06-19 18:33:34.825516 burnman-1.2.0/burnman/classes/solutionmodel.py
+-rw-r--r--   0        0        0      836 2022-09-23 21:19:22.479189 burnman-1.2.0/burnman/constants.py
+-rw-r--r--   0        0        0      369 2022-09-23 21:19:22.480017 burnman-1.2.0/burnman/data/input_compositions/dhz_mineral_compositions.dat
+-rw-r--r--   0        0        0   171285 2022-09-23 21:19:22.482490 burnman-1.2.0/burnman/data/input_figures/AA1994_liq_iron_PTrho_reference_isentrope.png
+-rw-r--r--   0        0        0   168727 2022-09-23 21:19:22.484580 burnman-1.2.0/burnman/data/input_figures/AA1994_liq_iron_TCv_different_densities.png
+-rw-r--r--   0        0        0   104900 2022-09-23 21:19:22.485912 burnman-1.2.0/burnman/data/input_figures/AA1994_liq_iron_Trho_1bar.png
+-rw-r--r--   0        0        0    35398 2022-09-23 21:19:22.486508 burnman-1.2.0/burnman/data/input_figures/Ahmad.png
+-rw-r--r--   0        0        0   149499 2022-09-23 21:19:22.488065 burnman-1.2.0/burnman/data/input_figures/Avseth_et_al_2010_fig3_K.png
+-rw-r--r--   0        0        0   165107 2022-09-23 21:19:22.489713 burnman-1.2.0/burnman/data/input_figures/Dewaele.png
+-rw-r--r--   0        0        0    43826 2022-09-23 21:19:22.490464 burnman-1.2.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig1_K.png
+-rw-r--r--   0        0        0    52707 2022-09-23 21:19:22.491047 burnman-1.2.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig2_G.png
+-rw-r--r--   0        0        0    63529 2022-09-23 21:19:22.491876 burnman-1.2.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig3_E.png
+-rw-r--r--   0        0        0     9750 2022-09-23 21:19:22.492411 burnman-1.2.0/burnman/data/input_figures/berryman_fig4.png
+-rw-r--r--   0        0        0    53273 2022-09-23 21:19:22.494266 burnman-1.2.0/burnman/data/input_figures/matas_vp_forcomparison.png
+-rw-r--r--   0        0        0    55032 2022-09-23 21:19:22.495590 burnman-1.2.0/burnman/data/input_figures/matas_vs_forcomparison.png
+-rw-r--r--   0        0        0    83274 2022-09-23 21:19:22.496696 burnman-1.2.0/burnman/data/input_figures/murakami_book_chapter.png
+-rw-r--r--   0        0        0    37258 2022-09-23 21:19:22.497356 burnman-1.2.0/burnman/data/input_figures/murakami_book_chapter_b.png
+-rw-r--r--   0        0        0    40985 2022-09-23 21:19:22.498232 burnman-1.2.0/burnman/data/input_figures/murakami_vs_cmp.png
+-rw-r--r--   0        0        0    41393 2022-09-23 21:19:22.498757 burnman-1.2.0/burnman/data/input_figures/slb_fig1.png
+-rw-r--r--   0        0        0    93593 2022-09-23 21:19:22.500728 burnman-1.2.0/burnman/data/input_figures/slb_fig10a.png
+-rw-r--r--   0        0        0    23587 2022-09-23 21:19:22.501311 burnman-1.2.0/burnman/data/input_figures/slb_fig3.png
+-rw-r--r--   0        0        0    46799 2022-09-23 21:19:22.502118 burnman-1.2.0/burnman/data/input_figures/slb_fig7_Cp.png
+-rw-r--r--   0        0        0    34954 2022-09-23 21:19:22.502536 burnman-1.2.0/burnman/data/input_figures/slb_fig7_G.png
+-rw-r--r--   0        0        0    32230 2022-09-23 21:19:22.502913 burnman-1.2.0/burnman/data/input_figures/slb_fig7_K.png
+-rw-r--r--   0        0        0    31896 2022-09-23 21:19:22.503502 burnman-1.2.0/burnman/data/input_figures/slb_fig7_vol.png
+-rw-r--r--   0        0        0    10985 2022-09-23 21:19:22.503991 burnman-1.2.0/burnman/data/input_figures/watt_1976_a1.png
+-rw-r--r--   0        0        0    11576 2022-09-23 21:19:22.504283 burnman-1.2.0/burnman/data/input_figures/watt_1976_a2.png
+-rw-r--r--   0        0        0     6260 2022-09-23 21:19:22.505067 burnman-1.2.0/burnman/data/input_fitting/Bertka_Fei_1997_mars_mantle.dat
+-rw-r--r--   0        0        0      802 2022-09-23 21:19:22.505348 burnman-1.2.0/burnman/data/input_fitting/Dubrovinsky_Saxena_1997_TV_periclase.dat
+-rw-r--r--   0        0        0      415 2022-09-23 21:19:22.505600 burnman-1.2.0/burnman/data/input_fitting/Hazen_1976_TV_periclase.dat
+-rw-r--r--   0        0        0     2507 2022-09-23 21:19:22.506071 burnman-1.2.0/burnman/data/input_fitting/PVT_MgO_Dewaele_et_al_2000.dat
+-rw-r--r--   0        0        0      413 2022-09-23 21:19:22.506378 burnman-1.2.0/burnman/data/input_fitting/Pearson_York.dat
+-rw-r--r--   0        0        0      676 2022-09-23 21:19:22.506561 burnman-1.2.0/burnman/data/input_fitting/Victor_Douglas_1963_deltaH_MgO.dat
+-rw-r--r--   0        0        0     1027 2022-09-23 21:19:22.507163 burnman-1.2.0/burnman/data/input_geotherm/Stacey_1977_continents.txt
+-rw-r--r--   0        0        0     1027 2022-09-23 21:19:22.507627 burnman-1.2.0/burnman/data/input_geotherm/Stacey_1977_oceans.txt
+-rw-r--r--   0        0        0      787 2022-09-23 21:19:22.507846 burnman-1.2.0/burnman/data/input_geotherm/anderson_82.txt
+-rw-r--r--   0        0        0      890 2022-09-23 21:19:22.508168 burnman-1.2.0/burnman/data/input_geotherm/brown_81.txt
+-rw-r--r--   0        0        0       70 2022-09-23 21:19:22.508610 burnman-1.2.0/burnman/data/input_geotherm/example_geotherm.txt
+-rw-r--r--   0        0        0     1239 2022-09-23 21:19:22.509159 burnman-1.2.0/burnman/data/input_masses/atomic_masses.dat
+-rw-r--r--   0        0        0      991 2022-09-23 21:19:22.509498 burnman-1.2.0/burnman/data/input_masses/atomic_numbers.dat
+-rw-r--r--   0        0        0      299 2022-09-23 21:19:22.510013 burnman-1.2.0/burnman/data/input_minphys/Murakami_periclase.txt
+-rw-r--r--   0        0        0      364 2022-09-23 21:19:22.510543 burnman-1.2.0/burnman/data/input_minphys/Murakami_perovskite.txt
+-rw-r--r--   0        0        0     3354 2022-09-23 21:19:22.510958 burnman-1.2.0/burnman/data/input_minphys/slb_fig7.txt
+-rw-r--r--   0        0        0      527 2022-09-23 21:19:22.511534 burnman-1.2.0/burnman/data/input_perplex/fo50_HP2011_params.dat
+-rw-r--r--   0        0        0      702 2022-09-23 21:19:22.511778 burnman-1.2.0/burnman/data/input_perplex/fo_HP2011_params.dat
+-rw-r--r--   0        0        0      701 2022-09-23 21:19:22.512087 burnman-1.2.0/burnman/data/input_perplex/fo_SLB2011_params.dat
+-rw-r--r--   0        0        0   295306 2022-09-23 21:19:22.514175 burnman-1.2.0/burnman/data/input_perplex/in23_1.tab
+-rw-r--r--   0        0        0      879 2022-09-23 21:19:22.514416 burnman-1.2.0/burnman/data/input_perplex/test_SLB_entropy_and_landau.dat
+-rw-r--r--   0        0        0        0 2022-09-23 21:19:22.514526 burnman-1.2.0/burnman/data/input_perplex/test_entropy_and_landau.dat
+-rw-r--r--   0        0        0    10906 2023-06-16 16:57:32.393229 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HGP633data_to_burnman.py
+-rw-r--r--   0        0        0     4692 2022-09-23 21:19:22.515573 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HHPH2013_endmembers.dat
+-rw-r--r--   0        0        0     3353 2023-06-16 16:57:32.395151 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HHPH2013data_to_burnman.py
+-rw-r--r--   0        0        0    10881 2023-06-16 16:57:32.398225 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HPdata_to_burnman.py
+-rw-r--r--   0        0        0       23 2023-06-19 15:28:31.038518 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/HEAD
+-rw-r--r--   0        0        0      327 2023-06-19 15:28:31.046198 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/config
+-rw-r--r--   0        0        0       73 2023-06-19 15:28:30.142583 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/description
+-rwxr-xr-x   0        0        0      478 2023-06-19 15:28:30.159103 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/applypatch-msg.sample
+-rwxr-xr-x   0        0        0      896 2023-06-19 15:28:30.146327 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/commit-msg.sample
+-rwxr-xr-x   0        0        0     4726 2023-06-19 15:28:30.163435 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/fsmonitor-watchman.sample
+-rwxr-xr-x   0        0        0      189 2023-06-19 15:28:30.172249 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/post-update.sample
+-rwxr-xr-x   0        0        0      424 2023-06-19 15:28:30.175891 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/pre-applypatch.sample
+-rwxr-xr-x   0        0        0     1643 2023-06-19 15:28:30.156661 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/pre-commit.sample
+-rwxr-xr-x   0        0        0      416 2023-06-19 15:28:30.174051 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/pre-merge-commit.sample
+-rwxr-xr-x   0        0        0     1374 2023-06-19 15:28:30.178539 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/pre-push.sample
+-rwxr-xr-x   0        0        0     4898 2023-06-19 15:28:30.152445 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/pre-rebase.sample
+-rwxr-xr-x   0        0        0      544 2023-06-19 15:28:30.167392 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/pre-receive.sample
+-rwxr-xr-x   0        0        0     1492 2023-06-19 15:28:30.169676 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/prepare-commit-msg.sample
+-rwxr-xr-x   0        0        0     2783 2023-06-19 15:28:30.186365 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/push-to-checkout.sample
+-rwxr-xr-x   0        0        0     3650 2023-06-19 15:28:30.182780 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/hooks/update.sample
+-rw-r--r--   0        0        0     7562 2023-06-19 15:28:31.127271 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/index
+-rw-r--r--   0        0        0      240 2023-06-19 15:28:30.139839 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/info/exclude
+-rw-r--r--   0        0        0      203 2023-06-19 15:28:31.040431 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/logs/HEAD
+-rw-r--r--   0        0        0      203 2023-06-19 15:28:31.041760 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/logs/refs/heads/master
+-rw-r--r--   0        0        0      203 2023-06-19 15:28:31.037623 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/logs/refs/remotes/origin/HEAD
+-rw-r--r--   0        0        0     3928 2023-06-19 15:28:31.022584 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/objects/pack/pack-597f2ae5b63d9a644f0245cea0ce2ab608892aaa.idx
+-rw-r--r--   0        0        0   624597 2023-06-19 15:28:31.022274 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/objects/pack/pack-597f2ae5b63d9a644f0245cea0ce2ab608892aaa.pack
+-rw-r--r--   0        0        0      114 2023-06-19 15:28:31.033646 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/packed-refs
+-rw-r--r--   0        0        0       41 2023-06-19 15:28:31.040138 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/refs/heads/master
+-rw-r--r--   0        0        0       32 2023-06-19 15:28:31.037679 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/.git/refs/remotes/origin/HEAD
+-rwxr-xr-x   0        0        0     1471 2023-06-19 15:28:31.049498 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/README.md
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.049752 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/ab
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.050041 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/al
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.050465 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/alpv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.050739 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/an
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.050965 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/anao
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.051234 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/apbo
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.051587 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/appv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.052231 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/capv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.053369 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/cats
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.053798 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/cen
+-rwxr-xr-x   0        0        0    72285 2023-06-19 15:28:31.054771 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/changelog
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.055531 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/co
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.055868 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/coes
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.056118 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/crst
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.056419 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/di
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.056661 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/en
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.057555 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/enm
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.057991 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fa
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.058220 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fapv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.058585 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fea
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.058866 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fec2
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.060182 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fecf
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.060415 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fee
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.060617 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/feg
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.061078 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/feil
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.064622 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fepv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.065070 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/feri
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.065629 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fewa
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.065950 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/flpv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.066654 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fnal
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.066950 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fo
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.067422 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fppv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.067819 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/fs
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.068083 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/gr
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.068428 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/hc
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.072137 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/he
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.072705 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/hem
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.073792 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/hepv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.073990 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/hlpv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.074178 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/hmag
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.074455 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/hppv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.074797 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/jd
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.075022 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/ky
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.075299 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/lppv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.075665 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mag
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.075924 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgc2
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.076302 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgcf
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.077552 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgil
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.077939 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgl
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.079973 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgmj
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.080583 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgpv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.080924 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgri
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.082014 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgts
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.082323 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mgwa
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.082616 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mnal
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.082791 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/mppv
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.083069 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/nacf
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.084641 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/namj
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.085175 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/neph
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.086173 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/nnal
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.086475 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/odi
+-rwxr-xr-x   0        0        0 10191380 2023-06-19 15:28:31.112583 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/out
+-rwxr-xr-x   0        0        0    28150 2023-06-19 15:28:31.115371 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/par.tex
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.116095 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/pe
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.116857 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/apbo
+-rwxr-xr-x   0        0        0      139 2023-06-19 15:28:31.117170 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/c2c
+-rwxr-xr-x   0        0        0      455 2023-06-19 15:28:31.117420 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/cf
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.117604 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/coes
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.117742 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/cpv
+-rwxr-xr-x   0        0        0      685 2023-06-19 15:28:31.118084 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/cpx
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.118427 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/crst
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.118836 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/enm
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.119312 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/fea
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.119815 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/fee
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.120242 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/feg
+-rwxr-xr-x   0        0        0      685 2023-06-19 15:28:31.121210 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/gt
+-rwxr-xr-x   0        0        0      455 2023-06-19 15:28:31.121514 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/il
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.121725 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/ky
+-rwxr-xr-x   0        0        0       81 2023-06-19 15:28:31.121944 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/liq
+-rwxr-xr-x   0        0        0      685 2023-06-19 15:28:31.122155 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/mw
+-rwxr-xr-x   0        0        0      273 2023-06-19 15:28:31.122282 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/nal
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.122379 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/neph
+-rwxr-xr-x   0        0        0      139 2023-06-19 15:28:31.122558 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/ol
+-rwxr-xr-x   0        0        0      455 2023-06-19 15:28:31.122771 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/opx
+-rwxr-xr-x   0        0        0      139 2023-06-19 15:28:31.122902 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/plg
+-rwxr-xr-x   0        0        0      685 2023-06-19 15:28:31.123031 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/ppv
+-rwxr-xr-x   0        0        0     1289 2023-06-19 15:28:31.123160 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/pv
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.123335 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/qtz
+-rwxr-xr-x   0        0        0      139 2023-06-19 15:28:31.123540 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/ri
+-rwxr-xr-x   0        0        0      139 2023-06-19 15:28:31.123783 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/sp
+-rwxr-xr-x   0        0        0        0 2023-06-19 15:28:31.124048 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/st
+-rwxr-xr-x   0        0        0      139 2023-06-19 15:28:31.124322 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phase/wa
+-rw-r--r--   0        0        0    12467 2023-06-20 13:54:07.457964 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/phaseeq.tex
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.124879 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/py
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.125139 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/qtz
+-rw-r--r--   0        0        0     5891 2023-06-20 13:54:07.464271 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/reactions.tex
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.125678 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/sil
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.125941 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/sp
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.126205 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/st
+-rwxr-xr-x   0        0        0     2970 2023-06-19 15:28:31.126473 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/wreg.tex
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.126755 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/wu
+-rwxr-xr-x   0        0        0     3448 2023-06-19 15:28:31.127120 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_parameters_010121/wuls
+-rw-r--r--   0        0        0    13833 2023-06-27 13:24:15.340368 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HeFESTo_to_burnman.py
+-rw-r--r--   0        0        0     7783 2023-06-16 16:57:32.400089 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/SLBdata_to_burnman.py
+-rw-r--r--   0        0        0     1724 2023-06-27 13:24:15.341377 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/hefesto_parameter_names.txt
+-rw-r--r--   0        0        0      891 2022-09-23 21:19:22.524920 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/perplex_slb_2011_names.txt
+-rw-r--r--   0        0        0     4829 2022-09-23 21:19:22.525135 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011.txt
+-rw-r--r--   0        0        0     1787 2022-09-23 21:19:22.525540 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011_aliases.txt
+-rw-r--r--   0        0        0      292 2022-09-23 21:19:22.525791 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011_landau.txt
+-rw-r--r--   0        0        0     5510 2022-09-23 21:19:22.526022 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011_solutions.txt
+-rw-r--r--   0        0        0      940 2022-09-23 21:19:22.527165 burnman-1.2.0/burnman/data/input_raw_endmember_datasets/tc-ds62_solutions.txt
+-rw-r--r--   0        0        0    60900 2022-09-23 21:19:22.528168 burnman-1.2.0/burnman/data/input_seismic/STW105.txt
+-rw-r--r--   0        0        0    13305 2022-09-23 21:19:22.528447 burnman-1.2.0/burnman/data/input_seismic/ak135.txt
+-rw-r--r--   0        0        0     4191 2022-09-23 21:19:22.528680 burnman-1.2.0/burnman/data/input_seismic/ak135_lowermantle.txt
+-rw-r--r--   0        0        0    69814 2022-09-23 21:19:22.529154 burnman-1.2.0/burnman/data/input_seismic/axisem_prem_ani_noocean.txt
+-rw-r--r--   0        0        0     7971 2022-09-23 21:19:22.529390 burnman-1.2.0/burnman/data/input_seismic/iasp91.txt
+-rw-r--r--   0        0        0    15268 2022-09-23 21:19:22.529674 burnman-1.2.0/burnman/data/input_seismic/mineos_prem_noocean.txt
+-rw-r--r--   0        0        0     9949 2022-09-23 21:19:22.529960 burnman-1.2.0/burnman/data/input_seismic/prem.txt
+-rw-r--r--   0        0        0     4233 2022-09-23 21:19:22.530578 burnman-1.2.0/burnman/data/input_seismic/pwave_fast.txt
+-rw-r--r--   0        0        0     4233 2022-09-23 21:19:22.531058 burnman-1.2.0/burnman/data/input_seismic/pwave_slow.txt
+-rw-r--r--   0        0        0     4122 2022-09-23 21:19:22.531343 burnman-1.2.0/burnman/data/input_seismic/swave_fast.txt
+-rw-r--r--   0        0        0     4122 2022-09-23 21:19:22.531581 burnman-1.2.0/burnman/data/input_seismic/swave_slow.txt
+-rw-r--r--   0        0        0      953 2022-09-23 21:19:22.531879 burnman-1.2.0/burnman/eos/__init__.py
+-rw-r--r--   0        0        0    16907 2023-06-16 16:57:32.403373 burnman-1.2.0/burnman/eos/aa.py
+-rw-r--r--   0        0        0     9286 2023-06-27 13:24:15.343065 burnman-1.2.0/burnman/eos/birch_murnaghan.py
+-rw-r--r--   0        0        0     7711 2023-06-16 16:57:32.413765 burnman-1.2.0/burnman/eos/birch_murnaghan_4th.py
+-rw-r--r--   0        0        0    19422 2023-06-16 16:57:32.434585 burnman-1.2.0/burnman/eos/brosh_calphad.py
+-rw-r--r--   0        0        0     8694 2023-06-16 16:57:32.441331 burnman-1.2.0/burnman/eos/cork.py
+-rw-r--r--   0        0        0     5684 2023-06-16 16:57:32.444286 burnman-1.2.0/burnman/eos/debye.py
+-rw-r--r--   0        0        0    27356 2023-06-16 16:57:32.447600 burnman-1.2.0/burnman/eos/dks_liquid.py
+-rw-r--r--   0        0        0    13413 2023-06-16 16:57:32.449622 burnman-1.2.0/burnman/eos/dks_solid.py
+-rw-r--r--   0        0        0     2767 2023-06-16 16:57:32.453292 burnman-1.2.0/burnman/eos/einstein.py
+-rw-r--r--   0        0        0    13647 2023-06-19 18:33:34.827637 burnman-1.2.0/burnman/eos/equation_of_state.py
+-rw-r--r--   0        0        0     2981 2023-06-16 16:57:32.455172 burnman-1.2.0/burnman/eos/helper.py
+-rw-r--r--   0        0        0    38331 2023-06-16 16:57:32.457332 burnman-1.2.0/burnman/eos/hp.py
+-rw-r--r--   0        0        0    12758 2023-06-16 16:57:32.460610 burnman-1.2.0/burnman/eos/mie_grueneisen_debye.py
+-rw-r--r--   0        0        0     7921 2023-06-16 16:57:32.462799 burnman-1.2.0/burnman/eos/modified_tait.py
+-rw-r--r--   0        0        0     7181 2023-06-16 16:57:32.464348 burnman-1.2.0/burnman/eos/morse_potential.py
+-rw-r--r--   0        0        0     5581 2023-06-16 16:57:32.466119 burnman-1.2.0/burnman/eos/murnaghan.py
+-rw-r--r--   0        0        0    23091 2023-06-27 13:24:15.344898 burnman-1.2.0/burnman/eos/property_modifiers.py
+-rw-r--r--   0        0        0    10985 2023-06-16 16:57:32.471146 burnman-1.2.0/burnman/eos/reciprocal_kprime.py
+-rw-r--r--   0        0        0    18663 2023-06-16 16:57:32.473374 burnman-1.2.0/burnman/eos/slb.py
+-rw-r--r--   0        0        0     6371 2023-06-16 16:57:32.475251 burnman-1.2.0/burnman/eos/vinet.py
+-rw-r--r--   0        0        0    14015 2023-06-16 16:57:32.479393 burnman-1.2.0/burnman/minerals/DKS_2013_liquids.py
+-rw-r--r--   0        0        0     3563 2023-06-16 16:57:32.481038 burnman-1.2.0/burnman/minerals/DKS_2013_solids.py
+-rw-r--r--   0        0        0   166699 2023-06-16 16:57:32.487404 burnman-1.2.0/burnman/minerals/HGP_2018_ds633.py
+-rw-r--r--   0        0        0  2457317 2023-06-16 16:57:32.509947 burnman-1.2.0/burnman/minerals/HGP_2018_ds633_cov.py
+-rw-r--r--   0        0        0    30423 2023-06-16 16:57:32.512579 burnman-1.2.0/burnman/minerals/HHPH_2013.py
+-rw-r--r--   0        0        0   140332 2023-06-16 16:57:32.515076 burnman-1.2.0/burnman/minerals/HP_2011_ds62.py
+-rw-r--r--   0        0        0  1929056 2023-06-16 16:57:32.521345 burnman-1.2.0/burnman/minerals/HP_2011_ds62_cov.py
+-rw-r--r--   0        0        0     5738 2023-06-16 16:57:32.525977 burnman-1.2.0/burnman/minerals/HP_2011_fluids.py
+-rw-r--r--   0        0        0     1544 2023-06-16 16:57:32.527558 burnman-1.2.0/burnman/minerals/ICL_2018.py
+-rw-r--r--   0        0        0    13147 2023-06-16 16:57:32.529283 burnman-1.2.0/burnman/minerals/JH_2015.py
+-rw-r--r--   0        0        0     7130 2023-06-16 16:57:32.531059 burnman-1.2.0/burnman/minerals/KMFBZ_2017.py
+-rw-r--r--   0        0        0     3209 2023-06-16 16:57:32.532721 burnman-1.2.0/burnman/minerals/Matas_etal_2007.py
+-rw-r--r--   0        0        0     2439 2023-06-16 16:57:32.537334 burnman-1.2.0/burnman/minerals/Murakami_2013.py
+-rw-r--r--   0        0        0     5159 2023-06-16 16:57:32.541163 burnman-1.2.0/burnman/minerals/Murakami_etal_2012.py
+-rw-r--r--   0        0        0     1893 2023-06-16 16:57:32.544002 burnman-1.2.0/burnman/minerals/RS_2014_liquids.py
+-rw-r--r--   0        0        0     9849 2023-06-16 16:57:32.545617 burnman-1.2.0/burnman/minerals/SE_2015.py
+-rw-r--r--   0        0        0     3114 2023-06-16 16:57:32.549065 burnman-1.2.0/burnman/minerals/SLB_2005.py
+-rw-r--r--   0        0        0    62671 2023-06-16 16:57:32.552454 burnman-1.2.0/burnman/minerals/SLB_2011.py
+-rw-r--r--   0        0        0     4448 2023-06-16 16:57:32.554098 burnman-1.2.0/burnman/minerals/SLB_2011_ZSB_2013.py
+-rw-r--r--   0        0        0    53494 2023-06-27 13:24:15.346066 burnman-1.2.0/burnman/minerals/SLB_2022.py
+-rw-r--r--   0        0        0     2374 2023-06-16 16:57:32.557164 burnman-1.2.0/burnman/minerals/Sundman_1991.py
+-rw-r--r--   0        0        0     1662 2023-06-27 13:24:15.353261 burnman-1.2.0/burnman/minerals/__init__.py
+-rw-r--r--   0        0        0     5268 2023-06-16 16:57:32.558727 burnman-1.2.0/burnman/minerals/other.py
+-rw-r--r--   0        0        0      413 2022-09-23 21:19:22.650883 burnman-1.2.0/burnman/optimize/__init__.py
+-rw-r--r--   0        0        0   601906 2023-06-23 13:39:24.730258 burnman-1.2.0/burnman/optimize/check_majorite.ipynb
+-rw-r--r--   0        0        0     7513 2023-07-01 14:52:43.645114 burnman-1.2.0/burnman/optimize/composition_fitting.py
+-rw-r--r--   0        0        0    21032 2023-06-19 18:33:34.831932 burnman-1.2.0/burnman/optimize/eos_fitting.py
+-rw-r--r--   0        0        0     3644 2023-06-19 18:33:34.834176 burnman-1.2.0/burnman/optimize/linear_fitting.py
+-rw-r--r--   0        0        0    21814 2023-06-19 18:33:34.836039 burnman-1.2.0/burnman/optimize/nonlinear_fitting.py
+-rw-r--r--   0        0        0    15925 2023-06-19 18:33:34.838340 burnman-1.2.0/burnman/optimize/nonlinear_solvers.py
+-rw-r--r--   0        0        0      673 2022-09-23 21:19:22.662837 burnman-1.2.0/burnman/tools/__init__.py
+-rw-r--r--   0        0        0    11402 2023-06-19 18:33:34.840536 burnman-1.2.0/burnman/tools/chemistry.py
+-rw-r--r--   0        0        0    10686 2023-06-19 18:33:34.842435 burnman-1.2.0/burnman/tools/eos.py
+-rw-r--r--   0        0        0    43053 2023-06-19 18:33:34.844728 burnman-1.2.0/burnman/tools/equilibration.py
+-rw-r--r--   0        0        0    12591 2023-06-19 18:33:34.846930 burnman-1.2.0/burnman/tools/output_seismo.py
+-rw-r--r--   0        0        0     2285 2023-06-19 18:33:34.848399 burnman-1.2.0/burnman/tools/partitioning.py
+-rw-r--r--   0        0        0     4653 2023-06-19 18:33:34.849971 burnman-1.2.0/burnman/tools/plot.py
+-rw-r--r--   0        0        0     9510 2023-06-19 18:33:34.851668 burnman-1.2.0/burnman/tools/polytope.py
+-rw-r--r--   0        0        0    13360 2023-06-19 18:33:34.853152 burnman-1.2.0/burnman/tools/solution.py
+-rw-r--r--   0        0        0      335 2023-06-16 16:57:32.595651 burnman-1.2.0/burnman/tools/unitcell.py
+-rw-r--r--   0        0        0      615 2023-06-16 16:57:32.598091 burnman-1.2.0/burnman/utils/__init__.py
+-rw-r--r--   0        0        0     4321 2023-06-16 16:57:32.599652 burnman-1.2.0/burnman/utils/anisotropy.py
+-rw-r--r--   0        0        0    24265 2023-06-27 13:24:15.356613 burnman-1.2.0/burnman/utils/chemistry.py
+-rw-r--r--   0        0        0     5489 2023-06-19 18:33:34.856403 burnman-1.2.0/burnman/utils/geotherm.py
+-rw-r--r--   0        0        0    17484 2023-06-19 18:33:34.859464 burnman-1.2.0/burnman/utils/math.py
+-rw-r--r--   0        0        0     6722 2023-06-19 18:33:34.862152 burnman-1.2.0/burnman/utils/misc.py
+-rw-r--r--   0        0        0    10051 2023-06-19 18:33:34.864187 burnman-1.2.0/burnman/utils/reductions.py
+-rw-r--r--   0        0        0     3467 2023-06-19 18:33:34.866226 burnman-1.2.0/burnman/utils/unitcell.py
+-rw-r--r--   0        0        0      427 2023-06-30 13:47:02.936652 burnman-1.2.0/burnman/wget-log
+-rw-r--r--   0        0        0      427 2023-06-30 13:50:56.522434 burnman-1.2.0/burnman/wget-log.1
+-rw-r--r--   0        0        0     1076 2023-07-01 15:01:16.001566 burnman-1.2.0/pyproject.toml
+-rw-r--r--   0        0        0     9024 1970-01-01 00:00:00.000000 burnman-1.2.0/PKG-INFO
```

### Comparing `burnman-1.1.0/burnman/__init__.py` & `burnman-1.2.0/burnman/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,15 +31,15 @@
 designed to allow the user to easily combine mineral physics with
 geophysics, and geodynamics. The features of BurnMan include:
 
   - the full codebase, which includes implementations of many static and thermal equations of state
     (including Vinet, Birch Murnaghan, Mie-Debye-Grueneisen, Modified Tait),
     and solution models (ideal, symmetric, asymmetric, subregular).
   - popular endmember and solution datasets already coded into burnman-usable format
-    (including :cite:`HP2011`, :cite:`Stixrude2005` and :cite:`Stixrude2011`)
+    (including :cite:`HP2011`, :cite:`Stixrude2005`, :cite:`Stixrude2011` and :cite:`Stixrude2022`)
   - Optimal least squares fitting routines for multivariate data with (potentially correlated) errors
     in pressure and temperature. As an example, such functions can be used to
     simultaneously fit volumes, seismic velocities and enthalpies.
   - a "Planet" class, which self-consistently calculates gravity profiles, mass, moment of
     inertia of planets given the chemical and temperature structure of a planet
   - published geotherms
   - a tutorial on the basic use of BurnMan
@@ -77,17 +77,27 @@
 
 .. _ref-installation:
 
 
 Requirements
 ------------
 
-  - Python 3.7+
-  - Python modules: NumPy, SciPy, SymPy, Matplotlib
-  - Optional modules: cvxpy, pycddlib
+  - Python 3.8+
+  - Python modules: NumPy, SciPy, SymPy, Sparse, Matplotlib
+
+Optional modules
+^^^^^^^^^^^^^^^^
+
+Needed for some functionality:
+
+  - cvxpy: required for some least squares fitting routines
+    and solution polytope calculations.
+  - pycddlib: required for solution polytope calculations.
+  - autograd: required for esoteric solution models defined using a single excess
+    function. Not required for the vast majority of users.
 
 Installation
 ------------
 
 Installation of BurnMan is mostly platform independent.
 As long as you know how to use a terminal, the process should be straightforward.
 The following instructions should help, but let us know if you have any problems.
@@ -158,19 +168,24 @@
 
 
 Citing BurnMan
 --------------
 
 If you use BurnMan in your work, we ask that you cite the following publications:
 
-  - Myhill, R., Cottaar, S., Heister, T., Rose, I., and Unterborn, C. (2022):
-    BurnMan v1.1.0 [Software]. Computational Infrastructure for Geodynamics. Zenodo.
-    `(https://doi.org/10.5281/zenodo.7080174) <https://doi.org/10.5281/zenodo.7080174>`_
+  - Myhill, R., Cottaar, S., Heister, T., Rose, I., Unterborn, C.,
+    Dannberg, J. and Gassmoeller, R. (2023). BurnMan - a Python toolkit for
+    planetary geophysics, geochemistry and thermodynamics. Journal of Open Source Software.
+    `(https://doi.org/10.21105/joss.05389) <https://doi.org/10.21105/joss.05389>`_
+
+  - Myhill, R., Cottaar, S., Heister, T., Rose, I., and Unterborn, C. (2023):
+    BurnMan v1.2.0 [Software]. Computational Infrastructure for Geodynamics. Zenodo.
+    `(https://doi.org/10.5281/zenodo.8104293) <https://doi.org/10.5281/zenodo.8104293>`_
 
-  - Cottaar S., Heister, T., Rose, I., and Unterborn, C., 2014, BurnMan: A
+  - Cottaar S., Heister, T., Rose, I., and Unterborn, C., (2014). BurnMan: A
     lower mantle mineral physics toolkit, Geochemistry, Geophysics, and
     Geosystems, 15(4), 1164-1179 `(https://doi.org/10.1002/2013GC005122)
     <https://doi.org/10.1002/2013GC005122>`_
 
 Contributing to BurnMan
 -----------------------
 
@@ -198,26 +213,25 @@
     Wendy Panero, and Wolfgang Bangerth for helpful discussions.
 
   - We thank CIG (`www.geodynamics.org <http://www.geodynamics.org>`_) for support
     and accepting our donation of BurnMan as an official project.
 
 """
 from __future__ import absolute_import
-from .version import version as __version__
+import importlib.metadata
 
 # Low level utility functions
 from . import utils
 from .utils import geotherm
 
 # Classes and associated functions for representing rocks and minerals:
 from .classes.material import Material, material_property
 from .classes.perplex import PerplexMaterial
 from .classes.mineral import Mineral
 from .classes.combinedmineral import CombinedMineral
-from .classes.solutionmodel import SolutionModel
 from .classes.solution import Solution, SolidSolution
 from .classes.elasticsolutionmodel import ElasticSolutionModel
 from .classes.elasticsolution import ElasticSolution, ElasticSolidSolution
 from .classes.composite import Composite
 from .classes.calibrant import Calibrant
 from .classes.anisotropy import AnisotropicMaterial
 from .classes.anisotropicmineral import AnisotropicMineral
@@ -251,7 +265,9 @@
 
 # Optimization functions
 from .optimize import composition_fitting
 from .optimize import linear_fitting
 from .optimize import nonlinear_fitting
 from .optimize import nonlinear_solvers
 from .optimize import eos_fitting
+
+__version__ = importlib.metadata.version("burnman")
```

### Comparing `burnman-1.1.0/burnman/calibrants/Decker_1971.py` & `burnman-1.2.0/burnman/calibrants/Decker_1971.py`

 * *Files 27% similar despite different names*

```diff
@@ -15,42 +15,41 @@
 from ..classes.calibrant import Calibrant
 
 
 class NaCl_B1(Calibrant):
     """
     The NaCl (B1 structured) pressure standard reported by Decker (1971).
 
-    Note: This calibrant is not exactly the same as that proposed by Decker.
-    The cold compression curve has here been approximated by a
-    Birch-Murnaghan EoS.
+    .. note:: This calibrant is not exactly the same as that proposed by Decker.
+        The cold compression curve has here been approximated by a
+        Birch-Murnaghan EoS.
 
-    TODO: Make the calibrant exactly match that published by Decker.
+    .. todo:: Make the calibrant exactly match that published by Decker.
     """
-    def __init__(self):
 
+    def __init__(self):
         def _pressure_Decker_NaCl(volume, temperature, params):
-            p300 = birch_murnaghan(params['V_0'] / volume, params)
-            grueneisen = MGD2._grueneisen_parameter(0.,
-                                                    params['V_0'] / volume,
-                                                    params)
-            Debye_T = params['Debye_0'] * np.exp((params['grueneisen_0']
-                                                  - grueneisen)
-                                                 / params['q_0'])
-            Eqh = debye.thermal_energy(temperature, Debye_T, params['n'])
-            EqhR = debye.thermal_energy(params['refT'], Debye_T, params['n'])
+            p300 = birch_murnaghan(params["V_0"] / volume, params)
+            grueneisen = MGD2._grueneisen_parameter(0.0, params["V_0"] / volume, params)
+            Debye_T = params["Debye_0"] * np.exp(
+                (params["grueneisen_0"] - grueneisen) / params["q_0"]
+            )
+            Eqh = debye.thermal_energy(temperature, Debye_T, params["n"])
+            EqhR = debye.thermal_energy(params["refT"], Debye_T, params["n"])
             dpqh = (Eqh - EqhR) * (grueneisen / volume)
             pressure = p300 + dpqh
             return pressure
 
-        _params_Decker_NaCl = {'V_0': 2.7015e-05,
-                               'K_0': 24.02e9,
-                               'Kprime_0': 4.7369,
-                               'Debye_0': 279,
-                               'grueneisen_0': 1.59,
-                               'q_0': 0.93,
-                               'n': 2.,
-                               'refT': 298.15,
-                               'P_0': 0,
-                               'Z': 4.}
+        _params_Decker_NaCl = {
+            "V_0": 2.7015e-05,
+            "K_0": 24.02e9,
+            "Kprime_0": 4.7369,
+            "Debye_0": 279,
+            "grueneisen_0": 1.59,
+            "q_0": 0.93,
+            "n": 2.0,
+            "refT": 298.15,
+            "P_0": 0,
+            "Z": 4.0,
+        }
 
-        Calibrant.__init__(self, _pressure_Decker_NaCl, 'pressure',
-                           _params_Decker_NaCl)
+        Calibrant.__init__(self, _pressure_Decker_NaCl, "pressure", _params_Decker_NaCl)
```

### Comparing `burnman-1.1.0/burnman/classes/__init__.py` & `burnman-1.2.0/burnman/classes/__init__.py`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/classes/anisotropicmineral.py` & `burnman-1.2.0/burnman/classes/anisotropicmineral.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,20 +1,25 @@
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit
 # for the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2021 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 import numpy as np
-from scipy.linalg import expm
+from scipy.linalg import expm, logm
 from numpy.linalg import cond
 from .mineral import Mineral
 from .material import Material, material_property
-from .anisotropy import AnisotropicMaterial, voigt_compliance_factors
+from .anisotropy import AnisotropicMaterial
 from ..utils.misc import copy_documentation
 from ..utils.unitcell import cell_parameters_to_vectors
 from ..utils.unitcell import cell_vectors_to_parameters
+from ..utils.anisotropy import (
+    voigt_notation_to_compliance_tensor,
+    voigt_notation_to_stiffness_tensor,
+    contract_compliances,
+)
 
 
 class AnisotropicMineral(Mineral, AnisotropicMaterial):
     """
     A class implementing the anisotropic mineral equation of state described
     in :cite:`Myhill2022`.
     This class is derived from both Mineral and AnisotropicMaterial,
@@ -59,539 +64,575 @@
     is aligned in a particular way relative to the coordinate axes
     (the anisotropic_parameters are defined relative to the coordinate axes).
     The crystallographic a-axis is assumed to be parallel to the first
     spatial coordinate axis, and the crystallographic b-axis is assumed to
     be perpendicular to the third spatial coordinate axis.
     """
 
-    def __init__(self, isotropic_mineral, cell_parameters,
-                 anisotropic_parameters,
-                 psi_function=None, orthotropic=None):
-
+    def __init__(
+        self,
+        isotropic_mineral,
+        cell_parameters,
+        anisotropic_parameters,
+        psi_function=None,
+        orthotropic=None,
+    ):
         if psi_function is None:
             self.check_standard_parameters(anisotropic_parameters)
-            self.anisotropic_params = {'c': anisotropic_parameters}
+            self.anisotropic_params = {"c": anisotropic_parameters}
             self.psi_function = self.standard_psi_function
         else:
             if not isinstance(orthotropic, bool):
-                raise Exception('If the Psi function is provided, '
-                                'you must specify whether your material is '
-                                'orthotropic as a boolean.')
+                raise Exception(
+                    "If the Psi function is provided, "
+                    "you must specify whether your material is "
+                    "orthotropic as a boolean."
+                )
             self.orthotropic = orthotropic
             self.anisotropic_params = anisotropic_parameters
             self.psi_function = psi_function
 
         self.cell_vectors_0 = cell_parameters_to_vectors(cell_parameters)
 
-        if (np.abs(np.linalg.det(self.cell_vectors_0)
-                   - isotropic_mineral.params['V_0']) > np.finfo(float).eps):
-            factor = np.cbrt(isotropic_mineral.params['V_0']
-                             / np.linalg.det(self.cell_vectors_0))
-            raise Exception('The standard state unit vectors are inconsistent '
-                            'with the volume. Suggest multiplying each '
-                            f'by {factor}.')
-
-        if 'name' in isotropic_mineral.params:
-            self.name = isotropic_mineral.params['name']
-
-        Mineral.__init__(self, isotropic_mineral.params,
-                         isotropic_mineral.property_modifiers)
+        if (
+            np.abs(np.linalg.det(self.cell_vectors_0) - isotropic_mineral.params["V_0"])
+            > np.finfo(float).eps
+        ):
+            factor = np.cbrt(
+                isotropic_mineral.params["V_0"] / np.linalg.det(self.cell_vectors_0)
+            )
+            raise Exception(
+                "The standard state unit vectors are inconsistent "
+                "with the volume. Suggest multiplying each "
+                f"by {factor}."
+            )
+
+        # Note, Psi_0 may be asymmetric, in which case the Voigt contraction
+        # cannot be applied
+        self.Psi_0 = np.einsum("ij, kl", logm(self.cell_vectors_0), np.eye(3) / 3.0)
+
+        self.isotropic_mineral = isotropic_mineral
+        if "name" in isotropic_mineral.params:
+            self.name = isotropic_mineral.params["name"]
+
+        Mineral.__init__(
+            self, isotropic_mineral.params, isotropic_mineral.property_modifiers
+        )
 
     def standard_psi_function(self, f, Pth, params):
         # Compute Psi, dPsidPth, dPsidf, needed by most anisotropic properties
-        c = params['c']
+        c = params["c"]
         ns = np.arange(c.shape[-1])
-        x = c[:, :, 0, :] + c[:, :, 1, :]*f
+        x = c[:, :, 0, :] + c[:, :, 1, :] * f
         dPsidf = c[:, :, 1, :]
 
         for i in list(range(2, c.shape[2])):
             # non-intuitively, the += operator doesn't simply add in-place,
             # so here we overwrite the arrays with new ones
-            x = x + c[:, :, i, :]*np.power(f, float(i))/float(i)
-            dPsidf = dPsidf + c[:, :, i, :] * np.power(f, float(i)-1.)
+            x = x + c[:, :, i, :] * np.power(f, float(i)) / float(i)
+            dPsidf = dPsidf + c[:, :, i, :] * np.power(f, float(i) - 1.0)
 
-        Psi = np.einsum('ikn, n->ik', x, np.power(Pth, ns))
+        Psi = np.einsum("ikn, n->ik", x, np.power(Pth, ns))
 
-        dPsidPth = np.einsum('ikn, n->ik',
-                             x[:, :, 1:],
-                             ns[1:]*np.power(Pth, ns[1:]-1))
+        dPsidPth = np.einsum(
+            "ikn, n->ik", x[:, :, 1:], ns[1:] * np.power(Pth, ns[1:] - 1)
+        )
 
-        dPsidf = np.einsum('ikn, n->ik', dPsidf, np.power(Pth, ns))
+        dPsidf = np.einsum("ikn, n->ik", dPsidf, np.power(Pth, ns))
         return (Psi, dPsidf, dPsidPth)
 
     @copy_documentation(Material.set_state)
     def set_state(self, pressure, temperature):
         # 1) Compute dPthdf|T
         # relatively large dP needed for accurate estimate of dPthdf
-        Mineral.set_state(self, pressure, temperature)
-        dP = self.isothermal_bulk_modulus_reuss*1.e-5
 
-        Mineral.set_state(self, pressure-dP/2., temperature)
-        V1 = self.V
-        Pth1 = pressure-dP/2. - self.method.pressure(self.params['T_0'],
-                                                     V1, self.params)
-
-        Mineral.set_state(self, pressure+dP/2., temperature)
-        V2 = self.V
-        Pth2 = pressure+dP/2. - self.method.pressure(self.params['T_0'],
-                                                     V2, self.params)
+        self.isotropic_mineral.set_state(pressure, temperature)
+        V2 = self.isotropic_mineral.V
+        KT2 = self.isotropic_mineral.K_T
+        self.isotropic_mineral.set_state_with_volume(V2, self.params["T_0"])
+        P1 = self.isotropic_mineral.pressure
+        KT1 = self.isotropic_mineral.K_T
+        self.dPthdf = KT1 - KT2
+        self.Pth = pressure - P1
 
-        self.dPthdf = (Pth2 - Pth1) / np.log(V2/V1)
+        self.isotropic_mineral.set_state(pressure, temperature)
         Mineral.set_state(self, pressure, temperature)
 
         # 2) Compute other properties needed for anisotropic equation of state
         V = self.V
-        V_0 = self.params['V_0']
-        Vrel = V/V_0
+        V_0 = self.params["V_0"]
+        Vrel = V / V_0
         f = np.log(Vrel)
         self._Vrel = Vrel
         self._f = f
 
-        Pth = pressure - self.method.pressure(self.params['T_0'], self.V,
-                                              self.params)
-
-        out = self.psi_function(f, Pth, self.anisotropic_params)
-
-        self.Psi_Voigt = out[0]
-        self.dPsidf_Voigt = out[1]
-        self.dPsidPth_Voigt = out[2]
-
-    def _contract_compliances(self, compliances):
-        """
-        Takes a compliance tensor in standard (3x3x3x3) form
-        and returns the Voigt form (6x6). Note the compliance factors
-        which are required to maintain the inverse relationship with the
-        corresponding stiffness tensor.
-        """
-        voigt_notation = np.zeros((6, 6))
-        for p in range(6):
-            i, j = self._voigt_index_to_ij(p)
-            for q in range(6):
-                m, n = self._voigt_index_to_ij(q)
-                voigt_notation[p, q] = compliances[i, j, m, n]
-        return np.multiply(voigt_notation, voigt_compliance_factors)
+        out = self.psi_function(f, self.Pth, self.anisotropic_params)
+        Psi_Voigt, self.dPsidf_Voigt, self.dPsidPth_Voigt = out
+        self.Psi = voigt_notation_to_compliance_tensor(Psi_Voigt) + self.Psi_0
+
+        # Convert to (f, T) variables
+        self.dPsidP_Voigt = -self.isothermal_compressibility_reuss * (
+            self.dPsidf_Voigt + self.dPsidPth_Voigt * self.dPthdf
+        )
+        self.dPsidT_Voigt = self.alpha * (
+            self.dPsidf_Voigt
+            + self.dPsidPth_Voigt * (self.dPthdf + self.isothermal_bulk_modulus_reuss)
+        )
 
     @material_property
     def deformation_gradient_tensor(self):
         """
-        Returns
-        -------
-        deformation_gradient_tensor : 2D numpy array
-            The deformation gradient tensor describing the deformation of the
+        :returns: The deformation gradient tensor describing the deformation of the
             mineral from its undeformed state
             (i.e. the state at the reference pressure and temperature).
+        :rtype: numpy.array (2D)
         """
-        Psi_full = self._voigt_notation_to_compliance_tensor(self.Psi_Voigt)
-        F = expm(np.einsum('ijkl, kl', Psi_full, np.eye(3)))
+        F = expm(np.einsum("ijkl, kl", self.Psi, np.eye(3)))
         return F
 
     @material_property
     def unrotated_cell_vectors(self):
         """
-        Returns
-        -------
-        unrotated_cell_vectors : 2D numpy array
-            The vectors of the cell constructed from one mole of formula units
-            after deformation of the mineral from its undeformed state
-            (i.e. the state at the reference pressure and temperature).
-            Each vector is given in [m]. See the documentation for the function
+        :returns: The vectors of the cell [m] constructed from one mole
+            of formula units after deformation of the mineral from its
+            undeformed state (i.e. the state at the reference
+            pressure and temperature). See the documentation for the function
             :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`
             for the assumed relationships between the cell vectors and
             spatial coordinate axes.
+        :rtype: numpy.array (2D)
         """
-        return self.deformation_gradient_tensor.dot(self.cell_vectors_0)
+        return self.deformation_gradient_tensor
 
     @material_property
     def deformed_coordinate_frame(self):
         """
-        Returns
-        -------
-        deformed_coordinate_frame : 2D numpy array
-            The orientations of the three spatial coordinate axes
-            after deformation of the mineral. For orthotropic minerals,
+        :returns: The orientations of the three spatial coordinate axes
+            after deformation of the mineral [m]. For orthotropic minerals,
             this is equal to the identity matrix, as hydrostatic stresses only
             induce rotations in monoclinic and triclinic crystals.
+        :rtype: numpy.array (2D)
         """
         if self.orthotropic:
             return np.eye(3)
         else:
             M = self.unrotated_cell_vectors
             Q = np.empty((3, 3))
             Q[0] = M[0] / np.linalg.norm(M[0])
-            Q[2] = np.cross(M[0], M[1])/np.linalg.norm(np.cross(M[0], M[1]))
+            Q[2] = np.cross(M[0], M[1]) / np.linalg.norm(np.cross(M[0], M[1]))
             Q[1] = np.cross(Q[2], Q[0])
             return Q
 
     @material_property
     def rotation_matrix(self):
         """
-        Returns
-        -------
-        rotation_matrix : 2D numpy array
-            The matrix required to rotate the properties of the deformed
+        :returns: The matrix required to rotate the properties of the deformed
             mineral into the deformed coordinate frame. For orthotropic
             minerals, this is equal to the identity matrix.
+        :rtype: numpy.array (2D)
         """
         return self.deformed_coordinate_frame.T
 
     @material_property
     def cell_vectors(self):
         """
-        Returns
-        -------
-        cell_vectors : 2D numpy array
-            The vectors of the cell constructed from one mole of formula units.
-            Each vector is given in [m]. See the documentation for the function
+        :returns: The vectors of the cell constructed from one mole
+            of formula units [m]. See the documentation for the function
             :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`
             for the assumed relationships between the cell vectors and
             spatial coordinate axes.
+        :rtype: numpy.array (2D)
         """
         if self.orthotropic:
             return self.unrotated_cell_vectors
         else:
-            return np.einsum('ij, jk->ik',
-                             self.unrotated_cell_vectors,
-                             self.rotation_matrix)
+            return np.einsum(
+                "ij, jk->ik", self.unrotated_cell_vectors, self.rotation_matrix
+            )
 
     @material_property
     def cell_parameters(self):
         """
-        Returns
-        -------
-        cell_parameters : 1D numpy array
-            The molar cell parameters of the mineral, given in standard form:
+        :returns: The molar cell parameters of the mineral, given in standard form:
             [:math:`a`, :math:`b`, :math:`c`,
             :math:`\\alpha`, :math:`\\beta`, :math:`\\gamma`],
             where the first three floats are the lengths of the vectors in [m]
             defining the cell constructed from one mole of formula units.
             The last three floats are angles between vectors
             (given in radians). See the documentation for the function
             :func:`~burnman.utils.unitcell.cell_parameters_to_vectors`
             for the assumed relationships between the cell vectors and
             spatial coordinate axes.
+        :rtype: numpy.array (1D)
         """
         return cell_vectors_to_parameters(self.cell_vectors)
 
     @material_property
     def shear_modulus(self):
         """
         Anisotropic minerals do not (in general) have a single shear modulus.
         This function returns a NotImplementedError. Users should instead
         consider directly querying the elements in the
         isothermal_stiffness_tensor or isentropic_stiffness_tensor.
         """
-        raise NotImplementedError("Anisotropic minerals do not have a shear "
-                                  "modulus property. Query "
-                                  "the isentropic or isothermal stiffness "
-                                  "tensors directory, or use"
-                                  "isentropic_shear_modulus_reuss or "
-                                  "isentropic_shear_modulus_voigt.")
+        raise NotImplementedError(
+            "Anisotropic minerals do not have a shear "
+            "modulus property. Query "
+            "the isentropic or isothermal stiffness "
+            "tensors directory, or use"
+            "isentropic_shear_modulus_reuss or "
+            "isentropic_shear_modulus_voigt."
+        )
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
         Anisotropic minerals do not have a single isothermal bulk modulus.
         This function returns a NotImplementedError. Users should instead
         consider either using isothermal_bulk_modulus_reuss,
         isothermal_bulk_modulus_voigt,
         or directly querying the elements in the isothermal_stiffness_tensor.
         """
-        raise NotImplementedError("isothermal_bulk_modulus is not "
-                                  "sufficiently explicit for an "
-                                  "anisotropic mineral. Did you mean "
-                                  "isothermal_bulk_modulus_reuss?")
+        raise NotImplementedError(
+            "isothermal_bulk_modulus is not "
+            "sufficiently explicit for an "
+            "anisotropic mineral. Did you mean "
+            "isothermal_bulk_modulus_reuss?"
+        )
 
     @material_property
     def isentropic_bulk_modulus(self):
         """
         Anisotropic minerals do not have a single isentropic bulk modulus.
         This function returns a NotImplementedError. Users should instead
         consider either using isentropic_bulk_modulus_reuss,
-        isentropic_bulk_modulus_voigt (both derived from Anisotropicmineral),
+        isentropic_bulk_modulus_voigt (both derived from AnisotropicMineral),
         or directly querying the elements in the isentropic_stiffness_tensor.
         """
-        raise NotImplementedError("isentropic_bulk_modulus is not "
-                                  "sufficiently explicit for an "
-                                  "anisotropic mineral. Did you mean "
-                                  "isentropic_bulk_modulus_reuss?")
+        raise NotImplementedError(
+            "isentropic_bulk_modulus is not "
+            "sufficiently explicit for an "
+            "anisotropic mineral. Did you mean "
+            "isentropic_bulk_modulus_reuss?"
+        )
 
     isothermal_bulk_modulus_reuss = Mineral.isothermal_bulk_modulus
 
     @material_property
+    def isothermal_compressibility(self):
+        """
+        Anisotropic minerals do not have a single isentropic compressibility.
+        This function returns a NotImplementedError. Users should instead
+        consider either using isothermal_compressibility_reuss,
+        isothermal_compressibility_voigt (both derived from AnisotropicMineral),
+        or directly querying the elements in the isothermal_compliance_tensor.
+        """
+        raise NotImplementedError(
+            "isothermal_compressibility is not "
+            "sufficiently explicit for an "
+            "anisotropic mineral. Did you mean "
+            "isothermal_compressibility_reuss?"
+        )
+
+    @material_property
+    def isentropic_compressibility(self):
+        """
+        Anisotropic minerals do not have a single isentropic compressibility.
+        This function returns a NotImplementedError. Users should instead
+        consider either using isentropic_compressibility_reuss,
+        isentropic_compressibility_voigt (both derived from AnisotropicMineral),
+        or directly querying the elements in the isentropic_compliance_tensor.
+        """
+        raise NotImplementedError(
+            "isentropic_compressibility is not "
+            "sufficiently explicit for an "
+            "anisotropic mineral. Did you mean "
+            "isentropic_compressibility_reuss?"
+        )
+
+    @material_property
     def isothermal_bulk_modulus_voigt(self):
         """
-        Returns
-        -------
-        isothermal_bulk_modulus_voigt : float
-            The Voigt bound on the isothermal bulk modulus in [Pa].
-        """
-        K = np.sum([[self.isothermal_stiffness_tensor[i][k]
-                     for k in range(3)]
-                    for i in range(3)])/9.
+        :returns: The Voigt bound on the isothermal bulk modulus in [Pa].
+        :rtype: float
+        """
+        K = (
+            np.sum(
+                [
+                    [self.isothermal_stiffness_tensor[i][k] for k in range(3)]
+                    for i in range(3)
+                ]
+            )
+            / 9.0
+        )
         return K
 
     @material_property
     def isothermal_compressibility_reuss(self):
         """
-        Returns
-        -------
-        isothermal_compressibility_reuss : float
-            The Reuss bound on the isothermal compressibility in [1/Pa].
+        :returns: The Reuss bound on the isothermal compressibility in [1/Pa].
+        :rtype: float
+        """
+        return 1.0 / self.isothermal_bulk_modulus_reuss
+
+    beta_T = isothermal_compressibility_reuss
+
+    @material_property
+    def isothermal_compressibility_voigt(self):
+        """
+        :returns: The Voigt bound on the isothermal compressibility in [1/Pa].
+        :rtype: float
+        """
+        return 1.0 / self.isothermal_bulk_modulus_voigt
+
+    @material_property
+    def isentropic_compressibility_reuss(self):
+        """
+        :returns: The Reuss bound on the isentropic compressibility in [1/Pa].
+        :rtype: float
+        """
+        return 1.0 / self.isentropic_bulk_modulus_reuss
+
+    beta_S = isentropic_compressibility_reuss
+
+    @material_property
+    def isentropic_compressibility_voigt(self):
+        """
+        :returns: The Voigt bound on the isentropic compressibility in [1/Pa].
+        :rtype: float
         """
-        return 1./self.isothermal_bulk_modulus_reuss
+        return 1.0 / self.isentropic_bulk_modulus_voigt
 
     @material_property
     def isothermal_compliance_tensor(self):
         """
-        Returns
-        -------
-        isothermal_compliance_tensor : 2D numpy array
-            The isothermal compliance tensor [1/Pa]
+        :returns: The isothermal compliance tensor [1/Pa]
             in Voigt form (:math:`\\mathbb{S}_{\\text{T} pq}`).
+        :rtype: numpy.array (2D)
         """
-        S_T = (self.isothermal_compressibility_reuss
-               * (self.dPsidf_Voigt + self.dPsidPth_Voigt * self.dPthdf))
+        S_T = -self.dPsidP_Voigt
         if self.orthotropic:
             return S_T
         else:
             R = self.rotation_matrix
-            S = self._voigt_notation_to_compliance_tensor(S_T)
-            S_rotated = np.einsum('mi, nj, ok, pl, ijkl->mnop', R, R, R, R, S)
-            return self._contract_compliances(S_rotated)
+            S = voigt_notation_to_compliance_tensor(S_T)
+            S_rotated = np.einsum("mi, nj, ok, pl, ijkl->mnop", R, R, R, R, S)
+            return contract_compliances(S_rotated)
 
     @material_property
     def thermal_expansivity_tensor(self):
         """
-        Returns
-        -------
-        thermal_expansivity_tensor : 2D numpy array
-            The tensor of thermal expansivities [1/K].
-        """
-        a = self.alpha * (self.dPsidf_Voigt
-                          + self.dPsidPth_Voigt
-                          * (self.dPthdf
-                             + 1./self.isothermal_compressibility_reuss))
-        alpha = np.einsum('ijkl, kl',
-                          self._voigt_notation_to_compliance_tensor(a),
-                          np.eye(3))
+        :returns: The tensor of thermal expansivities [1/K].
+        :rtype: numpy.array (2D)
+        """
+        alpha = np.einsum(
+            "ijkl, kl",
+            voigt_notation_to_compliance_tensor(self.dPsidT_Voigt),
+            np.eye(3),
+        )
 
         if self.orthotropic:
             return alpha
         else:
             R = self.rotation_matrix
-            return np.einsum('mi, nj, ij->mn', R, R, alpha)
+            return np.einsum("mi, nj, ij->mn", R, R, alpha)
 
     # Derived properties start here
     @material_property
     def isothermal_stiffness_tensor(self):
         """
-        Returns
-        -------
-        isothermal_stiffness_tensor : 2D numpy array
-            The isothermal stiffness tensor [Pa]
+        :returns: The isothermal stiffness tensor [Pa]
             in Voigt form (:math:`\\mathbb{C}_{\\text{T} pq}`).
+        :rtype: numpy.array (2D)
         """
         return np.linalg.inv(self.isothermal_compliance_tensor)
 
     @material_property
     def full_isothermal_compliance_tensor(self):
         """
-        Returns
-        -------
-        full_isothermal_stiffness_tensor : 4D numpy array
-            The isothermal compliance tensor [1/Pa]
+        :returns: The isothermal compliance tensor [1/Pa]
             in standard form (:math:`\\mathbb{S}_{\\text{T} ijkl}`).
+        :rtype: numpy.array (4D)
         """
         S_Voigt = self.isothermal_compliance_tensor
-        return self._voigt_notation_to_compliance_tensor(S_Voigt)
+        return voigt_notation_to_compliance_tensor(S_Voigt)
 
     @material_property
     def full_isothermal_stiffness_tensor(self):
         """
-        Returns
-        -------
-        full_isothermal_stiffness_tensor : 4D numpy array
-            The isothermal stiffness tensor [Pa]
+        :returns: The isothermal stiffness tensor [Pa]
             in standard form (:math:`\\mathbb{C}_{\\text{T} ijkl}`).
+        :rtype: numpy.array (4D)
         """
         CT = self.isothermal_stiffness_tensor
-        return self._voigt_notation_to_stiffness_tensor(CT)
+        return voigt_notation_to_stiffness_tensor(CT)
 
     @material_property
     def full_isentropic_compliance_tensor(self):
         """
-        Returns
-        -------
-        full_isentropic_stiffness_tensor : 4D numpy array
-            The isentropic compliance tensor [1/Pa]
+        :returns: The isentropic compliance tensor [1/Pa]
             in standard form (:math:`\\mathbb{S}_{\\text{N} ijkl}`).
+        :rtype: numpy.array (4D)
         """
-        return (self.full_isothermal_compliance_tensor
-                - np.einsum('ij, kl->ijkl',
-                            self.thermal_expansivity_tensor,
-                            self.thermal_expansivity_tensor)
-                * self.V * self.temperature / self.C_p)
+        return (
+            self.full_isothermal_compliance_tensor
+            - np.einsum(
+                "ij, kl->ijkl",
+                self.thermal_expansivity_tensor,
+                self.thermal_expansivity_tensor,
+            )
+            * self.V
+            * self.temperature
+            / self.C_p
+        )
 
     @material_property
     def isentropic_compliance_tensor(self):
         """
-        Returns
-        -------
-        isentropic_compliance_tensor : 2D numpy array
-            The isentropic compliance tensor [1/Pa]
+        :returns: The isentropic compliance tensor [1/Pa]
             in Voigt form (:math:`\\mathbb{S}_{\\text{N} pq}`).
+        :rtype: numpy.array (2D)
         """
         S_full = self.full_isentropic_compliance_tensor
-        return self._contract_compliances(S_full)
+        return contract_compliances(S_full)
 
     @material_property
     def isentropic_stiffness_tensor(self):
         """
-        Returns
-        -------
-        isentropic_stiffness_tensor : 2D numpy array
-            The isentropic stiffness tensor [Pa]
+        :returns: The isentropic stiffness tensor [Pa]
             in Voigt form (:math:`\\mathbb{C}_{\\text{N} pq}`).
+        :rtype: numpy.array (2D)
         """
         return np.linalg.inv(self.isentropic_compliance_tensor)
 
     @material_property
     def full_isentropic_stiffness_tensor(self):
         """
-        Returns
-        -------
-        full_isentropic_stiffness_tensor : 4D numpy array
-            The isentropic stiffness tensor [Pa]
+        :returns: The isentropic stiffness tensor [Pa]
             in standard form (:math:`\\mathbb{C}_{\\text{N} ijkl}`).
+        :rtype: numpy.array (4D)
         """
         C_Voigt = self.isentropic_stiffness_tensor
-        return self._voigt_notation_to_stiffness_tensor(C_Voigt)
+        return voigt_notation_to_stiffness_tensor(C_Voigt)
 
     @material_property
     def grueneisen_tensor(self):
         """
-        Returns
-        -------
-        grueneisen_tensor : 2D numpy array
-            The grueneisen tensor.
+        :returns: The grueneisen tensor [unitless].
             This is defined by :cite:`BarronMunn1967` as
             :math:`\\mathbb{C}_{\\text{N} ijkl} \\alpha_{kl} V/C_{P}`.
+        :rtype: numpy.array (2D)
         """
-        return (np.einsum('ijkl, kl->ij',
-                          self.full_isentropic_stiffness_tensor,
-                          self.thermal_expansivity_tensor)
-                * self.molar_volume / self.molar_heat_capacity_p)
+        return (
+            np.einsum(
+                "ijkl, kl->ij",
+                self.full_isentropic_stiffness_tensor,
+                self.thermal_expansivity_tensor,
+            )
+            * self.molar_volume
+            / self.molar_heat_capacity_p
+        )
 
     @material_property
     def grueneisen_parameter(self):
         """
-        Anisotropic minerals do not (in general) have a single grueneisen
-        parameter. This function returns a NotImplementedError.
-        Users should instead consider directly querying the elements in the
-        grueneisen_tensor.
-        """
-        raise NotImplementedError("Anisotropic minerals do not have a single "
-                                  "grueneisen parameter. Query "
-                                  "the grueneisen_tensor instead.")
+        :returns: The scalar grueneisen parameter [unitless].
+        :rtype: float
+        """
+        return (
+            self.thermal_expansivity
+            * self.V
+            / (self.isentropic_compressibility_reuss * self.molar_heat_capacity_p)
+        )
 
     @material_property
     def isothermal_compressibility_tensor(self):
         """
-        Returns
-        -------
-        isothermal_compressibility_tensor : 2D numpy array
-            The isothermal compressibility tensor.
-        """
-        return np.einsum('ijkl, kl->ij',
-                         self.full_isothermal_compliance_tensor,
-                         np.eye(3))
+        :returns: The isothermal compressibility tensor [1/Pa].
+        :rtype: numpy.array (2D)
+        """
+        return np.einsum(
+            "ijkl, kl->ij", self.full_isothermal_compliance_tensor, np.eye(3)
+        )
 
     @material_property
     def isentropic_compressibility_tensor(self):
         """
-        Returns
-        -------
-        isentropic_compressibility_tensor : 2D numpy array
-            The isentropic compressibility tensor.
-        """
-        return np.einsum('ijkl, kl->ij',
-                         self.full_isentropic_compliance_tensor,
-                         np.eye(3))
+        :returns: The isentropic compressibility tensor [1/Pa].
+        :rtype: numpy.array (2D)
+        """
+        return np.einsum(
+            "ijkl, kl->ij", self.full_isentropic_compliance_tensor, np.eye(3)
+        )
 
     @material_property
     def thermal_stress_tensor(self):
         """
-        Returns
-        -------
-        thermal stress : 2D numpy array
-            The change in stress with temperature at constant strain.
+        :returns: The change in stress with temperature at constant strain [Pa/K].
+        :rtype: numpy.array (2D)
         """
-        pi = np.einsum('ijkl, kl', self.full_isothermal_stiffness_tensor,
-                       self.thermal_expansivity_tensor)
+        pi = -np.einsum(
+            "ijkl, kl",
+            self.full_isothermal_stiffness_tensor,
+            self.thermal_expansivity_tensor,
+        )
         return pi
 
     @material_property
     def molar_isometric_heat_capacity(self):
         """
-        Returns
-        -------
-        molar_isometric_heat_capacity : float
-            The molar heat capacity at constant strain.
+        :returns: The molar heat capacity at constant strain [J/K/mol].
+        :rtype: float
         """
-
+        alpha = self.thermal_expansivity_tensor
         pi = self.thermal_stress_tensor
-        pipiV = np.einsum('ij, kl -> ijkl', pi, pi)*self.V
-        indices = np.where(np.abs(pipiV) > 1.e-5)
-        values = ((self.full_isentropic_stiffness_tensor
-                   - self.full_isothermal_stiffness_tensor)[indices]
-                  / pipiV[indices])
-        if not np.allclose(values, np.ones_like(values)*values[0],
-                           rtol=1.e-5):
-            raise Exception('Could not calculate the molar heat '
-                            'capacity at constant strain. '
-                            'There is an inconsistency in the '
-                            'equation of state.')
-        C_isometric = self.temperature/values[0]
-
+        C_isometric = (
+            self.molar_heat_capacity_p
+            + self.V * self.temperature * np.einsum("ij, ij", alpha, pi)
+        )
         return C_isometric
 
     def check_standard_parameters(self, anisotropic_parameters):
-
         if not np.all(anisotropic_parameters[:, :, 0, 0] == 0):
-            raise Exception("anisotropic_parameters_pqmn should be set to "
-                            "zero for all m = n = 0")
-
-        sum_ijij_block = np.sum(anisotropic_parameters[:3, :3, :, :],
-                                axis=(0, 1))
-
-        if np.abs(sum_ijij_block[1, 0] - 1.) > 1.e-5:
-            raise Exception('The sum of the upper 3x3 pq-block of '
-                            'anisotropic_parameters_pqmn must equal '
-                            '1 for m=1, n=0 for consistency with the volume. '
-                            f'Value is {sum_ijij_block[1, 0]}')
+            raise Exception(
+                "anisotropic_parameters_pqmn should be set to " "zero for all m = n = 0"
+            )
+
+        sum_ijij_block = np.sum(anisotropic_parameters[:3, :3, :, :], axis=(0, 1))
+
+        if np.abs(sum_ijij_block[1, 0] - 1.0) > 1.0e-5:
+            raise Exception(
+                "The sum of the upper 3x3 pq-block of "
+                "anisotropic_parameters_pqmn must equal "
+                "1 for m=1, n=0 for consistency with the volume. "
+                f"Value is {sum_ijij_block[1, 0]}"
+            )
 
         for m in range(2, len(sum_ijij_block)):
-            if np.abs(sum_ijij_block[m, 0]) > 1.e-10:
-                raise Exception('The sum of the upper 3x3 pq-block of '
-                                'anisotropic_parameters_pqmn must equal 0 for'
-                                f'm={m}, n=0 for consistency with the volume. '
-                                f'Value is {sum_ijij_block[m, 0]}')
+            if np.abs(sum_ijij_block[m, 0]) > 1.0e-10:
+                raise Exception(
+                    "The sum of the upper 3x3 pq-block of "
+                    "anisotropic_parameters_pqmn must equal 0 for"
+                    f"m={m}, n=0 for consistency with the volume. "
+                    f"Value is {sum_ijij_block[m, 0]}"
+                )
 
         for m in range(len(sum_ijij_block)):
             for n in range(1, len(sum_ijij_block[0])):
-                if np.abs(sum_ijij_block[m, n]) > 1.e-10:
-                    raise Exception('The sum of the upper 3x3 pq-block of '
-                                    'anisotropic_parameters_pqmn must equal '
-                                    f'0 for m={m}, n={n} for '
-                                    'consistency with the volume. '
-                                    f'Value is {sum_ijij_block[m, n]}')
+                if np.abs(sum_ijij_block[m, n]) > 1.0e-10:
+                    raise Exception(
+                        "The sum of the upper 3x3 pq-block of "
+                        "anisotropic_parameters_pqmn must equal "
+                        f"0 for m={m}, n={n} for "
+                        "consistency with the volume. "
+                        f"Value is {sum_ijij_block[m, n]}"
+                    )
 
-        if cond(anisotropic_parameters[:, :, 1, 0]) > 1/np.finfo(float).eps:
-            raise Exception('anisotropic_parameters[:, :, 1, 0] is singular')
+        if cond(anisotropic_parameters[:, :, 1, 0]) > 1 / np.finfo(float).eps:
+            raise Exception("anisotropic_parameters[:, :, 1, 0] is singular")
 
-        sum_lower_left_block = np.sum(anisotropic_parameters[3:, :3, :, :],
-                                      axis=1)
+        sum_lower_left_block = np.sum(anisotropic_parameters[3:, :3, :, :], axis=1)
 
         self.orthotropic = True
         for i, s in enumerate(sum_lower_left_block):
-            if not np.all(np.abs(s) < 1.e-10):
+            if not np.all(np.abs(s) < 1.0e-10):
                 self.orthotropic = False
```

### Comparing `burnman-1.1.0/burnman/classes/anisotropy.py` & `burnman-1.2.0/burnman/classes/anisotropy.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,22 +6,19 @@
 from __future__ import absolute_import
 from __future__ import print_function
 
 import numpy as np
 
 from ..utils.math import unit_normalize
 from .material import Material, material_property
-
-try:  # numpy.block was new in numpy version 1.13.0.
-    block = np.block([[np.ones((3, 3)), 2.*np.ones((3, 3))],
-                      [2.*np.ones((3, 3)), 4.*np.ones((3, 3))]])
-except:
-    block = np.array(np.bmat([[[[1.]*3]*3, [[2.]*3]*3],
-                              [[[2.]*3]*3, [[4.]*3]*3]] ))
-voigt_compliance_factors = block
+from ..utils.anisotropy import (
+    voigt_array_from_cijs,
+    voigt_notation_to_compliance_tensor,
+    voigt_notation_to_stiffness_tensor,
+)
 
 
 class AnisotropicMaterial(Material):
     """
     A base class for anisotropic elastic materials. The base class
     is initialised with a density and a full isentropic stiffness tensor
     in Voigt notation. It can then be interrogated to find the values of
@@ -32,445 +29,487 @@
 
     See :cite:`Mainprice2011`
     and https://docs.materialsproject.org/methodology/elasticity/
     for mathematical descriptions of each function.
     """
 
     def __init__(self, rho, cijs):
-
         self._isentropic_stiffness_tensor = cijs
         self._rho = rho
 
-        assert cijs.shape == (6, 6), 'cijs must be in Voigt notation (6x6)'
-        assert np.allclose(cijs.T, cijs), 'stiffness_tensor must be symmetric'
+        assert cijs.shape == (6, 6), "cijs must be in Voigt notation (6x6)"
+        assert np.allclose(cijs.T, cijs), "stiffness_tensor must be symmetric"
 
         Material.__init__(self)
 
-    def _voigt_index_to_ij(self, m):
-        """
-        Returns the ij (or kl) indices of the
-        stiffness tensor which correspond to those
-        of the Voigt notation m (or n).
-        """
-        if m == 3:
-            return 1, 2
-        elif m == 4:
-            return 0, 2
-        elif m == 5:
-            return 0, 1
-        else:
-            return m, m
-
-    def _voigt_notation_to_stiffness_tensor(self, voigt_notation):
-        """
-        Converts a stiffness tensor in Voigt notation (6x6 matrix)
-        to the full fourth rank tensor (3x3x3x3 matrix).
-        """
-        stiffness_tensor = np.zeros([3, 3, 3, 3])
-        for m in range(6):
-            i, j = self._voigt_index_to_ij(m)
-            for n in range(6):
-                k, l = self._voigt_index_to_ij(n)
-                stiffness_tensor[i][j][k][l] = voigt_notation[m][n]
-                stiffness_tensor[j][i][k][l] = voigt_notation[m][n]
-                stiffness_tensor[i][j][l][k] = voigt_notation[m][n]
-                stiffness_tensor[j][i][l][k] = voigt_notation[m][n]
-        return stiffness_tensor
-
-    def _voigt_notation_to_compliance_tensor(self, voigt_notation):
-        return self._voigt_notation_to_stiffness_tensor(np.divide(voigt_notation,
-                                                                  voigt_compliance_factors))
-
     @material_property
     def isentropic_stiffness_tensor(self):
         return self._isentropic_stiffness_tensor
 
     @material_property
     def full_isentropic_stiffness_tensor(self):
-        return self._voigt_notation_to_stiffness_tensor(self.isentropic_stiffness_tensor)
+        return voigt_notation_to_stiffness_tensor(self.isentropic_stiffness_tensor)
 
     @material_property
     def isentropic_compliance_tensor(self):
         return np.linalg.inv(self.isentropic_stiffness_tensor)
 
     @material_property
     def full_isentropic_compliance_tensor(self):
-        return self._voigt_notation_to_compliance_tensor(self.isentropic_compliance_tensor)
+        return voigt_notation_to_compliance_tensor(self.isentropic_compliance_tensor)
 
     @material_property
     def density(self):
         return self._rho
 
     @material_property
     def isentropic_bulk_modulus_voigt(self):
         """
-        Computes the isentropic bulk modulus (Voigt bound)
+        :returns: The Voigt bound on the isentropic bulk modulus [Pa].
+        :rtype: float
         """
-        K = np.sum([[self.isentropic_stiffness_tensor[i][k]
-                     for k in range(3)]
-                    for i in range(3)])/9.
+        K = (
+            np.sum(
+                [
+                    [self.isentropic_stiffness_tensor[i][k] for k in range(3)]
+                    for i in range(3)
+                ]
+            )
+            / 9.0
+        )
         return K
 
     @material_property
     def isentropic_bulk_modulus_reuss(self):
         """
-        Computes the isentropic bulk modulus (Reuss bound)
+        :returns: The Reuss bound on the isentropic bulk modulus [Pa].
+        :rtype: float
         """
-        beta = np.sum([[self.isentropic_compliance_tensor[i][k] for k in range(3)] for i in range(3)])
-        return 1./beta
+        beta = np.sum(
+            [
+                [self.isentropic_compliance_tensor[i][k] for k in range(3)]
+                for i in range(3)
+            ]
+        )
+        return 1.0 / beta
 
     @material_property
     def isentropic_bulk_modulus_vrh(self):
         """
-        Computes the isentropic bulk modulus (Voigt-Reuss-Hill average)
+        :returns: The Voigt-Reuss-Hill average of the isentropic bulk modulus [Pa].
+        :rtype: float
         """
-        return 0.5*(self.isentropic_bulk_modulus_voigt + self.isentropic_bulk_modulus_reuss)
+        return 0.5 * (
+            self.isentropic_bulk_modulus_voigt + self.isentropic_bulk_modulus_reuss
+        )
 
     @material_property
     def isentropic_shear_modulus_voigt(self):
         """
-        Computes the isentropic shear modulus (Voigt bound)
+        :returns: The Voigt bound on the isentropic shear modulus [Pa].
+        :rtype: float
         """
-        G = ( np.sum([self.isentropic_stiffness_tensor[i][i] for i in [0, 1, 2]]) +
-              np.sum([self.isentropic_stiffness_tensor[i][i] for i in [3, 4, 5]])*3. -
-              ( self.isentropic_stiffness_tensor[0][1] +
-                self.isentropic_stiffness_tensor[1][2] +
-                self.isentropic_stiffness_tensor[2][0] )) / 15.
+        G = (
+            np.sum([self.isentropic_stiffness_tensor[i][i] for i in [0, 1, 2]])
+            + np.sum([self.isentropic_stiffness_tensor[i][i] for i in [3, 4, 5]]) * 3.0
+            - (
+                self.isentropic_stiffness_tensor[0][1]
+                + self.isentropic_stiffness_tensor[1][2]
+                + self.isentropic_stiffness_tensor[2][0]
+            )
+        ) / 15.0
         return G
 
     @material_property
     def isentropic_shear_modulus_reuss(self):
         """
-        Computes the isentropic shear modulus (Reuss bound)
+        :returns: The Reuss bound on the isentropic shear modulus [Pa].
+        :rtype: float
         """
-        beta =  ( np.sum([self.isentropic_compliance_tensor[i][i] for i in [0, 1, 2]])*4. +
-                  np.sum([self.isentropic_compliance_tensor[i][i] for i in [3, 4, 5]])*3. -
-                  ( self.isentropic_compliance_tensor[0][1] +
-                    self.isentropic_compliance_tensor[1][2] +
-                    self.isentropic_compliance_tensor[2][0])*4. ) / 15.
-        return 1./beta
+        beta = (
+            np.sum([self.isentropic_compliance_tensor[i][i] for i in [0, 1, 2]]) * 4.0
+            + np.sum([self.isentropic_compliance_tensor[i][i] for i in [3, 4, 5]]) * 3.0
+            - (
+                self.isentropic_compliance_tensor[0][1]
+                + self.isentropic_compliance_tensor[1][2]
+                + self.isentropic_compliance_tensor[2][0]
+            )
+            * 4.0
+        ) / 15.0
+        return 1.0 / beta
 
     @material_property
     def isentropic_shear_modulus_vrh(self):
         """
-        Computes the shear modulus (Voigt-Reuss-Hill average)
+        :returns: The Voigt-Reuss-Hill average of the isentropic shear modulus [Pa].
+        :rtype: float
         """
-        return 0.5*(self.isentropic_shear_modulus_voigt
-                    + self.isentropic_shear_modulus_reuss)
+        return 0.5 * (
+            self.isentropic_shear_modulus_voigt + self.isentropic_shear_modulus_reuss
+        )
 
     @material_property
     def isentropic_universal_elastic_anisotropy(self):
         """
-        Compute the universal elastic anisotropy
+        :returns: The universal elastic anisotropy [unitless]
+        :rtype: float
         """
-        return ( 5.*(self.isentropic_shear_modulus_voigt/self.isentropic_shear_modulus_reuss) +
-                 (self.isentropic_bulk_modulus_voigt/self.isentropic_bulk_modulus_reuss) - 6. )
+        return (
+            5.0
+            * (
+                self.isentropic_shear_modulus_voigt
+                / self.isentropic_shear_modulus_reuss
+            )
+            + (self.isentropic_bulk_modulus_voigt / self.isentropic_bulk_modulus_reuss)
+            - 6.0
+        )
 
     @material_property
     def isentropic_isotropic_poisson_ratio(self):
         """
-        Compute mu, the isotropic Poisson ratio
-        (a description of the laterial response to loading)
-        """
-        return ((3.*self.isentropic_bulk_modulus_vrh
-                 - 2.*self.isentropic_shear_modulus_vrh)
-                / (6.*self.isentropic_bulk_modulus_vrh
-                   + 2.*self.isentropic_shear_modulus_vrh) )
+        :returns: The isotropic Poisson ratio (mu) [unitless].
+            A metric of the laterial response to loading.
+        :rtype: float
+        """
+        return (
+            3.0 * self.isentropic_bulk_modulus_vrh
+            - 2.0 * self.isentropic_shear_modulus_vrh
+        ) / (
+            6.0 * self.isentropic_bulk_modulus_vrh
+            + 2.0 * self.isentropic_shear_modulus_vrh
+        )
 
     def christoffel_tensor(self, propagation_direction):
         """
-        Computes the Christoffel tensor from an elastic stiffness
-        tensor and a propagation direction for a seismic wave
-        relative to the stiffness tensor
-
-        T_ik = C_ijkl n_j n_l
+        :returns: The Christoffel tensor from an elastic stiffness
+            tensor and a propagation direction for a seismic wave
+            relative to the stiffness tensor:
+            T_ik = C_ijkl n_j n_l.
+        :rtype: float
         """
         propagation_direction = unit_normalize(propagation_direction)
-        Tik = np.tensordot(np.tensordot(self.full_isentropic_stiffness_tensor,
-                                        propagation_direction,
-                                        axes=([1],[0])),
-                           propagation_direction,
-                           axes=([2],[0]))
+        Tik = np.tensordot(
+            np.tensordot(
+                self.full_isentropic_stiffness_tensor,
+                propagation_direction,
+                axes=([1], [0]),
+            ),
+            propagation_direction,
+            axes=([2], [0]),
+        )
         return Tik
 
     def isentropic_linear_compressibility(self, direction):
         """
-        Computes the linear isentropic compressibility in a given direction
-        relative to the stiffness tensor
+        :returns: The linear isentropic compressibility in a given direction
+        relative to the stiffness tensor [1/Pa].
+        :rtype: float
         """
         direction = unit_normalize(direction)
-        Sijkk = np.einsum('ijkk', self.full_isentropic_compliance_tensor)
+        Sijkk = np.einsum("ijkk", self.full_isentropic_compliance_tensor)
         beta = Sijkk.dot(direction).dot(direction)
         return beta
 
     def isentropic_youngs_modulus(self, direction):
         """
-        Computes the isentropic Youngs modulus in a given direction
-        relative to the stiffness tensor
+        :returns: The isentropic Youngs modulus in a given direction
+        relative to the stiffness tensor [Pa].
+        :rtype: float
         """
         direction = unit_normalize(direction)
         Sijkl = self.full_isentropic_compliance_tensor
         S = Sijkl.dot(direction).dot(direction).dot(direction).dot(direction)
-        return 1./S
+        return 1.0 / S
 
     def isentropic_shear_modulus(self, plane_normal, shear_direction):
         """
-        Computes the isentropic shear modulus on a plane in a given
-        shear direction relative to the stiffness tensor
+        :returns: The isentropic shear modulus on a plane in a given
+        shear direction relative to the stiffness tensor [Pa].
+        :rtype: float
         """
         plane_normal = unit_normalize(plane_normal)
         shear_direction = unit_normalize(shear_direction)
 
-        assert np.abs(plane_normal.dot(shear_direction)) < np.finfo(float).eps, 'plane_normal and shear_direction must be orthogonal'
+        assert (
+            np.abs(plane_normal.dot(shear_direction)) < np.finfo(float).eps
+        ), "plane_normal and shear_direction must be orthogonal"
         Sijkl = self.full_isentropic_compliance_tensor
-        G = Sijkl.dot(shear_direction).dot(plane_normal).dot(shear_direction).dot(plane_normal)
-        return 0.25/G
-
-    def isentropic_poissons_ratio(self,
-                                  axial_direction,
-                                  lateral_direction):
-        """
-        Computes the isentropic poisson ratio given loading and response
-        directions relative to the stiffness tensor
+        G = (
+            Sijkl.dot(shear_direction)
+            .dot(plane_normal)
+            .dot(shear_direction)
+            .dot(plane_normal)
+        )
+        return 0.25 / G
+
+    def isentropic_poissons_ratio(self, axial_direction, lateral_direction):
+        """
+        :returns: The isentropic poisson ratio given loading and response
+        directions relative to the stiffness tensor [unitless].
+        :rtype: float
         """
 
         axial_direction = unit_normalize(axial_direction)
         lateral_direction = unit_normalize(lateral_direction)
-        assert np.abs(axial_direction.dot(lateral_direction)) < np.finfo(float).eps, 'axial_direction and lateral_direction must be orthogonal'
+        assert (
+            np.abs(axial_direction.dot(lateral_direction)) < np.finfo(float).eps
+        ), "axial_direction and lateral_direction must be orthogonal"
 
         Sijkl = self.full_isentropic_compliance_tensor
         x = axial_direction
         y = lateral_direction
-        nu = -(Sijkl.dot(y).dot(y).dot(x).dot(x) /
-               Sijkl.dot(x).dot(x).dot(x).dot(x) )
+        nu = -(Sijkl.dot(y).dot(y).dot(x).dot(x) / Sijkl.dot(x).dot(x).dot(x).dot(x))
         return nu
 
     def wave_velocities(self, propagation_direction):
         """
-        Computes the compressional wave velocity, and two
-        shear wave velocities in a given propagation direction
-
-        Returns two lists, containing the wave speeds and
-        directions of particle motion relative to the stiffness tensor
+        :returns: The compressional wave velocity, and two
+        shear wave velocities in a given propagation direction [m/s].
+        :rtype: list, containing the wave speeds and directions
+            of particle motion relative to the stiffness tensor
         """
         propagation_direction = unit_normalize(propagation_direction)
 
         Tik = self.christoffel_tensor(propagation_direction)
 
         eigenvalues, eigenvectors = np.linalg.eig(Tik)
 
         idx = eigenvalues.argsort()[::-1]
         eigenvalues = np.real(eigenvalues[idx])
-        eigenvectors = eigenvectors[:,idx]
-        velocities = np.sqrt(eigenvalues/self.density)
+        eigenvectors = eigenvectors[:, idx]
+        velocities = np.sqrt(eigenvalues / self.density)
 
         return velocities, eigenvectors
 
-def voigt_array_from_cijs(cijs, index_lists):
-    """
-    Takes a list of cijs and a list of list of tuples corresponding to
-    the positions of each cij in the Voigt form matrix.
-    Note that the indices run from 0--5, not 1--6.
-    """
-    C = np.zeros([6, 6])
-    for i, index_list in enumerate(index_lists):
-        for indices in index_list:
-            C[indices] = cijs[i]
-            C[indices[::-1]] = cijs[i]
-    return C
 
 class IsotropicMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C12, C44] (i.e. lambda and mu, the Lame parameters)
     """
-    def __init__(self, rho, cijs):
 
+    def __init__(self, rho, cijs):
         assert len(cijs) == 2
         cijs = list(cijs)
-        cijs.insert(0, cijs[0] + 2.*cijs[1]) # C11 = C12 + 2C44
-        index_lists = [[(0, 0), (1, 1), (2, 2)], # C11
-                       [(0, 1), (0, 2), (1, 2)], # C12
-                       [(3, 3), (4, 4), (5, 5)]] # C44
+        cijs.insert(0, cijs[0] + 2.0 * cijs[1])  # C11 = C12 + 2C44
+        index_lists = [
+            [(0, 0), (1, 1), (2, 2)],  # C11
+            [(0, 1), (0, 2), (1, 2)],  # C12
+            [(3, 3), (4, 4), (5, 5)],
+        ]  # C44
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
+
 
 class CubicMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C11, C12, C44]
     """
-    def __init__(self, rho, cijs):
 
+    def __init__(self, rho, cijs):
         assert len(cijs) == 3
-        index_lists = [[(0, 0), (1, 1), (2, 2)], # C11
-                       [(0, 1), (0, 2), (1, 2)], # C12
-                       [(3, 3), (4, 4), (5, 5)]] # C44
+        index_lists = [
+            [(0, 0), (1, 1), (2, 2)],  # C11
+            [(0, 1), (0, 2), (1, 2)],  # C12
+            [(3, 3), (4, 4), (5, 5)],
+        ]  # C44
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
+
 
 class HexagonalMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C11, C12, C13, C33, C44]
     """
+
     def __init__(self, rho, cijs):
         assert len(cijs) == 5
         cijs = list(cijs)
-        cijs.append((cijs[0] - cijs[1])/2.) # C66 = (C11-C12)/2.
+        cijs.append((cijs[0] - cijs[1]) / 2.0)  # C66 = (C11-C12)/2.
 
-        index_lists = [[(0, 0), (1, 1)], # C11
-                       [(0, 1)], # C12
-                       [(0, 2), (1, 2)], # C13
-                       [(2, 2)], # C33
-                       [(3, 3), (4, 4)], # C44
-                       [(5, 5)]] # C66
+        index_lists = [
+            [(0, 0), (1, 1)],  # C11
+            [(0, 1)],  # C12
+            [(0, 2), (1, 2)],  # C13
+            [(2, 2)],  # C33
+            [(3, 3), (4, 4)],  # C44
+            [(5, 5)],
+        ]  # C66
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
+
 
 class TetragonalMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C11, C12, C13, C33, C44, C66] or
     [C11, C12, C13, C16, C33, C44, C66]
     """
+
     def __init__(self, rho, cijs):
         if len(cijs) == 6:
             # Tetragonal I / Laue class 4/mmm
-            index_lists = [[(0, 0), (1, 1)], # C11
-                           [(0, 1)], # C12
-                           [(0, 2), (1, 2)], # C13
-                           [(2, 2)], # C33
-                           [(3, 3), (4, 4)], # C44
-                           [(5, 5)]] # C66
+            index_lists = [
+                [(0, 0), (1, 1)],  # C11
+                [(0, 1)],  # C12
+                [(0, 2), (1, 2)],  # C13
+                [(2, 2)],  # C33
+                [(3, 3), (4, 4)],  # C44
+                [(5, 5)],
+            ]  # C66
         elif len(cijs) == 7:
             # Tetragonal II / Laue class 4/m
             cijs = list(cijs)
-            cijs.insert(4, -cijs[3]) # C26 = -C16
-            index_lists = [[(0, 0), (1, 1)], # C11
-                           [(0, 1)], # C12
-                           [(0, 2), (1, 2)], # C13
-                           [(0, 5)], # C16
-                           [(1, 5)], # C26
-                           [(2, 2)], # C33
-                           [(3, 3), (4, 4)], # C44
-                           [(5, 5)]] # C66
+            cijs.insert(4, -cijs[3])  # C26 = -C16
+            index_lists = [
+                [(0, 0), (1, 1)],  # C11
+                [(0, 1)],  # C12
+                [(0, 2), (1, 2)],  # C13
+                [(0, 5)],  # C16
+                [(1, 5)],  # C26
+                [(2, 2)],  # C33
+                [(3, 3), (4, 4)],  # C44
+                [(5, 5)],
+            ]  # C66
         else:
-            raise Exception('Tetragonal materials should have '
-                            'either 6 or 7 independent Cijs')
+            raise Exception(
+                "Tetragonal materials should have " "either 6 or 7 independent Cijs"
+            )
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
 
 
 class RhombohedralMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C11, C12, C13, C14, C33, C44, C66] or
     [C11, C12, C13, C14, C15, C33, C44, C66]
     """
+
     def __init__(self, rho, cijs):
         cijs = list(cijs)
         if len(cijs) == 7:
             # Rhombohedral I / Laue class \bar{3}m
-            cijs.insert(4, -cijs[3]) # C24 = -C14
-            index_lists = [[(0, 0), (1, 1)], # C11
-                           [(0, 1)], # C12
-                           [(0, 2), (1, 2)], # C13
-                           [(0, 3), (4, 5)], # C14
-                           [(1, 3)], # C24
-                           [(2, 2)], # C33
-                           [(3, 3), (4, 4)], # C44
-                           [(5, 5)]] # C66
+            cijs.insert(4, -cijs[3])  # C24 = -C14
+            index_lists = [
+                [(0, 0), (1, 1)],  # C11
+                [(0, 1)],  # C12
+                [(0, 2), (1, 2)],  # C13
+                [(0, 3), (4, 5)],  # C14
+                [(1, 3)],  # C24
+                [(2, 2)],  # C33
+                [(3, 3), (4, 4)],  # C44
+                [(5, 5)],
+            ]  # C66
 
         elif len(cijs) == 8:
             # Rhombohedral II / Laue class \bar{3}
-            cijs.insert(4, -cijs[3]) # C24 = -C14
-            cijs.insert(6, -cijs[5]) # C25 = -C15
-            index_lists = [[(0, 0), (1, 1)], # C11
-                           [(0, 1)], # C12
-                           [(0, 2), (1, 2)], # C13
-                           [(0, 3), (4, 5)], # C14
-                           [(1, 3)], # C24
-                           [(0, 4)], # C15
-                           [(1, 4), (3, 5)], # C25
-                           [(2, 2)], # C33
-                           [(3, 3), (4, 4)], # C44
-                           [(5, 5)]] # C66
+            cijs.insert(4, -cijs[3])  # C24 = -C14
+            cijs.insert(6, -cijs[5])  # C25 = -C15
+            index_lists = [
+                [(0, 0), (1, 1)],  # C11
+                [(0, 1)],  # C12
+                [(0, 2), (1, 2)],  # C13
+                [(0, 3), (4, 5)],  # C14
+                [(1, 3)],  # C24
+                [(0, 4)],  # C15
+                [(1, 4), (3, 5)],  # C25
+                [(2, 2)],  # C33
+                [(3, 3), (4, 4)],  # C44
+                [(5, 5)],
+            ]  # C66
 
         else:
-            raise Exception('Rhombohedral materials should have '
-                            'either 7 or 8 independent Cijs')
+            raise Exception(
+                "Rhombohedral materials should have " "either 7 or 8 independent Cijs"
+            )
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
+
 
 class OrthorhombicMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C11, C12, C13, C22, C23, C33, C44, C55, C66]
     """
-    def __init__(self, rho, cijs):
 
+    def __init__(self, rho, cijs):
         assert len(cijs) == 9
-        index_lists = [[(0, 0)], # C11
-                       [(0, 1)], # C12
-                       [(0, 2)], # C13
-                       [(1, 1)], # C22
-                       [(1, 2)], # C23
-                       [(2, 2)], # C33
-                       [(3, 3)], # C44
-                       [(4, 4)], # C55
-                       [(5, 5)]] # C66
+        index_lists = [
+            [(0, 0)],  # C11
+            [(0, 1)],  # C12
+            [(0, 2)],  # C13
+            [(1, 1)],  # C22
+            [(1, 2)],  # C23
+            [(2, 2)],  # C33
+            [(3, 3)],  # C44
+            [(4, 4)],  # C55
+            [(5, 5)],
+        ]  # C66
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
 
 
 class MonoclinicMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [C11, C12, C13, C15, C22, C23, C25, C33, C35, C44, C46, C55, C66]
     """
-    def __init__(self, rho, cijs):
 
+    def __init__(self, rho, cijs):
         assert len(cijs) == 13
-        index_lists = [[(0, 0)], # C11
-                       [(0, 1)], # C12
-                       [(0, 2)], # C13
-                       [(0, 4)], # C15
-                       [(1, 1)], # C22
-                       [(1, 2)], # C23
-                       [(1, 4)], # C25
-                       [(2, 2)], # C33
-                       [(2, 4)], # C35
-                       [(3, 3)], # C44
-                       [(3, 5)], # C46
-                       [(4, 4)], # C55
-                       [(5, 5)]] # C66
+        index_lists = [
+            [(0, 0)],  # C11
+            [(0, 1)],  # C12
+            [(0, 2)],  # C13
+            [(0, 4)],  # C15
+            [(1, 1)],  # C22
+            [(1, 2)],  # C23
+            [(1, 4)],  # C25
+            [(2, 2)],  # C33
+            [(2, 4)],  # C35
+            [(3, 3)],  # C44
+            [(3, 5)],  # C46
+            [(4, 4)],  # C55
+            [(5, 5)],
+        ]  # C66
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
+
 
 class TriclinicMaterial(AnisotropicMaterial):
     """
     A class derived from the AnisotropicMaterial base class
     Initialization takes two input parameters; rho and
     [Cij, where 1<=i<=6 and i<=j<=6]
     """
-    def __init__(self, rho, cijs):
 
+    def __init__(self, rho, cijs):
         assert len(cijs) == 21
-        index_lists=[[(i, j)] for i in range(6) for j in range(i, 6)]
+        index_lists = [[(i, j)] for i in range(6) for j in range(i, 6)]
 
         AnisotropicMaterial.__init__(
-            self, rho, voigt_array_from_cijs(cijs, index_lists))
+            self, rho, voigt_array_from_cijs(cijs, index_lists)
+        )
```

### Comparing `burnman-1.1.0/burnman/classes/averaging_schemes.py` & `burnman-1.2.0/burnman/classes/averaging_schemes.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,8 +1,9 @@
-# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
+# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit
+# for the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 from __future__ import absolute_import
 import numpy as np
 import warnings
 
@@ -21,584 +22,621 @@
     """
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli :math:`K` for a composite. This defines the interface
         for this method, and is not implemented in the base class.
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli of each phase in the composite. :math:`[Pa]`
+        :param volumes: List of the volume of each phase in the composite
+            :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli : List of bulk moduli of each phase in the composite
+            :math:`[Pa]`.
+        :type bulk_moduli: list of floats
+        :param shear_moduli : List of shear moduli of each phase in the composite
+            :math:`[Pa]`.
+        :type shear_moduli: list of floats
 
-        Returns
-        -------
-
-        K : float
-            The average bulk modulus :math:`K`. :math:`[Pa]`
+        :returns: The average bulk modulus :math:`K`. :math:`[Pa]`
+        :rtype: float
         """
         raise NotImplementedError("")
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the shear moduli :math:`G` for a composite.  This defines the interface
         for this method, and is not implemented in the base class.
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli of each phase in the composite. :math:`[Pa]`
-
-        Returns
-        -------
+        :param volumes: List of the volume of each phase in the composite
+            :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli of each phase in the composite
+            :math:`[Pa]`.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli of each phase in the composite
+            :math:`[Pa]`.
+        :type shear_moduli: list of floats
 
-        G : float
-            The average shear modulus :math:`G`. :math:`[Pa]`
+        :returns: The average shear modulus :math:`G`. :math:`[Pa]`
+        :rtype: float
         """
         raise NotImplementedError("")
 
     def average_density(self, volumes, densities):
         """
         Average the densities of a composite, given a list of volume
         fractions and densitites. This is implemented in the base class,
         as how to calculate it is not dependent on the geometry of the rock.
         The formula for density is given by
 
         .. math::
             \\rho = \\frac{\\Sigma_i \\rho_i V_i }{\\Sigma_i V_i}
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        densities : list of floats
-            List of densities of each phase in the composite. :math:`[kg/m^3]`
-
-        Returns
-        -------
-        rho : float
-           Density :math:`\\rho`. :math:`[kg/m^3]`
+        :param volumes: List of the volume of each phase in the composite
+            :math:`[m^3]`.
+        :type volumes: list of floats
+        :param densities: List of densities of each phase in the composite
+            :math:`[kg/m^3]`.
+        :type densities: list of floats
+
+        :returns: Density :math:`\\rho` :math:`[kg/m^3]`.
+        :rtype: float
         """
         total_mass = np.sum(np.array(densities) * np.array(volumes))
         total_vol = np.sum(np.array(volumes))  # should sum to one
         density = total_mass / total_vol
         return density
 
     def average_thermal_expansivity(self, volumes, alphas):
         """
-        thermal expansion coefficient of the mineral :math:`\\alpha`. :math:`[1/K]`
+        Averages the thermal expansion coefficient of the mineral :math:`\\alpha`
+        :math:`[1/K]`.
+
+        :param volumes: List of volume fractions of each phase
+            in the composite (should sum to 1.0).
+        :type volumes: list of floats
+        :param alphas: List of thermal expansivities :math:`\\alpha`
+            of each phase in the composite. :math:`[1/K]`
+        :type alphas: list of floats
+
+        :returns: Thermal expansivity of the composite :math:`\\alpha`. :math:`[1/K]`
+        :rtype: float
         """
         total_vol = np.sum(np.array(volumes))
         return np.sum(np.array(alphas) * np.array(volumes)) / total_vol
 
     def average_heat_capacity_v(self, fractions, c_v):
         # TODO: double-check that the formula we use is appropriate here.
         """
         Averages the heat capacities at constant volume :math:`C_V` by molar fractions
         as in eqn. (16) in :cite:`Ita1992`.
 
-        Parameters
-        ----------
-
-        fractions : list of floats
-            List of molar fractions of each phase in the composite (should sum to 1.0).
-        c_v : list of floats
-            List of heat capacities at constant volume :math:`C_V` of each phase in the composite. :math:`[J/K/mol]`
-
-        Returns
-        -------
-
-        c_v : float
-          heat capacity at constant volume of the composite :math:`C_V`. :math:`[J/K/mol]`
+        :param fractions: List of molar fractions of each phase
+            in the composite (should sum to 1.0).
+        :type fractions: list of floats
+        :param c_v: List of heat capacities at constant volume :math:`C_V`
+            of each phase in the composite. :math:`[J/K/mol]`
+        :type c_v: list of floats
+
+        :returns: Heat capacity at constant volume of the composite :math:`C_V`
+            :math:`[J/K/mol]`.
+        :rtype: float
         """
         return np.sum(np.array(fractions) * np.array(c_v))
 
     def average_heat_capacity_p(self, fractions, c_p):
         # TODO: double-check that the formula we use is correct.
         """
-        Averages the heat capacities at constant pressure :math:`C_P` by molar fractions.
+        Averages the heat capacities at constant pressure :math:`C_P`
+        by molar fractions.
 
-        Parameters
-        ----------
-        fractions : list of floats
-            List of molar fractions of each phase in the composite (should sum to 1.0).
-        c_p : list of floats
-            List of heat capacities at constant pressure :math:`C_P` of each phase in the composite. :math:`[J/K/mol]`
-
-        Returns
-        -------
-        c_p : float
-          heat capacity at constant pressure :math:`C_P` of the composite. :math:`[J/K/mol]`
+        :param fractions: List of molar fractions of each phase in the composite
+            (should sum to 1.0).
+        :type fractions: list of floats
+        :param c_p: List of heat capacities at constant pressure :math:`C_P` of each
+            phase in the composite :math:`[J/K/mol]`.
+        :type c_p: list of floats
+
+        :returns: Heat capacity at constant pressure :math:`C_P` of the composite
+            :math:`[J/K/mol]`.
+        :rtype: float
         """
         return np.sum(np.array(fractions) * np.array(c_p))
 
 
 class VoigtReussHill(AveragingScheme):
 
     """
     Class for computing the Voigt-Reuss-Hill average for elastic properties.
-    This derives from :class:`burnman.averaging_schemes.averaging_scheme`, and implements
-    the :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and
-    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.
+    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,
+    and implements the
+    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
+    and
+    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`
+    functions.
     """
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
-        Average the bulk moduli of a composite with the Voigt-Reuss-Hill average, given by:
+        Average the bulk moduli of a composite with the Voigt-Reuss-Hill average,
+        given by:
 
         .. math::
             K_{VRH} = \\frac{K_V + K_R}{2}
 
         This is simply a shorthand for an arithmetic average of the bounds given
-        by :class:`burnman.averaging_schemes.voigt` and :class:`burnman.averaging_schemes.reuss`.
-
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
-
-        Returns
-        -------
+        by :class:`burnman.averaging_schemes.voigt`
+        and :class:`burnman.averaging_schemes.reuss`.
 
-        K : float
-            The Voigt-Reuss-Hill average bulk modulus :math:`K_{VRH}`. :math:`[Pa]`
+        :param volumes: List of the volume of each phase
+            in the composite :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K`
+            of each phase in the composite :math:`[Pa]`.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite :math:`[Pa]`.
+            Not used in this average.
+        :type shear_moduli: list of floats
+
+        :returns: The Voigt-Reuss-Hill average bulk modulus :math:`K_{VRH}`
+            :math:`[Pa]`.
+        :rtype: float
         """
         return voigt_reuss_hill_function(volumes, bulk_moduli)
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
-        Average the shear moduli :math:`G` of a composite with the Voigt-Reuss-Hill average, given by:
+        Average the shear moduli :math:`G` of a composite with the
+        Voigt-Reuss-Hill average, given by:
 
         .. math::
             G_{VRH} = \\frac{G_V + G_R}{2}
 
         This is simply a shorthand for an arithmetic average of the bounds given
-        by :class:`burnman.averaging_schemes.voigt` and :class:`burnman.averaging_schemes.reuss`.
+        by :class:`burnman.averaging_schemes.voigt`
+        and :class:`burnman.averaging_schemes.reuss`.
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite
-            Not used in this average. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite :math:`[Pa]`
-
-        Returns
-        -------
+        .. math::
+            G_V = \\Sigma_i V_i G_i
 
-        G : float
-            The Voigt-Reuss-Hill average shear modulus :math:`G_{VRH}`. :math:`[Pa]`
+        :param volumes: List of the volume of each phase
+            in the composite :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K`
+            of each phase in the composite :math:`[Pa]`.
+            Not used in this average.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite :math:`[Pa]`.
+        :type shear_moduli: list of floats
+
+        :returns: The Voigt-Reuss-Hill average shear modulus :math:`G_{VRH}`
+            :math:`[Pa]`.
+        :rtype: float
         """
         return voigt_reuss_hill_function(volumes, shear_moduli)
 
 
 class Voigt(AveragingScheme):
 
     """
     Class for computing the Voigt (iso-strain) bound for elastic properties.
-    This derives from :class:`burnman.averaging_schemes.averaging_scheme`, and implements
-    the :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and
+    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,
+    and implements the
+    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and
     :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.
     """
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli of a composite :math:`K` with the Voigt (iso-strain)
         bound, given by:
 
         .. math::
             K_V = \\Sigma_i V_i K_i
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
+        :param volumes: List of the volume of each phase
+            in the composite :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K`
+            of each phase in the composite :math:`[Pa]`.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite :math:`[Pa]`.
+            Not used in this average.
+        :type shear_moduli: list of floats
 
-        Returns
-        -------
-
-        K : float
-            The Voigt average bulk modulus :math:`K_V`. :math:`[Pa]`
+        :returns: The Voigt average bulk modulus :math:`K_R` :math:`[Pa]`.
+        :rtype: float
         """
         return voigt_average_function(volumes, bulk_moduli)
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the shear moduli of a composite with the Voigt (iso-strain)
         bound, given by:
 
         .. math::
             G_V = \\Sigma_i V_i G_i
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
-
-        Returns
-        -------
+        :param volumes: List of the volume of each phase
+            in the composite :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K`
+            of each phase in the composite :math:`[Pa]`.
+            Not used in this average.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite :math:`[Pa]`.
+        :type shear_moduli: list of floats
 
-        G : float
-            The Voigt average shear modulus :math:`G_V`. :math:`[Pa]`
+        :returns: The Voigt average shear modulus :math:`G_V` :math:`[Pa]`.
+        :rtype: float
         """
         return voigt_average_function(volumes, shear_moduli)
 
 
 class Reuss(AveragingScheme):
 
     """
     Class for computing the Reuss (iso-stress) bound for elastic properties.
-    This derives from :class:`burnman.averaging_schemes.averaging_scheme`, and implements
-    the :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and
+    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,
+    and implements the
+    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli` and
     :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.
     """
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli of a composite with the Reuss (iso-stress)
         bound, given by:
 
         .. math::
             K_R = \\left(\\Sigma_i \\frac{V_i}{K_i} \\right)^{-1}
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
+        :param volumes: List of the volume of each phase
+            in the composite :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K`
+            of each phase in the composite :math:`[Pa]`.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite :math:`[Pa]`.
+            Not used in this average.
+        :type shear_moduli: list of floats
 
-        Returns
-        -------
-
-        K : float
-            The Reuss average bulk modulus :math:`K_R`. :math:`[Pa]`
+        :returns: The Reuss average bulk modulus :math:`K_R` :math:`[Pa]`.
+        :rtype: float
         """
         return reuss_average_function(volumes, bulk_moduli)
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the shear moduli of a composite with the Reuss (iso-stress)
         bound, given by:
 
         .. math::
             G_R = \\left( \\Sigma_i \\frac{V_i}{G_i} \\right)^{-1}
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
-
-        Returns
-        -------
+        :param volumes: List of the volume of each phase
+            in the composite :math:`[m^3]`.
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K`
+            of each phase in the composite :math:`[Pa]`.
+            Not used in this average.
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite :math:`[Pa]`.
+        :type shear_moduli: list of floats
 
-        G : float
-            The Reuss average shear modulus :math:`G_R`. :math:`[Pa]`
+        :returns: The Reuss average shear modulus :math:`G_R` :math:`[Pa]`.
+        :rtype: float
         """
         return reuss_average_function(volumes, shear_moduli)
 
 
 class HashinShtrikmanUpper(AveragingScheme):
 
     """
     Class for computing the upper Hashin-Shtrikman bound for elastic properties.
-    This derives from :class:`burnman.averaging_schemes.averaging_scheme`, and implements
-    the :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
-    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.
-    Implements formulas from :cite:`Watt1976`.  The Hashin-Shtrikman bounds
+    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,
+    and implements the
+    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
+    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`
+    functions. Implements formulas from :cite:`Watt1976`.
+    The Hashin-Shtrikman bounds
     are tighter than the Voigt and Reuss bounds because they make the
     additional assumption that the orientation of the phases are statistically
     isotropic.  In some cases this may be a good assumption, and in others it
     may not be.
     """
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli of a composite with the upper Hashin-Shtrikman bound.
-        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce here.
-
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
+        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce
+        here.
 
-        Returns
-        -------
-
-        K : float
-            The upper Hashin-Shtrikman average bulk modulus :math:`K`. :math:`[Pa]`
+        :param volumes: List of the volumes of each phase
+            in the composite. :math:`[m^3]`
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K` of each phase
+            in the composite. :math:`[Pa]`
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite. :math:`[Pa]`
+        :type shear_moduli: list of floats
+
+        :returns: The upper Hashin-Shtrikman average bulk modulus :math:`K`.
+            :math:`[Pa]`
+        :rtype: float
         """
 
         K_n = max(bulk_moduli)
         G_n = max(shear_moduli)
 
         vol_frac = volumes / sum(volumes)
 
-        alpha_n = -3. / (3. * K_n + 4. * G_n)
+        alpha_n = -3.0 / (3.0 * K_n + 4.0 * G_n)
         A_n = 0
         for i in range(len(vol_frac)):
             if bulk_moduli[i] != K_n:
-                A_n += vol_frac[i] / (1. / (bulk_moduli[i] - K_n) - alpha_n)
+                A_n += vol_frac[i] / (1.0 / (bulk_moduli[i] - K_n) - alpha_n)
 
-        K_upper = K_n + A_n / (1. + alpha_n * A_n)
+        K_upper = K_n + A_n / (1.0 + alpha_n * A_n)
         return K_upper
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the shear moduli of a composite with the upper Hashin-Shtrikman bound.
-        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce here.
-
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
+        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce
+        here.
 
-        Returns
-        -------
-
-        G : float
-            The upper Hashin-Shtrikman average shear modulus :math:`G`. :math:`[Pa]`
+        :param volumes: List of the volumes of each phase
+            in the composite. :math:`[m^3]`
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K` of each phase
+            in the composite. :math:`[Pa]`
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite. :math:`[Pa]`
+        :type shear_moduli: list of floats
+
+        :returns: The upper Hashin-Shtrikman average shear modulus :math:`G`.
+            :math:`[Pa]`
+        :rtype: float
         """
 
         K_n = max(bulk_moduli)
         G_n = max(shear_moduli)
 
         vol_frac = volumes / sum(volumes)
 
-        beta_n = -3. * (K_n + 2. * G_n) / (5. * G_n * (3. * K_n + 4. * G_n))
+        beta_n = -3.0 * (K_n + 2.0 * G_n) / (5.0 * G_n * (3.0 * K_n + 4.0 * G_n))
         B_n = 0
         for i in range(len(vol_frac)):
             if shear_moduli[i] != G_n:
-                B_n += vol_frac[i] / (
-                    1. / (2. * (shear_moduli[i] - G_n)) - beta_n)
+                B_n += vol_frac[i] / (1.0 / (2.0 * (shear_moduli[i] - G_n)) - beta_n)
 
-        G_upper = G_n + (0.5) * B_n / (1. + beta_n * B_n)
+        G_upper = G_n + (0.5) * B_n / (1.0 + beta_n * B_n)
         return G_upper
 
 
 class HashinShtrikmanLower(AveragingScheme):
 
     """
     Class for computing the lower Hashin-Shtrikman bound for elastic properties.
-    This derives from :class:`burnman.averaging_schemes.averaging_scheme`, and implements
-    the :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
-    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.
+    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,
+    and implements the
+    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
+    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`
+    functions.
     Implements Formulas from :cite:`Watt1976`.  The Hashin-Shtrikman bounds
     are tighter than the Voigt and Reuss bounds because they make the
     additional assumption that the orientation of the phases are statistically
     isotropic.  In some cases this may be a good assumption, and in others it
     may not be.
     """
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli of a composite with the lower Hashin-Shtrikman bound.
-        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce here.
-
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volume of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
-
-        Returns
-        -------
+        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce
+        here.
 
-        K : float
-            The lower Hashin-Shtrikman average bulk modulus :math:`K`. :math:`[Pa]`
+        :param volumes: List of the volumes of each phase
+            in the composite. :math:`[m^3]`
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K` of each phase
+            in the composite. :math:`[Pa]`
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite. :math:`[Pa]`
+        :type shear_moduli: list of floats
+
+        :returns: The lower Hashin-Shtrikman average bulk modulus :math:`K`.
+            :math:`[Pa]`
+        :rtype: float
         """
 
         K_1 = min(bulk_moduli)
         G_1 = min(shear_moduli)
 
         vol_frac = volumes / sum(volumes)
 
-        alpha_1 = -3. / (3. * K_1 + 4. * G_1)
+        alpha_1 = -3.0 / (3.0 * K_1 + 4.0 * G_1)
         A_1 = 0
         for i in range(len(vol_frac)):
             if bulk_moduli[i] != K_1:
-                A_1 += vol_frac[i] / (1. / (bulk_moduli[i] - K_1) - alpha_1)
+                A_1 += vol_frac[i] / (1.0 / (bulk_moduli[i] - K_1) - alpha_1)
 
-        K_lower = K_1 + A_1 / (1. + alpha_1 * A_1)
+        K_lower = K_1 + A_1 / (1.0 + alpha_1 * A_1)
         return K_lower
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the shear moduli of a composite with the lower Hashin-Shtrikman bound.
-        Implements Formulas from :cite:`Watt1976`, which are too lengthy to reproduce here.
+        Implements Formulas from :cite:`Watt1976`,
+        which are too lengthy to reproduce here.
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of volumes of each phase in the composite. :math:`[m^3]`.
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`.
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
-
-        Returns
-        -------
-
-        G : float
-            The lower Hashin-Shtrikman average shear modulus :math:`G`. :math:`[Pa]`
+        :param volumes: List of the volumes of each phase
+            in the composite. :math:`[m^3]`
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K` of each phase
+            in the composite. :math:`[Pa]`
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite. :math:`[Pa]`
+        :type shear_moduli: list of floats
+
+        :returns: The lower Hashin-Shtrikman average shear modulus :math:`G`.
+            :math:`[Pa]`
+        :rtype: float
         """
 
         K_1 = min(bulk_moduli)
         G_1 = min(shear_moduli)
 
         vol_frac = volumes / sum(volumes)
 
-        beta_1 = -3. * (K_1 + 2. * G_1) / (5. * G_1 * (3. * K_1 + 4. * G_1))
+        beta_1 = -3.0 * (K_1 + 2.0 * G_1) / (5.0 * G_1 * (3.0 * K_1 + 4.0 * G_1))
         B_1 = 0
         for i in range(len(vol_frac)):
             if shear_moduli[i] != G_1:
-                B_1 += vol_frac[i] / (
-                    1. / (2. * (shear_moduli[i] - G_1)) - beta_1)
+                B_1 += vol_frac[i] / (1.0 / (2.0 * (shear_moduli[i] - G_1)) - beta_1)
 
-        G_lower = G_1 + (0.5) * B_1 / (1. + beta_1 * B_1)
+        G_lower = G_1 + (0.5) * B_1 / (1.0 + beta_1 * B_1)
         return G_lower
 
 
 class HashinShtrikmanAverage(AveragingScheme):
 
     """
-    Class for computing arithmetic mean of the Hashin-Shtrikman bounds on elastic properties.
-    This derives from :class:`burnman.averaging_schemes.averaging_scheme`, and implements
-    the :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
-    and :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli` functions.
+    Class for computing arithmetic mean of the Hashin-Shtrikman bounds on
+    elastic properties.
+    This derives from :class:`burnman.averaging_schemes.averaging_scheme`,
+    and implements the
+    :func:`burnman.averaging_schemes.averaging_scheme.average_bulk_moduli`
+    and
+    :func:`burnman.averaging_schemes.averaging_scheme.average_shear_moduli`
+    functions.
     """
 
     def __init__(self):
         self.upper = HashinShtrikmanUpper()
         self.lower = HashinShtrikmanLower()
 
     def average_bulk_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli of a composite with the arithmetic mean of the upper
         and lower Hashin-Shtrikman bounds.
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volumes of each phase in the composite. :math:`[m^3]`
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
-
-        Returns
-        -------
-
-        K : float
-            The arithmetic mean of the Hashin-Shtrikman bounds on bulk modulus :math:`K`. :math:`[Pa]`
-        """
-        return (self.upper.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)
-                + self.lower.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)) / 2.0
+        :param volumes: List of the volumes of each phase
+            in the composite. :math:`[m^3]`
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K` of each phase
+            in the composite. :math:`[Pa]`
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite. Not used in this average. :math:`[Pa]`
+        :type shear_moduli: list of floats
+
+        :returns: The arithmetic mean of the Hashin-Shtrikman bounds on bulk modulus
+            :math:`K` :math:`[Pa]`.
+        :rtype: float
+        """
+        return (
+            self.upper.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)
+            + self.lower.average_bulk_moduli(volumes, bulk_moduli, shear_moduli)
+        ) / 2.0
 
     def average_shear_moduli(self, volumes, bulk_moduli, shear_moduli):
         """
         Average the bulk moduli of a composite with the arithmetic mean of the upper
         and lower Hashin-Shtrikman bounds.
 
-        Parameters
-        ----------
-        volumes : list of floats
-            List of the volumes of each phase in the composite. [m^3].
-        bulk_moduli : list of floats
-            List of bulk moduli :math:`K` of each phase in the composite.
-            Not used in this average. :math:`[Pa]`
-        shear_moduli : list of floats
-            List of shear moduli :math:`G` of each phase in the composite. :math:`[Pa]`
-
-        Returns
-        -------
-
-        G : float
-            The arithmetic mean of the Hashin-Shtrikman bounds on shear modulus :math:`G`. :math:`[Pa]`
-        """
-        return (self.upper.average_shear_moduli(volumes, bulk_moduli, shear_moduli)
-                + self.lower.average_shear_moduli(volumes, bulk_moduli, shear_moduli)) / 2.0
+        :param volumes: List of the volumes of each phase
+            in the composite. [m^3].
+        :type volumes: list of floats
+        :param bulk_moduli: List of bulk moduli :math:`K` of each phase
+            in the composite. Not used in this average. :math:`[Pa]`
+        :type bulk_moduli: list of floats
+        :param shear_moduli: List of shear moduli :math:`G` of each phase
+            in the composite. :math:`[Pa]`
+        :type shear_moduli: list of floats
+
+        :returns: The arithmetic mean of the Hashin-Shtrikman bounds on shear modulus
+            :math:`G` :math:`[Pa]`.
+        :rtype: float
+        """
+        return (
+            self.upper.average_shear_moduli(volumes, bulk_moduli, shear_moduli)
+            + self.lower.average_shear_moduli(volumes, bulk_moduli, shear_moduli)
+        ) / 2.0
 
 
 def voigt_average_function(phase_volume, X):
     """
-    Do Voigt (iso-strain) average.  Rather like
+    Calculates the Voigt (iso-strain) average.  Rather like
     resistors in series.  Called by voigt and
-    voigt_reuss_hill classes, takes a list of
-    volumes and moduli, returns a modulus.
+    voigt_reuss_hill classes.
+
+    :param phase_volume: Phase volumes.
+    :type phase_volume: List of floats
+
+    :param X: Phase moduli.
+    :type X: List of floats
+
+    :returns: Voigt-averaged modulus
+    :rtype: float
     """
     vol_frac = phase_volume / np.sum(phase_volume)
     X_voigt = sum(f * x for f, x in zip(vol_frac, X))
     return X_voigt
 
 
 def reuss_average_function(phase_volume, X):
     """
-    Do Reuss (iso-stress) average.  Rather like
+    Calculates the Reuss (iso-stress) average.  Rather like
     resistors in parallel.  Called by reuss and
-    voigt_reuss_hill classes, takes a list of
-    volumes and moduli, returns a modulus.
+    voigt_reuss_hill classes.
+
+
+    :param phase_volume: Phase volumes.
+    :type phase_volume: List of floats
+
+    :param X: Phase moduli.
+    :type X: List of floats
+
+    :returns: Reuss-averaged modulus
+    :rtype: float
     """
     vol_frac = phase_volume / np.sum(phase_volume)
     for f, x in zip(vol_frac, X):
         if x <= 0 and np.abs(f) > np.finfo(float).eps:
             warnings.warn("Oops, called reuss_average with Xi<=0!")
             return 0.0
-    X_reuss = 1. / sum(f / x for f, x in zip(vol_frac, X))
+    X_reuss = 1.0 / sum(f / x for f, x in zip(vol_frac, X))
     return X_reuss
 
 
 def voigt_reuss_hill_function(phase_volume, X):
     """
-    Do Voigt-Reuss-Hill average (arithmetic mean
+    Calculates the Voigt-Reuss-Hill average (arithmetic mean
     of Voigt and Reuss bounds).  Called by
-    voigt_reuss_hill class, takes a list of
-    volumes and moduli, returns a modulus.
+    voigt_reuss_hill class.
+
+    :param phase_volume: Phase volumes.
+    :type phase_volume: List of floats
+
+    :param X: Phase moduli.
+    :type X: List of floats
+
+    :returns: Voigt-Reuss-Hill-averaged modulus
+    :rtype: float
     """
-    X_vrh = (voigt_average_function(phase_volume, X)
-             + reuss_average_function(phase_volume, X)) / 2.0
+    X_vrh = (
+        voigt_average_function(phase_volume, X)
+        + reuss_average_function(phase_volume, X)
+    ) / 2.0
     return X_vrh
```

### Comparing `burnman-1.1.0/burnman/classes/calibrant.py` & `burnman-1.2.0/burnman/classes/calibrant.py`

 * *Files 13% similar despite different names*

```diff
@@ -8,164 +8,156 @@
 from ..utils.math import bracket
 
 
 class Calibrant(object):
     """
     The base class for a pressure calibrant material.
 
-    Initialization of a Calibrant object requires the following parameters:
+    :param calibrant_function: A function that takes either pressure,
+        temperature and a params object as arguments, returning the volume,
+        or takes volume, temperature and a params object, returning the pressure.
+    :type calibrant_function: function
+
+    :param calibrant_function_return_type: The return type of the calibrant function.
+        Valid values are 'pressure' or 'volume'.
+    :type calibrant_function_return_type: str
 
-    calibrant_function : Function
-        A function that takes either pressure, temperature and a params
-        object as arguments, returning the volume, or takes volume, temperature
-        and a params object, returning the pressure.
-
-    calibrant_function_return_type : 'pressure' or 'volume'
-        The return type of the calibrant function.
-
-    params : dictionary
-        A dictionary containing the parameters required by the
+    :param params: A dictionary containing the parameters required by the
         calibrant function.
+    :type params: dictionary
     """
-    def __init__(self, calibrant_function,
-                 calibrant_function_return_type,
-                 params):
 
-        if calibrant_function_return_type == 'pressure':
+    def __init__(self, calibrant_function, calibrant_function_return_type, params):
+        if calibrant_function_return_type == "pressure":
             self.pressure_function = calibrant_function
             self.volume_function = self._volume_using_pressure_function
-        elif calibrant_function_return_type == 'volume':
+        elif calibrant_function_return_type == "volume":
             self.volume_function = calibrant_function
             self.pressure_function = self._pressure_using_volume_function
         else:
-            raise Exception('calibrant function return type must either '
-                            'be pressure or volume')
+            raise Exception(
+                "calibrant function return type must either " "be pressure or volume"
+            )
 
         self.calibrant_function = calibrant_function
 
         self.params = params
 
     def _volume_using_pressure_function(self, pressure, temperature, params):
         """
         Helper function to compute volume iteratively by Brent's method using
         a function of the form pressure(volume, temperature).
         """
+
         def func(x):
-            return (self.pressure_function(x, temperature, params) - pressure)
+            return self.pressure_function(x, temperature, params) - pressure
+
         try:
-            sol = bracket(func, params['V_0'], 1.e-2 * params['V_0'])
+            sol = bracket(func, params["V_0"], 1.0e-2 * params["V_0"])
         except ValueError:
-            raise ValueError('Cannot find a volume, perhaps you are outside '
-                             'of the range of validity for the equation '
-                             'of state?')
+            raise ValueError(
+                "Cannot find a volume, perhaps you are outside "
+                "of the range of validity for the equation "
+                "of state?"
+            )
         return opt.brentq(func, sol[0], sol[1])
 
     def _pressure_using_volume_function(self, volume, temperature, params):
         """
         Helper function to compute pressure iteratively by Brent's method using
         a function of the form volume(pressure, temperature).
         """
+
         def func(x):
             (self.volume_function(x, temperature, params) - volume)
+
         try:
-            sol = bracket(func, 0., 300.e9)
+            sol = bracket(func, 0.0, 300.0e9)
         except ValueError:
-            raise ValueError('Cannot find a pressure, perhaps you are outside '
-                             'of the range of validity for the equation '
-                             'of state?')
+            raise ValueError(
+                "Cannot find a pressure, perhaps you are outside "
+                "of the range of validity for the equation "
+                "of state?"
+            )
         return opt.brentq(func, sol[0], sol[1])
 
     def pressure(self, volume, temperature, VT_covariance=None):
         """
         Returns the pressure of the calibrant as a function of
         volume, temperature and (optionally) a volume-temperature
         variance-covariance matrix.
 
-        Parameters
-        ----------
-        volume : float
-            The volume of the calibrant [m^3/mol]
-        temperature : float
-            The temperature of the calibrant [K]
-        VT_covariance : 2x2 numpy array [optional]
-            The volume-temperature
-            variance-covariance matrix
-
-        Returns
-        -------
-        pressure : float
-            The pressure of the calibrant [Pa]
+        :param volume: The volume of the calibrant [m^3/mol].
+        :type volume: float
 
-        PVT_covariance : 3x3 numpy array (if PT_covariance is provided)
-            The pressure-volume-temperature variance-covariance matrix.
+        :param temperature: The temperature of the calibrant [K].
+        :type temperature: float
+
+        :param VT_covariance: The volume-temperature
+            variance-covariance matrix [optional].
+        :type VT_covariance: 2x2 numpy.array
+
+        :returns: The pressure of the calibrant [Pa] and the
+            pressure-volume-temperature variance-covariance matrix
+            if PT_covariance is provided.
+        :rtype: float, tuple of a float and a numpy.array (3x3)
         """
         if VT_covariance is None:
             return self.pressure_function(volume, temperature, self.params)
         else:
             # Here we take the centered differences
             # We could alternatively use thermodynamic properties
             # but these have not yet been implemented.
-            dV = volume / 1.e7
+            dV = volume / 1.0e7
             dT = 0.01
-            PdV0 = self.pressure_function(volume - dV/2., temperature,
-                                          self.params)
-            PdV1 = self.pressure_function(volume + dV/2., temperature,
-                                          self.params)
-            PdT0 = self.pressure_function(volume, temperature - dT/2.,
-                                          self.params)
-            PdT1 = self.pressure_function(volume, temperature + dT/2.,
-                                          self.params)
-            pressure = (PdV0 + PdV1 + PdT0 + PdT1)/4.
+            PdV0 = self.pressure_function(volume - dV / 2.0, temperature, self.params)
+            PdV1 = self.pressure_function(volume + dV / 2.0, temperature, self.params)
+            PdT0 = self.pressure_function(volume, temperature - dT / 2.0, self.params)
+            PdT1 = self.pressure_function(volume, temperature + dT / 2.0, self.params)
+            pressure = (PdV0 + PdV1 + PdT0 + PdT1) / 4.0
 
             gradPVT = np.zeros((2, 3))
             gradPVT[:, 1:] = np.eye(2)
-            gradPVT[:, 0] = [(PdV1 - PdV0)/dV, (PdT1 - PdT0)/dT]
+            gradPVT[:, 0] = [(PdV1 - PdV0) / dV, (PdT1 - PdT0) / dT]
             PVT_covariance = gradPVT.T.dot(VT_covariance).dot(gradPVT)
             return pressure, PVT_covariance
 
     def volume(self, pressure, temperature, PT_covariance=None):
         """
         Returns the volume of the calibrant as a function of
         pressure, temperature and (optionally) a pressure-temperature
         variance-covariance matrix.
 
-        Parameters
-        ----------
-        pressure : float
-            The pressure of the calibrant [Pa]
-        temperature : float
-            The temperature of the calibrant [K]
-        PT_covariance : 2x2 numpy array [optional]
-            The pressure-temperature
-            variance-covariance matrix
-
-        Returns
-        -------
-        volume : float
-            The volume of the calibrant [m^3/mol]
+        :param pressure: The pressure of the calibrant [Pa].
+        :type pressure: float
+
+        :param temperature: The temperature of the calibrant [K].
+        :type temperature: float
 
-        VPT_covariance : 3x3 numpy array (if VT_covariance is provided)
-            The volume-pressure-temperature variance-covariance matrix.
+        :param PT_covariance: The pressure-temperature
+            variance-covariance matrix [optional].
+        :type PT_covariance: 2x2 numpy.array
+
+        :returns: The volume of the calibrant [m^3/mol] and
+            the volume-pressure-temperature variance-covariance matrix
+            if VT_covariance is provided.
+        :rtype: float, tuple of a float and a numpy.array (3x3)
         """
         if PT_covariance is None:
             return self.volume_function(pressure, temperature, self.params)
         else:
             # Here we take the centered differences
             # We could alternatively use thermodynamic properties
             # but these have not yet been implemented.
-            dP = 100.
+            dP = 100.0
             dT = 0.01
-            VdP0 = self.volume_function(pressure - dP/2., temperature,
-                                        self.params)
-            VdP1 = self.volume_function(pressure + dP/2., temperature,
-                                        self.params)
-            VdT0 = self.volume_function(pressure, temperature - dT/2.,
-                                        self.params)
-            VdT1 = self.volume_function(pressure, temperature + dT/2.,
-                                        self.params)
-            volume = (VdP0 + VdP1 + VdT0 + VdT1)/4.
+            VdP0 = self.volume_function(pressure - dP / 2.0, temperature, self.params)
+            VdP1 = self.volume_function(pressure + dP / 2.0, temperature, self.params)
+            VdT0 = self.volume_function(pressure, temperature - dT / 2.0, self.params)
+            VdT1 = self.volume_function(pressure, temperature + dT / 2.0, self.params)
+            volume = (VdP0 + VdP1 + VdT0 + VdT1) / 4.0
 
             gradVPT = np.zeros((2, 3))
             gradVPT[:, 1:] = np.eye(2)
-            gradVPT[:, 0] = [(VdP1 - VdP0)/dP, (VdT1 - VdT0)/dT]
+            gradVPT[:, 0] = [(VdP1 - VdP0) / dP, (VdT1 - VdT0) / dT]
             VPT_covariance = gradVPT.T.dot(PT_covariance).dot(gradVPT)
             return volume, VPT_covariance
```

### Comparing `burnman-1.1.0/burnman/classes/combinedmineral.py` & `burnman-1.2.0/burnman/classes/combinedmineral.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 
 from __future__ import absolute_import
 
 import numpy as np
 
 from .mineral import Mineral, material_property
 from .solution import Solution
+from .solutionmodel import MechanicalSolution
 
 
 class CombinedMineral(Mineral):
 
     """
     This is the base class for endmembers constructed from a
     linear combination of other minerals.
@@ -28,85 +29,91 @@
 
     For example, a crude approximation to a bridgmanite model might be
     bdg = CombinedMineral([per, stv], [1.0, 1.0], [-15.e3, 0., 0.])
 
     This class is available as :class:`burnman.CombinedMineral`.
     """
 
-    def __init__(self, mineral_list, molar_amounts,
-                 free_energy_adjustment=[],
-                 name='User-created endmember'):
-        self.mixture = Solution(solution_type='mechanical',
-                                endmembers=[[m, ''] for m in mineral_list],
-                                molar_fractions=molar_amounts)
+    def __init__(
+        self,
+        mineral_list,
+        molar_amounts,
+        free_energy_adjustment=[],
+        name="User-created endmember",
+    ):
+        model = MechanicalSolution(endmembers=[[m, ""] for m in mineral_list])
+        self.mixture = Solution(solution_model=model, molar_fractions=molar_amounts)
 
         # Remove elements from the chemical formula if they have
         # negligible concentrations
         for key, value in list(self.mixture.formula.items()):
-            if np.abs(value) < 1.e-10:
+            if np.abs(value) < 1.0e-10:
                 self.mixture.formula.pop(key)
 
-        self.params = {'name': name,
-                       'formula': self.mixture.formula,
-                       'equation_of_state': 'combined',
-                       'molar_mass': self.mixture.molar_mass,
-                       'n': sum(self.mixture.formula.values())}
+        self.params = {
+            "name": name,
+            "formula": self.mixture.formula,
+            "equation_of_state": "combined",
+            "molar_mass": self.mixture.molar_mass,
+            "n": sum(self.mixture.formula.values()),
+        }
 
         if free_energy_adjustment != []:
-            assert(len(free_energy_adjustment) == 3)
+            assert len(free_energy_adjustment) == 3
             dE, dS, dV = free_energy_adjustment
-            self.property_modifiers = [['linear', {'delta_E': dE,
-                                                   'delta_S': dS,
-                                                   'delta_V': dV}]]
+            self.property_modifiers = [
+                ["linear", {"delta_E": dE, "delta_S": dS, "delta_V": dV}]
+            ]
 
         Mineral.__init__(self)
 
     def set_state(self, pressure, temperature):
         self.mixture.set_state(pressure, temperature)
         Mineral.set_state(self, pressure, temperature)
 
     @material_property
     def molar_gibbs(self):
         """
         Returns Gibbs free energy of the mineral [J]
         Aliased with self.gibbs
         """
-        return self.mixture.molar_gibbs + self._property_modifiers['G']
+        return self.mixture.molar_gibbs + self._property_modifiers["G"]
 
     @material_property
     def _molar_volume_unmodified(self):
         return self.mixture.molar_volume
 
     @material_property
     def molar_volume(self):
         """
         Returns molar volume of the mineral [m^3/mol]
         Aliased with self.V
         """
-        return self.mixture.molar_volume + self._property_modifiers['dGdP']
+        return self.mixture.molar_volume + self._property_modifiers["dGdP"]
 
     @material_property
     def molar_entropy(self):
         """
         Returns entropy of the mineral [J]
         Aliased with self.S
         """
-        return self.mixture.molar_entropy - self._property_modifiers['dGdT']
+        return self.mixture.molar_entropy - self._property_modifiers["dGdT"]
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
         Returns isothermal bulk modulus of the mineral [Pa]
         Aliased with self.K_T
         """
         K_T_orig = self.mixture.isothermal_bulk_modulus
 
-        return (self.molar_volume
-                / ((self._molar_volume_unmodified / K_T_orig)
-                   - self._property_modifiers['d2GdP2']))
+        return self.molar_volume / (
+            (self._molar_volume_unmodified / K_T_orig)
+            - self._property_modifiers["d2GdP2"]
+        )
 
     @material_property
     def shear_modulus(self):
         """
         Returns shear modulus of the mineral [Pa]
         Aliased with self.G
         """
@@ -114,26 +121,29 @@
 
     @material_property
     def thermal_expansivity(self):
         """
         Returns thermal expansion coefficient (alpha) of the mineral [1/K]
         Aliased with self.alpha
         """
-        return ((self.mixture.thermal_expansivity
-                 * self._molar_volume_unmodified)
-                + self._property_modifiers['d2GdPdT']) / self.molar_volume
+        return (
+            (self.mixture.thermal_expansivity * self._molar_volume_unmodified)
+            + self._property_modifiers["d2GdPdT"]
+        ) / self.molar_volume
 
     @material_property
     def molar_heat_capacity_p(self):
         """
         Returns heat capacity at constant pressure of the mineral [J/K/mol]
         Aliased with self.C_p
         """
-        return (self.mixture.molar_heat_capacity_p
-                - self.temperature * self._property_modifiers['d2GdT2'])
+        return (
+            self.mixture.molar_heat_capacity_p
+            - self.temperature * self._property_modifiers["d2GdT2"]
+        )
 
     """
     Properties from mineral parameters,
     Legendre transformations
     or Maxwell relations
     """
 
@@ -161,17 +171,19 @@
 
     @material_property
     def molar_internal_energy(self):
         """
         Returns molar internal energy of the mineral [J/mol]
         Aliased with self.energy
         """
-        return (self.molar_gibbs
-                - self.pressure * self.molar_volume
-                + self.temperature * self.molar_entropy)
+        return (
+            self.molar_gibbs
+            - self.pressure * self.molar_volume
+            + self.temperature * self.molar_entropy
+        )
 
     @material_property
     def molar_helmholtz(self):
         """
         Returns molar Helmholtz free energy of the mineral [J/mol]
         Aliased with self.helmholtz
         """
@@ -187,47 +199,51 @@
 
     @material_property
     def adiabatic_bulk_modulus(self):
         """
         Returns adiabatic bulk modulus of the mineral [Pa]
         Aliased with self.K_S
         """
-        if self.temperature < 1.e-10:
+        if self.temperature < 1.0e-10:
             return self.isothermal_bulk_modulus
         else:
-            return (self.isothermal_bulk_modulus
-                    * self.molar_heat_capacity_p
-                    / self.molar_heat_capacity_v)
+            return (
+                self.isothermal_bulk_modulus
+                * self.molar_heat_capacity_p
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     def isothermal_compressibility(self):
         """
         Returns isothermal compressibility of the mineral
         (or inverse isothermal bulk modulus) [1/Pa]
         Aliased with self.K_T
         """
-        return 1. / self.isothermal_bulk_modulus
+        return 1.0 / self.isothermal_bulk_modulus
 
     @material_property
     def adiabatic_compressibility(self):
         """
         Returns adiabatic compressibility of the mineral
         (or inverse adiabatic bulk modulus) [1/Pa]
         Aliased with self.K_S
         """
-        return 1. / self.adiabatic_bulk_modulus
+        return 1.0 / self.adiabatic_bulk_modulus
 
     @material_property
     def p_wave_velocity(self):
         """
         Returns P wave speed of the mineral [m/s]
         Aliased with self.v_p
         """
-        return np.sqrt((self.adiabatic_bulk_modulus + 4. / 3. *
-                        self.shear_modulus) / self.density)
+        return np.sqrt(
+            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)
+            / self.density
+        )
 
     @material_property
     def bulk_sound_velocity(self):
         """
         Returns bulk sound speed of the mineral [m/s]
         Aliased with self.v_phi
         """
@@ -243,23 +259,31 @@
 
     @material_property
     def grueneisen_parameter(self):
         """
         Returns grueneisen parameter of the mineral [unitless]
         Aliased with self.gr
         """
-        if self.temperature < 1.e-12:
-            return 0.
+        if self.temperature < 1.0e-12:
+            return 0.0
         else:
-            return self.thermal_expansivity * self.isothermal_bulk_modulus \
-                * self.molar_volume / self.molar_heat_capacity_v
+            return (
+                self.thermal_expansivity
+                * self.isothermal_bulk_modulus
+                * self.molar_volume
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     def molar_heat_capacity_v(self):
         """
         Returns molar heat capacity at constant volume of the mineral [J/K/mol]
         Aliased with self.C_v
         """
-        return (self.molar_heat_capacity_p
-                - self.molar_volume * self.temperature
-                * self.thermal_expansivity * self.thermal_expansivity
-                * self.isothermal_bulk_modulus)
+        return (
+            self.molar_heat_capacity_p
+            - self.molar_volume
+            * self.temperature
+            * self.thermal_expansivity
+            * self.thermal_expansivity
+            * self.isothermal_bulk_modulus
+        )
```

### Comparing `burnman-1.1.0/burnman/classes/composite.py` & `burnman-1.2.0/burnman/classes/composite.py`

 * *Files 4% similar despite different names*

```diff
@@ -12,32 +12,32 @@
 from .material import Material, material_property, cached_property
 from .mineral import Mineral
 from .solution import Solution
 from . import averaging_schemes
 
 from ..utils.reductions import independent_row_indices
 from ..utils.chemistry import sum_formulae, sort_element_list_to_IUPAC_order
+from ..utils.chemistry import reaction_matrix_as_strings
 
 
 def check_pairs(phases, fractions):
     if len(fractions) < 1:
-        raise Exception('ERROR: we need at least one phase')
+        raise Exception("ERROR: we need at least one phase")
 
     if len(phases) != len(fractions):
-        raise Exception(
-            'ERROR: different array lengths for phases and fractions')
+        raise Exception("ERROR: different array lengths for phases and fractions")
 
     total = sum(fractions)
     if abs(total - 1.0) > 1e-10:
-        raise Exception(
-            'ERROR: list of molar fractions does not add up to one')
+        raise Exception("ERROR: list of molar fractions does not add up to one")
     for p in phases:
         if not isinstance(p, Mineral):
             raise Exception(
-                'ERROR: object of type ''%s'' is not of type Mineral' % (type(p)))
+                "ERROR: object of type " "%s" " is not of type Mineral" % (type(p))
+            )
 
 
 # static composite of minerals/composites
 class Composite(Material):
 
     """
     Base class for a composite material.
@@ -48,104 +48,111 @@
     as either 'molar' or 'mass' during instantiation,
     and modified (or initialised) after this point by
     using set_fractions.
 
     This class is available as ``burnman.Composite``.
     """
 
-    def __init__(self, phases, fractions=None, fraction_type='molar', name='Unnamed composite'):
+    def __init__(
+        self, phases, fractions=None, fraction_type="molar", name="Unnamed composite"
+    ):
         """
         Create a composite using a list of phases and their fractions (adding to 1.0).
 
-        Parameters
-        ----------
-        phases: list of :class:`burnman.Material`
-            list of phases.
-        fractions: list of floats
-            molar or mass fraction for each phase.
-        fraction_type: 'molar' or 'mass' (optional, 'molar' as standard)
+        :param phases: List of phases.
+        :type phases: list of :class:`burnman.Material`
+        :param fractions: molar or mass fraction for each phase.
+        :type fractions: list of floats
+        :param fraction_type: 'molar' or 'mass' (optional, 'molar' as standard)
             specify whether molar or mass fractions are specified.
+        :type fraction_type: str
         """
 
         Material.__init__(self)
 
-        assert(len(phases) > 0)
+        assert len(phases) > 0
         self.phases = phases
 
         if fractions is not None:
             self.set_fractions(fractions, fraction_type)
         else:
             self.molar_fractions = None
 
-        self.set_averaging_scheme('VoigtReussHill')
+        self.set_averaging_scheme("VoigtReussHill")
         self.name = name
-        self.equilibrium_tolerance = 1.e-3  # J/reaction
+        self.equilibrium_tolerance = 1.0e-3  # J/reaction
         self.print_precision = 4  # number of significant figures used by self.__str__
 
     def __str__(self):
-        string='Composite: {0}'.format(self.name)
+        string = "Composite: {0}".format(self.name)
         try:
-            string += '\n  P, T: {0:.{sf}g} Pa, {1:.{sf}g} K'.format(self.pressure,
-                                                                     self.temperature,
-                                                                     sf=self.print_precision)
+            string += "\n  P, T: {0:.{sf}g} Pa, {1:.{sf}g} K".format(
+                self.pressure, self.temperature, sf=self.print_precision
+            )
         except:
             pass
-        string+='\nPhase and endmember fractions:'
+        string += "\nPhase and endmember fractions:"
         for phase, fraction in zip(*self.unroll()):
-            string+='\n  {0}: {1:0.{sf}f}'.format(phase.name, fraction, sf=self.print_precision)
+            string += "\n  {0}: {1:0.{sf}f}".format(
+                phase.name, fraction, sf=self.print_precision
+            )
             if isinstance(phase, Solution):
-               for i in range(phase.n_endmembers):
-                   string+='\n    {0}: {1:0.{sf}f}'.format(phase.endmember_names[i],
-                                                           phase.molar_fractions[i],
-                                                           sf=self.print_precision)
+                for i in range(phase.n_endmembers):
+                    string += "\n    {0}: {1:0.{sf}f}".format(
+                        phase.endmember_names[i],
+                        phase.molar_fractions[i],
+                        sf=self.print_precision,
+                    )
         return string
 
-    def set_fractions(self, fractions, fraction_type='molar'):
+    def set_fractions(self, fractions, fraction_type="molar"):
         """
         Change the fractions of the phases of this Composite.
         Resets cached properties
 
-        Parameters
-        ----------
-        fractions: list or numpy array of floats
+        :param fractions: list or numpy array of floats
             molar or mass fraction for each phase.
-        fraction_type: 'molar' or 'mass'
+        :param fraction_type: 'molar' or 'mass'
             specify whether molar or mass fractions are specified.
         """
-        assert(len(self.phases) == len(fractions))
+        assert len(self.phases) == len(fractions)
 
         if isinstance(fractions, list):
             fractions = np.array(fractions)
 
         try:
             total = sum(fractions)
         except TypeError:
             raise Exception(
-                "Since v0.8, burnman.Composite takes an array of Materials, then an array of fractions")
+                "Since v0.8, burnman.Composite takes an array of Materials, "
+                "then an array of fractions"
+            )
 
         assert np.all(fractions >= -1e-12)
 
         self.reset()
 
         if abs(total - 1.0) > 1e-12:
-            warnings.warn('Warning: list of fractions does not add '
-                          f'up to one but {total:g}. Normalizing.')
+            warnings.warn(
+                "Warning: list of fractions does not add "
+                f"up to one but {total:g}. Normalizing."
+            )
             fractions /= total
 
-        if fraction_type == 'molar':
+        if fraction_type == "molar":
             molar_fractions = fractions
-        elif fraction_type == 'mass':
-            molar_fractions = self._mass_to_molar_fractions(self.phases,
-                                                            fractions)
+        elif fraction_type == "mass":
+            molar_fractions = self._mass_to_molar_fractions(self.phases, fractions)
         else:
-            raise Exception("Fraction type not recognised. "
-                            "Please use 'molar' or mass")
+            raise Exception(
+                "Fraction type not recognised. " "Please use 'molar' or mass"
+            )
 
         # Set minimum value of a molar fraction at 0.0 (rather than -1.e-12)
-        self.molar_fractions = molar_fractions.clip(0.)
+        self.molar_fractions = molar_fractions.clip(0.0)
 
     def set_method(self, method):
         """
         set the same equation of state method for all the phases in the composite
         """
         for phase in self.phases:
             phase.set_method(method)
@@ -155,16 +162,15 @@
     def set_averaging_scheme(self, averaging_scheme):
         """
         Set the averaging scheme for the moduli in the composite.
         Default is set to VoigtReussHill, when Composite is initialized.
         """
 
         if type(averaging_scheme) == str:
-            self.averaging_scheme = getattr(
-                averaging_schemes, averaging_scheme)()
+            self.averaging_scheme = getattr(averaging_schemes, averaging_scheme)()
         else:
             self.averaging_scheme = averaging_scheme
         # Clear the cache on resetting averaging scheme
         self.reset()
 
     def set_state(self, pressure, temperature):
         """
@@ -183,16 +189,15 @@
         else:
             for i, phase in enumerate(self.phases):
                 print("%s%g of" % (indent, self.molar_fractions[i]))
                 phase.debug_print(indent + "  ")
 
     def unroll(self):
         if self.molar_fractions is None:
-            raise Exception(
-                "Unroll only works if the composite has defined fractions.")
+            raise Exception("Unroll only works if the composite has defined fractions.")
         phases = []
         fractions = []
         for i, phase in enumerate(self.phases):
             p_mineral, p_fraction = phase.unroll()
             check_pairs(p_mineral, p_fraction)
             fractions.extend([f * self.molar_fractions[i] for f in p_fraction])
             phases.extend(p_mineral)
@@ -213,152 +218,188 @@
 
     @material_property
     def molar_internal_energy(self):
         """
         Returns molar internal energy of the mineral [J/mol]
         Aliased with self.energy
         """
-        U = sum(phase.molar_internal_energy * molar_fraction for (
-                phase, molar_fraction) in zip(self.phases, self.molar_fractions))
+        U = sum(
+            phase.molar_internal_energy * molar_fraction
+            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+        )
         return U
 
     @material_property
     def molar_gibbs(self):
         """
         Returns molar Gibbs free energy of the composite [J/mol]
         Aliased with self.gibbs
         """
-        G = sum(phase.molar_gibbs * molar_fraction for (phase, molar_fraction)
-                in zip(self.phases, self.molar_fractions))
+        G = sum(
+            phase.molar_gibbs * molar_fraction
+            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+        )
         return G
 
     @material_property
     def molar_helmholtz(self):
         """
         Returns molar Helmholtz free energy of the mineral [J/mol]
         Aliased with self.helmholtz
         """
-        F = sum(phase.molar_helmholtz * molar_fraction for (
-                phase, molar_fraction) in zip(self.phases, self.molar_fractions))
+        F = sum(
+            phase.molar_helmholtz * molar_fraction
+            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+        )
         return F
 
     @material_property
     def molar_volume(self):
         """
         Returns molar volume of the composite [m^3/mol]
         Aliased with self.V
         """
         volumes = np.array(
-            [phase.molar_volume * molar_fraction for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
+            [
+                phase.molar_volume * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
         return np.sum(volumes)
 
     @material_property
     def molar_mass(self):
         """
         Returns molar mass of the composite [kg/mol]
         """
-        return sum([phase.molar_mass * molar_fraction for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
+        return sum(
+            [
+                phase.molar_mass * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
 
     @material_property
     def density(self):
         """
         Compute the density of the composite based on the molar volumes and masses
         Aliased with self.rho
         """
         densities = np.array([phase.density for phase in self.phases])
         volumes = np.array(
-            [phase.molar_volume * molar_fraction for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
+            [
+                phase.molar_volume * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
         return self.averaging_scheme.average_density(volumes, densities)
 
     @material_property
     def molar_entropy(self):
         """
         Returns enthalpy of the mineral [J]
         Aliased with self.S
         """
-        S = sum(phase.molar_entropy * molar_fraction for (
-                phase, molar_fraction) in zip(self.phases, self.molar_fractions))
+        S = sum(
+            phase.molar_entropy * molar_fraction
+            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+        )
         return S
 
     @material_property
     def molar_enthalpy(self):
         """
         Returns enthalpy of the mineral [J]
         Aliased with self.H
         """
-        H = sum(phase.molar_enthalpy * molar_fraction for (
-                phase, molar_fraction) in zip(self.phases, self.molar_fractions))
+        H = sum(
+            phase.molar_enthalpy * molar_fraction
+            for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+        )
         return H
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
         Returns isothermal bulk modulus of the composite [Pa]
         Aliased with self.K_T
         """
-        V_frac = np.array([phase.molar_volume * molar_fraction for (
-                           phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
-        K_ph = np.array(
-            [phase.isothermal_bulk_modulus for phase in self.phases])
+        V_frac = np.array(
+            [
+                phase.molar_volume * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
+        K_ph = np.array([phase.isothermal_bulk_modulus for phase in self.phases])
         G_ph = np.array([phase.shear_modulus for phase in self.phases])
 
         return self.averaging_scheme.average_bulk_moduli(V_frac, K_ph, G_ph)
 
     @material_property
     def adiabatic_bulk_modulus(self):
         """
         Returns adiabatic bulk modulus of the mineral [Pa]
         Aliased with self.K_S
         """
-        V_frac = np.array([phase.molar_volume * molar_fraction for (
-                           phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
-        K_ph = np.array(
-            [phase.adiabatic_bulk_modulus for phase in self.phases])
+        V_frac = np.array(
+            [
+                phase.molar_volume * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
+        K_ph = np.array([phase.adiabatic_bulk_modulus for phase in self.phases])
         G_ph = np.array([phase.shear_modulus for phase in self.phases])
 
         return self.averaging_scheme.average_bulk_moduli(V_frac, K_ph, G_ph)
 
     @material_property
     def isothermal_compressibility(self):
         """
-        Returns isothermal compressibility of the composite (or inverse isothermal bulk modulus) [1/Pa]
+        Returns isothermal compressibility of the composite
+        (or inverse isothermal bulk modulus) [1/Pa]
         Aliased with self.beta_T
         """
-        return 1. / self.isothermal_bulk_modulus
+        return 1.0 / self.isothermal_bulk_modulus
 
     @material_property
     def adiabatic_compressibility(self):
         """
-        Returns isothermal compressibility of the composite (or inverse isothermal bulk modulus) [1/Pa]
+        Returns isothermal compressibility of the composite
+        (or inverse isothermal bulk modulus) [1/Pa]
         Aliased with self.beta_S
         """
-        return 1. / self.adiabatic_bulk_modulus
+        return 1.0 / self.adiabatic_bulk_modulus
 
     @material_property
     def shear_modulus(self):
         """
         Returns shear modulus of the mineral [Pa]
         Aliased with self.G
         """
-        V_frac = np.array([phase.molar_volume * molar_fraction for (
-                           phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
-        K_ph = np.array(
-            [phase.adiabatic_bulk_modulus for phase in self.phases])
+        V_frac = np.array(
+            [
+                phase.molar_volume * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
+        K_ph = np.array([phase.adiabatic_bulk_modulus for phase in self.phases])
         G_ph = np.array([phase.shear_modulus for phase in self.phases])
 
         return self.averaging_scheme.average_shear_moduli(V_frac, K_ph, G_ph)
 
     @material_property
     def p_wave_velocity(self):
         """
         Returns P wave speed of the composite [m/s]
         Aliased with self.v_p
         """
-        return np.sqrt((self.adiabatic_bulk_modulus + 4. / 3. *
-                        self.shear_modulus) / self.density)
+        return np.sqrt(
+            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)
+            / self.density
+        )
 
     @material_property
     def bulk_sound_velocity(self):
         """
         Returns bulk sound speed of the composite [m/s]
         Aliased with self.v_phi
         """
@@ -374,24 +415,33 @@
 
     @material_property
     def grueneisen_parameter(self):
         """
         Returns grueneisen parameter of the composite [unitless]
         Aliased with self.gr
         """
-        return self.thermal_expansivity * self.isothermal_bulk_modulus * self.molar_volume / self.molar_heat_capacity_v
+        return (
+            self.thermal_expansivity
+            * self.isothermal_bulk_modulus
+            * self.molar_volume
+            / self.molar_heat_capacity_v
+        )
 
     @material_property
     def thermal_expansivity(self):
         """
         Returns thermal expansion coefficient of the composite [1/K]
         Aliased with self.alpha
         """
         volumes = np.array(
-            [phase.molar_volume * molar_fraction for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)])
+            [
+                phase.molar_volume * molar_fraction
+                for (phase, molar_fraction) in zip(self.phases, self.molar_fractions)
+            ]
+        )
         alphas = np.array([phase.thermal_expansivity for phase in self.phases])
         return self.averaging_scheme.average_thermal_expansivity(volumes, alphas)
 
     @material_property
     def molar_heat_capacity_v(self):
         """
         Returns molar_heat capacity at constant volume of the composite [J/K/mol]
@@ -417,15 +467,15 @@
         """
         partial_gibbs = np.empty(self.n_endmembers)
         j = 0
         for i, n_endmembers in enumerate(self.endmembers_per_phase):
             if n_endmembers == 1:
                 partial_gibbs[j] = self.phases[i].gibbs
             else:
-                partial_gibbs[j:j+n_endmembers] = self.phases[i].partial_gibbs
+                partial_gibbs[j : j + n_endmembers] = self.phases[i].partial_gibbs
             j += n_endmembers
         return partial_gibbs
 
     @material_property
     def reaction_affinities(self):
         """
         Returns the affinities corresponding to each reaction in reaction_basis
@@ -434,16 +484,15 @@
 
     @material_property
     def equilibrated(self):
         """
         Returns True if the reaction affinities are all zero
         within a given tolerance given by self.equilibrium_tolerance.
         """
-        return np.all(np.abs(self.reaction_affinities)
-                      < self.equilibrium_tolerance)
+        return np.all(np.abs(self.reaction_affinities) < self.equilibrium_tolerance)
 
     def set_components(self, components):
         """
         Sets the components and components_array attributes of the
         composite material. The components attribute is a list of dictionaries
         containing the chemical formulae of the components.
         The components_array attribute is a 2D numpy array describing the
@@ -454,103 +503,102 @@
         However, it must be possible to obtain the composition of each
         component from a linear sum of the endmember compositions of
         the composite. For example, if the composite was composed of
         MgSiO3 and Mg2SiO4, SiO2 would be a valid component, but Si would not.
         The method raises an exception if any of the chemical potentials are
         not defined by the assemblage.
 
-        Parameters
-        ----------
-        components: list of dictionaries
-            List of formulae of the components.
+        :param components: List of formulae of the components.
+        :type components: list of dictionaries
         """
         # Convert components into array form
-        b = np.array([[component[el] if el in component else 0.
-                       for component in components]
-                      for el in self.elements])
+        b = np.array(
+            [
+                [component[el] if el in component else 0.0 for component in components]
+                for el in self.elements
+            ]
+        )
 
         # Solve to find a set of endmember proportions that
         # satisfy each of the component formulae
         p = np.linalg.lstsq(self.stoichiometric_array.T, b, rcond=None)
 
         res = np.abs((self.stoichiometric_array.T.dot(p[0]) - b).T)
         res = np.sum(res, axis=1)
         # Check that all components can be described by linear sums of
         # the endmembers
-        if not np.all(res < 1.e-12):
-            bad_indices = np.argwhere(res > 1.e-12)
+        if not np.all(res < 1.0e-12):
+            bad_indices = np.argwhere(res > 1.0e-12)
 
-            raise Exception(f'Components {bad_indices} not defined by '
-                            'prescribed assemblage')
+            raise Exception(
+                f"Components {bad_indices} not defined by " "prescribed assemblage"
+            )
 
         self.components = components
         self.component_array = p[0]
 
     def chemical_potential(self, components=None):
         """
         Returns the chemical potentials of the currently defined components
         in the composite. Raises an exception if
         the assemblage is not equilibrated.
 
-        Parameters
-        ----------
-        components: list of dictionaries (optional)
-            List of formulae of the desired components. If not specified,
-            the method uses the components specified by a previous call to
-            set_components.
-
-        Returns
-        -------
-        chemical_potential: numpy array of floats
-            The chemical potentials of the desired components in the
+        :param components: List of formulae of the desired components.
+            If not specified, the method uses the components specified
+            by a previous call to set_components.
+        :type components: list of dictionaries
+
+        :returns: The chemical potentials of the desired components in the
             equilibrium composite.
+        :rtype: numpy.array of floats
         """
         if not self.equilibrated:
-            raise Exception('This composite is not equilibrated, so '
-                            'it cannot have a defined chemical potential.')
+            raise Exception(
+                "This composite is not equilibrated, so "
+                "it cannot have a defined chemical potential."
+            )
 
         if components is not None:
             self.set_components(components)
 
         # Return the chemical potential of each component
         return np.dot(self.component_array.T, self.endmember_partial_gibbs)
 
     def _mass_to_molar_fractions(self, phases, mass_fractions):
         """
         Converts a set of mass fractions for phases into a set of molar fractions.
 
-        Parameters
-        ----------
-        phases : list of :class:`burnman.Material`
-        The list of phases for which fractions should be converted.
-
-        mass_fractions : numpy array of floats
-        An array of mass fractions of the input phases.
-
-        Returns
-        -------
-        molar_fractions : numpy array of floats
-        An array of molar fractions corresponding to the input molar fractions
+        :param phases: The list of phases for which fractions should be converted.
+        :type phases: list of :class:`burnman.Material`
+
+        :param mass_fractions: An array of mass fractions of the input phases.
+        :type mass_fractions: numpy.array of floats
+
+        :returns: An array of molar fractions corresponding to the
+            input molar fractions.
+        :rtype: numpy.array of floats
         """
         molar_masses = np.array([phase.molar_mass for phase in phases])
         moles = mass_fractions / molar_masses
         return moles / sum(moles)
 
     @cached_property
     def stoichiometric_matrix(self):
         """
         An sympy Matrix where each element M[i,j] corresponds
         to the number of atoms of element[j] in endmember[i].
         """
+
         def f(i, j):
             e = self.elements[j]
             if e in self.endmember_formulae[i]:
                 return nsimplify(self.endmember_formulae[i][e])
             else:
                 return 0
+
         return Matrix(self.n_endmembers, self.n_elements, f)
 
     @cached_property
     def stoichiometric_array(self):
         """
         An array where each element arr[i,j] corresponds
         to the number of atoms of element[j] in endmember[i].
@@ -559,129 +607,118 @@
 
     @cached_property
     def reaction_basis(self):
         """
         An array where each element arr[i,j] corresponds
         to the number of moles of endmember[j] involved in reaction[i].
         """
-        reaction_basis = np.array([v[:] for v in
-                                   self.stoichiometric_matrix.T.nullspace()],
-                                  dtype=float)
+        reaction_basis = np.array(
+            [v[:] for v in self.stoichiometric_matrix.T.nullspace()], dtype=float
+        )
 
         if len(reaction_basis) == 0:
             reaction_basis = np.empty((0, self.n_endmembers))
 
         return reaction_basis
 
     @cached_property
     def reaction_basis_as_strings(self):
         """
         Returns a list of string representations of all the reactions in
         reaction_basis.
         """
-        reaction_strings = []
-        for reaction in self.reaction_basis:
-            lhs, rhs = ('', '')
-            for i, coefficient in enumerate(reaction):
-                if coefficient < -1.e-10:
-                    if len(lhs) > 0:
-                        lhs += ' + '
-                    lhs += f'{-coefficient} {self.endmember_names[i]}'
-                if coefficient > 1.e-10:
-                    if len(rhs) > 0:
-                        rhs += ' + '
-                    rhs += f'{coefficient} {self.endmember_names[i]}'
-            reaction_strings.append(f'{lhs} = {rhs}')
-
-        return reaction_strings
+        return reaction_matrix_as_strings(self.reaction_basis, self.endmember_names)
 
     @cached_property
     def n_reactions(self):
         """
         The number of reactions in reaction_basis.
         """
         return len(self.reaction_basis[:, 0])
 
     @cached_property
     def independent_element_indices(self):
         """
         A list of an independent set of element indices. If the amounts of
         these elements are known (element_amounts),
         the amounts of the other elements can be
-        inferred by -compositional_null_basis[independent_element_indices].dot(element_amounts)
+        inferred by
+        -compositional_null_basis[independent_element_indices].dot(element_amounts)
         """
         return sorted(independent_row_indices(self.stoichiometric_matrix.T))
 
     @cached_property
     def dependent_element_indices(self):
         """
         The element indices not included in the independent list.
         """
-        return [i for i in range(self.n_elements)
-                if i not in self.independent_element_indices]
+        return [
+            i
+            for i in range(self.n_elements)
+            if i not in self.independent_element_indices
+        ]
 
     @cached_property
     def reduced_stoichiometric_array(self):
         """
         The stoichiometric array including only the independent elements
         """
         return self.stoichiometric_array[:, self.independent_element_indices]
 
     @cached_property
     def compositional_null_basis(self):
         """
         An array N such that N.b = 0 for all bulk compositions that can
         be produced with a linear sum of the endmembers in the composite.
         """
-        null_basis = np.array([v[:] for v in
-                               self.stoichiometric_matrix.nullspace()],
-                              dtype=float)
+        null_basis = np.array(
+            [v[:] for v in self.stoichiometric_matrix.nullspace()], dtype=float
+        )
         if null_basis.shape[0] != 0:
             M = null_basis[:, self.dependent_element_indices]
-            assert ((M.shape[0] == M.shape[1])
-                    and (M == np.eye(M.shape[0])).all())
+            assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()
 
         return null_basis
 
     @cached_property
     def endmember_formulae(self):
         """
         A list of the formulae in the composite.
         """
         self._set_endmember_properties()
-        return self.__dict__['endmember_formulae']
+        return self.__dict__["endmember_formulae"]
 
     @cached_property
     def endmember_names(self):
         """
         A list of the endmember names contained in the composite.
         Mineral names are returned as given in Mineral.name.
         Solution endmember names are given in the format
         `Mineral.name in Solution.name`.
         """
         self._set_endmember_properties()
-        return self.__dict__['endmember_names']
+        return self.__dict__["endmember_names"]
 
     @cached_property
     def endmembers_per_phase(self):
         """
         A list of integers corresponding to the number of endmembers
         stored within each phase.
         """
         self._set_endmember_properties()
-        return self.__dict__['endmembers_per_phase']
+        return self.__dict__["endmembers_per_phase"]
 
     @cached_property
     def elements(self):
         """
         A list of the elements which could be contained in the composite,
         returned in the IUPAC element order.
         """
         self._set_endmember_properties()
-        return self.__dict__['elements']
+        return self.__dict__["elements"]
 
     @cached_property
     def n_endmembers(self):
         """
         Returns the number of endmembers in the composite.
         """
         return len(self.endmember_names)
@@ -702,33 +739,35 @@
         the properties to be stored and documented as individual
         cached_properties.
         """
         endmember_formulae = []
         endmember_names = []
         endmembers_per_phase = []
         for ph_idx, ph in enumerate(self.phases):
-
             if isinstance(ph, Solution):
                 endmember_formulae.extend(ph.endmember_formulae)
-                endmember_names.extend([name+' in '+ph.name
-                                        for name in ph.endmember_names])
+                endmember_names.extend(
+                    [name + " in " + ph.name for name in ph.endmember_names]
+                )
                 endmembers_per_phase.append(ph.n_endmembers)
 
             elif isinstance(ph, Mineral):
                 endmember_formulae.append(ph.formula)
                 endmember_names.append(ph.name)
                 endmembers_per_phase.append(1)
 
             else:
-                raise Exception('Unsupported Material type, can only read'
-                                'burnman.Mineral or burnman.Solution')
+                raise Exception(
+                    "Unsupported Material type, can only read"
+                    "burnman.Mineral or burnman.Solution"
+                )
 
         # Populate the stoichiometric matrix
         keys = []
         for f in endmember_formulae:
             keys.extend(f.keys())
 
         # Save to dict so that we only need to do this once
-        self.__dict__['endmember_formulae'] = endmember_formulae
-        self.__dict__['endmember_names'] = endmember_names
-        self.__dict__['endmembers_per_phase'] = endmembers_per_phase
-        self.__dict__['elements'] = sort_element_list_to_IUPAC_order(set(keys))
+        self.__dict__["endmember_formulae"] = endmember_formulae
+        self.__dict__["endmember_names"] = endmember_names
+        self.__dict__["endmembers_per_phase"] = endmembers_per_phase
+        self.__dict__["elements"] = sort_element_list_to_IUPAC_order(set(keys))
```

### Comparing `burnman-1.1.0/burnman/classes/composition.py` & `burnman-1.2.0/burnman/classes/composition.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from __future__ import print_function
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
 # the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2018 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 from copy import deepcopy
 import numpy as np
@@ -13,132 +14,139 @@
 
 
 def file_to_composition_list(fname, unit_type, normalize):
     """
     Takes an input file with a specific format and returns a list of
     compositions (and associated comments) contained in that file.
 
-    Parameters
-    ----------
-    fname : string
-        Path to ascii file containing composition data.
+    :param fname: Path to ascii file containing composition data.
         Lines beginning with a hash are not read.
         The first read-line of the datafile contains a list of tab or
         space-separated components (e.g. FeO or SiO2), followed by the
         word Comment.
         Following lines are lists of floats with the amounts of each component.
         After the component amounts, the user can write anything they like
         in the Comment section.
-    unit_type : 'mass', 'weight' or 'molar'
+    :type fname: str
+    :param unit_type: 'mass', 'weight' or 'molar'
         Specify whether the compositions in the file are given as
         mass (weight) or molar amounts.
-    normalize : boolean
-        If False, absolute numbers of moles/grams of component are stored,
+    :type unit_type: str
+    :param normalize: If False, absolute numbers of moles/grams of component are stored,
         otherwise the component amounts of returned compositions will
         sum to one (until Composition.renormalize() is used).
+    :type normalize : bool
 
     """
-    lines = list(filter(None, [line.rstrip('\n').split()
-                               for line in open(fname) if line[0] != '#']))
+    lines = list(
+        filter(
+            None, [line.rstrip("\n").split() for line in open(fname) if line[0] != "#"]
+        )
+    )
     n_components = lines[0].index("Comment")
     components = lines[0][:n_components]
     comments = [line[n_components:] for line in lines[1:]]
-    compositions = np.array([map(float, ln)
-                             for ln in list(zip(*(list(zip(*lines[1:]))[:n_components])))])
-    return [Composition(OrderedCounter(dict(zip(components, c))),
-                        unit_type, normalize)
-            for c in compositions], comments
+    compositions = np.array(
+        [map(float, ln) for ln in list(zip(*(list(zip(*lines[1:]))[:n_components])))]
+    )
+    return [
+        Composition(OrderedCounter(dict(zip(components, c))), unit_type, normalize)
+        for c in compositions
+    ], comments
 
 
 class Composition(object):
     """
     Class for a composition object, which can be used
     to store, modify and renormalize compositions,
     and also convert between mass, molar
     and atomic amounts. Weight is provided as an alias
     for mass, as we assume that only Earthlings
     will use this software.
 
     This class is available as ``burnman.Composition``.
     """
 
-    def __init__(self, composition_dictionary, unit_type='mass',
-                 normalize=False):
+    def __init__(self, composition_dictionary, unit_type="mass", normalize=False):
         """
         Create a composition using a dictionary and unit type.
 
-        Parameters
-        ----------
-        composition_dictionary : dictionary
-            Dictionary of components (given as a string) and their amounts.
-        unit_type : 'mass', 'weight' or 'molar' (optional, 'mass' as default)
+        :param composition_dictionary: Dictionary of components
+            (given as a string) and their amounts.
+        :type composition_dictionary: dictionary
+        :param unit_type: 'mass', 'weight' or 'molar' (optional, 'mass' as default)
             Specify whether the input composition is given as mass or
             molar amounts.
-        normalize : boolean
-            If False, absolute numbers of kilograms/moles of component are
+        :type unit_type: str
+        :param normalize: If False, absolute numbers of kilograms/moles of component are
             stored, otherwise the component amounts of returned compositions
             will sum to one (until Composition.renormalize() is used).
+        :type normalize: bool
         """
 
         self._cached = {}
 
         n_total = float(sum(composition_dictionary.values()))
 
         # Create the input dictionary, normalize if requested
         input_dictionary = OrderedCounter(deepcopy(composition_dictionary))
         if normalize:
             for k in composition_dictionary.keys():
-                input_dictionary[k] = composition_dictionary[k]/n_total
+                input_dictionary[k] = composition_dictionary[k] / n_total
 
         # Break component formulae into atomic dictionaries
-        self.component_formulae = {c: dictionarize_formula(c)
-                                   for c in composition_dictionary.keys()}
+        self.component_formulae = {
+            c: dictionarize_formula(c) for c in composition_dictionary.keys()
+        }
 
         # Create lists of elemental compositions of components
         self.element_list = OrderedCounter()
         for component in self.component_formulae.values():
-            self.element_list += OrderedCounter({element: n_atoms
-                                                 for (element, n_atoms)
-                                                 in component.items()})
+            self.element_list += OrderedCounter(
+                {element: n_atoms for (element, n_atoms) in component.items()}
+            )
         self.element_list = list(self.element_list.keys())
 
-        if unit_type == 'mass' or unit_type == 'weight':
+        if unit_type == "mass" or unit_type == "weight":
             self.mass_composition = input_dictionary
-        elif unit_type == 'molar':
+        elif unit_type == "molar":
             self.mass_composition = self._mole_to_mass_composition(input_dictionary)
         else:
-            raise Exception('Unit type not yet implemented. '
-                            'Should be either mass, weight or molar.')
+            raise Exception(
+                "Unit type not yet implemented. "
+                "Should be either mass, weight or molar."
+            )
 
-    def renormalize(self, unit_type, normalization_component,
-                    normalization_amount):
+    def renormalize(self, unit_type, normalization_component, normalization_amount):
         """
         Change the total amount of material in the composition
         to satisfy a given normalization condition
         (mass, weight, molar, or atomic)
 
-        Parameters
-        ----------
-        unit_type : 'mass', 'weight', 'molar' or 'atomic'
+        :param unit_type: 'mass', 'weight', 'molar' or 'atomic'
             Unit type with which to normalize the composition
-        normalization_component: string
-            Component/element on which to renormalize.
+        :type unit_type: str
+        :param normalization_component: Component/element on which to renormalize.
             String must either be one of the components/elements
-            already in the composition, or have the value 'total'
-        normalization_amount: float
-            Amount of component in the renormalised composition
+            already in the composition, or have the value 'total'.
+        :type normalization_component: str
+        :param normalization_amount: Amount of component in the
+            renormalised composition.
+        :type normalization_amount: float
         """
 
-        if unit_type not in ['mass', 'weight', 'molar', 'atomic']:
-            raise Exception('unit_type not yet implemented.'
-                            'Should be either mass, weight, molar or atomic.')
+        if unit_type not in ["mass", "weight", "molar", "atomic"]:
+            raise Exception(
+                "unit_type not yet implemented."
+                "Should be either mass, weight, molar or atomic."
+            )
 
         c = self.composition(unit_type)
 
-        if normalization_component == 'total':
+        if normalization_component == "total":
             f = normalization_amount / float(sum(c.values()))
         else:
             f = normalization_amount / c[normalization_component]
 
         new_mass_composition = OrderedCounter()
         for k in self.mass_composition.keys():
             new_mass_composition[k] = self.mass_composition[k] * f
@@ -148,81 +156,80 @@
     def add_components(self, composition_dictionary, unit_type):
         """
         Add (or remove) components from the composition.
         The components are added to the current state of the
         (mass, weight or molar) composition; if the composition has
         been renormalised, then this should be taken into account.
 
-        Parameters
-        ----------
-        composition_dictionary : dictionary
-            Components to add, and their amounts, in dictionary form
-        unit_type : 'mass', 'weight' or 'molar'
-            Unit type of the components to be added
+        :param composition_dictionary: Components to add, and their amounts.
+        :type composition_dictionary: dictionary
+        :param unit_type: 'mass', 'weight' or 'molar'.
+            Unit type of the components to be added.
+        :type unit_type: str
         """
-        if unit_type == 'mass' or unit_type == 'weight':
+        if unit_type == "mass" or unit_type == "weight":
             composition = self.mass_composition
-        elif unit_type == 'molar':
+        elif unit_type == "molar":
             composition = self.molar_composition
         else:
-            raise Exception('Unit type not recognised. '
-                            'Should be either mass, weight or molar.')
+            raise Exception(
+                "Unit type not recognised. " "Should be either mass, weight or molar."
+            )
 
         composition += OrderedCounter(composition_dictionary)
 
         # Reinitialize composition object
         self.__init__(composition, unit_type)
 
     def change_component_set(self, new_component_list):
         """
         Change the set of basis components without
         changing the bulk composition.
 
         Will raise an exception if the new component set is
         invalid for the given composition.
 
-        Parameters
-        ----------
-        new_component_list : list of strings
-            New set of basis components.
-        """
-        composition = np.array([self.atomic_composition[element]
-                                for element in self.element_list])
-        component_matrix = np.zeros((len(new_component_list),
-                                     len(self.element_list)))
+        :param new_component_list: New set of basis components.
+        :type new_component_list: list of strings
+        """
+        composition = np.array(
+            [self.atomic_composition[element] for element in self.element_list]
+        )
+        component_matrix = np.zeros((len(new_component_list), len(self.element_list)))
 
         for i, component in enumerate(new_component_list):
             formula = dictionarize_formula(component)
             for element, n_atoms in formula.items():
                 component_matrix[i][self.element_list.index(element)] = n_atoms
 
         sol = nnls(component_matrix.T, composition)
-        if sol[1] < 1.e-12:
+        if sol[1] < 1.0e-12:
             component_amounts = sol[0]
         else:
-            raise Exception('Failed to change component set. '
-                            'Could not find a non-negative '
-                            'least squares solution. '
-                            'Can the bulk composition be described '
-                            'with this set of components?')
+            raise Exception(
+                "Failed to change component set. "
+                "Could not find a non-negative "
+                "least squares solution. "
+                "Can the bulk composition be described "
+                "with this set of components?"
+            )
 
-        composition = OrderedCounter(dict(zip(new_component_list,
-                                              component_amounts)))
+        composition = OrderedCounter(dict(zip(new_component_list, component_amounts)))
 
         # Reinitialize the object
-        self.__init__(composition, 'molar')
+        self.__init__(composition, "molar")
 
     def _mole_to_mass_composition(self, molar_comp):
         """
         Hidden function to returns the mass composition as a counter [kg]
         """
         cf = self.component_formulae
-        mass_composition = OrderedCounter({c: molar_comp[c]
-                                             * formula_mass(cf[c])
-                                             for c in molar_comp.keys()})
+        mass_composition = OrderedCounter(
+            {c: molar_comp[c] * formula_mass(cf[c]) for c in molar_comp.keys()}
+        )
 
         return mass_composition
 
     @property
     def weight_composition(self):
         """
         An alias for mass composition [kg].
@@ -233,88 +240,98 @@
     def molar_composition(self):
         """
         Returns the molar composition as a counter [moles]
         """
         mass_comp = self.mass_composition
         cf = self.component_formulae
 
-        return OrderedCounter({c: mass_comp[c] / formula_mass(cf[c])
-                               for c in mass_comp.keys()})
+        return OrderedCounter(
+            {c: mass_comp[c] / formula_mass(cf[c]) for c in mass_comp.keys()}
+        )
 
     @property
     def atomic_composition(self):
         """
         Returns the atomic composition as a counter [moles]
         """
 
         return self._moles_to_atoms(self.molar_composition)
 
     def composition(self, unit_type):
         """
         Helper function to return the composition in the
         desired type.
 
-        Parameters
-        ----------
-        unit_type : string
-            One of 'mass', 'weight', 'molar' and 'atomic'.
+        :param unit_type: One of 'mass', 'weight', 'molar' and 'atomic'.
+        :type unit_type: str
+
+        :returns: Mass (weight), molar or atomic composition.
+        :rtype: OrderedCounter
         """
-        return getattr(self, f'{unit_type}_composition')
+        return getattr(self, f"{unit_type}_composition")
 
     def _moles_to_atoms(self, molar_comp_dictionary):
         """
         Hidden function that converts a molar component
         dictionary into an atomic (elemental) dictionary
         """
-        component_matrix = np.zeros((len(self.component_formulae),
-                                     len(self.element_list)))
+        component_matrix = np.zeros(
+            (len(self.component_formulae), len(self.element_list))
+        )
         cf = self.component_formulae
         molar_composition_vector = np.zeros(len(cf))
         for i, (component, formula) in enumerate(cf.items()):
             molar_composition_vector[i] = molar_comp_dictionary[component]
 
             for element, n_atoms in formula.items():
                 component_matrix[i][self.element_list.index(element)] = n_atoms
 
         atom_compositions = np.dot(molar_composition_vector, component_matrix)
         return OrderedCounter(dict(zip(self.element_list, atom_compositions)))
 
-    def print(self, unit_type, significant_figures=1,
-              normalization_component='total', normalization_amount=None):
+    def print(
+        self,
+        unit_type,
+        significant_figures=1,
+        normalization_component="total",
+        normalization_amount=None,
+    ):
         """
         Pretty-print function for the composition
         This does not renormalize the Composition object itself,
         only the printed values.
 
-        Parameters
-        ----------
-        unit_type : 'mass', 'weight', 'molar' or 'atomic'
-            Unit type in which to print the composition
-        significant_figures : integer
-            Number of significant figures for each amount
-        normalization_component: string
-            Component/element on which to renormalize.
+        :param unit_type: 'mass', 'weight', 'molar' or 'atomic'
+            Unit type in which to print the composition.
+        :type unit_type: str
+        :param significant_figures: Number of significant figures
+            for each amount.
+        :type significant_figures: int
+        :param normalization_component: Component/element on which to renormalize.
             String must either be one of the components/elements
             already in composite, or have the value 'total'.
             (default = 'total')
-        normalization_amount: float
-            Amount of component in the renormalised composition.
-            If not explicitly set, no renormalization will be applied.
-            (default = None)
+        :type normalization_component: str
+        :param normalization_amount: Amount of component in the
+            renormalised composition. If not explicitly set,
+            no renormalization will be applied.
+        :type normalization_amount: float
         """
 
-        if unit_type not in ['mass', 'weight', 'molar', 'atomic']:
-            raise Exception('unit_type not yet implemented.'
-                            'Should be either mass, weight, molar or atomic.')
+        if unit_type not in ["mass", "weight", "molar", "atomic"]:
+            raise Exception(
+                "unit_type not yet implemented."
+                "Should be either mass, weight, molar or atomic."
+            )
 
         c = self.composition(unit_type)
-        print(f'{unit_type.capitalize()} composition')
+        print(f"{unit_type.capitalize()} composition")
 
         if normalization_amount is None:
             f = 1
-        elif normalization_component == 'total':
+        elif normalization_component == "total":
             f = normalization_amount / float(sum(c.values()))
         else:
             f = normalization_amount / c[normalization_component]
 
-        for (key, value) in sorted(c.items()):
-            print(f'{key}: {value*f:0.{significant_figures}f}')
+        for key, value in sorted(c.items()):
+            print(f"{key}: {value*f:0.{significant_figures}f}")
```

### Comparing `burnman-1.1.0/burnman/classes/elasticsolution.py` & `burnman-1.2.0/burnman/classes/elasticsolution.py`

 * *Files 13% similar despite different names*

```diff
@@ -11,21 +11,15 @@
 import scipy.optimize as opt
 
 from burnman.classes.solutionmodel import IdealSolution
 
 from ..constants import gas_constant
 from .material import material_property, cached_property
 from .mineral import Mineral
-from .elasticsolutionmodel import ElasticSolutionModel
 from .elasticsolutionmodel import ElasticMechanicalSolution
-from .elasticsolutionmodel import ElasticIdealSolution
-from .elasticsolutionmodel import ElasticSymmetricRegularSolution
-from .elasticsolutionmodel import ElasticAsymmetricRegularSolution
-from .elasticsolutionmodel import ElasticSubregularSolution
-from .elasticsolutionmodel import ElasticFunctionSolution
 from .averaging_schemes import reuss_average_function
 
 from ..utils.math import bracket
 from ..utils.reductions import independent_row_indices
 from ..utils.chemistry import sum_formulae, sort_element_list_to_IUPAC_order
 
 
@@ -47,177 +41,92 @@
     means that the interaction parameters should be in J/mol, with the T
     and V derivatives in J/K/mol and Pa/mol.
 
     The parameters are relevant to all Elastic solution models. Please
     see the documentation for individual models for details about
     other parameters.
 
-    Parameters
-    ----------
-    name : string
-        Name of the solution
-    solution_type : string
-        String determining which SolutionModel to use. One of 'mechanical',
-        'ideal', 'symmetric', 'asymmetric' or 'subregular'.
-    endmembers : list of lists
-        List of endmembers in this solution. The first item of each
-        list should be a :class:`burnman.Mineral` object. The second item
-        should be a string with the site formula of the endmember.
-    molar_fractions : numpy array (optional)
-        The molar fractions of each endmember in the solution.
+    :param name: Name of the solution.
+    :type name: string
+    :param solution_model: The ElasticSolutionModel object defining the
+        properties of the solution.
+    :type solution_model: :class:`burnman.ElasticSolutionModel`
+    :param molar_fractions: The molar fractions of each endmember in the solution.
         Can be reset using the set_composition() method.
+    :type molar_fractions: numpy.array
     """
 
-    def __init__(self,
-                 name=None,
-                 solution_type=None,
-                 endmembers=None,
-                 energy_interaction=None,
-                 pressure_interaction=None,
-                 entropy_interaction=None,
-                 energy_ternary_terms=None,
-                 pressure_ternary_terms=None,
-                 entropy_ternary_terms=None,
-                 alphas=None,
-                 excess_helmholtz_function=None,
-                 molar_fractions=None):
+    def __init__(self, name=None, solution_model=None, molar_fractions=None):
         """
         Set up matrices to speed up calculations for when P, T, X is defined.
         """
         Mineral.__init__(self)
 
         # Solution needs a method attribute to call Mineral.set_state().
         # Note that set_method() below will not change self.method
-        self.method = 'ElasticSolutionMethod'
+        self.method = "ElasticSolutionMethod"
 
         if name is not None:
             self.name = name
-        if solution_type is not None:
-            self.solution_type = solution_type
-        if endmembers is not None:
-            self.endmembers = endmembers
-        if energy_interaction is not None:
-            self.energy_interaction = energy_interaction
-        if pressure_interaction is not None:
-            self.pressure_interaction = pressure_interaction
-        if entropy_interaction is not None:
-            self.entropy_interaction = entropy_interaction
-        if energy_ternary_terms is not None:
-            self.energy_ternary_terms = energy_ternary_terms
-        if pressure_ternary_terms is not None:
-            self.pressure_ternary_terms = pressure_ternary_terms
-        if entropy_ternary_terms is not None:
-            self.entropy_ternary_terms = entropy_ternary_terms
-        if alphas is not None:
-            self.alphas = alphas
-        if endmembers is not None:
-            self.endmembers = endmembers
-        if excess_helmholtz_function is not None:
-            self.excess_helmholtz_function = excess_helmholtz_function
-
-        if hasattr(self, 'endmembers') is False:
-            raise Exception("'endmembers' attribute missing "
-                            "from solution")
-
-        # Set default solution model type
-        if hasattr(self, 'solution_type'):
-            if self.solution_type == 'mechanical':
-                self.solution_model = ElasticMechanicalSolution(
-                    self.endmembers)
-            elif self.solution_type == 'ideal':
-                self.solution_model = ElasticIdealSolution(self.endmembers)
-            else:
-                if hasattr(self, 'energy_interaction') is False:
-                    self.energy_interaction = None
-                if hasattr(self, 'pressure_interaction') is False:
-                    self.pressure_interaction = None
-                if hasattr(self, 'entropy_interaction') is False:
-                    self.entropy_interaction = None
-
-                if self.solution_type == 'symmetric':
-                    self.solution_model = ElasticSymmetricRegularSolution(
-                        self.endmembers, self.energy_interaction,
-                        self.pressure_interaction, self.entropy_interaction)
-                elif self.solution_type == 'asymmetric':
-                    if hasattr(self, 'alphas') is False:
-                        raise Exception(
-                            "'alphas' attribute missing from solution")
-                    self.solution_model = ElasticAsymmetricRegularSolution(
-                        self.endmembers, self.alphas, self.energy_interaction,
-                        self.pressure_interaction, self.entropy_interaction)
-                elif self.solution_type == 'subregular':
-                    if hasattr(self, 'energy_ternary_terms') is False:
-                        self.energy_ternary_terms = None
-                    if hasattr(self, 'pressure_ternary_terms') is False:
-                        self.pressure_ternary_terms = None
-                    if hasattr(self, 'entropy_ternary_terms') is False:
-                        self.entropy_ternary_terms = None
-
-                    self.solution_model = ElasticSubregularSolution(
-                        self.endmembers,
-                        self.energy_interaction,  self.pressure_interaction,
-                        self.entropy_interaction,
-                        self.energy_ternary_terms, self.pressure_ternary_terms,
-                        self.entropy_ternary_terms)
-                elif self.solution_type == 'function':
-                    self.solution_model = ElasticFunctionSolution(self.endmembers,
-                                                                  self.excess_helmholtz_function)
-                else:
-                    raise Exception("Solution model type "
-                                    + self.solution_type + "not recognised.")
+        if solution_model is not None:
+            self.solution_model = solution_model
+
+        if isinstance(solution_model, ElasticMechanicalSolution):
+            self.solution_type = "mechanical"
         else:
-            self.solution_model = ElasticSolutionModel()
+            self.solution_type = "chemical"
 
         # Starting guess and delta for pressure iteration
-        self.min_V0 = min([mbr[0].params['V_0']
-                           for mbr in self.endmembers])
-        self.dV = 0.01*self.min_V0
+        self.min_V0 = min(
+            [mbr[0].params["V_0"] for mbr in self.solution_model.endmembers]
+        )
+        self.dV = 0.01 * self.min_V0
 
         # Equation of state
         for i in range(self.n_endmembers):
-            self.endmembers[i][0].set_method(
-                self.endmembers[i][0].params['equation_of_state'])
+            self.solution_model.endmembers[i][0].set_method(
+                self.solution_model.endmembers[i][0].params["equation_of_state"]
+            )
 
         # Molar fractions
         if molar_fractions is not None:
             self.set_composition(molar_fractions)
 
-    def get_endmembers(self):
-        return self.endmembers
+    @cached_property
+    def endmembers(self):
+        return self.solution_model.endmembers
 
     def set_composition(self, molar_fractions):
         """
         Set the composition for this solution.
         Resets cached properties.
 
-        Parameters
-        ----------
-        molar_fractions: list of float
-            molar abundance for each endmember, needs to sum to one.
-        """
-        assert(len(self.endmembers) == len(molar_fractions))
-
-        if self.solution_type != 'mechanical':
-            assert(sum(molar_fractions) > 0.9999)
-            assert(sum(molar_fractions) < 1.0001)
+        :param molar_fractions: Molar abundance for each endmember,
+            needs to sum to one.
+        :type molar_fractions: list of float
+        """
+        assert len(self.solution_model.endmembers) == len(molar_fractions)
+
+        if self.solution_type != "mechanical":
+            assert sum(molar_fractions) > 0.9999
+            assert sum(molar_fractions) < 1.0001
 
         self.reset()
         self.molar_fractions = np.array(molar_fractions)
 
         if self.temperature is not None:
             _ = self.molar_volume
 
     def set_method(self, method):
         for i in range(self.n_endmembers):
-            self.endmembers[i][0].set_method(method)
+            self.solution_model.endmembers[i][0].set_method(method)
         # note: do not set self.method here!
         self.reset()
 
     def set_state(self, pressure, temperature):
-
         Mineral.set_state(self, pressure, temperature)
 
         try:
             _ = self.molar_volume
         except AttributeError:
             pass
 
@@ -229,37 +138,51 @@
         return sum_formulae(self.endmember_formulae, self.molar_fractions)
 
     @material_property
     def activities(self):
         """
         Returns a list of endmember activities [unitless].
         """
-        volumes = [self.endmembers[i][0].method.volume(self.pressure,
-                                                       self.temperature,
-                                                       self.endmembers[i][0].params)
-                   for i in range(self.n_endmembers)]
-
-        gibbs_pure = [self.endmembers[i][0].method.gibbs_free_energy(self.pressure,
-                                                                     self.temperature,
-                                                                     volumes[i],
-                                                                     self.endmembers[i][0].params)
-                      for i in range(self.n_endmembers)]
-
-        acts = np.exp((self.partial_gibbs - np.array(gibbs_pure))
-                      / (gas_constant*self.temperature))
+        volumes = [
+            self.solution_model.endmembers[i][0].method.volume(
+                self.pressure,
+                self.temperature,
+                self.solution_model.endmembers[i][0].params,
+            )
+            for i in range(self.n_endmembers)
+        ]
+
+        gibbs_pure = [
+            self.solution_model.endmembers[i][0].method.gibbs_free_energy(
+                self.pressure,
+                self.temperature,
+                volumes[i],
+                self.solution_model.endmembers[i][0].params,
+            )
+            for i in range(self.n_endmembers)
+        ]
+
+        acts = np.exp(
+            (self.partial_gibbs - np.array(gibbs_pure))
+            / (gas_constant * self.temperature)
+        )
         return acts
 
     @material_property
     def activity_coefficients(self):
         """
         Returns a list of endmember activity coefficients
         (gamma = activity / ideal activity) [unitless].
         """
-        return np.exp(np.log(self.activities)
-                      - IdealSolution._log_ideal_activities(self.solution_model, self.molar_fractions))
+        return np.exp(
+            np.log(self.activities)
+            - IdealSolution._log_ideal_activities(
+                self.solution_model, self.molar_fractions
+            )
+        )
 
     @material_property
     def molar_internal_energy(self):
         """
         Returns molar internal energy of the mineral [J/mol].
         Aliased with self.energy
         """
@@ -268,67 +191,85 @@
     @material_property
     def _excess_partial_helmholtz(self):
         """
         Returns excess partial molar helmholtz energy
         at constant volume [J/mol].
         Property specific to solutions.
         """
-        return self.solution_model.excess_partial_helmholtz_energies(self.molar_volume,
-                                                                     self.temperature,
-                                                                     self.molar_fractions)
+        return self.solution_model.excess_partial_helmholtz_energies(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def _excess_partial_pressures(self):
         """
         Returns excess partial pressures at constant volume [Pa].
         Property specific to solutions.
         """
-        return self.solution_model.excess_partial_pressures(self.molar_volume,
-                                                            self.temperature,
-                                                            self.molar_fractions)
+        return self.solution_model.excess_partial_pressures(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def _excess_partial_entropies(self):
         """
         Returns excess partial entropies at constant volume [J/K].
         Property specific to solutions.
         """
-        return self.solution_model.excess_partial_entropies(self.molar_volume,
-                                                            self.temperature,
-                                                            self.molar_fractions)
+        return self.solution_model.excess_partial_entropies(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def _partial_helmholtz(self):
         """
         Returns endmember partial molar Helmholtz energy at constant volume [J/mol].
         Property specific to solutions.
         """
-        return (np.array([self.endmembers[i][0].helmholtz
-                          for i in range(self.n_endmembers)])
-                + self._excess_partial_helmholtz)
+        return (
+            np.array(
+                [
+                    self.solution_model.endmembers[i][0].helmholtz
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self._excess_partial_helmholtz
+        )
 
     @material_property
     def _partial_pressures(self):
         """
         Returns endmember partial pressures at constant volume [Pa].
         Property specific to solutions.
         """
-        return (np.array([self.endmembers[i][0].pressure
-                          for i in range(self.n_endmembers)])
-                + self._excess_partial_pressures)
+        return (
+            np.array(
+                [
+                    self.solution_model.endmembers[i][0].pressure
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self._excess_partial_pressures
+        )
 
     @material_property
     def _partial_entropies(self):
         """
         Returns endmember partial entropies at constant volume [J/K].
         Property specific to solutions.
         """
-        return (np.array([self.endmembers[i][0].molar_entropy
-                          for i in range(self.n_endmembers)])
-                + self._excess_partial_entropies)
+        return (
+            np.array(
+                [
+                    self.solution_model.endmembers[i][0].molar_entropy
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self._excess_partial_entropies
+        )
 
     @material_property
     def partial_gibbs(self):
         """
         Returns endmember partial molar Gibbs energy
         at constant pressure [J/mol].
         Property specific to solutions.
@@ -338,18 +279,16 @@
     @material_property
     def _dPdX(self):
         """
         Returns the change in pressure with amount of each endmember
         at constant volume.
         """
         sumX = np.sum(self.molar_fractions)
-        sumXP = np.einsum('i,i->',
-                          self.molar_fractions,
-                          self._partial_pressures)
-        return (self._partial_pressures * sumX - sumXP)/(sumX*sumX)
+        sumXP = np.einsum("i,i->", self.molar_fractions, self._partial_pressures)
+        return (self._partial_pressures * sumX - sumXP) / (sumX * sumX)
 
     @material_property
     def _dVdX(self):
         """
         Returns the change in pressure with amount of each endmember
         at constant pressure.
         """
@@ -367,69 +306,69 @@
     @material_property
     def partial_volumes(self):
         """
         Returns endmember partial molar volumes [m^3/mol].
         Property specific to solutions.
         """
         A = np.eye(self.n_endmembers) - self.molar_fractions
-        Vs = self.molar_volume + np.einsum('ij, j->i', A, self._dVdX)
+        Vs = self.molar_volume + np.einsum("ij, j->i", A, self._dVdX)
         return Vs
 
     @material_property
     def partial_entropies(self):
         """
         Returns endmember partial molar entropies [J/K/mol].
         Property specific to solutions.
         """
         A = np.eye(self.n_endmembers) - self.molar_fractions
-        Ss = self._partial_entropies + np.einsum('ij, j->i', A, self._dSdX_mod)
+        Ss = self._partial_entropies + np.einsum("ij, j->i", A, self._dSdX_mod)
         return Ss
 
     @material_property
     def _excess_helmholtz(self):
         """
         Returns molar excess Helmholtz energy at constant volume [J/mol].
         Property specific to solutions.
         """
-        return self.solution_model.excess_helmholtz_energy(self.molar_volume,
-                                                           self.temperature,
-                                                           self.molar_fractions)
+        return self.solution_model.excess_helmholtz_energy(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def _helmholtz_hessian(self):
         """
         Returns an array containing the second compositional derivative
         of the Helmholtz energy at constant volume [J/mol].
         Property specific to solutions.
         """
-        return self.solution_model.helmholtz_hessian(self.molar_volume,
-                                                     self.temperature,
-                                                     self.molar_fractions)
+        return self.solution_model.helmholtz_hessian(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def _entropy_hessian(self):
         """
         Returns an array containing the second compositional derivative
         of the entropy at constant volume [J/K].
         Property specific to solutions.
         """
-        return self.solution_model.entropy_hessian(self.molar_volume,
-                                                   self.temperature,
-                                                   self.molar_fractions)
+        return self.solution_model.entropy_hessian(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def _pressure_hessian(self):
         """
         Returns an array containing the second compositional derivative
         of the pressure at constant volume [Pa].
         Property specific to solutions.
         """
-        return self.solution_model.pressure_hessian(self.molar_volume,
-                                                    self.temperature,
-                                                    self.molar_fractions)
+        return self.solution_model.pressure_hessian(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def gibbs_hessian(self):
         """
         Returns an array containing the second compositional derivative
         of the Gibbs energy at constant pressure [J/mol].
         Property specific to solutions.
@@ -438,76 +377,100 @@
 
     @material_property
     def molar_helmholtz(self):
         """
         Returns molar Helmholtz energy of the solution [J/mol].
         Aliased with self.helmholtz.
         """
-        return (sum([self.endmembers[i][0].molar_helmholtz
-                     * self.molar_fractions[i]
-                     for i in range(self.n_endmembers)])
-                + self._excess_helmholtz)
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].molar_helmholtz
+                    * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self._excess_helmholtz
+        )
 
     @material_property
     def molar_gibbs(self):
         """
         Returns molar Gibbs free energy of the solution [J/mol].
         Aliased with self.gibbs.
         """
         return self.molar_helmholtz + self.pressure * self.molar_volume
 
     @material_property
     def molar_mass(self):
         """
         Returns molar mass of the solution [kg/mol].
         """
-        return sum([self.endmembers[i][0].molar_mass
-                    * self.molar_fractions[i]
-                    for i in range(self.n_endmembers)])
+        return sum(
+            [
+                self.solution_model.endmembers[i][0].molar_mass
+                * self.molar_fractions[i]
+                for i in range(self.n_endmembers)
+            ]
+        )
 
     @material_property
     def excess_pressure(self):
         """
         Returns excess pressure of the solution [Pa].
         Specific property for solutions.
         """
-        return self.solution_model.excess_pressure(self.molar_volume,
-                                                   self.temperature,
-                                                   self.molar_fractions)
+        return self.solution_model.excess_pressure(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_volume(self):
         """
         Returns molar volume of the solution [m^3/mol].
         Aliased with self.V.
         """
 
         def _delta_pressure(volume):
-            self._ptmp = [self.endmembers[i][0].method.pressure(self.temperature,
-                                                                volume,
-                                                                self.endmembers[i][0].params)
-                          for i in range(self.n_endmembers)]
-
-            pressure_try = (sum([self._ptmp[i] * self.molar_fractions[i]
-                            for i in range(self.n_endmembers)])
-                            + self.solution_model.excess_pressure(volume,
-                                                                  self.temperature,
-                                                                  self.molar_fractions))
+            self._ptmp = [
+                self.solution_model.endmembers[i][0].method.pressure(
+                    self.temperature,
+                    volume,
+                    self.solution_model.endmembers[i][0].params,
+                )
+                for i in range(self.n_endmembers)
+            ]
+
+            pressure_try = sum(
+                [
+                    self._ptmp[i] * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            ) + self.solution_model.excess_pressure(
+                volume, self.temperature, self.molar_fractions
+            )
 
             return pressure_try - self.pressure
 
         def _K_T(volume):
-            # Note, this only works when the excess pressure is not a function of V or T.
+            # Note, this only works when the excess pressure is not a function
+            # of V or T.
 
-            return sum([self.endmembers[i][0].method.isothermal_bulk_modulus(0.,
-                                                                             self.temperature,
-                                                                             volume,
-                                                                             self.endmembers[i][0].params)
-                        * self.molar_fractions[i]
-                        for i in range(self.n_endmembers)])
+            return sum(
+                [
+                    self.solution_model.endmembers[i][0].method.isothermal_bulk_modulus(
+                        0.0,
+                        self.temperature,
+                        volume,
+                        self.solution_model.endmembers[i][0].params,
+                    )
+                    * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
 
         try:
             # The first attempt to find a bracket for
             # root finding uses V_0 as a starting point
             sol = bracket(_delta_pressure, self.min_V0, self.dV)
         except Exception:
             # At high temperature, the naive bracketing above may
@@ -520,30 +483,36 @@
             # or (b) using that pressure to create a better bracket for
             # brentq.
 
             sol_K_T = bracket(_K_T, self.min_V0, self.dV)
             V_crit = opt.brentq(_K_T, sol_K_T[0], sol_K_T[1])
             P_min = self.pressure + _delta_pressure(V_crit)
             if P_min > self.pressure:
-                raise Exception('The desired pressure is not achievable '
-                                'at this temperature. The minimum pressure '
-                                f'achievable is {P_min:.2e} Pa.')
+                raise Exception(
+                    "The desired pressure is not achievable "
+                    "at this temperature. The minimum pressure "
+                    f"achievable is {P_min:.2e} Pa."
+                )
             else:
                 try:
                     sol = bracket(_delta_pressure, V_crit - self.dV, self.dV)
                 except Exception:
-                    raise Exception('Cannot find a volume, perhaps you are '
-                                    'outside of the range of validity for '
-                                    'the equation of state?')
+                    raise Exception(
+                        "Cannot find a volume, perhaps you are "
+                        "outside of the range of validity for "
+                        "the equation of state?"
+                    )
 
         V = opt.brentq(_delta_pressure, sol[0], sol[1])
 
         _delta_pressure(V)
         for i in range(self.n_endmembers):
-            self.endmembers[i][0].set_state(self._ptmp[i], self.temperature)
+            self.solution_model.endmembers[i][0].set_state(
+                self._ptmp[i], self.temperature
+            )
 
         return V
 
     @material_property
     def density(self):
         """
         Returns density of the solution [kg/m^3].
@@ -553,104 +522,130 @@
 
     @material_property
     def excess_entropy(self):
         """
         Returns excess molar entropy [J/K/mol].
         Property specific to solutions.
         """
-        return self.solution_model.excess_entropy(self.molar_volume,
-                                                  self.temperature,
-                                                  self.molar_fractions)
+        return self.solution_model.excess_entropy(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_entropy(self):
         """
         Returns molar entropy of the solution [J/K/mol].
         Aliased with self.S.
         """
-        return sum([self.endmembers[i][0].S * self.molar_fractions[i]
-                    for i in range(self.n_endmembers)]) + self.excess_entropy
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].S * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_entropy
+        )
 
     @material_property
     def excess_enthalpy(self):
         """
         Returns excess molar enthalpy [J/mol].
         Property specific to solutions.
         """
-        return self.solution_model.excess_enthalpy(self.molar_volume,
-                                                   self.temperature,
-                                                   self.molar_fractions)
+        return self.solution_model.excess_enthalpy(
+            self.molar_volume, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_enthalpy(self):
         """
         Returns molar enthalpy of the solution [J/mol].
         Aliased with self.H.
         """
-        return sum([self.endmembers[i][0].H * self.molar_fractions[i]
-                    for i in range(self.n_endmembers)]) + self.excess_enthalpy
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].H * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_enthalpy
+        )
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
         Returns isothermal bulk modulus of the solution [Pa].
         Aliased with self.K_T.
         """
-        return sum([self.endmembers[i][0].isothermal_bulk_modulus
-                    * self.molar_fractions[i]
-                    for i in range(self.n_endmembers)])
+        return sum(
+            [
+                self.solution_model.endmembers[i][0].isothermal_bulk_modulus
+                * self.molar_fractions[i]
+                for i in range(self.n_endmembers)
+            ]
+        )
 
     @material_property
     def adiabatic_bulk_modulus(self):
         """
         Returns adiabatic bulk modulus of the solution [Pa].
         Aliased with self.K_S.
         """
         if self.temperature < 1e-10:
             return self.isothermal_bulk_modulus
         else:
-            return (self.isothermal_bulk_modulus
-                    * self.molar_heat_capacity_p / self.molar_heat_capacity_v)
+            return (
+                self.isothermal_bulk_modulus
+                * self.molar_heat_capacity_p
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     def isothermal_compressibility(self):
         """
         Returns isothermal compressibility of the solution.
         (or inverse isothermal bulk modulus) [1/Pa].
         Aliased with self.K_T.
         """
-        return 1. / self.isothermal_bulk_modulus
+        return 1.0 / self.isothermal_bulk_modulus
 
     @material_property
     def adiabatic_compressibility(self):
         """
         Returns adiabatic compressibility of the solution.
         (or inverse adiabatic bulk modulus) [1/Pa].
         Aliased with self.K_S.
         """
-        return 1. / self.adiabatic_bulk_modulus
+        return 1.0 / self.adiabatic_bulk_modulus
 
     @material_property
     def shear_modulus(self):
         """
         Returns shear modulus of the solution [Pa].
         Aliased with self.G.
         """
-        G_list = np.fromiter((e[0].G for e in self.endmembers), dtype=float,
-                             count=self.n_endmembers)
+        G_list = np.fromiter(
+            (e[0].G for e in self.solution_model.endmembers),
+            dtype=float,
+            count=self.n_endmembers,
+        )
         return reuss_average_function(self.molar_fractions, G_list)
 
     @material_property
     def p_wave_velocity(self):
         """
         Returns P wave speed of the solution [m/s].
         Aliased with self.v_p.
         """
-        return np.sqrt((self.adiabatic_bulk_modulus
-                        + 4. / 3. * self.shear_modulus) / self.density)
+        return np.sqrt(
+            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)
+            / self.density
+        )
 
     @material_property
     def bulk_sound_velocity(self):
         """
         Returns bulk sound speed of the solution [m/s].
         Aliased with self.v_phi.
         """
@@ -667,67 +662,85 @@
     @material_property
     def grueneisen_parameter(self):
         """
         Returns grueneisen parameter of the solution [unitless].
         Aliased with self.gr.
         """
         if self.temperature < 1e-10:
-            return float('nan')
+            return float("nan")
         else:
-            return (self.thermal_expansivity * self.isothermal_bulk_modulus
-                    * self.molar_volume / self.molar_heat_capacity_v)
+            return (
+                self.thermal_expansivity
+                * self.isothermal_bulk_modulus
+                * self.molar_volume
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     def thermal_expansivity(self):
         """
         Returns thermal expansion coefficient (alpha)
         of the solution [1/K].
         Aliased with self.alpha.
         """
-        alphaKT = sum([self.endmembers[i][0].isothermal_bulk_modulus
-                       * self.endmembers[i][0].alpha
-                       * self.molar_fractions[i]
-                       for i in range(self.n_endmembers)])
+        alphaKT = sum(
+            [
+                self.solution_model.endmembers[i][0].isothermal_bulk_modulus
+                * self.solution_model.endmembers[i][0].alpha
+                * self.molar_fractions[i]
+                for i in range(self.n_endmembers)
+            ]
+        )
         return alphaKT / self.isothermal_bulk_modulus
 
     @material_property
     def molar_heat_capacity_v(self):
         """
         Returns molar heat capacity at constant volume of the
         solution [J/K/mol].
         Aliased with self.C_v.
         """
-        return sum([self.endmembers[i][0].molar_heat_capacity_v
-                    * self.molar_fractions[i]
-                    for i in range(self.n_endmembers)])
+        return sum(
+            [
+                self.solution_model.endmembers[i][0].molar_heat_capacity_v
+                * self.molar_fractions[i]
+                for i in range(self.n_endmembers)
+            ]
+        )
 
     @material_property
     def molar_heat_capacity_p(self):
         """
         Returns molar heat capacity at constant pressure
         of the solution [J/K/mol].
         Aliased with self.C_p.
         """
-        return (self.molar_heat_capacity_v
-                + self.molar_volume * self.temperature
-                * self.thermal_expansivity * self.thermal_expansivity
-                * self.isothermal_bulk_modulus)
+        return (
+            self.molar_heat_capacity_v
+            + self.molar_volume
+            * self.temperature
+            * self.thermal_expansivity
+            * self.thermal_expansivity
+            * self.isothermal_bulk_modulus
+        )
 
     @cached_property
     def stoichiometric_matrix(self):
         """
         A sympy Matrix where each element M[i,j] corresponds
         to the number of atoms of element[j] in endmember[i].
         """
+
         def f(i, j):
             e = self.elements[j]
             if e in self.endmember_formulae[i]:
                 return nsimplify(self.endmember_formulae[i][e])
             else:
                 return 0
+
         return Matrix(len(self.endmember_formulae), len(self.elements), f)
 
     @cached_property
     def stoichiometric_array(self):
         """
         An array where each element arr[i,j] corresponds
         to the number of atoms of element[j] in endmember[i].
@@ -736,16 +749,17 @@
 
     @cached_property
     def reaction_basis(self):
         """
         An array where each element arr[i,j] corresponds
         to the number of moles of endmember[j] involved in reaction[i].
         """
-        reaction_basis = np.array([v[:] for v in
-                                   self.stoichiometric_matrix.T.nullspace()])
+        reaction_basis = np.array(
+            [v[:] for v in self.stoichiometric_matrix.T.nullspace()]
+        )
 
         if len(reaction_basis) == 0:
             reaction_basis = np.empty((0, len(self.endmember_names)))
 
         return reaction_basis
 
     @cached_property
@@ -766,51 +780,53 @@
         return sorted(independent_row_indices(self.stoichiometric_matrix.T))
 
     @cached_property
     def dependent_element_indices(self):
         """
         The element indices not included in the independent list.
         """
-        return [i for i in range(len(self.elements))
-                if i not in self.independent_element_indices]
+        return [
+            i
+            for i in range(len(self.elements))
+            if i not in self.independent_element_indices
+        ]
 
     @cached_property
     def compositional_null_basis(self):
         """
         An array N such that N.b = 0 for all bulk compositions that can
         be produced with a linear sum of the endmembers in the solution.
         """
-        null_basis = np.array([v[:] for v in
-                               self.stoichiometric_matrix.nullspace()])
+        null_basis = np.array([v[:] for v in self.stoichiometric_matrix.nullspace()])
 
         M = null_basis[:, self.dependent_element_indices]
         assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()
 
         return null_basis
 
     @cached_property
     def endmember_formulae(self):
         """
         A list of formulae for all the endmember in the solution.
         """
-        return [mbr[0].params['formula'] for mbr in self.endmembers]
+        return [mbr[0].params["formula"] for mbr in self.solution_model.endmembers]
 
     @cached_property
     def endmember_names(self):
         """
         A list of names for all the endmember in the solution.
         """
-        return [mbr[0].name for mbr in self.endmembers]
+        return [mbr[0].name for mbr in self.solution_model.endmembers]
 
     @cached_property
     def n_endmembers(self):
         """
         The number of endmembers in the solution.
         """
-        return len(self.endmembers)
+        return len(self.solution_model.endmembers)
 
     @cached_property
     def elements(self):
         """
         A list of the elements which could be contained in the solution,
         returned in the IUPAC element order.
         """
```

### Comparing `burnman-1.1.0/burnman/classes/elasticsolutionmodel.py` & `burnman-1.2.0/burnman/classes/elasticsolutionmodel.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,18 +13,20 @@
 from .solutionmodel import _non_ideal_hessian_fct, _non_ideal_interactions_fct
 from .solutionmodel import _non_ideal_hessian_subreg
 from .solutionmodel import _non_ideal_interactions_subreg
 from .solutionmodel import logish, inverseish
 from .. import constants
 
 try:
-    ag = importlib.import_module('autograd')
+    ag = importlib.import_module("autograd")
 except ImportError as err:
-    print(f'Warning: {err}. '
-          'For full functionality of BurnMan, please install autograd.')
+    print(
+        f"Warning: {err}. "
+        "For full functionality of BurnMan, please install autograd."
+    )
 
 
 class ElasticSolutionModel(object):
 
     """
     This is the base class for an Elastic solution model, intended for use
     in defining solutions and performing thermodynamic calculations
@@ -49,344 +51,341 @@
     def excess_helmholtz_energy(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess Helmholtz free energy of the solution.
         The base class implementation assumes that the excess Helmholtz
         energy is zero.
 
-        Parameters
-        ----------
-        volume : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        F_excess : float
-            The excess Helmholtz energy
-        """
-        return np.dot(np.array(molar_fractions),
-                      self.excess_partial_helmholtz_energies(volume,
-                                                             temperature,
-                                                             molar_fractions))
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
+
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess Helmholtz energy.
+        :rtype: float
+        """
+        return np.dot(
+            np.array(molar_fractions),
+            self.excess_partial_helmholtz_energies(
+                volume, temperature, molar_fractions
+            ),
+        )
 
     def excess_pressure(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess pressure of the solution.
         The base class implementation assumes that the excess pressure is zero.
 
-        Parameters
-        ----------
-        volume : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        P_excess : float
-            The excess pressure of the solution
-        """
-        return np.dot(molar_fractions,
-                      self.excess_partial_pressures(volume, temperature,
-                                                    molar_fractions))
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
+
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess pressure of the solution.
+        :rtype: float
+        """
+        return np.dot(
+            molar_fractions,
+            self.excess_partial_pressures(volume, temperature, molar_fractions),
+        )
 
     def excess_entropy(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess entropy of the solution.
         The base class implementation assumes that the excess entropy is zero.
 
-        Parameters
-        ----------
-        volume : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        S_excess : float
-            The excess entropy of the solution
-        """
-        return np.dot(molar_fractions,
-                      self.excess_partial_entropies(volume, temperature,
-                                                    molar_fractions))
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
+
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess entropy of the solution.
+        :rtype: float
+        """
+        return np.dot(
+            molar_fractions,
+            self.excess_partial_entropies(volume, temperature, molar_fractions),
+        )
 
     def excess_enthalpy(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess enthalpy of the solution.
         The base class implementation assumes that the excess enthalpy is zero.
 
-        Parameters
-        ----------
-        volume : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        H_excess : float
-            The excess enthalpy of the solution
-        """
-        return (self.excess_helmholtz_energy(volume, temperature,
-                                             molar_fractions)
-                + temperature *
-                self.excess_entropy(volume, temperature, molar_fractions)
-                - volume*self.excess_pressure(volume, temperature,
-                                              molar_fractions))
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
 
-    def excess_partial_helmholtz_energies(self, volume, temperature,
-                                          molar_fractions):
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess enthalpy of the solution.
+        :rtype: float
+        """
+        return (
+            self.excess_helmholtz_energy(volume, temperature, molar_fractions)
+            + temperature * self.excess_entropy(volume, temperature, molar_fractions)
+            - volume * self.excess_pressure(volume, temperature, molar_fractions)
+        )
+
+    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess Helmholtz energy for each endmember of the solution.
         The base class implementation assumes that the excess Helmholtz energy
         is zero.
 
-        Parameters
-        ----------
-        volume : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        partial_F_excess : numpy array
-            The excess Helmholtz energy of each endmember
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
+
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess Helmholtz energy of each endmember
+        :rtype: numpy.array
         """
         return np.zeros_like(molar_fractions)
 
     def excess_partial_entropies(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess entropy for each endmember of the solution.
         The base class implementation assumes that the excess entropy
         is zero (true for mechanical solutions).
 
-        Parameters
-        ----------
-        pressure : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        partial_S_excess : numpy array
-            The excess entropy of each endmember
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
+
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess entropy of each endmember.
+        :rtype: numpy.array
         """
         return np.zeros_like(molar_fractions)
 
     def excess_partial_pressures(self, volume, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess pressure for each endmember of the solution.
         The base class implementation assumes that the excess pressure
         is zero.
 
-        Parameters
-        ----------
-        volume : float
-            Volume at which to evaluate the solution model. [m^3/mol]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        partial_P_excess : numpy array
-            The excess pressure of each endmember
+        :param volume: Volume at which to evaluate the solution model. [m^3/mol]
+        :type volume: float
+
+        :param temperature: Temperature at which to evaluate the solution. [K]
+        :type temperature: float
+
+        :param molar_fractions: List of molar fractions of the different
+            endmembers in solution.
+        :type molar_fractions: list of floats
+
+        :returns: The excess pressure of each endmember.
+        :rtype: numpy.array
         """
         return np.zeros_like(np.array(molar_fractions))
 
 
-class ElasticMechanicalSolution (ElasticSolutionModel):
+class ElasticMechanicalSolution(ElasticSolutionModel):
 
     """
     An extremely simple class representing a mechanical solution model.
     A mechanical solution experiences no interaction between endmembers.
     Therefore, unlike ideal solutions there is no entropy of mixing;
     the total Helmholtz energy of the solution is equal to the
     dot product of the molar Helmholtz energies and molar fractions
     of the constituent materials.
     """
 
     def __init__(self, endmembers):
+        self.endmembers = endmembers
         self.n_endmembers = len(endmembers)
         self.formulas = [e[1] for e in endmembers]
 
     def excess_helmholtz_energy(self, volume, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
     def excess_pressure(self, volume, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
     def excess_entropy(self, volume, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
-    def excess_partial_helmholtz_energies(self, volume, temperature,
-                                          molar_fractions):
+    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):
         return np.zeros_like(molar_fractions)
 
     def excess_partial_pressures(self, volume, temperature, molar_fractions):
         return np.zeros_like(molar_fractions)
 
     def excess_partial_entropies(self, volume, temperature, molar_fractions):
         return np.zeros_like(molar_fractions)
 
 
-class ElasticIdealSolution (ElasticSolutionModel):
+class ElasticIdealSolution(ElasticSolutionModel):
 
     """
     A class representing an ideal solution model.
     Calculates the excess Helmholtz energy and entropy due to configurational
     entropy. Excess internal energy and volume are equal to zero.
 
     The multiplicity of each type of site in the structure is allowed to
     change linearly as a function of endmember proportions. This class
     is therefore equivalent to the entropic part of
     a Temkin-type model :cite:`Temkin1945`.
     """
 
     def __init__(self, endmembers):
+        self.endmembers = endmembers
         self.n_endmembers = len(endmembers)
         self.formulas = [e[1] for e in endmembers]
 
         # Process solution chemistry
         process_solution_chemistry(self)
 
         self._calculate_endmember_configurational_entropies()
 
     def _calculate_endmember_configurational_entropies(self):
-        S_conf = -(constants.gas_constant
-                   * (self.endmember_noccupancies
-                      * logish(self.endmember_occupancies)).sum(-1))
+        S_conf = -(
+            constants.gas_constant
+            * (self.endmember_noccupancies * logish(self.endmember_occupancies)).sum(-1)
+        )
         self.endmember_configurational_entropies = S_conf
 
-    def excess_partial_helmholtz_energies(self, volume, temperature,
-                                          molar_fractions):
-        return self._ideal_excess_partial_helmholtz(temperature,
-                                                    molar_fractions)
+    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):
+        return self._ideal_excess_partial_helmholtz(temperature, molar_fractions)
 
     def excess_partial_entropies(self, volume, temperature, molar_fractions):
-        return self._ideal_excess_partial_entropies(temperature,
-                                                    molar_fractions)
+        return self._ideal_excess_partial_entropies(temperature, molar_fractions)
 
     def excess_partial_pressures(self, volume, temperature, molar_fractions):
         return np.zeros((self.n_endmembers))
 
     def helmholtz_hessian(self, volume, temperature, molar_fractions):
         hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)
-        return -temperature*hess_S
+        return -temperature * hess_S
 
     def entropy_hessian(self, volume, temperature, molar_fractions):
         hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)
         return hess_S
 
     def pressure_hessian(self, volume, temperature, molar_fractions):
         return np.zeros((len(molar_fractions), len(molar_fractions)))
 
     def _configurational_entropy(self, molar_fractions):
-        site_noccupancies = np.einsum('i, ij', molar_fractions,
-                                      self.endmember_noccupancies)
-        site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                        self.site_multiplicities)
-        site_occupancies = (site_noccupancies
-                            * inverseish(site_multiplicities))
-        conf_entropy = -(constants.gas_constant
-                         * (site_noccupancies
-                            * logish(site_occupancies)).sum(-1))
+        site_noccupancies = np.einsum(
+            "i, ij", molar_fractions, self.endmember_noccupancies
+        )
+        site_multiplicities = np.einsum(
+            "i, ij", molar_fractions, self.site_multiplicities
+        )
+        site_occupancies = site_noccupancies * inverseish(site_multiplicities)
+        conf_entropy = -(
+            constants.gas_constant
+            * (site_noccupancies * logish(site_occupancies)).sum(-1)
+        )
         return conf_entropy
 
     def _ideal_excess_partial_helmholtz(self, temperature, molar_fractions):
-        return -(temperature
-                 * self._ideal_excess_partial_entropies(temperature,
-                                                        molar_fractions))
+        return -(
+            temperature
+            * self._ideal_excess_partial_entropies(temperature, molar_fractions)
+        )
 
     def _ideal_excess_partial_entropies(self, temperature, molar_fractions):
-        return -(constants.gas_constant
-                 * self._log_ideal_activities(molar_fractions))
+        return -(constants.gas_constant * self._log_ideal_activities(molar_fractions))
 
     def _ideal_entropy_hessian(self, temperature, molar_fractions):
-        hessian = -constants.gas_constant * \
-            self._log_ideal_activity_derivatives(molar_fractions)
+        hessian = -constants.gas_constant * self._log_ideal_activity_derivatives(
+            molar_fractions
+        )
         return hessian
 
     def _log_ideal_activities(self, molar_fractions):
-        site_noccupancies = np.einsum('i, ij', molar_fractions,
-                                      self.endmember_noccupancies)
-        site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                        self.site_multiplicities)
-
-        lna = np.einsum('ij, j->i', self.endmember_noccupancies,
-                        logish(site_noccupancies)
-                        - logish(site_multiplicities))
-
-        normalisation_constants = (self.endmember_configurational_entropies
-                                   / constants.gas_constant)
+        site_noccupancies = np.einsum(
+            "i, ij", molar_fractions, self.endmember_noccupancies
+        )
+        site_multiplicities = np.einsum(
+            "i, ij", molar_fractions, self.site_multiplicities
+        )
+
+        lna = np.einsum(
+            "ij, j->i",
+            self.endmember_noccupancies,
+            logish(site_noccupancies) - logish(site_multiplicities),
+        )
+
+        normalisation_constants = (
+            self.endmember_configurational_entropies / constants.gas_constant
+        )
         return lna + normalisation_constants
 
     def _log_ideal_activity_derivatives(self, molar_fractions):
-        site_noccupancies = np.einsum('i, ij', molar_fractions,
-                                      self.endmember_noccupancies)
-        site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                        self.site_multiplicities)
-
-        dlnadp = (np.einsum('pj, qj, j->pq', self.endmember_noccupancies,
-                            self.endmember_noccupancies,
-                            inverseish(site_noccupancies))
-                  - np.einsum('pj, qj, j->pq', self.endmember_noccupancies,
-                              self.site_multiplicities,
-                              inverseish(site_multiplicities)))
+        site_noccupancies = np.einsum(
+            "i, ij", molar_fractions, self.endmember_noccupancies
+        )
+        site_multiplicities = np.einsum(
+            "i, ij", molar_fractions, self.site_multiplicities
+        )
+
+        dlnadp = np.einsum(
+            "pj, qj, j->pq",
+            self.endmember_noccupancies,
+            self.endmember_noccupancies,
+            inverseish(site_noccupancies),
+        ) - np.einsum(
+            "pj, qj, j->pq",
+            self.endmember_noccupancies,
+            self.site_multiplicities,
+            inverseish(site_multiplicities),
+        )
 
         return dlnadp
 
     def _ideal_activities(self, molar_fractions):
-        return _ideal_activities_fct(molar_fractions,
-                                     self.endmember_noccupancies,
-                                     self.n_endmembers,
-                                     self.n_occupancies,
-                                     self.site_multiplicities,
-                                     self.endmember_configurational_entropies)
+        return _ideal_activities_fct(
+            molar_fractions,
+            self.endmember_noccupancies,
+            self.n_endmembers,
+            self.n_occupancies,
+            self.site_multiplicities,
+            self.endmember_configurational_entropies,
+        )
 
 
-class ElasticAsymmetricRegularSolution (ElasticIdealSolution):
+class ElasticAsymmetricRegularSolution(ElasticIdealSolution):
 
     """
     Solution model implementing the asymmetric regular solution model
     formulation as described in :cite:`HP2003`.
 
     The excess nonconfigurational Helmholtz energy is given by the
     expression:
@@ -398,40 +397,46 @@
     in the excess properties.
 
     .. math::
         \\phi_i = \\frac{\\alpha_i p_i}{\\sum_{k=1}^{n} \\alpha_k p_k},
         W_{ij} = \\frac{2 w_{ij}}{\\alpha_i + \\alpha_j} \\textrm{for i<j}
     """
 
-    def __init__(self, endmembers, alphas, energy_interaction,
-                 pressure_interaction=None, entropy_interaction=None):
-
+    def __init__(
+        self,
+        endmembers,
+        alphas,
+        energy_interaction,
+        pressure_interaction=None,
+        entropy_interaction=None,
+    ):
         self.n_endmembers = len(endmembers)
 
         # Create array of van Laar parameters
         self.alphas = np.array(alphas)
 
         # Create 2D arrays of interaction parameters
-        self.We = np.triu(2. / (self.alphas[:, np.newaxis] + self.alphas), 1)
-        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array([i for row in energy_interaction
-                                                                    for i in row])
+        self.We = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)
+        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array(
+            [i for row in energy_interaction for i in row]
+        )
 
         if entropy_interaction is not None:
-            self.Ws = np.triu(
-                2. / (self.alphas[:, np.newaxis] + self.alphas), 1)
-            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array([i for row in entropy_interaction
-                                                                        for i in row])
+            self.Ws = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)
+            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array(
+                [i for row in entropy_interaction for i in row]
+            )
         else:
             self.Ws = np.zeros((self.n_endmembers, self.n_endmembers))
 
         if pressure_interaction is not None:
-            self.Wp = np.triu(
-                2. / (self.alphas[:, np.newaxis] + self.alphas), 1)
-            self.Wp[np.triu_indices(self.n_endmembers, 1)] *= np.array([i for row in pressure_interaction
-                                                                        for i in row])
+            self.Wp = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)
+            self.Wp[np.triu_indices(self.n_endmembers, 1)] *= np.array(
+                [i for row in pressure_interaction for i in row]
+            )
         else:
             self.Wp = np.zeros((self.n_endmembers, self.n_endmembers))
 
         # initialize ideal solution model
         ElasticIdealSolution.__init__(self, endmembers)
 
     def _phi(self, molar_fractions):
@@ -439,205 +444,220 @@
         phi = np.divide(phi, np.sum(phi))
         return phi
 
     def _non_ideal_interactions(self, W, molar_fractions):
         # -sum(sum(qi.qj.Wij*)
         # equation (2) of Holland and Powell 2003
         phi = self._phi(molar_fractions)
-        return _non_ideal_interactions_fct(phi, np.array(molar_fractions),
-                                           self.n_endmembers,
-                                           self.alphas, W)
+        return _non_ideal_interactions_fct(
+            phi, np.array(molar_fractions), self.n_endmembers, self.alphas, W
+        )
 
-    def _non_ideal_excess_partial_helmholtz(self, volume, temperature,
-                                            molar_fractions):
+    def _non_ideal_excess_partial_helmholtz(self, volume, temperature, molar_fractions):
         Eint = self._non_ideal_interactions(self.We, molar_fractions)
         Sint = self._non_ideal_interactions(self.Ws, molar_fractions)
         Pint = self._non_ideal_interactions(self.Wp, molar_fractions)
         return Eint - temperature * Sint - volume * Pint
 
-    def excess_partial_helmholtz_energies(self, volume, temperature,
-                                          molar_fractions):
+    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):
         ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(
-            volume, temperature, molar_fractions)
+            volume, temperature, molar_fractions
+        )
         return ideal_helmholtz + non_ideal_helmholtz
 
     def excess_partial_entropies(self, volume, temperature, molar_fractions):
         ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(
-            self, temperature, molar_fractions)
-        non_ideal_entropies = self._non_ideal_interactions(
-            self.Ws, molar_fractions)
+            self, temperature, molar_fractions
+        )
+        non_ideal_entropies = self._non_ideal_interactions(self.Ws, molar_fractions)
         return ideal_entropies + non_ideal_entropies
 
     def excess_partial_pressures(self, volume, temperature, molar_fractions):
         return self._non_ideal_interactions(self.Wp, molar_fractions)
 
     def helmholtz_hessian(self, volume, temperature, molar_fractions):
         ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         phi = self._phi(molar_fractions)
-        nonideal_helmholtz_hessian = _non_ideal_hessian_fct(phi, molar_fractions,
-                                                            self.n_endmembers, self.alphas,
-                                                            self.We - temperature*self.Ws - volume*self.Wp)
+        nonideal_helmholtz_hessian = _non_ideal_hessian_fct(
+            phi,
+            molar_fractions,
+            self.n_endmembers,
+            self.alphas,
+            self.We - temperature * self.Ws - volume * self.Wp,
+        )
 
-        return nonideal_helmholtz_hessian - temperature*ideal_entropy_hessian
+        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian
 
     def entropy_hessian(self, volume, temperature, molar_fractions):
         ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         phi = self._phi(molar_fractions)
-        nonideal_entropy_hessian = _non_ideal_hessian_fct(phi, molar_fractions,
-                                                          self.n_endmembers, self.alphas,
-                                                          self.Ws)
+        nonideal_entropy_hessian = _non_ideal_hessian_fct(
+            phi, molar_fractions, self.n_endmembers, self.alphas, self.Ws
+        )
         return ideal_entropy_hessian + nonideal_entropy_hessian
 
     def pressure_hessian(self, volume, temperature, molar_fractions):
         phi = self._phi(molar_fractions)
-        return _non_ideal_hessian_fct(phi, molar_fractions,
-                                      self.n_endmembers, self.alphas,
-                                      self.Wp)
+        return _non_ideal_hessian_fct(
+            phi, molar_fractions, self.n_endmembers, self.alphas, self.Wp
+        )
 
 
-class ElasticSymmetricRegularSolution (ElasticAsymmetricRegularSolution):
+class ElasticSymmetricRegularSolution(ElasticAsymmetricRegularSolution):
 
     """
     Solution model implementing the symmetric regular solution model.
     This is a special case of the
     :class:`burnman.solutionmodel.AsymmetricRegularSolution` class.
     """
 
-    def __init__(self, endmembers, energy_interaction,
-                 pressure_interaction=None,
-                 entropy_interaction=None):
+    def __init__(
+        self,
+        endmembers,
+        energy_interaction,
+        pressure_interaction=None,
+        entropy_interaction=None,
+    ):
         alphas = np.ones(len(endmembers))
-        ElasticAsymmetricRegularSolution.__init__(self, endmembers, alphas,
-                                                  energy_interaction,
-                                                  pressure_interaction,
-                                                  entropy_interaction)
+        ElasticAsymmetricRegularSolution.__init__(
+            self,
+            endmembers,
+            alphas,
+            energy_interaction,
+            pressure_interaction,
+            entropy_interaction,
+        )
 
 
-class ElasticSubregularSolution (ElasticIdealSolution):
+class ElasticSubregularSolution(ElasticIdealSolution):
 
     """
     Solution model implementing the subregular solution model formulation
     as described in :cite:`HW1989`. The excess conconfigurational
     Helmholtz energy is given by the expression:
 
     .. math::
         \\mathcal{F}_{\\textrm{excess}} = \\sum_i \\sum_{j > i} (p_i p_j^2
         W_{ij} + p_j p_i^2 W_{ji} + \\sum_{k > j > i} p_i p_j p_k W_{ijk})
 
     Interaction parameters are inserted into a 3D interaction matrix during
     initialization to make use of numpy vector algebra.
 
-    Parameters
-    ----------
-    endmembers : list of lists
-        A list of all the independent endmembers in the solution.
+    :param endmembers: A list of all the independent endmembers in the solution.
         The first item of each list gives the Mineral object corresponding
         to the endmember. The second item gives the site-species formula.
-
-    energy_interaction : list of list of lists
-        The binary endmember interaction energies.
+    :type endmembers: list of lists
+    :param energy_interaction: The binary endmember interaction energies.
         Each interaction[i, j-i-1, 0] corresponds to W(i,j), while
         interaction[i, j-i-1, 1] corresponds to W(j,i).
-
-    pressure_interaction : list of list of lists
-        The binary endmember interaction pressures.
+    :type energy_interaction: list of list of lists
+    :param pressure_interaction: The binary endmember interaction pressures.
         Each interaction[i, j-i-1, 0] corresponds to W(i,j), while
         interaction[i, j-i-1, 1] corresponds to W(j,i).
-
-    entropy_interaction : list of list of lists
-        The binary endmember interaction entropies.
+    :type pressure_interaction: list of list of lists
+    :param entropy_interaction: The binary endmember interaction entropies.
         Each interaction[i, j-i-1, 0] corresponds to W(i,j), while
         interaction[i, j-i-1, 1] corresponds to W(j,i).
-
-    energy_ternary_terms : list of lists
-        The ternary interaction energies. Each list should contain
-        four entries: the indices i, j, k and the value of the interaction.
-
-    pressure_ternary_terms : list of lists
-        The ternary interaction pressures. Each list should contain
-        four entries: the indices i, j, k and the value of the interaction.
-
-    entropy_ternary_terms : list of lists
-        The ternary interaction entropies. Each list should contain
-        four entries: the indices i, j, k and the value of the interaction.
-    """
-
-    def __init__(self, endmembers, energy_interaction,
-                 pressure_interaction=None, entropy_interaction=None,
-                 energy_ternary_terms=None,
-                 pressure_ternary_terms=None, entropy_ternary_terms=None):
+    :type entropy_interaction: list of list of lists
+    :param energy_ternary_terms: The ternary interaction energies.
+        Each list should contain four entries: the indices i, j, k
+        and the value of the interaction.
+    :type energy_ternary_terms: list of lists
+    :param pressure_ternary_terms: The ternary interaction pressures.
+        Each list should contain four entries: the indices i, j, k
+        and the value of the interaction.
+    :type pressure_ternary_terms: list of lists
+    :param entropy_ternary_terms: The ternary interaction entropies.
+        Each list should contain four entries:
+        the indices i, j, k and the value of the interaction.
+    :type entropy_ternary_terms: list of lists
+    """
+
+    def __init__(
+        self,
+        endmembers,
+        energy_interaction,
+        pressure_interaction=None,
+        entropy_interaction=None,
+        energy_ternary_terms=None,
+        pressure_ternary_terms=None,
+        entropy_ternary_terms=None,
+    ):
         """
         Initialization function for the SubregularSolution class.
         """
 
         self.n_endmembers = len(endmembers)
 
         # Create 3D arrays of interaction parameters
-        self.Wijke = np.zeros(shape=(self.n_endmembers,
-                                     self.n_endmembers,
-                                     self.n_endmembers))
+        self.Wijke = np.zeros(
+            shape=(self.n_endmembers, self.n_endmembers, self.n_endmembers)
+        )
         self.Wijks = np.zeros_like(self.Wijke)
         self.Wijkp = np.zeros_like(self.Wijke)
 
         # setup excess enthalpy interaction matrix
         for i in range(self.n_endmembers):
             for j in range(i + 1, self.n_endmembers):
-                w0 = energy_interaction[i][j - i - 1][0]/2.
-                w1 = energy_interaction[i][j - i - 1][1]/2.
+                w0 = energy_interaction[i][j - i - 1][0] / 2.0
+                w1 = energy_interaction[i][j - i - 1][1] / 2.0
                 self.Wijke[:, i, j] += w0
                 self.Wijke[:, j, i] += w1
 
                 self.Wijke[i, j, j] += w0
                 self.Wijke[j, i, i] += w1
 
                 self.Wijke[i, j, i] -= w0
                 self.Wijke[j, i, j] -= w1
 
         if energy_ternary_terms is not None:
-            for (i, j, k, v) in energy_ternary_terms:
+            for i, j, k, v in energy_ternary_terms:
                 self.Wijke[i, j, k] += v
 
         if entropy_interaction is not None:
             for i in range(self.n_endmembers):
                 for j in range(i + 1, self.n_endmembers):
-                    w0 = entropy_interaction[i][j - i - 1][0]/2.
-                    w1 = entropy_interaction[i][j - i - 1][1]/2.
+                    w0 = entropy_interaction[i][j - i - 1][0] / 2.0
+                    w1 = entropy_interaction[i][j - i - 1][1] / 2.0
                     self.Wijks[:, i, j] += w0
                     self.Wijks[:, j, i] += w1
 
                     self.Wijks[i, j, j] += w0
                     self.Wijks[j, i, i] += w1
 
                     self.Wijks[i, j, i] -= w0
                     self.Wijks[j, i, j] -= w1
 
         if entropy_ternary_terms is not None:
-            for (i, j, k, v) in entropy_ternary_terms:
+            for i, j, k, v in entropy_ternary_terms:
                 self.Wijks[i, j, k] += v
 
         if pressure_interaction is not None:
             for i in range(self.n_endmembers):
                 for j in range(i + 1, self.n_endmembers):
-                    w0 = pressure_interaction[i][j - i - 1][0]/2.
-                    w1 = pressure_interaction[i][j - i - 1][1]/2.
+                    w0 = pressure_interaction[i][j - i - 1][0] / 2.0
+                    w1 = pressure_interaction[i][j - i - 1][1] / 2.0
                     self.Wijkp[:, i, j] += w0
                     self.Wijkp[:, j, i] += w1
 
                     self.Wijkp[i, j, j] += w0
                     self.Wijkp[j, i, i] += w1
 
                     self.Wijkp[i, j, i] -= w0
                     self.Wijkp[j, i, j] -= w1
 
         if pressure_ternary_terms is not None:
-            for (i, j, k, v) in pressure_ternary_terms:
+            for i, j, k, v in pressure_ternary_terms:
                 self.Wijkv[i, j, k] += v
 
         # initialize ideal solution model
         ElasticIdealSolution.__init__(self, endmembers)
 
     def _non_ideal_function(self, Wijk, molar_fractions):
         n = len(molar_fractions)
@@ -646,163 +666,173 @@
     def _non_ideal_interactions(self, molar_fractions):
         # equation (6') of Helffrich and Wood, 1989
         Eint = self._non_ideal_function(self.Wijke, molar_fractions)
         Sint = self._non_ideal_function(self.Wijks, molar_fractions)
         Pint = self._non_ideal_function(self.Wijkp, molar_fractions)
         return Eint, Sint, Pint
 
-    def _non_ideal_excess_partial_helmholtz(self, volume, temperature,
-                                            molar_fractions):
+    def _non_ideal_excess_partial_helmholtz(self, volume, temperature, molar_fractions):
         Eint, Sint, Pint = self._non_ideal_interactions(molar_fractions)
         return Eint - temperature * Sint - volume * Pint
 
-    def excess_partial_helmholtz_energies(self, volume, temperature,
-                                          molar_fractions):
+    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):
         ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(
-            volume, temperature, molar_fractions)
+            volume, temperature, molar_fractions
+        )
         return ideal_helmholtz + non_ideal_helmholtz
 
     def excess_partial_entropies(self, volume, temperature, molar_fractions):
         ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(
-            self, temperature, molar_fractions)
-        non_ideal_entropies = self._non_ideal_function(
-            self.Wijks, molar_fractions)
+            self, temperature, molar_fractions
+        )
+        non_ideal_entropies = self._non_ideal_function(self.Wijks, molar_fractions)
         return ideal_entropies + non_ideal_entropies
 
     def excess_partial_pressures(self, volume, temperature, molar_fractions):
-        non_ideal_pressures = self._non_ideal_function(
-            self.Wijkp, molar_fractions)
+        non_ideal_pressures = self._non_ideal_function(self.Wijkp, molar_fractions)
         return non_ideal_pressures
 
     def helmholtz_hessian(self, volume, temperature, molar_fractions):
         n = len(molar_fractions)
         ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(
-            self, temperature, molar_fractions)
-        nonideal_helmholtz_hessian = _non_ideal_hessian_subreg(molar_fractions,
-                                                               n,
-                                                               self.Wijke - temperature*self.Wijks
-                                                               - volume*self.Wijkp)
+            self, temperature, molar_fractions
+        )
+        nonideal_helmholtz_hessian = _non_ideal_hessian_subreg(
+            molar_fractions,
+            n,
+            self.Wijke - temperature * self.Wijks - volume * self.Wijkp,
+        )
 
-        return nonideal_helmholtz_hessian - temperature*ideal_entropy_hessian
+        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian
 
     def entropy_hessian(self, volume, temperature, molar_fractions):
         n = len(molar_fractions)
         ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(
-            self, temperature, molar_fractions)
-        nonideal_entropy_hessian = _non_ideal_hessian_subreg(molar_fractions,
-                                                             n,
-                                                             self.Wijks)
+            self, temperature, molar_fractions
+        )
+        nonideal_entropy_hessian = _non_ideal_hessian_subreg(
+            molar_fractions, n, self.Wijks
+        )
         return ideal_entropy_hessian + nonideal_entropy_hessian
 
     def pressure_hessian(self, volume, temperature, molar_fractions):
         n = len(molar_fractions)
         return _non_ideal_hessian_subreg(molar_fractions, n, self.Wijkp)
 
 
-class ElasticFunctionSolution (ElasticIdealSolution):
+class ElasticFunctionSolution(ElasticIdealSolution):
     """
     Solution model implementing a generalized elastic solution model.
     The extensive excess nonconfigurational Helmholtz energy is
     provided as a function by the user.
 
     Derivatives are calculated using the autograd module,
     and so the user-defined excess Helmholtz energy function
     should be defined using autograd-friendly expressions.
 
-    Parameters
-    ----------
-    endmembers : list of lists
-        A list of all the independent endmembers in the solution.
+    :param endmembers: A list of all the independent endmembers in the solution.
         The first item of each list gives the Mineral object corresponding
         to the endmember. The second item gives the site-species formula.
+    :type endmembers: list of lists
 
-    excess_helmholtz_function : function
-        The nonconfigurational Helmholtz energy function with arguments
-        volume, temperature and molar_amounts, in that order.
+    :param excess_helmholtz_function: The nonconfigurational
+        Helmholtz energy function with arguments volume,
+        temperature and molar_amounts, in that order.
         Note that the function must be extensive; if the molar amounts
         are doubled, the Helmholtz energy must also double.
+    :type excess_helmholtz_function: function
     """
 
     def __init__(self, endmembers, excess_helmholtz_function):
         """
         Initialization function for the GeneralSolution class.
         """
 
         # initialize ideal solution model
         ElasticIdealSolution.__init__(self, endmembers)
 
         self.n_endmembers = len(endmembers)
         self._excess_helmholtz_function = excess_helmholtz_function
 
-        self._non_ideal_excess_partial_helmholtz = ag.jacobian(excess_helmholtz_function,
-                                                               argnum=2)
+        self._non_ideal_excess_partial_helmholtz = ag.jacobian(
+            excess_helmholtz_function, argnum=2
+        )
 
         def partial_entropies(volume, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz,
-                                    argnum=1)(volume, temperature,
-                                              molar_amounts)
+                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=1)(
+                    volume, temperature, molar_amounts
+                )
 
         self._non_ideal_excess_partial_entropies = partial_entropies
 
         def partial_pressures(volume, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz,
-                                    argnum=0)(volume, temperature,
-                                              molar_amounts)
+                return -ag.jacobian(self._non_ideal_excess_partial_helmholtz, argnum=0)(
+                    volume, temperature, molar_amounts
+                )
 
         self.excess_partial_pressures = partial_pressures
 
-        self._non_ideal_helmholtz_hessian = ag.jacobian(self._non_ideal_excess_partial_helmholtz,
-                                                        argnum=2)
+        self._non_ideal_helmholtz_hessian = ag.jacobian(
+            self._non_ideal_excess_partial_helmholtz, argnum=2
+        )
 
         def entropy_hess(volume, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return ag.jacobian(partial_entropies, argnum=2)(volume,
-                                                                temperature,
-                                                                molar_amounts)
+                return ag.jacobian(partial_entropies, argnum=2)(
+                    volume, temperature, molar_amounts
+                )
 
         self._non_ideal_entropy_hessian = entropy_hess
 
         def pressure_hess(volume, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return ag.jacobian(partial_pressures, argnum=2)(volume,
-                                                                temperature,
-                                                                molar_amounts)
+                return ag.jacobian(partial_pressures, argnum=2)(
+                    volume, temperature, molar_amounts
+                )
 
         self.pressure_hessian = pressure_hess
 
-    def excess_partial_helmholtz_energies(self, volume, temperature,
-                                          molar_fractions):
+    def excess_partial_helmholtz_energies(self, volume, temperature, molar_fractions):
         ideal_helmholtz = ElasticIdealSolution._ideal_excess_partial_helmholtz(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_helmholtz = self._non_ideal_excess_partial_helmholtz(
-            volume, temperature, molar_fractions)
+            volume, temperature, molar_fractions
+        )
         return ideal_helmholtz + non_ideal_helmholtz
 
     def excess_partial_entropies(self, volume, temperature, molar_fractions):
         ideal_entropies = ElasticIdealSolution._ideal_excess_partial_entropies(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_entropies = self._non_ideal_excess_partial_entropies(
-            volume, temperature, molar_fractions)
+            volume, temperature, molar_fractions
+        )
         return ideal_entropies + non_ideal_entropies
 
-    def helmholtz_hessian(self, volume, temperature,
-                          molar_fractions):
-        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
+    def helmholtz_hessian(self, volume, temperature, molar_fractions):
+        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
         nonideal_helmholtz_hessian = self._non_ideal_helmholtz_hessian(
-            volume, temperature, molar_fractions)
+            volume, temperature, molar_fractions
+        )
 
-        return nonideal_helmholtz_hessian - temperature*ideal_entropy_hessian
+        return nonideal_helmholtz_hessian - temperature * ideal_entropy_hessian
 
-    def entropy_hessian(self, volume, temperature,
-                        molar_fractions):
-        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
+    def entropy_hessian(self, volume, temperature, molar_fractions):
+        ideal_entropy_hessian = ElasticIdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
         nonideal_entropy_hessian = self._non_ideal_entropy_hessian(
-            volume, temperature, molar_fractions)
+            volume, temperature, molar_fractions
+        )
         return ideal_entropy_hessian + nonideal_entropy_hessian
```

### Comparing `burnman-1.1.0/burnman/classes/layer.py` & `burnman-1.2.0/burnman/classes/layer.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from __future__ import print_function
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
 # the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 import numpy as np
 from scipy.integrate import odeint
@@ -51,24 +52,26 @@
         self.n_slices = len(self.radii)
         self.verbose = verbose
         self._cached = {}
         self._pressures = None
         self._temperatures = None
         self.sublayers = None
         self.material = None
-        self.pressure_mode = 'self-consistent'
+        self.pressure_mode = "self-consistent"
         self.temperature_mode = None
 
     def __str__(self):
         """
         Prints details of the layer
         """
-        writing = (f'The {self.name} is made of {self.material.name}'
-                   f' with {self.temperature_mode} temperatures and '
-                   f'{self.pressure_mode} pressures\n')
+        writing = (
+            f"The {self.name} is made of {self.material.name}"
+            f" with {self.temperature_mode} temperatures and "
+            f"{self.pressure_mode} pressures\n"
+        )
         return writing
 
     def reset(self):
         """
         Resets all cached material properties.
         It is typically not required for the user to call this function.
         """
@@ -77,282 +80,295 @@
         self._temperatures = None
         self.sublayers = None
 
     def set_material(self, material):
         """
         Set the material of a Layer with a Material
         """
-        assert(isinstance(material, Material))
+        assert isinstance(material, Material)
         self.material = material
         self.reset()
 
-    def set_temperature_mode(self, temperature_mode='adiabatic',
-                             temperatures=None, temperature_top=None):
+    def set_temperature_mode(
+        self, temperature_mode="adiabatic", temperatures=None, temperature_top=None
+    ):
         """
         Sets temperatures within the layer as user-defined values or as
         a (potentially perturbed) adiabat.
 
-        Parameters
-        ----------
-        temperature_mode : string
-            This can be set to 'user-defined', 'adiabatic',
+        :param temperature_mode: This can be set to 'user-defined', 'adiabatic',
             or 'perturbed-adiabatic'. 'user-defined' fixes the temperature
             with the profile input by the user. 'adiabatic' self-consistently
             computes the adiabat when setting the state of the layer.
             'perturbed-adiabatic' adds the user input array to the adiabat.
             This allows the user to apply boundary layers (for example).
-        temperatures : array of float
-            The desired fixed temperatures in [K].
+        :type temperature_mode: string
+        :param temperatures: The desired fixed temperatures in [K].
             Should have same length as defined radii in layer.
-        temperature_top : float
-            Temperature at the top of the layer. Used if the temperature mode
-            is chosen to be 'adiabatic' or 'perturbed-adiabatic'.
-            If 'perturbed-adiabatic' is chosen as the temperature mode,
-            temperature_top corresponds to the true temperature at the
-            top of the layer, and the reference isentrope at this radius
+        :type temperatures: array of float
+        :param temperature_top: Temperature at the top of the layer.
+            Used if the temperature mode is chosen to be 'adiabatic' or
+            'perturbed-adiabatic'. If 'perturbed-adiabatic' is chosen as the
+            temperature mode, temperature_top corresponds to the true temperature
+            at the top of the layer, and the reference isentrope at this radius
             is defined to lie at a temperature of
             temperature_top - temperatures[-1].
+        :type temperature_top: float
         """
         self.reset()
-        assert(temperature_mode == 'user-defined'
-               or temperature_mode == 'adiabatic'
-               or temperature_mode == 'perturbed-adiabatic')
+        assert (
+            temperature_mode == "user-defined"
+            or temperature_mode == "adiabatic"
+            or temperature_mode == "perturbed-adiabatic"
+        )
 
         self.temperature_mode = temperature_mode
 
-        if ((temperature_mode == 'user-defined'
-             or temperature_mode == 'perturbed-adiabatic')):
-            assert(len(temperatures) == len(self.radii))
+        if (
+            temperature_mode == "user-defined"
+            or temperature_mode == "perturbed-adiabatic"
+        ):
+            assert len(temperatures) == len(self.radii)
             self.usertemperatures = temperatures
         else:
             self.usertemperatures = np.zeros_like(self.radii)
 
-        if ((temperature_mode == 'adiabatic'
-             or temperature_mode == 'perturbed-adiabatic')):
+        if temperature_mode == "adiabatic" or temperature_mode == "perturbed-adiabatic":
             self.temperature_top = temperature_top
         else:
             self.temperature_top = None
 
-    def set_pressure_mode(self, pressure_mode='self-consistent',
-                          pressures=None, gravity_bottom=None,
-                          pressure_top=None, n_max_iterations=50,
-                          max_delta=1.e-5):
+    def set_pressure_mode(
+        self,
+        pressure_mode="self-consistent",
+        pressures=None,
+        gravity_bottom=None,
+        pressure_top=None,
+        n_max_iterations=50,
+        max_delta=1.0e-5,
+    ):
         """
         Sets the pressure mode of the layer,
         which can either be 'user-defined', or 'self-consistent'.
 
-        Parameters
-        ----------
-        pressure_mode : string
-            This can be set to 'user-defined' or 'self-consistent'.
+        :param pressure_mode: This can be set to 'user-defined' or 'self-consistent'.
             'user-defined' fixes the pressures with the profile input
             by the user in the 'pressures' argument.
             'self-consistent' forces Layer to calculate pressures
             self-consistently. If this is selected, the user will need
             to supply values for the gravity_bottom [m/s^2]
             and pressure_top [Pa] arguments.
-        pressures : array of floats
-            Pressures [Pa] to set layer to
+        :type pressure_mode: string
+        :param pressures: Pressures [Pa] to set layer to
             (if the 'user-defined' pressure_mode has been selected).
             The array should be the same length as
             the layers user-defined radii array.
-        pressure_top : float
-            Pressure [Pa] at the top of the layer.
-        gravity_bottom : float
-            gravity [m/s^2] at the bottom of the layer.
-        n_max_iterations : integer
-            Maximum number of iterations to reach
-            self-consistent pressures (default = 50)
-        max_delta : float
-            Relative update to the highest pressure in the layer between
-            iterations to stop iterations (default = 1.e-5)
+        :type pressures: array of floats
+        :param pressure_top: Pressure [Pa] at the top of the layer.
+        :type pressure_top: float
+        :param gravity_bottom: Gravity [m/s^2] at the bottom of the layer.
+        :type gravity_bottom: float
+        :param n_max_iterations: Maximum number of iterations to reach
+            self-consistent pressures.
+        :type n_max_iterations: integer
+        :param max_delta: Relative update to the highest pressure in the layer between
+            iterations to stop iterations.
+        :type max_delta: float
         """
         self.reset()
-        assert(pressure_mode == 'user-defined'
-               or pressure_mode == 'self-consistent')
+        assert pressure_mode == "user-defined" or pressure_mode == "self-consistent"
         self.pressure_mode = pressure_mode
 
-        assert(gravity_bottom is not None)
+        assert gravity_bottom is not None
         self.gravity_bottom = gravity_bottom
 
-        if pressure_mode == 'user-defined':
-            assert(pressures is not None)
-            assert(len(pressures) == len(self.radii))
+        if pressure_mode == "user-defined":
+            assert pressures is not None
+            assert len(pressures) == len(self.radii)
             self.pressures = pressures
-            warnings.warn("By setting the pressures in Layer they "
-                          "are unlikely to be self-consistent")
-        elif pressure_mode == 'self-consistent':
+            warnings.warn(
+                "By setting the pressures in Layer they "
+                "are unlikely to be self-consistent"
+            )
+        elif pressure_mode == "self-consistent":
             self.pressure_top = pressure_top
             self.n_max_iterations = n_max_iterations
             self.max_delta = max_delta
         else:
-            raise NotImplementedError(f'pressure mode {pressure_mode} '
-                                      'not recognised')
+            raise NotImplementedError(
+                f"pressure mode {pressure_mode} " "not recognised"
+            )
 
     def make(self):
         """
         This routine needs to be called before evaluating any properties.
         If pressures and temperatures are not user-defined, they
         are computed here. This method also initializes an array of copied
         materials from which properties can be computed.
         """
         self.reset()
-        if not hasattr(self, 'material'):
-            raise AttributeError('You must set_material() for the layer '
-                                 'before running make().')
-        if not hasattr(self, 'temperature_mode'):
-            raise AttributeError('You must set_temperature_mode() for the '
-                                 'layer before running make().')
-        if not hasattr(self, 'pressure_mode'):
-            raise AttributeError('You must set_pressure_mode() for the layer '
-                                 'before running make().')
+        if not hasattr(self, "material"):
+            raise AttributeError(
+                "You must set_material() for the layer " "before running make()."
+            )
+        if not hasattr(self, "temperature_mode"):
+            raise AttributeError(
+                "You must set_temperature_mode() for the "
+                "layer before running make()."
+            )
+        if not hasattr(self, "pressure_mode"):
+            raise AttributeError(
+                "You must set_pressure_mode() for the layer " "before running make()."
+            )
 
-        if self.pressure_mode == 'user-defined':
+        if self.pressure_mode == "user-defined":
             self.temperatures = self._evaluate_temperature(
-                self.pressures, self.temperature_top)
-        elif self.pressure_mode == 'self-consistent':
-            new_press = (self.pressure_top
-                         + (-self.radii + max(self.radii))
-                         * 1.e3)  # initial pressure curve guess
-            temperatures = self._evaluate_temperature(
-                new_press, self.temperature_top)
+                self.pressures, self.temperature_top
+            )
+        elif self.pressure_mode == "self-consistent":
+            new_press = (
+                self.pressure_top + (-self.radii + max(self.radii)) * 1.0e3
+            )  # initial pressure curve guess
+            temperatures = self._evaluate_temperature(new_press, self.temperature_top)
             # Make it self-consistent!!!
             i = 0
 
             while i < self.n_max_iterations:
                 i += 1
                 ref_press = new_press
                 new_grav, new_press = self._evaluate_eos(
-                    new_press, temperatures, self.gravity_bottom,
-                    self.pressure_top)
+                    new_press, temperatures, self.gravity_bottom, self.pressure_top
+                )
                 temperatures = self._evaluate_temperature(
-                    new_press, self.temperature_top)
-                rel_err = abs(
-                    (max(ref_press) - max(new_press)) / max(new_press))
+                    new_press, self.temperature_top
+                )
+                rel_err = abs((max(ref_press) - max(new_press)) / max(new_press))
                 if self.verbose:
-                    print(f'Iteration {i:0d} maximum relative pressure error: '
-                          f'{rel_err:.1f}')
+                    print(
+                        f"Iteration {i:0d} maximum relative pressure error: "
+                        f"{rel_err:.1f}"
+                    )
 
                 if rel_err < self.max_delta:
                     break
 
             self.pressures = new_press
             self.temperatures = temperatures
         else:
-            raise NotImplementedError('pressure mode not recognised')
+            raise NotImplementedError("pressure mode not recognised")
 
         self.sublayers = []
         for r in range(len(self.radii)):
             self.sublayers.append(self.material.copy())
-            self.sublayers[r].set_state(self.pressures[r],
-                                        self.temperatures[r])
+            self.sublayers[r].set_state(self.pressures[r], self.temperatures[r])
 
     def evaluate(self, properties, radlist=None, radius_planet=None):
         """
         Function that is used to evaluate properties
         across the layer. If radlist is not defined, values are
         returned at the internal radlist.
         If asking for different radii than the internal radlist,
         pressure and temperature values are interpolated and the
         layer material evaluated at those pressures and
         temperatures.
 
-        Parameters
-        ----------
-        properties : list of strings
-            List of properties to evaluate
-        radlist : array of floats
-            Radii to evaluate properties at. If left empty,
+        :param properties: List of properties to evaluate.
+        :type properties: list of strings
+        :param radlist: Radii to evaluate properties at. If left empty,
             internal radii list is used.
-        planet_radius : float
-            Planet outer radius. Used only to calculate depth.
+        :type radlist: array of floats
+        :param planet_radius: Planet outer radius. Used only to calculate depth.
+        :type planet_radius: float
 
-        Returns
-        -------
-        property_array : numpy array
-            1D or 2D array of requested properties
+        :returns: 1D or 2D array of requested properties
             (1D if only one property was requested)
+        :rtype: numpy.array
         """
 
         if radlist is None:
             values = np.empty([len(properties), len(self.radii)])
             for i, prop in enumerate(properties):
-                if prop == 'depth':
+                if prop == "depth":
                     values[i] = radius_planet - self.radii
                 else:
                     try:
                         values[i] = getattr(self, prop)
                     except:
-                        values[i] = np.array([getattr(self.sublayers[i], prop)
-                                              for i
-                                              in range(len(self.sublayers))])
+                        values[i] = np.array(
+                            [
+                                getattr(self.sublayers[i], prop)
+                                for i in range(len(self.sublayers))
+                            ]
+                        )
         else:
             func_p = interp1d(self.radii, self.pressures)
             pressures = func_p(radlist)
             func_t = interp1d(self.radii, self.temperatures)
             temperatures = func_t(radlist)
             values = np.empty([len(properties), len(radlist)])
             for i, prop in enumerate(properties):
-                if prop == 'depth':
+                if prop == "depth":
                     values[i] = radius_planet - radlist
                 else:
                     try:
-                        values[i] = self.material.evaluate([prop],
-                                                           pressures,
-                                                           temperatures)
+                        values[i] = self.material.evaluate(
+                            [prop], pressures, temperatures
+                        )
                     except:
                         func_prop = interp1d(self.radii, getattr(self, prop))
                         values[i] = func_prop(radlist)
 
         if values.shape[0] == 1:
             values = values[0]
         return values
 
     def _evaluate_temperature(self, pressures=None, temperature_top=None):
         """
         Returns the temperatures of the layer for given pressures.
         Used by make()
         """
-        if ((self.temperature_mode == 'adiabatic'
-             or self.temperature_mode == 'perturbed-adiabatic')):
-            adiabat = geotherm.adiabatic(pressures[::-1],
-                                         temperature_top
-                                         - self.usertemperatures[-1],
-                                         self.material)[::-1]
+        if (
+            self.temperature_mode == "adiabatic"
+            or self.temperature_mode == "perturbed-adiabatic"
+        ):
+            adiabat = geotherm.adiabatic(
+                pressures[::-1],
+                temperature_top - self.usertemperatures[-1],
+                self.material,
+            )[::-1]
         else:
             adiabat = np.zeros_like(self.radii)
         return adiabat + self.usertemperatures
 
-    def _evaluate_eos(self, pressures, temperatures,
-                      gravity_bottom, pressure_top):
+    def _evaluate_eos(self, pressures, temperatures, gravity_bottom, pressure_top):
         """
         Returns updated gravity and pressure
         make() loops over this until consistency is achieved.
         """
-        [density] = self.material.evaluate(
-            ['density'], pressures, temperatures)
+        [density] = self.material.evaluate(["density"], pressures, temperatures)
         grav = self._compute_gravity(density, gravity_bottom)
         press = self._compute_pressure(density, grav, pressure_top)
         return grav, press
 
     # Functions needed to compute self-consistent radii-pressures
     def _compute_gravity(self, density, gravity_bottom):
         """
         Computes the gravity of a layer
         Used by _evaluate_eos()
         """
         # Create a spline fit of density as a function of radius
         rhofunc = UnivariateSpline(self.radii, density)
         # Numerically integrate Poisson's equation
 
-        def poisson(p, x): return 4.0 * np.pi * \
-            constants.G * rhofunc(x) * x * x
-        grav = np.ravel(odeint(poisson,
-                               gravity_bottom * self.radii[0] * self.radii[0],
-                               self.radii))
+        def poisson(p, x):
+            return 4.0 * np.pi * constants.G * rhofunc(x) * x * x
+
+        grav = np.ravel(
+            odeint(poisson, gravity_bottom * self.radii[0] * self.radii[0], self.radii)
+        )
 
         if self.radii[0] == 0:
             grav[0] = 0
             grav[1:] = grav[1:] / self.radii[1:] / self.radii[1:]
         else:
             grav[:] = grav[:] / self.radii[:] / self.radii[:]
         return grav
@@ -369,43 +385,50 @@
         gravity = gravity[::-1]
         # Make a spline fit of density as a function of depth
         rhofunc = UnivariateSpline(depthfromtop, density)
         # Make a spline fit of gravity as a function of depth
         gfunc = UnivariateSpline(depthfromtop, gravity)
 
         # integrate the hydrostatic equation
-        pressure = np.ravel(odeint((lambda p, x: gfunc(x) * rhofunc(x)),
-                                   pressure_top, depthfromtop))
+        pressure = np.ravel(
+            odeint((lambda p, x: gfunc(x) * rhofunc(x)), pressure_top, depthfromtop)
+        )
 
         return pressure[::-1]
 
     @property
     def mass(self):
         """
         Calculates the mass of the layer [kg]
         """
         mass = 0.0
         radii = self.radii
-        density = self.evaluate(['density'])
+        density = self.evaluate(["density"])
         rhofunc = UnivariateSpline(radii, density)
-        mass = np.abs(quad(lambda r: 4 * np.pi * rhofunc(r)
-                           * r * r, radii[0], radii[-1])[0])
+        mass = np.abs(
+            quad(lambda r: 4 * np.pi * rhofunc(r) * r * r, radii[0], radii[-1])[0]
+        )
         return mass
 
     @property
     def moment_of_inertia(self):
         """
         Returns the moment of inertia of the layer [kg m^2]
         """
         moment = 0.0
         radii = self.radii
-        density = self.evaluate(['density'])
+        density = self.evaluate(["density"])
         rhofunc = UnivariateSpline(radii, density)
-        moment = np.abs(quad(lambda r: 8.0 / 3.0 * np.pi * rhofunc(r)
-                             * r * r * r * r, radii[0], radii[-1])[0])
+        moment = np.abs(
+            quad(
+                lambda r: 8.0 / 3.0 * np.pi * rhofunc(r) * r * r * r * r,
+                radii[0],
+                radii[-1],
+            )[0]
+        )
         return moment
 
     @property
     def gravity(self):
         """
         Returns gravity profile of the layer [m s^(-2)]
         """
@@ -418,23 +441,25 @@
         The Bullen parameter assess if compression as a function of pressure is
         like homogeneous, adiabatic compression.
         Bullen parameter =1  , homogeneous, adiabatic compression
         Bullen parameter > 1 , more compressed with pressure,
         e.g. across phase transitions Bullen parameter < 1,
         less compressed with pressure, e.g. across a boundary layer.
         """
-        kappa = (self.bulk_sound_velocity
-                 * self.bulk_sound_velocity * self.density)
+        kappa = self.bulk_sound_velocity * self.bulk_sound_velocity * self.density
         phi = self.bulk_sound_velocity * self.bulk_sound_velocity
         try:
-            dkappadP = np.gradient(kappa, edge_order=2) / \
-                       np.gradient(self.pressures, edge_order=2)
-            dphidr = (np.gradient(phi, edge_order=2)
-                      / np.gradient(self.radii, edge_order=2)
-                      / self.gravity)
+            dkappadP = np.gradient(kappa, edge_order=2) / np.gradient(
+                self.pressures, edge_order=2
+            )
+            dphidr = (
+                np.gradient(phi, edge_order=2)
+                / np.gradient(self.radii, edge_order=2)
+                / self.gravity
+            )
         except:
             dkappadP = np.gradient(kappa) / np.gradient(self.pressures)
             dphidr = np.gradient(phi) / np.gradient(self.radii) / self.gravity
         bullen = dkappadP + dphidr
         return bullen
 
     @property
@@ -442,374 +467,369 @@
         """
         Returns the brunt-vasala (or buoyancy) frequency, N, across the layer.
         This frequency assess the stabilty of the layer:
         N < 0, fluid will convect
         N= 0, fluid is neutral
         N > 0, fluid is stabily stratified.
         """
-        kappa = (self.bulk_sound_velocity
-                 * self.bulk_sound_velocity * self.density)
-        brunt_vasala = self.density * self.gravity * \
-            self.gravity * (self.bullen - 1.) / kappa
+        kappa = self.bulk_sound_velocity * self.bulk_sound_velocity * self.density
+        brunt_vasala = (
+            self.density * self.gravity * self.gravity * (self.bullen - 1.0) / kappa
+        )
         return brunt_vasala
 
     @property
     def pressure(self):
         """
         Returns current pressures across the layer that was set
         with :func:`~burnman.Material.set_state`.
 
         Aliased with :func:`~burnman.Material.P`.
 
-        Returns
-        -------
-        pressure : array of floats
-            Pressures in [Pa] at the predefined radii.
+        :returns: Pressures in [Pa] at the predefined radii.
+        :rtype: numpy.array
         """
         return self.pressures
 
     @property
     def temperature(self):
         """
         Returns current temperature  across the layer that was set with
         :func:`~burnman.Material.set_state`.
 
         - Aliased with :func:`~burnman.Material.T`.
 
-        Returns
-        -------
-        temperature : array of floats
-            Temperatures in [K] at the predefined radii.
+        :returns: Temperatures in [K] at the predefined radii.
+        :rtype: numpy.array
         """
         return self.temperatures
 
     @material_property
     def molar_internal_energy(self):
         """
         Returns the molar internal energies across the layer.
 
         Notes
         -----
         - Needs to be implemented in derived classes.
         - Aliased with :func:`~burnman.Material.energy`.
 
-        Returns
-        -------
-        molar_internal_energy : array of floats
-            The internal energies in [J/mol] at the predefined radii.
+        :returns: The internal energies in [J/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_internal_energy
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].molar_internal_energy
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     @material_property
     def molar_gibbs(self):
         """
         Returns the molar Gibbs free energies across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.gibbs`.
 
-        Returns
-        -------
-        molar_gibbs : array of floats
-            Gibbs free energies in [J/mol] at the predefined radii.
+        :returns: Gibbs energies in [J/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_gibbs
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].molar_gibbs for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def molar_helmholtz(self):
         """
         Returns the molar Helmholtz free energies across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.helmholtz`.
 
-        Returns
-        -------
-        molar_helmholtz : array of floats
-            Helmholtz free energies in [J/mol] at the predefined radii.
+        :returns: Helmholtz energies in [J/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_helmholtz
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].molar_helmholtz for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def molar_mass(self):
         """
         Returns molar mass of the layer.
 
         Needs to be implemented in derived classes.
 
-        Returns
-        -------
-        molar_mass : array of floats
-            Molar mass in [kg/mol].
+        :returns: Molar mass in [kg/mol].
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_mass
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].molar_mass for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def molar_volume(self):
         """
         Returns molar volumes across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.V`.
 
-        Returns
-        -------
-        molar_volume : array of floats
-            Molar volumes in [m^3/mol] at the predefined radii.
+        :returns: Molar volumes in [m^3/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_volume
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].molar_volume for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def density(self):
         """
         Returns the densities across this layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.rho`.
 
-        Returns
-        -------
-        density : array of floats
-            The densities of this material in [kg/m^3] at the predefined radii.
+        :returns: The densities of this material in [kg/m^3] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].density
-                         for i in range(len(self.sublayers))])
+        return np.array([self.sublayers[i].density for i in range(len(self.sublayers))])
 
     @material_property
     def molar_entropy(self):
         """
         Returns molar entropies acroos the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.S`.
 
-        Returns
-        -------
-        molar_entropy : array of floats
-            Entropies in [J/K/mol] at the predefined radii.
+        :returns: Entropies in [J/K/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_entropy
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].molar_entropy for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def molar_enthalpy(self):
         """
         Returns molar enthalpies across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.H`.
 
-        Returns
-        -------
-        molar_enthalpy : array of floats
-            Enthalpies in [J/mol] at the predefined radii.
+        :returns: Enthalpies in [J/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_enthalpy
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].molar_enthalpy for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
         Returns isothermal bulk moduli across the layer.
 
         Notes
         -----
         - Needs to be implemented in derived classes.
         - Aliased with :func:`~burnman.Material.K_T`.
 
-        Returns
-        -------
-        isothermal_bulk_modulus : array of floats
-            Bulk moduli in [Pa] at the predefined radii.
+        :returns: Bulk moduli in [Pa] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].isothermal_bulk_modulus
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].isothermal_bulk_modulus
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     @material_property
     def adiabatic_bulk_modulus(self):
         """
         Returns the adiabatic bulk moduli across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.K_S`.
 
-        Returns
-        -------
-        adiabatic_bulk_modulus : array of floats
-            Adiabatic bulk modulus in [Pa] at the predefined radii.
+        :returns: Adiabatic bulk modulus in [Pa] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].adiabatic_bulk_modulus
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].adiabatic_bulk_modulus
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     @material_property
     def isothermal_compressibility(self):
         """
         Returns isothermal compressibilities across the layer
         (or inverse isothermal bulk moduli).
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.beta_T`.
 
-        Returns
-        -------
-        (K_T)^-1 : array of floats
-            Compressibilities in [1/Pa] at the predefined radii.
+        :returns: Isothermal compressibilities in [1/Pa] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].isothermal_compressibility
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].isothermal_compressibility
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     @material_property
     def adiabatic_compressibility(self):
         """
         Returns adiabatic compressibilities across the layer
         (or inverse adiabatic bulk moduli).
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.beta_S`.
 
-        Returns
-        -------
-        adiabatic_compressibility : array of floats
-            adiabatic compressibilities in [1/Pa] at the predefined radii.
+        :returns: Adiabatic compressibilities in [1/Pa] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].adiabatic_compressibility
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].adiabatic_compressibility
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     @material_property
     def shear_modulus(self):
         """
         Returns shear moduli across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.beta_G`.
 
-        Returns
-        -------
-        shear_modulus : array of floats
-            Shear modulie in [Pa]  at the predefined radii.
+        :returns: Shear moduli in [Pa] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].shear_modulus
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].shear_modulus for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def p_wave_velocity(self):
         """
         Returns P wave speeds across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.v_p`.
 
-        Returns
-        -------
-        p_wave_velocity : array of floats
-            P wave speeds in [m/s] at the predefined radii.
+        :returns: P wave speeds in [m/s] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].p_wave_velocity
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].p_wave_velocity for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def bulk_sound_velocity(self):
         """
         Returns bulk sound speeds across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.v_phi`.
 
-        Returns
-        -------
-        bulk sound velocity: array of floats
-            Sound velocities in [m/s] at the predefined radii.
+        :returns: Bulk sound velocities in [m/s] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].bulk_sound_velocity
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].bulk_sound_velocity for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def shear_wave_velocity(self):
         """
         Returns shear wave speeds across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.v_s`.
 
-        Returns
-        -------
-        shear_wave_velocity : array of floats
-            Wave speeds in [m/s] at the predefined radii.
+        :returns: Shear wave speeds in [m/s] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].shear_wave_velocity
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].shear_wave_velocity for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def grueneisen_parameter(self):
         """
         Returns the grueneisen parameters across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.gr`.
 
-        Returns
-        -------
-        gr : array of floats
-            Grueneisen parameters [unitless] at the predefined radii.
+        :returns: Grueneisen parameters [unitless] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].grueneisen_parameter
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].grueneisen_parameter for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def thermal_expansivity(self):
         """
         Returns thermal expansion coefficients across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.alpha`.
 
-        Returns
-        -------
-        alpha : array of floats
-            Thermal expansivities in [1/K] at the predefined radii.
+        :returns: Thermal expansivities in [1/K] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].thermal_expansivity
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [self.sublayers[i].thermal_expansivity for i in range(len(self.sublayers))]
+        )
 
     @material_property
     def molar_heat_capacity_v(self):
         """
         Returns molar heat capacity at constant volumes across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.C_v`.
 
-        Returns
-        -------
-        molar_heat_capacity_v : array of floats
-            Heat capacities in [J/K/mol] at the predefined radii.
+        :returns: Heat capacities in [J/K/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_heat_capacity_v
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].molar_heat_capacity_v
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     @material_property
     def molar_heat_capacity_p(self):
         """
         Returns molar_heat capacity at constant pressures across the layer.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.C_p`.
 
-        Returns
-        -------
-        molar_heat_capacity_p : array of floats
-            Heat capacities in [J/K/mol] at the predefined radii.
+        :returns: Heat capacities in [J/K/mol] at the predefined radii.
+        :rtype: numpy.array
         """
-        return np.array([self.sublayers[i].molar_heat_capacity_p
-                         for i in range(len(self.sublayers))])
+        return np.array(
+            [
+                self.sublayers[i].molar_heat_capacity_p
+                for i in range(len(self.sublayers))
+            ]
+        )
 
     # Aliased properties
     @property
     def P(self):
         """Alias for :func:`~burnman.Layer.pressure`"""
         return self.pressure
 
@@ -922,105 +942,101 @@
     T = a*exp((r - r1)/(r0 - r1)*c) + b*exp((r - r0)/(r1 - r0)*c)
     The relationships between the input parameters and a, b and c are
     given below.
 
     This model is a simpler version of that proposed
     by :cite:`Richter1981`.
 
-    Parameters
-    ----------
-    radius_bottom : float
-        The radius at the bottom of the layer (r0) [m].
+    :param radius_bottom: The radius at the bottom of the layer (r0) [m].
+    :type radius_bottom: float
 
-    radius_top : float
-        The radius at the top of the layer (r1) [m].
+    :param radius_top: The radius at the top of the layer (r1) [m].
+    :type radius_top: float
 
-    rayleigh_number : float
-        The Rayleigh number of convection within the layer. The
+    :param rayleigh_number: The Rayleigh number of convection within the layer. The
         exponential scale factor is this number to the power of 1/4
         (Ra = c^4).
+    :type rayleigh_number: float
 
-    temperature_change : float
-        The total difference in potential temperature across the layer [K].
-        temperature_change = (a + b)*exp(c)
-
-    boundary_layer_ratio : float
-        The ratio of the linear scale factors (a/b) corresponding to the
-        thermal boundary layers at the top and bottom of the layer. A number
-        greater than 1 implies a larger change in temperature across the
-        top boundary than the bottom boundary.
+    :param temperature_change: The total difference in potential
+        temperature across the layer [K]. temperature_change = (a + b)*exp(c).
+    :type temperature_change: float
+
+    :param boundary_layer_ratio: The ratio of the linear scale factors (a/b)
+        corresponding to the thermal boundary layers at the top and bottom of
+        the layer. A number greater than 1 implies a larger change in
+        temperature across the top boundary than the bottom boundary.
+    :type boundary_layer_ratio: float
     """
 
-    def __init__(self, radius_bottom, radius_top, rayleigh_number,
-                 temperature_change, boundary_layer_ratio):
+    def __init__(
+        self,
+        radius_bottom,
+        radius_top,
+        rayleigh_number,
+        temperature_change,
+        boundary_layer_ratio,
+    ):
         self.r0 = radius_bottom
         self.r1 = radius_top
 
         self.Ra = rayleigh_number
-        self.c = np.power(self.Ra, 1./4.)
+        self.c = np.power(self.Ra, 1.0 / 4.0)
 
-        self.a = temperature_change / (np.exp(self.c)
-                                       * (1. + boundary_layer_ratio))
-        self.b = - boundary_layer_ratio * self.a
+        self.a = temperature_change / (np.exp(self.c) * (1.0 + boundary_layer_ratio))
+        self.b = -boundary_layer_ratio * self.a
 
     def temperature(self, radii):
         """
         Returns the temperature at one or more radii [K].
 
-        Parameters
-        ----------
-        radii : float or array
-            The radii at which to evaluate the temperature.
-
-        Returns
-        -------
-        temperature : float or array
-            The temperatures at the requested radii.
-        """
-        return (self.a * np.exp((radii - self.r1)
-                                / (self.r0 - self.r1)*self.c)
-                + self.b * np.exp((radii - self.r0)
-                                  / (self.r1 - self.r0)*self.c))
+        :param radii: The radii at which to evaluate the temperature.
+        :type radii: float or numpy.array
+
+        :returns: The temperatures at the requested radii.
+        :rtype: float or numpy.array
+        """
+        return self.a * np.exp(
+            (radii - self.r1) / (self.r0 - self.r1) * self.c
+        ) + self.b * np.exp((radii - self.r0) / (self.r1 - self.r0) * self.c)
 
     def dTdr(self, radii):
         """
         Returns the thermal gradient at one or more radii [K/m].
 
-        Parameters
-        ----------
-        radii : float or array
-            The radii at which to evaluate the thermal gradients.
-
-        Returns
-        -------
-        dTdr : float or array
-            The thermal gradient at the requested radii.
-        """
-        return (self.c/(self.r0 - self.r1)
-                * (self.a * np.exp((radii - self.r1)
-                                   / (self.r0 - self.r1)*self.c)
-                   - self.b * np.exp((radii - self.r0)
-                                     / (self.r1 - self.r0)*self.c)))
+        :param radii: The radii at which to evaluate the thermal gradients.
+        :type radii: float or numpy.array
+
+        :returns: The thermal gradient at the requested radii.
+        :rtype: float or numpy.array
+        """
+        return (
+            self.c
+            / (self.r0 - self.r1)
+            * (
+                self.a * np.exp((radii - self.r1) / (self.r0 - self.r1) * self.c)
+                - self.b * np.exp((radii - self.r0) / (self.r1 - self.r0) * self.c)
+            )
+        )
 
     def set_model_thermal_gradients(self, dTdr_bottom, dTdr_top):
         """
         Reparameterizes the model based on the thermal gradients
         at the bottom and top of the model.
 
-        Parameters
-        ----------
-        dTdr_bottom : float
-            The thermal gradient at the bottom of the model [K/m].
+        :param dTdr_bottom: The thermal gradient at the bottom of the model [K/m].
             Typically negative for a cooling planet.
+        :type dTdr_bottom: float
 
-        dTdr_top : float
-            The thermal gradient at the top of the model [K/m].
+        :param dTdr_top: The thermal gradient at the top of the model [K/m].
             Typically negative for a cooling planet.
+        :type dTdr_top: float
         """
+
         def delta_dTdrs(args, dTdr_bottom, dTdr_top):
             a, b = args
             self.a = a
             self.b = b
 
-            return [dTdr_bottom - self.dTdr(self.r0),
-                    dTdr_top - self.dTdr(self.r1)]
+            return [dTdr_bottom - self.dTdr(self.r0), dTdr_top - self.dTdr(self.r1)]
+
         fsolve(delta_dTdrs, [self.a, self.b], args=(dTdr_bottom, dTdr_top))
```

### Comparing `burnman-1.1.0/burnman/classes/material.py` & `burnman-1.2.0/burnman/classes/solution.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,790 +1,711 @@
-from __future__ import print_function
-# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
-# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
+# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
+# the Earth and Planetary Sciences
+# Copyright (C) 2012 - 2022 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
-import numpy as np
-from copy import deepcopy
-from ..utils.math import bracket
-from scipy.optimize import brentq
-
-# TODO: When we require Python 3.8+, replace with
-# functools.cached_property decorator
-class cached_property(property):
-
-    """A decorator that converts a function into a lazy property.  The
-    function wrapped is called the first time to retrieve the result
-    and then that calculated result is used the next time you access
-    the value::
-
-        class Foo(object):
-
-            @cached_property
-            def foo(self):
-                # calculate something important here
-                return 42
 
-    The class has to have a `__dict__` in order for this property to
-    work.
+from __future__ import absolute_import
 
-    This decorator is adapted slightly from the one in the werkzeug module:
-    https://tedboy.github.io/flask/_modules/werkzeug/utils.html#cached_property
-    """
+import numpy as np
+from sympy import Matrix, nsimplify
+from collections import OrderedDict
+
+from .material import material_property, cached_property
+from .mineral import Mineral
+from .solutionmodel import MechanicalSolution
+from .solutionmodel import PolynomialSolution
+from .averaging_schemes import reuss_average_function
 
-    def __init__(self, func, name=None, doc=None):
-        self.__name__ = name or func.__name__
-        self.__module__ = func.__module__
-        self.__doc__ = doc or func.__doc__
-        self.func = func
-
-    def __set__(self, obj, value):
-        obj.__dict__[self.__name__] = value
-
-    def __get__(self, obj, type=None):
-        if obj is None:
-            return self
-        try:
-            value = obj.__dict__[self.__name__]
-        except KeyError:
-            value = self.func(obj)
-            obj.__dict__[self.__name__] = value
-        return value
+from ..utils.reductions import independent_row_indices
+from ..utils.chemistry import sum_formulae, sort_element_list_to_IUPAC_order
 
 
-def material_property(func):
+class Solution(Mineral):
+    """
+    This is the base class for all solutions.
+    Site occupancies, endmember activities and the constant
+    and pressure and temperature dependencies of the excess
+    properties can be queried after using set_composition().
+    States of the solution can only be queried after setting
+    the pressure, temperature and composition using set_state().
+
+    This class is available as :class:`burnman.Solution`.
+    It uses an instance of :class:`burnman.SolutionModel` to
+    calculate interaction terms between endmembers.
+
+    All the solution parameters are expected to be in SI units.  This
+    means that the interaction parameters should be in J/mol, with the T
+    and P derivatives in J/K/mol and m^3/mol.
+
+    The parameters are relevant to all solution models. Please
+    see the documentation for individual models for details about
+    other parameters.
+
+    :param name: Name of the solution.
+    :type name: string
+    :param solution_model: The SolutionModel object defining the properties
+        of the solution.
+    :type solution_model: :class:`burnman.SolutionModel`
+    :param molar_fractions: The molar fractions of each endmember in the solution.
+        Can be reset using the set_composition() method.
+    :type molar_fractions: numpy.array
     """
-    Decorator @material_property to be used for cached properties of materials.
 
-    To be used on function in Material or derived classes that should be exposed
-    as read-only properties that are cached. The function Material.reset() will
-    reset the cached values.
+    def __init__(self, name=None, solution_model=None, molar_fractions=None):
+        """
+        Set up matrices to speed up calculations for when P, T, X is defined.
+        """
+        Mineral.__init__(self)
 
-    Internally, the values are stored in a dictionary member called _cached, which
-    is emptied by .reset().
-    """
-    class mat_obj():
+        # Solution needs a method attribute to call Mineral.set_state().
+        # Note that set_method() below will not change self.method
+        self.method = "SolutionMethod"
 
-        def __init__(self, func):
-            self.func = func
-            self.varname = self.func.__name__
+        if name is not None:
+            self.name = name
+        if solution_model is not None:
+            self.solution_model = solution_model
 
-        def get(self, obj):
-            if not hasattr(obj, "_cached"):
-                raise Exception("The material_property decorator could not find class member _cached. "
-                                "Did you forget to call Material.__init__(self) in __init___?")
-            cache_array = getattr(obj, "_cached")
-            if self.varname not in cache_array:
-                cache_array[self.varname] = self.func(obj)
-            return cache_array[self.varname]
+        # Equation of state
+        for i in range(self.n_endmembers):
+            self.solution_model.endmembers[i][0].set_method(
+                self.solution_model.endmembers[i][0].params["equation_of_state"]
+            )
 
-    return property(mat_obj(func).get, doc=func.__doc__)
+        # Molar fractions
+        if molar_fractions is not None:
+            self.set_composition(molar_fractions)
 
+    @cached_property
+    def endmembers(self):
+        return self.solution_model.endmembers
 
-class Material(object):
+    def set_composition(self, molar_fractions):
+        """
+        Set the composition for this solution.
+        Resets cached properties.
 
-    """
-    Base class for all materials. The main functionality is unroll() which
-    returns a list of objects of type :class:`~burnman.Mineral` and their molar
-    fractions. This class is available as ``burnman.Material``.
+        :param molar_fractions: Molar abundance for each endmember, needs to sum to one.
+        :type molar_fractions: list of float
+        """
+        assert len(self.solution_model.endmembers) == len(molar_fractions)
 
-    The user needs to call set_method() (once in the beginning) and set_state()
-    before querying the material with unroll() or density().
-    """
+        if type(self.solution_model) != MechanicalSolution:
+            assert sum(molar_fractions) > 0.9999
+            assert sum(molar_fractions) < 1.0001
 
-    def __init__(self):
-        self._pressure = None
-        self._temperature = None
-        if not hasattr(self, "name"):
-            # if a derived class decides to set .name before calling this
-            # constructor (I am looking at you, SLB_2011.py!), do not
-            # overwrite the name here.
-            self._name = self.__class__.__name__
-        self._cached = {}
-
-    @property
-    def name(self):
-        """ Human-readable name of this material.
-
-        By default this will return the name of the class, but it can be set
-        to an arbitrary string. Overriden in Mineral.
-        """
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        self._name = value
+        if type(self.solution_model) == PolynomialSolution:
+            self.solution_model.set_composition(molar_fractions)
+
+        self.reset()
+        self.molar_fractions = np.array(molar_fractions)
 
     def set_method(self, method):
+        for i in range(self.n_endmembers):
+            self.solution_model.endmembers[i][0].set_method(method)
+        # note: do not set self.method here!
+        self.reset()
+
+    def set_state(self, pressure, temperature):
+        if type(self.solution_model) == PolynomialSolution:
+            self.solution_model.set_state(pressure, temperature)
+
+        Mineral.set_state(self, pressure, temperature)
+        for i in range(self.n_endmembers):
+            self.solution_model.endmembers[i][0].set_state(pressure, temperature)
+
+    @material_property
+    def formula(self):
         """
-        Set the averaging method. See :doc:`averaging` for details.
+        Returns molar chemical formula of the solution.
+        :rtype: Counter
+        """
+        return sum_formulae(self.endmember_formulae, self.molar_fractions)
 
-        Notes
-        -----
-        Needs to be implemented in derived classes.
+    @material_property
+    def site_occupancies(self):
         """
-        raise NotImplementedError(
-            "need to implement set_method() in derived class!")
+        :returns: The fractional occupancies of species on each site.
+        :rtype: list of OrderedDicts
+        """
+        occs = np.einsum(
+            "ij, i", self.solution_model.endmember_occupancies, self.molar_fractions
+        )
+        site_occs = []
+        k = 0
+        for i in range(self.solution_model.n_sites):
+            site_occs.append(OrderedDict())
+            for j in range(len(self.solution_model.sites[i])):
+                site_occs[-1][self.solution_model.sites[i][j]] = occs[k]
+                k += 1
+
+        return site_occs
 
-    def to_string(self):
+    def site_formula(self, precision=2):
         """
-        Returns a human-readable name of this material. The default implementation will return the name of the class,
-        which is a reasonable default.
+        Returns the molar chemical formula of the solution with site occupancies.
+            For example, [Mg0.4Fe0.6]2SiO4.
 
-        Returns
-        -------
-        name : string
-            Name of this material.
+        :param precision: Precision with which to print the site occupancies
+        :type precision: int
+
+        :returns: Molar chemical formula of the solution with site occupancies
+        :rtype: str
         """
-        return "'" + self.name + "'"
+        split_empty = self.solution_model.empty_formula.split("[")
+        formula = split_empty[0]
+        for i, site_occs in enumerate(self.site_occupancies):
+            formula += "["
+            for species, occ in site_occs.items():
+                formula += f"{species}{occ:0.{precision}f}"
+            formula += split_empty[i + 1]
+        return formula
 
-    def debug_print(self, indent=""):
+    @material_property
+    def activities(self):
         """
-        Print a human-readable representation of this Material.
+        Returns a list of endmember activities [unitless].
         """
-        raise NotImplementedError(
-            "Derived classes need to implement debug_print(). This is '" + self.__class__.__name__ + "'")
+        return self.solution_model.activities(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
-    def print_minerals_of_current_state(self):
+    @material_property
+    def activity_coefficients(self):
         """
-        Print a human-readable representation of this Material at the current P, T as a list of minerals.
-        This requires set_state() has been called before.
+        Returns a list of endmember activity coefficients
+        (gamma = activity / ideal activity) [unitless].
         """
-        (minerals, fractions) = self.unroll()
-        if len(minerals) == 1:
-            print(minerals[0].to_string())
-        else:
-            print("Material %s:" % self.to_string())
-            for (mineral, fraction) in zip(minerals, fractions):
-                print("  %g of phase %s" % (fraction, mineral.to_string()))
+        return self.solution_model.activity_coefficients(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
-    def set_state(self, pressure, temperature):
+    @material_property
+    def molar_internal_energy(self):
         """
-        Set the material to the given pressure and temperature.
-
-        Parameters
-        ----------
-        pressure : float
-            The desired pressure in [Pa].
-        temperature : float
-            The desired temperature in [K].
-        """
-        if not hasattr(self, "_pressure"):
-            raise Exception("Material.set_state() could not find class member _pressure. "
-                            "Did you forget to call Material.__init__(self) in __init___?")
-        self.reset()
-
-        self._pressure = pressure
-        self._temperature = temperature
-
-    def set_state_with_volume(self, volume, temperature,
-                              pressure_guesses=[0.e9, 10.e9]):
+        Returns molar internal energy of the mineral [J/mol].
+        Aliased with self.energy
         """
-        This function acts similarly to set_state, but takes volume and
-        temperature as input to find the pressure. In order to ensure
-        self-consistency, this function does not use any pressure functions
-        from the material classes, but instead finds the pressure using the
-        brentq root-finding method.
-
-        Parameters
-        ----------
-        volume : float
-            The desired molar volume of the mineral [m^3].
-        temperature : float
-            The desired temperature of the mineral [K].
-        pressure_guesses : list of floats (default: [5.e9, 10.e9])
-            The initial low and high guesses for bracketing of
-            the pressure [Pa].
-            These guesses should preferably bound the correct pressure,
-            but do not need to do so. More importantly,
-            they should not lie outside the valid region of
-            the equation of state.
-        """
-        def _delta_volume(pressure, volume, temperature):
-            self.set_state(pressure, temperature)
-            return volume - self.molar_volume
-
-        # we need to have a sign change in [a,b] to find a zero.
-        args = (volume, temperature)
-        try:
-            sol = bracket(_delta_volume,
-                          pressure_guesses[0], pressure_guesses[1], args)
-        except ValueError:
-            raise Exception('Cannot find a pressure, perhaps the volume or starting pressures '
-                            'are outside the range of validity for the equation of state?')
-        pressure = brentq(_delta_volume, sol[0], sol[1], args=args)
-        self.set_state(pressure, temperature)
-
-    def reset(self):
-        """
-        Resets all cached material properties.
-
-        It is typically not required for the user to call this function.
-        """
-        self._cached = {}
-
-    def copy(self):
-        return deepcopy(self)
-
-    def unroll(self):
-        """
-        Unroll this material into a list of :class:`burnman.Mineral` and their molar fractions. All averaging schemes
-        then operate on this list of minerals. Note that the return value of this function may depend on the current
-        state (temperature, pressure).
-
-        Notes
-        -----
-        Needs to be implemented in derived classes.
-
-        Returns
-        -------
-        fractions : list of float
-            List of molar fractions, should sum to 1.0.
-        minerals : list of :class:`burnman.Mineral`
-            List of minerals.
-        """
-        raise NotImplementedError(
-            "need to implement unroll() in derived class!")
-
-    def evaluate(self, vars_list, pressures, temperatures):
-        """
-        Returns an array of material properties requested through a list of strings at given pressure and temperature
-        conditions. At the end it resets the set_state to the original values.
-        The user needs to call set_method() before.
-
-        Parameters
-        ----------
-        vars_list : list of strings
-            Variables to be returned for given conditions
-        pressures : ndlist or ndarray of float
-            n-dimensional array of pressures in [Pa].
-        temperatures : ndlist or ndarray of float
-            n-dimensional array of temperatures in [K].
-
-        Returns
-        -------
-        output : array of array of float
-            Array returning all variables at given pressure/temperature values. output[i][j] is property vars_list[j]
-            and temperatures[i] and pressures[i].
-
-        """
-        old_pressure = self.pressure
-        old_temperature = self.temperature
-        pressures = np.array(pressures)
-        temperatures = np.array(temperatures)
-
-        assert(pressures.shape == temperatures.shape)
-
-        output = np.empty((len(vars_list),) + pressures.shape)
-        for i, p in np.ndenumerate(pressures):
-            self.set_state(p, temperatures[i])
-            for j in range(len(vars_list)):
-                output[(j,) + i] = getattr(self, vars_list[j])
-        if old_pressure is None or old_temperature is None:
-            # do not set_state if old values were None. Just reset to None
-            # manually
-            self._pressure = self._temperature = None
-            self.reset()
-        else:
-            self.set_state(old_pressure, old_temperature)
+        return self.molar_helmholtz + self.temperature * self.molar_entropy
 
-        return output
+    @material_property
+    def excess_partial_gibbs(self):
+        """
+        Returns excess partial molar gibbs free energy [J/mol].
+        Property specific to solutions.
+        """
+        return self.solution_model.excess_partial_gibbs_free_energies(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
-    @property
-    def pressure(self):
+    @material_property
+    def excess_partial_volumes(self):
         """
-        Returns current pressure that was set with :func:`~burnman.Material.set_state`.
+        Returns excess partial volumes [m^3].
+        Property specific to solutions.
+        """
+        return self.solution_model.excess_partial_volumes(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
+    @material_property
+    def excess_partial_entropies(self):
+        """
+        Returns excess partial entropies [J/K].
+        Property specific to solutions.
+        """
+        return self.solution_model.excess_partial_entropies(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
-        Notes
-        -----
-        - Aliased with :func:`~burnman.Material.P`.
+    @material_property
+    def partial_gibbs(self):
+        """
+        Returns endmember partial molar gibbs free energy [J/mol].
+        Property specific to solutions.
+        """
+        return (
+            np.array(
+                [
+                    self.solution_model.endmembers[i][0].gibbs
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_partial_gibbs
+        )
 
-        Returns
-        -------
-        pressure : float
-            Pressure in [Pa].
+    @material_property
+    def partial_volumes(self):
         """
-        return self._pressure
+        Returns endmember partial volumes [m^3].
+        Property specific to solutions.
+        """
+        return (
+            np.array(
+                [
+                    self.solution_model.endmembers[i][0].molar_volume
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_partial_volumes
+        )
 
-    @property
-    def temperature(self):
+    @material_property
+    def partial_entropies(self):
         """
-        Returns current temperature that was set with :func:`~burnman.Material.set_state`.
+        Returns endmember partial entropies [J/K].
+        Property specific to solutions.
+        """
+        return (
+            np.array(
+                [
+                    self.solution_model.endmembers[i][0].molar_entropy
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_partial_entropies
+        )
 
-        Notes
-        -----
-        - Aliased with :func:`~burnman.Material.T`.
+    @material_property
+    def excess_gibbs(self):
+        """
+        Returns molar excess gibbs free energy [J/mol].
+        Property specific to solutions.
+        """
+        return self.solution_model.excess_gibbs_free_energy(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
-        Returns
-        -------
-        temperature : float
-            Temperature in [K].
+    @material_property
+    def gibbs_hessian(self):
+        """
+        Returns an array containing the second compositional derivative
+        of the Gibbs free energy [J]. Property specific to solutions.
         """
-        return self._temperature
+        return self.solution_model.gibbs_hessian(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
     @material_property
-    def molar_internal_energy(self):
+    def entropy_hessian(self):
+        """
+        Returns an array containing the second compositional derivative
+        of the entropy [J/K]. Property specific to solutions.
         """
-        Returns the molar internal energy of the mineral.
+        return self.solution_model.entropy_hessian(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.energy`.
-
-        Returns
-        -------
-        molar_internal_energy : float
-            The internal energy in [J/mol].
+    @material_property
+    def volume_hessian(self):
+        """
+        Returns an array containing the second compositional derivative
+        of the volume [m^3]. Property specific to solutions.
         """
-        raise NotImplementedError(
-            "need to implement molar_internal_energy() in derived class!")
+        return self.solution_model.volume_hessian(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_gibbs(self):
         """
-        Returns the molar Gibbs free energy of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.gibbs`.
-
-        Returns
-        -------
-        molar_gibbs : float
-            Gibbs free energy in [J/mol].
+        Returns molar Gibbs free energy of the solution [J/mol].
+        Aliased with self.gibbs.
         """
-        raise NotImplementedError(
-            "need to implement molar_gibbs() in derived class!")
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].gibbs * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_gibbs
+        )
 
     @material_property
     def molar_helmholtz(self):
         """
-        Returns the molar Helmholtz free energy of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.helmholtz`.
-
-        Returns
-        -------
-        molar_helmholtz : float
-            Helmholtz free energy in [J/mol].
+        Returns molar Helmholtz free energy of the solution [J/mol].
+        Aliased with self.helmholtz.
         """
-        raise NotImplementedError(
-            "need to implement molar_helmholtz() in derived class!")
+        return self.molar_gibbs - self.pressure * self.molar_volume
 
     @material_property
     def molar_mass(self):
         """
-        Returns molar mass of the mineral.
+        Returns molar mass of the solution [kg/mol].
+        """
+        return sum(
+            [
+                self.solution_model.endmembers[i][0].molar_mass
+                * self.molar_fractions[i]
+                for i in range(self.n_endmembers)
+            ]
+        )
 
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-
-        Returns
-        -------
-        molar_mass : float
-            Molar mass in [kg/mol].
+    @material_property
+    def excess_volume(self):
         """
-        raise NotImplementedError(
-            "need to implement molar_mass() in derived class!")
+        Returns excess molar volume of the solution [m^3/mol].
+        Specific property for solutions.
+        """
+        return self.solution_model.excess_volume(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_volume(self):
         """
-        Returns molar volume of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.V`.
-
-        Returns
-        -------
-        molar_volume : float
-            Molar volume in [m^3/mol].
+        Returns molar volume of the solution [m^3/mol].
+        Aliased with self.V.
         """
-        raise NotImplementedError(
-            "need to implement molar_volume() in derived class!")
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].molar_volume
+                    * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_volume
+        )
 
     @material_property
     def density(self):
         """
-        Returns the density of this material.
+        Returns density of the solution [kg/m^3].
+        Aliased with self.rho.
+        """
+        return self.molar_mass / self.molar_volume
 
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.rho`.
-
-        Returns
-        -------
-        density : float
-            The density of this material in [kg/m^3].
+    @material_property
+    def excess_entropy(self):
         """
-        raise NotImplementedError(
-            "need to implement density() in derived class!")
+        Returns excess molar entropy [J/K/mol].
+        Property specific to solutions.
+        """
+        return self.solution_model.excess_entropy(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_entropy(self):
         """
-        Returns molar entropy of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.S`.
-
-        Returns
-        -------
-        molar_entropy : float
-            Entropy in [J/K/mol].
+        Returns molar entropy of the solution [J/K/mol].
+        Aliased with self.S.
         """
-        raise NotImplementedError(
-            "need to implement molar_entropy() in derived class!")
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].S * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_entropy
+        )
+
+    @material_property
+    def excess_enthalpy(self):
+        """
+        Returns excess molar enthalpy [J/mol].
+        Property specific to solutions.
+        """
+        return self.solution_model.excess_enthalpy(
+            self.pressure, self.temperature, self.molar_fractions
+        )
 
     @material_property
     def molar_enthalpy(self):
         """
-        Returns molar enthalpy of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.H`.
-
-        Returns
-        -------
-        molar_enthalpy : float
-            Enthalpy in [J/mol].
+        Returns molar enthalpy of the solution [J/mol].
+        Aliased with self.H.
         """
-        raise NotImplementedError(
-            "need to implement molar_enthalpy() in derived class!")
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].H * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.excess_enthalpy
+        )
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
-        Returns isothermal bulk modulus of the material.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.K_T`.
-
-        Returns
-        -------
-        isothermal_bulk_modulus : float
-            Bulk modulus in [Pa].
+        Returns isothermal bulk modulus of the solution [Pa].
+        Aliased with self.K_T.
         """
-        raise NotImplementedError(
-            "need to implement isothermal_bulk_moduls() in derived class!")
+        return (
+            self.V
+            * 1.0
+            / (
+                sum(
+                    [
+                        self.solution_model.endmembers[i][0].V
+                        / (self.solution_model.endmembers[i][0].K_T)
+                        * self.molar_fractions[i]
+                        for i in range(self.n_endmembers)
+                    ]
+                )
+                + self.solution_model.VoverKT_excess()
+            )
+        )
 
     @material_property
     def adiabatic_bulk_modulus(self):
         """
-        Returns the adiabatic bulk modulus of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.K_S`.
-
-        Returns
-        -------
-        adiabatic_bulk_modulus : float
-            Adiabatic bulk modulus in [Pa].
+        Returns adiabatic bulk modulus of the solution [Pa].
+        Aliased with self.K_S.
         """
-        raise NotImplementedError(
-            "need to implement adiabatic_bulk_modulus() in derived class!")
+        if self.temperature < 1e-10:
+            return self.isothermal_bulk_modulus
+        else:
+            return (
+                self.isothermal_bulk_modulus
+                * self.molar_heat_capacity_p
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     def isothermal_compressibility(self):
         """
-        Returns isothermal compressibility of the mineral (or inverse isothermal bulk modulus).
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.beta_T`.
-
-        Returns
-        -------
-        (K_T)^-1 : float
-            Compressibility in [1/Pa].
+        Returns isothermal compressibility of the solution.
+        (or inverse isothermal bulk modulus) [1/Pa].
+        Aliased with self.K_T.
         """
-        raise NotImplementedError(
-            "need to implement compressibility() in derived class!")
+        return 1.0 / self.isothermal_bulk_modulus
 
     @material_property
     def adiabatic_compressibility(self):
         """
-        Returns adiabatic compressibility of the mineral (or inverse adiabatic bulk modulus).
-
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.beta_S`.
-
-        Returns
-        -------
-        adiabatic_compressibility : float
-            adiabatic compressibility in [1/Pa].
+        Returns adiabatic compressibility of the solution.
+        (or inverse adiabatic bulk modulus) [1/Pa].
+        Aliased with self.K_S.
         """
-        raise NotImplementedError(
-            "need to implement compressibility() in derived class!")
+        return 1.0 / self.adiabatic_bulk_modulus
 
     @material_property
     def shear_modulus(self):
         """
-        Returns shear modulus of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.beta_G`.
-
-        Returns
-        -------
-        shear_modulus : float
-            Shear modulus in [Pa].
+        Returns shear modulus of the solution [Pa].
+        Aliased with self.G.
         """
-        raise NotImplementedError(
-            "need to implement shear_modulus() in derived class!")
+        G_list = np.fromiter(
+            (e[0].G for e in self.solution_model.endmembers),
+            dtype=float,
+            count=self.n_endmembers,
+        )
+        return reuss_average_function(self.molar_fractions, G_list)
 
     @material_property
     def p_wave_velocity(self):
         """
-        Returns P wave speed of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.v_p`.
-
-        Returns
-        -------
-        p_wave_velocity : float
-            P wave speed in [m/s].
+        Returns P wave speed of the solution [m/s].
+        Aliased with self.v_p.
         """
-        raise NotImplementedError(
-            "need to implement p_wave_velocity() in derived class!")
+        return np.sqrt(
+            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)
+            / self.density
+        )
 
     @material_property
     def bulk_sound_velocity(self):
         """
-        Returns bulk sound speed of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.v_phi`.
-
-        Returns
-        -------
-        bulk sound velocity: float
-            Sound velocity in [m/s].
+        Returns bulk sound speed of the solution [m/s].
+        Aliased with self.v_phi.
         """
-        raise NotImplementedError(
-            "need to implement bulk_sound_velocity() in derived class!")
+        return np.sqrt(self.adiabatic_bulk_modulus / self.density)
 
     @material_property
     def shear_wave_velocity(self):
         """
-        Returns shear wave speed of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.v_s`.
-
-        Returns
-        -------
-        shear_wave_velocity : float
-            Wave speed in [m/s].
+        Returns shear wave speed of the solution [m/s].
+        Aliased with self.v_s.
         """
-        raise NotImplementedError(
-            "need to implement shear_wave_velocity() in derived class!")
+        return np.sqrt(self.shear_modulus / self.density)
 
     @material_property
     def grueneisen_parameter(self):
         """
-        Returns the grueneisen parameter of the mineral.
-
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.gr`.
-
-        Returns
-        -------
-        gr : float
-            Grueneisen parameters [unitless].
+        Returns grueneisen parameter of the solution [unitless].
+        Aliased with self.gr.
         """
-        raise NotImplementedError(
-            "need to implement grueneisen_parameter() in derived class!")
+        if self.temperature < 1e-10:
+            return float("nan")
+        else:
+            return (
+                self.thermal_expansivity
+                * self.isothermal_bulk_modulus
+                * self.molar_volume
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     def thermal_expansivity(self):
         """
-        Returns thermal expansion coefficient of the mineral.
+        Returns thermal expansion coefficient (alpha)
+        of the solution [1/K].
+        Aliased with self.alpha.
+        """
+        return (1.0 / self.V) * (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].alpha
+                    * self.solution_model.endmembers[i][0].V
+                    * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.solution_model.alphaV_excess()
+        )
 
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.alpha`.
-
-        Returns
-        -------
-        alpha : float
-            Thermal expansivity in [1/K].
+    @material_property
+    def molar_heat_capacity_v(self):
         """
-        raise NotImplementedError(
-            "need to implement thermal_expansivity() in derived class!")
+        Returns molar heat capacity at constant volume of the
+        solution [J/K/mol].
+        Aliased with self.C_v.
+        """
+        return (
+            self.molar_heat_capacity_p
+            - self.molar_volume
+            * self.temperature
+            * self.thermal_expansivity
+            * self.thermal_expansivity
+            * self.isothermal_bulk_modulus
+        )
 
     @material_property
-    def molar_heat_capacity_v(self):
+    def molar_heat_capacity_p(self):
         """
-        Returns molar heat capacity at constant volume of the mineral.
+        Returns molar heat capacity at constant pressure
+        of the solution [J/K/mol].
+        Aliased with self.C_p.
+        """
+        return (
+            sum(
+                [
+                    self.solution_model.endmembers[i][0].molar_heat_capacity_p
+                    * self.molar_fractions[i]
+                    for i in range(self.n_endmembers)
+                ]
+            )
+            + self.solution_model.Cp_excess()
+        )
 
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.C_v`.
-
-        Returns
-        -------
-        molar_heat_capacity_v : float
-            Heat capacity in [J/K/mol].
+    @cached_property
+    def stoichiometric_matrix(self):
+        """
+        A sympy Matrix where each element M[i,j] corresponds
+        to the number of atoms of element[j] in endmember[i].
         """
-        raise NotImplementedError(
-            "need to implement molar_heat_capacity_v() in derived class!")
 
-    @material_property
-    def molar_heat_capacity_p(self):
+        def f(i, j):
+            e = self.elements[j]
+            if e in self.endmember_formulae[i]:
+                return nsimplify(self.endmember_formulae[i][e])
+            else:
+                return 0
+
+        return Matrix(len(self.endmember_formulae), len(self.elements), f)
+
+    @cached_property
+    def stoichiometric_array(self):
+        """
+        An array where each element arr[i,j] corresponds
+        to the number of atoms of element[j] in endmember[i].
+        """
+        return np.array(self.stoichiometric_matrix)
+
+    @cached_property
+    def reaction_basis(self):
+        """
+        An array where each element arr[i,j] corresponds
+        to the number of moles of endmember[j] involved in reaction[i].
+        """
+        reaction_basis = np.array(
+            [v[:] for v in self.stoichiometric_matrix.T.nullspace()]
+        )
+
+        if len(reaction_basis) == 0:
+            reaction_basis = np.empty((0, len(self.endmember_names)))
+
+        return reaction_basis
+
+    @cached_property
+    def n_reactions(self):
+        """
+        The number of reactions in reaction_basis.
+        """
+        return len(self.reaction_basis[:, 0])
+
+    @cached_property
+    def independent_element_indices(self):
+        """
+        A list of an independent set of element indices. If the amounts of
+        these elements are known (element_amounts),
+        the amounts of the other elements can be inferred by
+        -compositional_null_basis[independent_element_indices].dot(element_amounts).
+        """
+        return sorted(independent_row_indices(self.stoichiometric_matrix.T))
+
+    @cached_property
+    def dependent_element_indices(self):
+        """
+        The element indices not included in the independent list.
+        """
+        return [
+            i
+            for i in range(len(self.elements))
+            if i not in self.independent_element_indices
+        ]
+
+    @cached_property
+    def compositional_null_basis(self):
+        """
+        An array N such that N.b = 0 for all bulk compositions that can
+        be produced with a linear sum of the endmembers in the solution.
         """
-        Returns molar heat capacity at constant pressure of the mineral.
+        null_basis = np.array([v[:] for v in self.stoichiometric_matrix.nullspace()])
+
+        M = null_basis[:, self.dependent_element_indices]
+        assert (M.shape[0] == M.shape[1]) and (M == np.eye(M.shape[0])).all()
+
+        return null_basis
+
+    @cached_property
+    def endmember_formulae(self):
+        """
+        A list of formulae for all the endmember in the solution.
+        """
+        return [mbr[0].params["formula"] for mbr in self.solution_model.endmembers]
+
+    @cached_property
+    def endmember_names(self):
+        """
+        A list of names for all the endmember in the solution.
+        """
+        return [mbr[0].name for mbr in self.solution_model.endmembers]
+
+    @cached_property
+    def n_endmembers(self):
+        """
+        The number of endmembers in the solution.
+        """
+        return len(self.solution_model.endmembers)
+
+    @cached_property
+    def elements(self):
+        """
+        A list of the elements which could be contained in the solution,
+        returned in the IUPAC element order.
+        """
+        keys = []
+        for f in self.endmember_formulae:
+            keys.extend(f.keys())
+
+        return sort_element_list_to_IUPAC_order(set(keys))
+
 
-        Notes
-        -----
-        - Needs to be implemented in derived classes.
-        - Aliased with :func:`~burnman.Material.C_p`.
-
-        Returns
-        -------
-        molar_heat_capacity_p : float
-            Heat capacity in [J/K/mol].
-        """
-        raise NotImplementedError(
-            "need to implement molar_heat_capacity_p() in derived class!")
-
-    #
-    # Aliased properties
-    @property
-    def P(self):
-        """Alias for :func:`~burnman.Material.pressure`"""
-        return self.pressure
-
-    @property
-    def T(self):
-        """Alias for :func:`~burnman.Material.temperature`"""
-        return self.temperature
-
-    @property
-    def energy(self):
-        """Alias for :func:`~burnman.Material.molar_internal_energy`"""
-        return self.molar_internal_energy
-
-    @property
-    def helmholtz(self):
-        """Alias for :func:`~burnman.Material.molar_helmholtz`"""
-        return self.molar_helmholtz
-
-    @property
-    def gibbs(self):
-        """Alias for :func:`~burnman.Material.molar_gibbs`"""
-        return self.molar_gibbs
-
-    @property
-    def V(self):
-        """Alias for :func:`~burnman.Material.molar_volume`"""
-        return self.molar_volume
-
-    @property
-    def rho(self):
-        """Alias for :func:`~burnman.Material.density`"""
-        return self.density
-
-    @property
-    def S(self):
-        """Alias for :func:`~burnman.Material.molar_entropy`"""
-        return self.molar_entropy
-
-    @property
-    def H(self):
-        """Alias for :func:`~burnman.Material.molar_enthalpy`"""
-        return self.molar_enthalpy
-
-    @property
-    def K_T(self):
-        """Alias for :func:`~burnman.Material.isothermal_bulk_modulus`"""
-        return self.isothermal_bulk_modulus
-
-    @property
-    def K_S(self):
-        """Alias for :func:`~burnman.Material.adiabatic_bulk_modulus`"""
-        return self.adiabatic_bulk_modulus
-
-    @property
-    def beta_T(self):
-        """Alias for :func:`~burnman.Material.isothermal_compressibility`"""
-        return self.isothermal_compressibility
-
-    @property
-    def beta_S(self):
-        """Alias for :func:`~burnman.Material.adiabatic_compressibility`"""
-        return self.adiabatic_compressibility
-
-    @property
-    def G(self):
-        """Alias for :func:`~burnman.Material.shear_modulus`"""
-        return self.shear_modulus
-
-    @property
-    def v_p(self):
-        """Alias for :func:`~burnman.Material.p_wave_velocity`"""
-        return self.p_wave_velocity
-
-    @property
-    def v_phi(self):
-        """Alias for :func:`~burnman.Material.bulk_sound_velocity`"""
-        return self.bulk_sound_velocity
-
-    @property
-    def v_s(self):
-        """Alias for :func:`~burnman.Material.shear_wave_velocity`"""
-        return self.shear_wave_velocity
-
-    @property
-    def gr(self):
-        """Alias for :func:`~burnman.Material.grueneisen_parameter`"""
-        return self.grueneisen_parameter
-
-    @property
-    def alpha(self):
-        """Alias for :func:`~burnman.Material.thermal_expansivity`"""
-        return self.thermal_expansivity
-
-    @property
-    def C_v(self):
-        """Alias for :func:`~burnman.Material.molar_heat_capacity_v`"""
-        return self.molar_heat_capacity_v
-
-    @property
-    def C_p(self):
-        """Alias for :func:`~burnman.Material.molar_heat_capacity_p`"""
-        return self.molar_heat_capacity_p
+SolidSolution = Solution
```

### Comparing `burnman-1.1.0/burnman/classes/mineral.py` & `burnman-1.2.0/burnman/classes/mineral.py`

 * *Files 11% similar despite different names*

```diff
@@ -42,27 +42,27 @@
     unit cell. You can look up Z in many places, including www.mindat.org
     """
 
     def __init__(self, params=None, property_modifiers=None):
         Material.__init__(self)
         if params is not None:
             self.params = params
-        elif 'params' not in self.__dict__:
+        elif "params" not in self.__dict__:
             self.params = {}
 
         if property_modifiers is not None:
             self.property_modifiers = property_modifiers
-        elif 'property_modifiers' not in self.__dict__:
+        elif "property_modifiers" not in self.__dict__:
             self.property_modifiers = []
 
         self.method = None
-        if 'equation_of_state' in self.params:
-            self.set_method(self.params['equation_of_state'])
-        if 'name' in self.params:
-            self.name = self.params['name']
+        if "equation_of_state" in self.params:
+            self.set_method(self.params["equation_of_state"])
+        if "name" in self.params:
+            self.name = self.params["name"]
 
     def set_method(self, equation_of_state):
         """
         Set the equation of state to be used for this mineral.
         Takes a string corresponding to any of the predefined
         equations of state:  'bm2', 'bm3', 'mgd2', 'mgd3', 'slb2', 'slb3',
         'mt', 'hp_tmt', or 'cork'.  Alternatively, you can pass a user defined
@@ -73,241 +73,310 @@
         """
 
         if equation_of_state is None:
             self.method = None
             return
 
         new_method = eos.create(equation_of_state)
-        if self.method is not None and 'equation_of_state' in self.params:
-            self.method = eos.create(self.params['equation_of_state'])
+        if self.method is not None and "equation_of_state" in self.params:
+            self.method = eos.create(self.params["equation_of_state"])
 
-        if type(new_method).__name__ == 'instance':
+        if type(new_method).__name__ == "instance":
             raise Exception(
-                "Please derive your method from object (see python old style classes)")
-
-        if ((self.method is not None
-             and isinstance(new_method, type(self.method)) is False)):
+                "Please derive your method from object (see python old style classes)"
+            )
 
+        if (
+            self.method is not None
+            and isinstance(new_method, type(self.method)) is False
+        ):
             # Warn user that they are changing the EoS
-            warnings.warn('Warning, you are changing the method to '
-                          f'{new_method.__class__.__name__} even though the '
-                          'material is designed to be used with the method '
-                          f'{self.method.__class__.__name__}. '
-                          'This does not overwrite any mineral attributes',
-                          stacklevel=2)
+            warnings.warn(
+                "Warning, you are changing the method to "
+                f"{new_method.__class__.__name__} even though the "
+                "material is designed to be used with the method "
+                f"{self.method.__class__.__name__}. "
+                "This does not overwrite any mineral attributes",
+                stacklevel=2,
+            )
             self.reset()
 
         self.method = new_method
 
         # Validate the params object on the requested EOS.
         try:
             self.method.validate_parameters(self.params)
         except Exception as e:
-            print(f'Mineral {self.to_string()} failed to validate parameters '
-                  f'with message: \"{e.message}\"')
+            print(
+                f"Mineral {self.to_string()} failed to validate parameters "
+                f'with message: "{e.message}"'
+            )
             raise
 
         # Invalidate the cache upon resetting the method
         self.reset()
 
     def to_string(self):
         """
         Returns the name of the mineral class
         """
-        return "'" + self.__class__.__module__.replace(".minlib_", ".") + "." + self.__class__.__name__ + "'"
+        return (
+            "'"
+            + self.__class__.__module__.replace(".minlib_", ".")
+            + "."
+            + self.__class__.__name__
+            + "'"
+        )
 
     def debug_print(self, indent=""):
         print("%s%s" % (indent, self.to_string()))
 
     def unroll(self):
         return ([self], [1.0])
 
     @copy_documentation(Material.set_state)
     def set_state(self, pressure, temperature):
         Material.set_state(self, pressure, temperature)
-        self._property_modifiers = eos.property_modifiers.calculate_property_modifications(
-            self)
+        self._property_modifiers = (
+            eos.property_modifiers.calculate_property_modifications(self)
+        )
 
         if self.method is None:
             raise AttributeError(
-                "no method set for mineral, or equation_of_state given in mineral.params")
+                "no method set for mineral, or equation_of_state given in mineral.params"
+            )
 
     """
     Properties from equations of state
     We choose the P, T properties (e.g. Gibbs(P, T) rather than Helmholtz(V, T)),
     as it allows us to more easily apply corrections to the free energy
     """
+
     @material_property
     @copy_documentation(Material.molar_gibbs)
     def molar_gibbs(self):
-        return self.method.gibbs_free_energy(self.pressure, self.temperature, self._molar_volume_unmodified, self.params) \
-            + self._property_modifiers['G']
+        return (
+            self.method.gibbs_free_energy(
+                self.pressure,
+                self.temperature,
+                self._molar_volume_unmodified,
+                self.params,
+            )
+            + self._property_modifiers["G"]
+        )
 
     @material_property
     def _molar_volume_unmodified(self):
         return self.method.volume(self.pressure, self.temperature, self.params)
 
     @material_property
     @copy_documentation(Material.molar_volume)
     def molar_volume(self):
-        return self._molar_volume_unmodified \
-            + self._property_modifiers['dGdP']
+        return self._molar_volume_unmodified + self._property_modifiers["dGdP"]
 
     @material_property
     @copy_documentation(Material.molar_entropy)
     def molar_entropy(self):
-        return self.method.entropy(self.pressure, self.temperature, self._molar_volume_unmodified, self.params) \
-            - self._property_modifiers['dGdT']
+        return (
+            self.method.entropy(
+                self.pressure,
+                self.temperature,
+                self._molar_volume_unmodified,
+                self.params,
+            )
+            - self._property_modifiers["dGdT"]
+        )
 
     @material_property
     @copy_documentation(Material.isothermal_bulk_modulus)
     def isothermal_bulk_modulus(self):
         K_T_orig = self.method.isothermal_bulk_modulus(
-            self.pressure, self.temperature,
-            self._molar_volume_unmodified, self.params)
+            self.pressure, self.temperature, self._molar_volume_unmodified, self.params
+        )
 
-        return self.molar_volume \
-            / ((self._molar_volume_unmodified / K_T_orig) - self._property_modifiers['d2GdP2'])
+        return self.molar_volume / (
+            (self._molar_volume_unmodified / K_T_orig)
+            - self._property_modifiers["d2GdP2"]
+        )
 
     @material_property
     @copy_documentation(Material.molar_heat_capacity_p)
     def molar_heat_capacity_p(self):
-        return (self.method.molar_heat_capacity_p(self.pressure,
-                                                  self.temperature,
-                                                  self._molar_volume_unmodified,
-                                                  self.params)
-                - self.temperature * self._property_modifiers['d2GdT2'])
+        return (
+            self.method.molar_heat_capacity_p(
+                self.pressure,
+                self.temperature,
+                self._molar_volume_unmodified,
+                self.params,
+            )
+            - self.temperature * self._property_modifiers["d2GdT2"]
+        )
 
     @material_property
     @copy_documentation(Material.thermal_expansivity)
     def thermal_expansivity(self):
         return (
-            (self.method.thermal_expansivity(self.pressure, self.temperature,
-                                             self._molar_volume_unmodified,
-                                             self.params)
-             * self._molar_volume_unmodified)
-            + self._property_modifiers['d2GdPdT']) / self.molar_volume
+            (
+                self.method.thermal_expansivity(
+                    self.pressure,
+                    self.temperature,
+                    self._molar_volume_unmodified,
+                    self.params,
+                )
+                * self._molar_volume_unmodified
+            )
+            + self._property_modifiers["d2GdPdT"]
+        ) / self.molar_volume
 
     @material_property
     @copy_documentation(Material.shear_modulus)
     def shear_modulus(self):
         G = self.method.shear_modulus(
-            self.pressure, self.temperature, self._molar_volume_unmodified,
-            self.params)
-        if G < np.finfo('float').eps:
-            warnings.formatwarning = lambda msg, * \
-                a: 'Warning from file \'{0}\', line {1}:\n{2}\n\n'.format(
-                    a[1], a[2], msg)
-            warnings.warn('You are trying to calculate shear modulus for {0} when it is exactly zero. \n'
-                          'If {0} is a liquid, then you can safely ignore this warning, but consider \n'
-                          'calculating bulk modulus or bulk sound rather than Vp or Vs. \n'
-                          'If {0} is not a liquid, then shear modulus calculations for the \n'
-                          'underlying equation of state ({1}) have not been implemented, \n'
-                          'and Vp and Vs estimates will be incorrect.'.format(self.name, self.method.__class__.__name__), stacklevel=1)
+            self.pressure, self.temperature, self._molar_volume_unmodified, self.params
+        )
+        if G < np.finfo("float").eps:
+            warnings.formatwarning = (
+                lambda msg, *a: "Warning from file '{0}', line {1}:\n{2}\n\n".format(
+                    a[1], a[2], msg
+                )
+            )
+            warnings.warn(
+                "You are trying to calculate shear modulus for {0} when it is exactly zero. \n"
+                "If {0} is a liquid, then you can safely ignore this warning, but consider \n"
+                "calculating bulk modulus or bulk sound rather than Vp or Vs. \n"
+                "If {0} is not a liquid, then shear modulus calculations for the \n"
+                "underlying equation of state ({1}) have not been implemented, \n"
+                "and Vp and Vs estimates will be incorrect.".format(
+                    self.name, self.method.__class__.__name__
+                ),
+                stacklevel=1,
+            )
         return G
 
     """
     Properties from mineral parameters,
     Legendre transformations
     or Maxwell relations
     """
+
     @material_property
     def formula(self):
         """
         Returns the chemical formula of the Mineral class
         """
-        if 'formula' in self.params:
-            return self.params['formula']
+        if "formula" in self.params:
+            return self.params["formula"]
         else:
             raise ValueError(
-                'No formula parameter for mineral {0}.'.format(self.to_string))
+                "No formula parameter for mineral {0}.".format(self.to_string)
+            )
 
     @material_property
     @copy_documentation(Material.molar_mass)
     def molar_mass(self):
-        if 'molar_mass' in self.params:
-            return self.params['molar_mass']
+        if "molar_mass" in self.params:
+            return self.params["molar_mass"]
         else:
             raise ValueError(
-                'No molar_mass parameter for mineral {0}.'.format(self.to_string))
+                "No molar_mass parameter for mineral {0}.".format(self.to_string)
+            )
 
     @material_property
     @copy_documentation(Material.density)
     def density(self):
         return self.molar_mass / self.molar_volume
 
     @material_property
     @copy_documentation(Material.molar_internal_energy)
     def molar_internal_energy(self):
-        return self.molar_gibbs - self.pressure * self.molar_volume + self.temperature * self.molar_entropy
+        return (
+            self.molar_gibbs
+            - self.pressure * self.molar_volume
+            + self.temperature * self.molar_entropy
+        )
 
     @material_property
     @copy_documentation(Material.molar_helmholtz)
     def molar_helmholtz(self):
         return self.molar_gibbs - self.pressure * self.molar_volume
 
     @material_property
     @copy_documentation(Material.molar_enthalpy)
     def molar_enthalpy(self):
         return self.molar_gibbs + self.temperature * self.molar_entropy
 
     @material_property
     @copy_documentation(Material.adiabatic_bulk_modulus)
     def adiabatic_bulk_modulus(self):
-        if self.temperature < 1.e-10:
+        if self.temperature < 1.0e-10:
             return self.isothermal_bulk_modulus
         else:
-            return self.isothermal_bulk_modulus * self.molar_heat_capacity_p / self.molar_heat_capacity_v
+            return (
+                self.isothermal_bulk_modulus
+                * self.molar_heat_capacity_p
+                / self.molar_heat_capacity_v
+            )
 
     @material_property
     @copy_documentation(Material.isothermal_compressibility)
     def isothermal_compressibility(self):
-        return 1. / self.isothermal_bulk_modulus
+        return 1.0 / self.isothermal_bulk_modulus
 
     @material_property
     @copy_documentation(Material.adiabatic_compressibility)
     def adiabatic_compressibility(self):
-        return 1. / self.adiabatic_bulk_modulus
+        return 1.0 / self.adiabatic_bulk_modulus
 
     @material_property
     @copy_documentation(Material.p_wave_velocity)
     def p_wave_velocity(self):
-        return np.sqrt((self.adiabatic_bulk_modulus
-                        + 4. / 3. * self.shear_modulus) / self.density)
+        return np.sqrt(
+            (self.adiabatic_bulk_modulus + 4.0 / 3.0 * self.shear_modulus)
+            / self.density
+        )
 
     @material_property
     @copy_documentation(Material.bulk_sound_velocity)
     def bulk_sound_velocity(self):
         return np.sqrt(self.adiabatic_bulk_modulus / self.density)
 
     @material_property
     @copy_documentation(Material.shear_wave_velocity)
     def shear_wave_velocity(self):
         return np.sqrt(self.shear_modulus / self.density)
 
     @material_property
     @copy_documentation(Material.grueneisen_parameter)
     def grueneisen_parameter(self):
-        eps = np.finfo('float').eps
+        eps = np.finfo("float").eps
         if np.abs(self.molar_heat_capacity_v) > eps:
-
-            return (self.thermal_expansivity
-                    * self.isothermal_bulk_modulus
-                    * self.molar_volume
-                    / self.molar_heat_capacity_v)
-        elif ((np.abs(self._property_modifiers['d2GdPdT']) < eps)
-              and (np.abs(self._property_modifiers['d2GdP2']) < eps)
-              and (np.abs(self._property_modifiers['dGdP']) < eps)
-              and (np.abs(self._property_modifiers['d2GdT2']) < eps)):
-
-            return self.method.grueneisen_parameter(self.pressure, self.temperature,
-                                                    self.molar_volume, self.params)
+            return (
+                self.thermal_expansivity
+                * self.isothermal_bulk_modulus
+                * self.molar_volume
+                / self.molar_heat_capacity_v
+            )
+        elif (
+            (np.abs(self._property_modifiers["d2GdPdT"]) < eps)
+            and (np.abs(self._property_modifiers["d2GdP2"]) < eps)
+            and (np.abs(self._property_modifiers["dGdP"]) < eps)
+            and (np.abs(self._property_modifiers["d2GdT2"]) < eps)
+        ):
+            return self.method.grueneisen_parameter(
+                self.pressure, self.temperature, self.molar_volume, self.params
+            )
         else:
             raise Exception(
-                'You are trying to calculate the grueneisen parameter at a temperature where the heat capacity is very low and where you have defined Gibbs property modifiers.')
+                "You are trying to calculate the grueneisen parameter at a temperature where the heat capacity is very low and where you have defined Gibbs property modifiers."
+            )
 
     @material_property
     @copy_documentation(Material.molar_heat_capacity_v)
     def molar_heat_capacity_v(self):
-        return self.molar_heat_capacity_p - self.molar_volume * self.temperature \
-            * self.thermal_expansivity * self.thermal_expansivity \
+        return (
+            self.molar_heat_capacity_p
+            - self.molar_volume
+            * self.temperature
+            * self.thermal_expansivity
+            * self.thermal_expansivity
             * self.isothermal_bulk_modulus
+        )
```

### Comparing `burnman-1.1.0/burnman/classes/mineral_helpers.py` & `burnman-1.2.0/burnman/classes/mineral_helpers.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,20 +13,21 @@
 
 from .material import Material, material_property
 from .composite import Composite
 
 
 class HelperRockSwitcher(Material):
     """
-    A Helper that represents a Material that switches between different rocks based on a user specified
-    select_rock() function based on current temperature and pressure. This class can be used in several
-    ways:
+    A Helper that represents a Material that switches between different rocks
+    based on a user specified select_rock() function based on current temperature
+    and pressure. This class can be used in several ways:
     1. By creating an instance and setting select_rock to a lambda that returns a rock
     2. By deriving from this class and implementing select_rock.
     """
+
     def __init__(self):
         self.current_rock = None
         Material.__init__(self)
 
     def select_rock(self):
         raise NotImplementedError("Need to implement select_rock() in derived class!")
 
@@ -124,34 +125,47 @@
     @material_property
     def molar_heat_capacity_p(self):
         return self.current_rock.molar_heat_capacity_p
 
 
 class HelperLowHighPressureRockTransition(HelperRockSwitcher):
     """
-    A Helper that represents a Material that switches between two given rocks based on a given transition pressure.
+    A Helper that represents a Material that switches between two given rocks based
+    on a given transition pressure.
     """
+
     def __init__(self, transition_pressure, low_pressure_rock, high_pressure_rock):
         self.transition_pressure = transition_pressure
         self.rocks = [low_pressure_rock, high_pressure_rock]
         HelperRockSwitcher.__init__(self)
-        self._name = "HelperLowHighPressureRockTransition("+str(self.transition_pressure)+ " GPa, " + self.rocks[0].name +  ", " + self.rocks[1].name + ")"
+        self._name = (
+            "HelperLowHighPressureRockTransition("
+            + str(self.transition_pressure)
+            + " GPa, "
+            + self.rocks[0].name
+            + ", "
+            + self.rocks[1].name
+            + ")"
+        )
 
     def select_rock(self):
         if self._pressure < self.transition_pressure:
             return self.rocks[0]
         else:
             return self.rocks[1]
 
     def set_method(self, method):
         for r in self.rocks:
             r.set_method(method)
 
     def debug_print(self, indent=""):
-        print("%sHelperLowHighPressureRockTransition (%f GPa):" % (indent, self.transition_pressure))
+        print(
+            "%sHelperLowHighPressureRockTransition (%f GPa):"
+            % (indent, self.transition_pressure)
+        )
         indent += "  "
         for r in self.rocks:
             r.debug_print(indent)
 
 
 class HelperSpinTransition(Composite):
 
@@ -175,13 +189,13 @@
 
     def debug_print(self, indent=""):
         print("%sHelperSpinTransition:" % indent)
         self.ls_mat.debug_print(indent + "  ")
         self.hs_mat.debug_print(indent + "  ")
 
     def set_state(self, pressure, temperature):
-        if (pressure >= self.transition_pressure):
+        if pressure >= self.transition_pressure:
             Composite.set_fractions(self, [1.0, 0.0])
         else:
             Composite.set_fractions(self, [0.0, 1.0])
 
         Composite.set_state(self, pressure, temperature)
```

### Comparing `burnman-1.1.0/burnman/classes/planet.py` & `burnman-1.2.0/burnman/classes/planet.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,81 +1,78 @@
 from __future__ import print_function
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
 # the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 import numpy as np
 import warnings
 from .material import material_property
 
 
 class Planet(object):
     """
     A class to build (self-consistent) Planets made out of Layers
-    (``burnman.Layer``). By default the planet is set to be self-consistent
+    (:class:`burnman.Layer`). By default the planet is set to be self-consistent
     (with zero pressure at the surface and zero gravity at the center),
     but this can be overwritte using the set_pressure_mode().
     Pressure_modes defined in the individual layers will be ignored.
     If temperature modes are already set for each of the layers, when the
     planet is initialized, the planet will be built immediately.
     """
 
-    def __init__(self, name, layers, n_max_iterations=50,
-                 max_delta=1.e-5, verbose=False):
-        """
-        Parameters
-        ----------
-        name : string
-            Name of planet
-        layers : list of ``burnman.Layer``
-            Layers to build the planet out of
-            (layers are sorted within the planet)
-        n_max_iterations : int
-            Maximum number of iterations to reach self-consistent planet
-            (default = 50)
-        max_delta : float
-            Relative update to the center pressure of the planet between
-            iterations to stop iterations (default = 1.e-5)
+    def __init__(
+        self, name, layers, n_max_iterations=50, max_delta=1.0e-5, verbose=False
+    ):
+        """
+        :param name: Name of planet.
+        :type name: str
+        :param layers: Layers to build the planet out of
+            (layers are sorted within the planet).
+        :type layers: list of :class:`burnman.Layer`
+        :param n_max_iterations: Maximum number of iterations to reach
+            self-consistent planet.
+        :type n_max_iterations: int
+        :param max_delta: Relative update to the center pressure of the planet between
+            iterations to stop iterations.
+        :type max_delta: float
         """
         # sort layers
         self.layers = sorted(layers, key=lambda x: x.inner_radius)
         # assert layers attach to one another
         if len(self.layers) > 1:
             for i in range(1, len(self.layers)):
-                assert(self.layers[i].inner_radius
-                       == self.layers[i - 1].outer_radius)
+                assert self.layers[i].inner_radius == self.layers[i - 1].outer_radius
 
         self.name = name
 
-        self.radii = self.evaluate(['radii'])
+        self.radii = self.evaluate(["radii"])
         self.n_slices = len(self.radii)
         self.radius_planet = max(self.radii)
-        self.volume = 4./3.*np.pi*np.power(self.radius_planet, 3.)
+        self.volume = 4.0 / 3.0 * np.pi * np.power(self.radius_planet, 3.0)
 
         for layer in self.layers:
             layer.n_start = np.where(self.radii == layer.inner_radius)[0][-1]
             layer.n_end = np.where(self.radii == layer.outer_radius)[0][0] + 1
         self._cached = {}
         self.verbose = verbose
-        self.set_pressure_mode(
-            n_max_iterations=n_max_iterations, max_delta=max_delta)
+        self.set_pressure_mode(n_max_iterations=n_max_iterations, max_delta=max_delta)
 
     def __iter__(self):
         """
         Planet object will iterate over Layers.
         """
         return list(self.layers).__iter__()
 
     def __str__(self):
         """
         Prints details of the planet
         """
-        writing = '{0} consists of {1} layers:\n'.format(
-            self.name, len(self.layers))
+        writing = "{0} consists of {1} layers:\n".format(self.name, len(self.layers))
         for layer in self:
             writing = writing + layer.__str__()
         return writing
 
     def reset(self):
         """
         Resets all cached material properties.
@@ -83,33 +80,34 @@
         """
         self._cached = {}
 
     def get_layer(self, name):
         """
         Returns a layer with a given name
 
-        Parameters
-        ----------
-        name : string
-            Given name of a layer
+        :param name: Given name of a layer
+        :type name: str
+
+        :returns: Layer with the given name.
+        :rtype: :class:`burnman.Layer`
         """
         for layer in self.layers:
             if layer.name == name:
                 return layer
         raise LookupError()
 
     def get_layer_by_radius(self, radius):
         """
         Returns a layer in which this radius lies
 
-        Parameters
-        ----------
-        radius : float
-            radius at which to evaluate the layer
+        :param radius: Radius at which to evaluate the layer.
+        :type radius: float
 
+        :returns: Layer in which the radius lies.
+        :rtype: :class:`burnman.Layer`
         """
         for layer in self.layers:
             if layer.outer_radius >= radius:
                 return layer
         raise LookupError()
 
     def evaluate(self, properties, radlist=None):
@@ -117,218 +115,243 @@
         Function that is generally used to evaluate properties
         of the different layers and stitch them together.
         If asking for different radii than the internal radlist,
         pressure and temperature values are interpolated and the
         layer material evaluated at those pressures and
         temperatures.
 
-        Parameters
-        ----------
-        properties : list of strings
-            List of properties to evaluate
-        radlist : array of floats
-            Radii to evaluate properties at. If left empty,
+        :param properties: List of properties to evaluate
+        :type properties: list of strings
+        :param radlist: Radii to evaluate properties at. If left empty,
             internal radius lists are used.
+        :type radlist: array of floats
 
-        Returns
-        -------
-        properties_array : numpy array
-            1D or 2D array of requested properties
+        :returns: 1D or 2D array of requested properties
             (1D if only one property was requested)
+        :rtype: numpy.array
         """
         if radlist is None:
-            values = np.empty([len(properties),
-                               np.sum([len(layer.radii)
-                                       for layer in self.layers])])
+            values = np.empty(
+                [len(properties), np.sum([len(layer.radii) for layer in self.layers])]
+            )
             for i, prop in enumerate(properties):
-                if prop == 'depth':
+                if prop == "depth":
                     values[i] = np.array(
-                        [self.radius_planet - r for layer in self.layers
-                         for r in layer.radii])
+                        [
+                            self.radius_planet - r
+                            for layer in self.layers
+                            for r in layer.radii
+                        ]
+                    )
                 else:
                     j = 0
                     for layer in self.layers:
                         vals = getattr(layer, prop)
-                        values[i, j:j + len(vals)] = vals
+                        values[i, j : j + len(vals)] = vals
                         j += len(vals)
         else:
             values = np.empty([len(properties), len(radlist)])
-            l_idx = [i for i, layer in enumerate(self.layers) for r in radlist
-                     if r >= layer.inner_radius and r <= layer.outer_radius]
+            l_idx = [
+                i
+                for i, layer in enumerate(self.layers)
+                for r in radlist
+                if r >= layer.inner_radius and r <= layer.outer_radius
+            ]
 
             for j, r in enumerate(radlist):
-                values[:, j] = self.layers[l_idx[j]].evaluate(
-                    properties, [r], self.radius_planet).T[0]
+                values[:, j] = (
+                    self.layers[l_idx[j]]
+                    .evaluate(properties, [r], self.radius_planet)
+                    .T[0]
+                )
 
         if values.shape[0] == 1:
             values = values[0]
         return values
 
-    def set_pressure_mode(self, pressure_mode='self-consistent',
-                          pressures=None, pressure_top=0.,
-                          gravity_bottom=0., n_max_iterations=50,
-                          max_delta=1.e-5):
+    def set_pressure_mode(
+        self,
+        pressure_mode="self-consistent",
+        pressures=None,
+        pressure_top=0.0,
+        gravity_bottom=0.0,
+        n_max_iterations=50,
+        max_delta=1.0e-5,
+    ):
         """
         Sets the pressure mode of the planet by user-defined values are in a
         self-consistent fashion.
         pressure_mode is 'user-defined' or 'self-consistent'.
         The default for the planet is self-consistent, with zero pressure at
         the surface and zero pressure at the center.
 
-        Parameters
-        ----------
-        pressure_mode : string
-            This can be set to 'user-defined' or 'self-consistent'
-        pressures : array of floats
-            Pressures (Pa) to set layer to ('user-defined'). This should be the
-            same length as defined radius array for the layer
-        pressure_top : float
-            Pressure (Pa) at the top of the layer.
-        gravity_bottom : float
-            gravity (m/s^2) at the bottom the layer
-        n_max_iterations : int
-            Maximum number of iterations to reach self-consistent pressures
-            (default = 50)
+        :param pressure_mode: This can be set to 'user-defined' or 'self-consistent'.
+        :type pressure_mode: str
+        :param pressures: Pressures (Pa) to set layer to ('user-defined').
+            This should be the same length as defined radius array for the layer.
+        :type pressures: array of floats
+        :param pressure_top: Pressure (Pa) at the top of the layer.
+        :type pressure_top: float
+        :param gravity_bottom: Gravity (m/s^2) at the bottom the layer
+        :type gravity_bottom: float
+        :param n_max_iterations: Maximum number of iterations to reach
+            self-consistent pressures.
+        :type n_max_iterations: int
         """
         self.reset()
-        assert(pressure_mode == 'user-defined' or pressure_mode == 'self-consistent')
+        assert pressure_mode == "user-defined" or pressure_mode == "self-consistent"
 
         self.pressure_mode = pressure_mode
         self.gravity_bottom = gravity_bottom
 
-        if pressure_mode == 'user-defined':
-            assert(len(pressures) == len(self.radii))
+        if pressure_mode == "user-defined":
+            assert len(pressures) == len(self.radii)
             self._pressures = pressures
-            warnings.warn('User-defined pressures mean that the planet is '
-                          'unlikely to be self-consistent')
+            warnings.warn(
+                "User-defined pressures mean that the planet is "
+                "unlikely to be self-consistent"
+            )
 
-        if pressure_mode == 'self-consistent':
+        if pressure_mode == "self-consistent":
             self.pressure_top = pressure_top
             self.n_max_iterations = n_max_iterations
             self.max_delta = max_delta
 
     def make(self):
         """
-        This routine needs to be called before evaluating any properties. If pressures and temperatures are self-consistent, they
-        are computed across the planet here. Also initializes an array of materials in each Layer to compute properties from.
+        This routine needs to be called before evaluating any properties.
+        If pressures and temperatures are self-consistent, they
+        are computed across the planet here. Also initializes an array of materials
+        in each Layer to compute properties from.
         """
 
         self.reset()
         for layer in self.layers:
-            assert(layer.temperature_mode is not None)
+            assert layer.temperature_mode is not None
 
-        if self.pressure_mode == 'user-defined':
+        if self.pressure_mode == "user-defined":
             self._temperatures = self._evaluate_temperature(self._pressures)
 
-        if self.pressure_mode == 'self-consistent':
-
-            new_press = self.pressure_top + \
-                (-self.radii + max(self.radii)) * \
-                1.e3  # initial pressure curve guess
+        if self.pressure_mode == "self-consistent":
+            new_press = (
+                self.pressure_top + (-self.radii + max(self.radii)) * 1.0e3
+            )  # initial pressure curve guess
             temperatures = self._evaluate_temperature(new_press)
 
             # Make it self-consistent!!!
             i = 0
             while i < self.n_max_iterations:
                 i += 1
                 ref_press = new_press
-                new_grav, new_press = self._evaluate_eos(new_press,
-                                                         temperatures,
-                                                         self.gravity_bottom,
-                                                         self.pressure_top)
+                new_grav, new_press = self._evaluate_eos(
+                    new_press, temperatures, self.gravity_bottom, self.pressure_top
+                )
                 temperatures = self._evaluate_temperature(new_press)
-                rel_err = abs((max(ref_press) - max(new_press))
-                              / max(new_press))
+                rel_err = abs((max(ref_press) - max(new_press)) / max(new_press))
                 if self.verbose:
-                    print(f'Iteration {i:0d} maximum relative pressure error: '
-                          f'{rel_err:.1e}')
+                    print(
+                        f"Iteration {i:0d} maximum relative pressure error: "
+                        f"{rel_err:.1e}"
+                    )
 
                 if rel_err < self.max_delta:
                     break
 
             self.pressures = new_press
             self.temperatures = temperatures
             self._gravity = new_grav
 
         for layer in self.layers:
             layer.sublayers = []
-            layer.pressures = self.pressures[layer.n_start: layer.n_end]
-            layer.temperatures = self.temperatures[layer.n_start: layer.n_end]
+            layer.pressures = self.pressures[layer.n_start : layer.n_end]
+            layer.temperatures = self.temperatures[layer.n_start : layer.n_end]
             layer.gravity_bottom = self._gravity[layer.n_start - 1]
-            layer.pressure_mode = 'set-in-planet'
+            layer.pressure_mode = "set-in-planet"
             for i in range(len(layer.radii)):
                 layer.sublayers.append(layer.material.copy())
-                layer.sublayers[i].set_state(
-                    layer.pressures[i], layer.temperatures[i])
+                layer.sublayers[i].set_state(layer.pressures[i], layer.temperatures[i])
 
-    def _evaluate_eos(self, pressures, temperatures,
-                      gravity_bottom, pressure_top):
+    def _evaluate_eos(self, pressures, temperatures, gravity_bottom, pressure_top):
         """
         Used to update the pressure profile in set_state()
         """
         density = self._evaluate_density(pressures, temperatures)
         grav = self._compute_gravity(density, gravity_bottom)
         press = self._compute_pressure(density, grav, pressure_top)
         return grav, press
 
     def _evaluate_density(self, pressures, temperatures):
         """
         Used to update the density profile in _evaluate_eos()
         """
         density = []
         for layer in self.layers:
-            density.append(layer.material.evaluate(['density'],
-                                                   pressures[layer.n_start:layer.n_end],
-                                                   temperatures[layer.n_start:layer.n_end]))
+            density.append(
+                layer.material.evaluate(
+                    ["density"],
+                    pressures[layer.n_start : layer.n_end],
+                    temperatures[layer.n_start : layer.n_end],
+                )
+            )
         return np.squeeze(np.hstack(density))
 
     def _evaluate_temperature(self, pressures):
         """
         Returns the temperatures of different layers for given pressures.
         Used by set_state()
         """
         temps = []
         temperature_top = None
         for layer in self.layers[::-1]:
             if temperature_top is None or layer.temperature_top is not None:
                 temperature_top = layer.temperature_top
-            temps.extend(layer._evaluate_temperature(
-                (pressures[layer.n_start:layer.n_end]), temperature_top)[::-1])
+            temps.extend(
+                layer._evaluate_temperature(
+                    (pressures[layer.n_start : layer.n_end]), temperature_top
+                )[::-1]
+            )
             temperature_top = temps[-1]
         return np.hstack(np.squeeze(temps))[::-1]
 
     def _compute_gravity(self, density, gravity_bottom):
         """
         Calculate the gravity of the planet, based on a density profile.
         This integrates Poisson's equation in radius, under the assumption
         that the planet is laterally homogeneous.
         Used to update the gravity profile in _evaluate_eos()
         """
 
         start_gravity = gravity_bottom
         grav = []
         for layer in self.layers:
-            grav.extend(layer._compute_gravity(
-                density[layer.n_start: layer.n_end], start_gravity))
+            grav.extend(
+                layer._compute_gravity(
+                    density[layer.n_start : layer.n_end], start_gravity
+                )
+            )
             start_gravity = grav[-1]
 
         return np.array(grav)
 
     def _compute_pressure(self, density, gravity, pressure_top):
         """
         Calculate the pressure profile based on density and gravity.
         This integrates the equation for hydrostatic equilibrium P = rho g z.
         Used to update the pressure profile in _evaluate_eos()
         """
         start_pressure = pressure_top
         press = []
         for layer in self.layers[::-1]:
-            press.extend(layer._compute_pressure(density[layer.n_start:layer.n_end],
-                                                 gravity[layer.n_start: layer.n_end],
-                                                 start_pressure)[::-1])
+            press.extend(
+                layer._compute_pressure(
+                    density[layer.n_start : layer.n_end],
+                    gravity[layer.n_start : layer.n_end],
+                    start_pressure,
+                )[::-1]
+            )
             start_pressure = press[-1]
         return np.array(press)[::-1]
 
     @property
     def mass(self):
         """
         calculates the mass of the entire planet [kg]
@@ -336,390 +359,347 @@
         return np.sum([layer.mass for layer in self.layers])
 
     @property
     def average_density(self):
         """
         calculates the average density of the entire planet [kg/m^3]
         """
-        return self.mass/self.volume
+        return self.mass / self.volume
 
     @property
     def moment_of_inertia(self):
         """
         #Returns the moment of inertia of the planet [kg m^2]
         """
         return np.sum([layer.moment_of_inertia for layer in self.layers])
 
     @property
     def moment_of_inertia_factor(self):
         """
         #Returns the moment of inertia of the planet [kg m^2]
         """
-        moment_factor = self.moment_of_inertia / self.mass / \
-            self.radius_planet / self.radius_planet
+        moment_factor = (
+            self.moment_of_inertia / self.mass / self.radius_planet / self.radius_planet
+        )
         return moment_factor
 
     @property
     def depth(self):
         """
         Returns depth of the layer [m]
         """
-        return self.evaluate(['depth'])
+        return self.evaluate(["depth"])
 
     @property
     def gravity(self):
         """
         Returns gravity of the layer [m s^(-2)]
         """
-        return self.evaluate(['gravity'])
+        return self.evaluate(["gravity"])
 
     @property
     def bullen(self):
         """
         Returns the Bullen parameter
         """
-        return self.evaluate(['bullen'])
+        return self.evaluate(["bullen"])
 
     @property
     def brunt_vasala(self):
-        return self.evaluate(['brunt_vasala'])
+        return self.evaluate(["brunt_vasala"])
 
     @property
     def pressure(self):
         """
         Returns current pressure that was set with
         :func:`~burnman.Material.set_state`.
 
         Aliased with :func:`~burnman.Material.P`.
 
-        Returns
-        -------
-        pressure : array of floats
-            Pressure in [Pa].
+        :returns: Pressure in [Pa].
+        :rtype: array of floats
         """
         return self.pressures
 
     @property
     def temperature(self):
         """
         Returns current temperature that was set with
         :func:`~burnman.Material.set_state`.
 
         Aliased with :func:`~burnman.Material.T`.
 
-        Returns
-        -------
-        temperature : array of floats
-            Temperature in [K].
+        :returns: Temperature in [K].
+        :rtype: array of floats
         """
         return self.temperatures
 
     @material_property
     def molar_internal_energy(self):
         """
         Returns the molar internal energy of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.energy`.
 
-        Returns
-        -------
-        molar_internal_energy : array of floats
-            The internal energy in [J/mol].
+        :returns: The internal energy in [J/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_internal_energy'])
+        return self.evaluate(["molar_internal_energy"])
 
     @material_property
     def molar_gibbs(self):
         """
         Returns the molar Gibbs free energy of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.gibbs`.
 
-        Returns
-        -------
-        molar_gibbs : array of floats
-            Gibbs free energy in [J/mol].
+        :returns: Gibbs energy in [J/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_gibbs'])
+        return self.evaluate(["molar_gibbs"])
 
     @material_property
     def molar_helmholtz(self):
         """
         Returns the molar Helmholtz free energy of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.helmholtz`.
 
-        Returns
-        -------
-        molar_helmholtz : array of floats
-            Helmholtz free energy in [J/mol].
+        :returns: Helmholtz energy in [J/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_helmholtz'])
+        return self.evaluate(["molar_helmholtz"])
 
     @material_property
     def molar_mass(self):
         """
         Returns molar mass of the planet.
 
         Needs to be implemented in derived classes.
 
-        Returns
-        -------
-        molar_mass : array of floats
-            Molar mass in [kg/mol].
+        :returns: Molar mass in [kg/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_mass'])
+        return self.evaluate(["molar_mass"])
 
     @material_property
     def molar_volume(self):
         """
         Returns molar volume of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.V`.
 
-        Returns
-        -------
-        molar_volume : array of floats
-            Molar volume in [m^3/mol].
+        :returns: Molar volume in [m^3/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_volume'])
+        return self.evaluate(["molar_volume"])
 
     @material_property
     def density(self):
         """
         Returns the density of this planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.rho`.
 
-        Returns
-        -------
-        density : array of floats
-            The density of this material in [kg/m^3].
+        :returns: The density of this material in [kg/m^3].
+        :rtype: array of floats
         """
-        return self.evaluate(['density'])
+        return self.evaluate(["density"])
 
     @material_property
     def molar_entropy(self):
         """
         Returns molar entropy of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.S`.
 
-        Returns
-        -------
-        molar_entropy : array of floats
-            Entropy in [J/mol].
+        :returns: Entropy in [J/K/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_entropy'])
+        return self.evaluate(["molar_entropy"])
 
     @material_property
     def molar_enthalpy(self):
         """
         Returns molar enthalpy of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.H`.
 
-        Returns
-        -------
-        molar_enthalpy : array of floats
-            Enthalpy in [J/mol].
+        :returns: Enthalpy in [J/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_enthalpy'])
+        return self.evaluate(["molar_enthalpy"])
 
     @material_property
     def isothermal_bulk_modulus(self):
         """
         Returns isothermal bulk modulus of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.K_T`.
 
-        Returns
-        -------
-        isothermal_bulk_modulus : array of floats
-            Bulk modulus in [Pa].
+        :returns: Isothermal bulk modulus in [Pa].
+        :rtype: array of floats
         """
-        return self.evaluate(['isothermal_bulk_modulus'])
+        return self.evaluate(["isothermal_bulk_modulus"])
 
     @material_property
     def adiabatic_bulk_modulus(self):
         """
         Returns the adiabatic bulk modulus of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.K_S`.
 
-        Returns
-        -------
-        adiabatic_bulk_modulus : array of floats
-            Adiabatic bulk modulus in [Pa].
+        :returns: Adiabatic bulk modulus in [Pa].
+        :rtype: array of floats
         """
-        return self.evaluate(['adiabatic_bulk_modulus'])
+        return self.evaluate(["adiabatic_bulk_modulus"])
 
     @material_property
     def isothermal_compressibility(self):
         """
         Returns isothermal compressibility of the planet
         (or inverse isothermal bulk modulus).
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.beta_T`.
 
-        Returns
-        -------
-        (K_T)^-1 : array of floats
-            Compressibility in [1/Pa].
+        :returns: Isothermal compressibility in [1/Pa].
+        :rtype: array of floats
         """
-        return self.evaluate(['istothermal_compressibility'])
+        return self.evaluate(["istothermal_compressibility"])
 
     @material_property
     def adiabatic_compressibility(self):
         """
         Returns adiabatic compressibility of the planet
         (or inverse adiabatic bulk modulus).
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.beta_S`.
 
-        Returns
-        -------
-        adiabatic_compressibility : array of floats
-            adiabatic compressibility in [1/Pa].
+        :returns: Adiabatic compressibility in [1/Pa].
+        :rtype: array of floats
         """
-        return self.evaluate(['adiabatic_compressibility'])
+        return self.evaluate(["adiabatic_compressibility"])
 
     @material_property
     def shear_modulus(self):
         """
         Returns shear modulus of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.beta_G`.
 
-        Returns
-        -------
-        shear_modulus : array of floats
-            Shear modulus in [Pa].
+        :returns: Shear modulus in [Pa].
+        :rtype: array of floats
         """
-        return self.evaluate(['shear_modulus'])
+        return self.evaluate(["shear_modulus"])
 
     @material_property
     def p_wave_velocity(self):
         """
         Returns P wave speed of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.v_p`.
 
-        Returns
-        -------
-        p_wave_velocity : array of floats
-            P wave speed in [m/s].
+        :returns: P wave speed in [m/s].
+        :rtype: array of floats
         """
-        return self.evaluate(['p_wave_velocity'])
+        return self.evaluate(["p_wave_velocity"])
 
     @material_property
     def bulk_sound_velocity(self):
         """
         Returns bulk sound speed of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.v_phi`.
 
-        Returns
-        -------
-        bulk sound velocity: array of floats
-            Sound velocity in [m/s].
+        :returns: Bulk sound velocity in [m/s].
+        :rtype: array of floats
         """
-        return self.evaluate(['bulk_sound_velocity'])
+        return self.evaluate(["bulk_sound_velocity"])
 
     @material_property
     def shear_wave_velocity(self):
         """
         Returns shear wave speed of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.v_s`.
 
-        Returns
-        -------
-        shear_wave_velocity : array of floats
-            Wave speed in [m/s].
+        :returns: Shear wave speed in [m/s].
+        :rtype: array of floats
         """
-        return self.evaluate(['shear_wave_velocity'])
+        return self.evaluate(["shear_wave_velocity"])
 
     @material_property
     def grueneisen_parameter(self):
         """
         Returns the grueneisen parameter of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.gr`.
 
-        Returns
-        -------
-        gr : array of floats
-            Grueneisen parameters [unitless].
+        :returns: Grueneisen parameters [unitless].
+        :rtype: array of floats
         """
-        return self.evaluate(['grueneisen_parameter'])
+        return self.evaluate(["grueneisen_parameter"])
 
     @material_property
     def thermal_expansivity(self):
         """
         Returns thermal expansion coefficient of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.alpha`.
 
-        Returns
-        -------
-        alpha : array of floats
-            Thermal expansivity in [1/K].
+        :returns: Thermal expansivity in [1/K].
+        :rtype: array of floats
         """
-        return self.evaluate(['thermal_expansivity'])
+        return self.evaluate(["thermal_expansivity"])
 
     @material_property
     def molar_heat_capacity_v(self):
         """
         Returns molar heat capacity at constant volume of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.C_v`.
 
-        Returns
-        -------
-        molar_heat_capacity_v : array of floats
-            Heat capacity in [J/K/mol].
+        :returns: Isochoric heat capacity in [J/K/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_heat_capacity_v'])
+        return self.evaluate(["molar_heat_capacity_v"])
 
     @material_property
     def molar_heat_capacity_p(self):
         """
         Returns molar heat capacity at constant pressure of the planet.
 
         Needs to be implemented in derived classes.
         Aliased with :func:`~burnman.Material.C_p`.
 
-        Returns
-        -------
-        molar_heat_capacity_p : array of floats
-            Heat capacity in [J/K/mol].
+        :returns: Isobaric heat capacity in [J/K/mol].
+        :rtype: array of floats
         """
-        return self.evaluate(['molar_heat_capacity_p'])
+        return self.evaluate(["molar_heat_capacity_p"])
 
-#
-# Aliased properties
+    #
+    # Aliased properties
     @property
     def P(self):
         """Alias for :func:`~burnman.Material.pressure`"""
         return self.pressure
 
     @property
     def T(self):
```

### Comparing `burnman-1.1.0/burnman/classes/polytope.py` & `burnman-1.2.0/burnman/classes/polytope.py`

 * *Files 5% similar despite different names*

```diff
@@ -14,18 +14,20 @@
 from copy import copy
 
 from .material import cached_property
 
 from ..utils.math import independent_row_indices
 
 try:
-    cdd = importlib.import_module('cdd')
+    cdd = importlib.import_module("cdd")
 except ImportError as err:
-    print(f'Warning: {err}. '
-          'For full functionality of BurnMan, please install pycddlib.')
+    print(
+        f"Warning: {err}. "
+        "For full functionality of BurnMan, please install pycddlib."
+    )
 
 
 class SimplexGrid(object):
     """
     A class that creates objects that can efficiently generate a set of points
     that grid a simplex with a user-defined number of vertices. The class
     contains both a generator method and a grid method. It also contains
@@ -36,145 +38,144 @@
     """
 
     def __init__(self, vertices, points_per_edge):
         """
         Initialize SimplexGrid object with the desired number of vertices
         and points per edge.
         """
-        assert vertices >= 2, 'need at least two vertices'
-        assert points_per_edge >= 2, 'need at least 2 points per edge'
+        assert vertices >= 2, "need at least two vertices"
+        assert points_per_edge >= 2, "need at least 2 points per edge"
 
         self.vertices = vertices
         self.points_per_edge = points_per_edge
 
-    def generate(self, generate_type='list'):
+    def generate(self, generate_type="list"):
         """
         Generates the grid points of the simplex in lexicographic order.
 
-        Parameters
-        ----------
-        generate_type : 'list' or 'array'
-            Determines whether the generator returns lists or arrays
-            corresponding to each point in the simplex grid.
-
-        Returns
-        -------
-        generator of lists or ndarrays (int, ndim=1)
-            Grid points of the simplex.
+        :param generate_type: Determines whether the generator returns
+            lists or arrays corresponding to each point in the simplex grid.
+            Valid options are 'list' or 'array'.
+        :type generate_type: str
+
+        :returns: Grid points of the simplex.
+        :rtype: generator of lists or ndarrays (int, ndim=1)
         """
 
-        if generate_type == 'list':
-            x = [0]*self.vertices
-        elif generate_type == 'array':
+        if generate_type == "list":
+            x = [0] * self.vertices
+        elif generate_type == "array":
             x = np.zeros(self.vertices, dtype=int)
         else:
-            raise Exception('generate_type must be of type list or array.')
+            raise Exception("generate_type must be of type list or array.")
 
-        x[self.vertices-1] = self.points_per_edge-1
+        x[self.vertices - 1] = self.points_per_edge - 1
 
         h = self.vertices
         while True:
             yield copy(x)
 
             h -= 1
             if h == 0:
                 return
 
             val = x[h]
             x[h] = 0
-            x[self.vertices-1] = val - 1
-            x[h-1] += 1
+            x[self.vertices - 1] = val - 1
+            x[h - 1] += 1
             if val != 1:
                 h = self.vertices
 
-    def grid(self, generate_type='list'):
+    def grid(self, generate_type="list"):
         """
         Returns either a list or a numpy array
         corresponding the the points in the simplex grid, depending on
         whether the user chooses 'list' (default) or 'array' as
         the generate_type parameter.
         """
-        if generate_type == 'list':
+        if generate_type == "list":
             return list(self.generate(generate_type))
-        elif generate_type == 'array':
+        elif generate_type == "array":
             return np.array(list(self.generate(generate_type)))
         else:
-            raise Exception('generate_type must be of type list or array.')
+            raise Exception("generate_type must be of type list or array.")
 
     def n_points(self):
         """
         The number of points corresponding to the number of vertices and
         points per edge chosen by the user.
         """
-        return comb(self.vertices+self.points_per_edge-2,
-                    self.vertices-1, exact=True)
+        return comb(
+            self.vertices + self.points_per_edge - 2, self.vertices - 1, exact=True
+        )
 
 
 class MaterialPolytope(object):
     """
     A class that can be instantiated to create pycddlib polytope objects.
     These objects can be interrogated to provide the vertices satisfying the
     input constraints.
 
     This class is available as :class:`burnman.polytope.MaterialPolytope`.
     """
 
-    def __init__(self, equalities,
-                 inequalities,
-                 number_type='fraction',
-                 return_fractions=False,
-                 independent_endmember_occupancies=None):
+    def __init__(
+        self,
+        equalities,
+        inequalities,
+        number_type="fraction",
+        return_fractions=False,
+        independent_endmember_occupancies=None,
+    ):
         """
         Initialization function for the MaterialPolytope class.
         Declares basis attributes of the class.
 
-        Parameters
-        ----------
-        equalities: 2D numpy array
-            A numpy array containing all the equalities of the polytope.
-            Each row should evaluate to 0.
-        inequalities: 2D numpy array
-            A numpy array containing all the inequalities of the polytope.
-            Each row should evaluate to <= 0.
-        number_type: 'fraction' or 'float' (default is 'fraction')
-            Whether pycddlib should read the input arrays as
-            fractions or floats.
-        return_fractions : boolean (default is False)
-            Whether the generated polytope object should return fractions or
-            floats.
-        independent_endmember_occupancies : 2D numpy array (or None)
-            If specified, this array provides the independent endmember set
-            against which the dependent endmembers are defined.
+        :param equalities: A numpy array containing all the
+            equalities defining the polytope. Each row should evaluate to 0.
+        :type equalities: numpy.array (2D)
+        :param inequalities: A numpy array containing all the inequalities
+            defining the polytope. Each row should evaluate to <= 0.
+        :type inequalities: numpy.array (2D)
+        :param number_type: Whether pycddlib should read the input arrays as
+            fractions or floats. Valid options are 'fraction' or 'float'.
+        :type number_type: str
+        :param return_fractions: Choose whether the generated polytope object
+            should return fractions or floats.
+        :type return_fractions: bool
+        :param independent_endmember_occupancies: If specified, this array provides
+            the independent endmember set against which the dependent endmembers
+            are defined.
+        :type independent_endmember_occupancies: numpy.array (2D) or None
         """
         self.set_return_type(return_fractions)
         self.equality_matrix = equalities[:, 1:]
         self.equality_vector = -equalities[:, 0]
 
-        self.polytope_matrix = cdd.Matrix(equalities, linear=True,
-                                          number_type=number_type)
+        self.polytope_matrix = cdd.Matrix(
+            equalities, linear=True, number_type=number_type
+        )
         self.polytope_matrix.rep_type = cdd.RepType.INEQUALITY
         self.polytope_matrix.extend(inequalities, linear=False)
         self.polytope = cdd.Polyhedron(self.polytope_matrix)
 
         if independent_endmember_occupancies is not None:
             self.independent_endmember_occupancies = independent_endmember_occupancies
 
     def set_return_type(self, return_fractions=False):
         """
         Sets the return_type for the polytope object. Also deletes the cached
         endmember_occupancies property.
 
-        Parameters
-        ----------
-        return_fractions : boolean (default is False)
-            Whether the generated polytope object should return fractions or
-            floats.
+        :param return_fractions: Choose whether the generated polytope object
+            should return fractions or floats.
+        :type return_fractions: bool
         """
         try:
-            del self.__dict__['endmember_occupancies']
+            del self.__dict__["endmember_occupancies"]
         except KeyError:
             pass
         self.return_fractions = return_fractions
 
     @cached_property
     def raw_vertices(self):
         """
@@ -201,28 +202,33 @@
     @cached_property
     def endmember_occupancies(self):
         """
         Return the endmember occupancies
         (a processed list of all of the vertex locations).
         """
         if self.return_fractions:
-            if self.polytope.number_type == 'fraction':
-                v = np.array([[Fraction(value) for value in v]
-                              for v in self.raw_vertices])
+            if self.polytope.number_type == "fraction":
+                v = np.array(
+                    [[Fraction(value) for value in v] for v in self.raw_vertices]
+                )
             else:
-                v = np.array([[Rational(value).limit_denominator(1000000)
-                               for value in v]
-                              for v in self.raw_vertices])
+                v = np.array(
+                    [
+                        [Rational(value).limit_denominator(1000000) for value in v]
+                        for v in self.raw_vertices
+                    ]
+                )
         else:
-            v = np.array([[float(value) for value in v]
-                          for v in self.raw_vertices])
+            v = np.array([[float(value) for value in v] for v in self.raw_vertices])
 
         if len(v.shape) == 1:
-            raise ValueError("The combined equality and positivity "
-                             "constraints result in a null polytope.")
+            raise ValueError(
+                "The combined equality and positivity "
+                "constraints result in a null polytope."
+            )
 
         return v[:, 1:] / v[:, 0, np.newaxis]
 
     @cached_property
     def independent_endmember_occupancies(self):
         """
         Return an independent set of endmember occupancies
@@ -235,29 +241,35 @@
     def endmembers_as_independent_endmember_amounts(self):
         """
         Return a list of all the endmembers as a linear sum of
         the independent endmembers.
         """
         ind = self.independent_endmember_occupancies
 
-        sol = np.linalg.lstsq(np.array(ind.T).astype(float),
-                              np.array(self.endmember_occupancies.T).astype(
-                                  float),
-                              rcond=0)[0].round(decimals=12).T
+        sol = (
+            np.linalg.lstsq(
+                np.array(ind.T).astype(float),
+                np.array(self.endmember_occupancies.T).astype(float),
+                rcond=0,
+            )[0]
+            .round(decimals=12)
+            .T
+        )
         return sol
 
     def _decompose_vertices_into_simplices(self, vertices):
         """
         Decomposes a set of vertices into simplices by Delaunay triangulation.
         """
         # Delaunay triangulation only works in dimensions > 1
         # and we remove the nullspace (sum(fractions) = 1)
         if len(vertices) > 2:
-            nulls = np.repeat(vertices[:, -1],
-                              vertices.shape[1]).reshape(vertices.shape)
+            nulls = np.repeat(vertices[:, -1], vertices.shape[1]).reshape(
+                vertices.shape
+            )
             tri = Delaunay((vertices - nulls)[:, :-1])
             return tri.simplices
         else:
             return [[0, 1]]
 
     @cached_property
     def independent_endmember_polytope(self):
@@ -265,26 +277,27 @@
         Returns the polytope expressed in terms of proportions of the
         independent endmembers. The polytope involves the first
         n-1 independent endmembers. The last endmember proportion makes
         the sum equal to one.
         """
         arr = self.endmembers_as_independent_endmember_amounts
         arr = np.hstack((np.ones((len(arr), 1)), arr[:, :-1]))
-        M = cdd.Matrix(arr, number_type='fraction')
+        M = cdd.Matrix(arr, number_type="fraction")
         M.rep_type = cdd.RepType.GENERATOR
         return cdd.Polyhedron(M)
 
     @cached_property
     def independent_endmember_limits(self):
         """
         Gets the limits of the polytope as a function of the independent
         endmembers.
         """
-        return np.array(self.independent_endmember_polytope.get_inequalities(),
-                        dtype=float)
+        return np.array(
+            self.independent_endmember_polytope.get_inequalities(), dtype=float
+        )
 
     def subpolytope_from_independent_endmember_limits(self, limits):
         """
         Returns a smaller polytope by applying additional limits to the amounts
         of the independent endmembers.
         """
         modified_limits = self.independent_endmember_polytope.get_inequalities().copy()
@@ -296,93 +309,118 @@
         Returns a smaller polytope by applying additional limits to the
         individual site occupancies.
         """
         modified_limits = self.polytope_matrix.copy()
         modified_limits.extend(limits, linear=False)
         return cdd.Polyhedron(modified_limits)
 
-    def grid(self, points_per_edge=2, unique_sorted=True,
-             grid_type='independent endmember proportions', limits=None):
+    def grid(
+        self,
+        points_per_edge=2,
+        unique_sorted=True,
+        grid_type="independent endmember proportions",
+        limits=None,
+    ):
         """
         Create a grid of points which span the polytope.
 
-        Parameters
-        ----------
-        points_per_edge : integer (default is 2)
-            Number of points per edge of the polytope.
-        unique_sorted : boolean (default is True)
-            The gridding is done by splitting the polytope into
+        :param points_per_edge: Number of points per edge of the polytope.
+        :type points_per_edge: int
+        :param unique_sorted: The gridding is done by splitting the polytope into
             a set of simplices. This means that points will be duplicated along
             vertices, faces etc. If unique_sorted is True, this function
             will sort and make the points unique. This is an expensive
             operation for large polytopes, and may not always be necessary.
-        grid_type : 'independent endmember proportions' (default) or 'site occupancies'
-            Whether to grid the polytope in terms of
+        :type unique_sorted: bool
+        :param grid_type: Whether to grid the polytope in terms of
             independent endmember proportions or site occupancies.
-        limits : 2D numpy array
-            Additional inequalities restricting the gridded area of the polytope.
-        Returns
-        -------
-        points : 2D numpy array
-            A list of points gridding the polytope.
+            Choices are 'independent endmember proportions' or 'site occupancies'
+        :type grid_type: str
+        :param limits: Additional inequalities restricting the
+            gridded area of the polytope.
+        :type limits: numpy.array (2D)
+
+        :returns: A list of points gridding the polytope.
+        :rtype: numpy.array (2D)
         """
         if limits is None:
-            if grid_type == 'independent endmember proportions':
-                f_occ = (self.endmembers_as_independent_endmember_amounts
-                         / (points_per_edge - 1))
-            elif grid_type == 'site occupancies':
-                f_occ = self.endmember_occupancies/(points_per_edge-1)
+            if grid_type == "independent endmember proportions":
+                f_occ = self.endmembers_as_independent_endmember_amounts / (
+                    points_per_edge - 1
+                )
+            elif grid_type == "site occupancies":
+                f_occ = self.endmember_occupancies / (points_per_edge - 1)
             else:
-                raise Exception('grid type not recognised. Should be one of '
-                                'independent endmember proportions '
-                                'or site occupancies')
+                raise Exception(
+                    "grid type not recognised. Should be one of "
+                    "independent endmember proportions "
+                    "or site occupancies"
+                )
 
             simplices = self._decompose_vertices_into_simplices(
-                self.endmembers_as_independent_endmember_amounts)
+                self.endmembers_as_independent_endmember_amounts
+            )
         else:
-            if grid_type == 'independent endmember proportions':
-                ppns = np.array(self.subpolytope_from_independent_endmember_limits(
-                    limits).get_generators()[:])[:, 1:]
-                last_ppn = np.array([1. - sum(p)
-                                    for p in ppns]).reshape((len(ppns), 1))
+            if grid_type == "independent endmember proportions":
+                ppns = np.array(
+                    self.subpolytope_from_independent_endmember_limits(
+                        limits
+                    ).get_generators()[:]
+                )[:, 1:]
+                last_ppn = np.array([1.0 - sum(p) for p in ppns]).reshape(
+                    (len(ppns), 1)
+                )
                 vertices_as_independent_endmember_proportions = np.hstack(
-                    (ppns, last_ppn))
-                f_occ = vertices_as_independent_endmember_proportions / \
-                    (points_per_edge-1)
-
-            elif grid_type == 'site occupancies':
-                occ = np.array(self.subpolytope_from_site_occupancy_limits(
-                    limits).get_generators()[:])[:, 1:]
-                f_occ = occ/(points_per_edge-1)
+                    (ppns, last_ppn)
+                )
+                f_occ = vertices_as_independent_endmember_proportions / (
+                    points_per_edge - 1
+                )
+
+            elif grid_type == "site occupancies":
+                occ = np.array(
+                    self.subpolytope_from_site_occupancy_limits(
+                        limits
+                    ).get_generators()[:]
+                )[:, 1:]
+                f_occ = occ / (points_per_edge - 1)
 
                 ind = self.independent_endmember_occupancies
 
-                vertices_as_independent_endmember_proportions = np.linalg.lstsq(np.array(ind.T).astype(float),
-                                                                                np.array(occ.T).astype(
-                                                                                    float),
-                                                                                rcond=None)[0].round(decimals=12).T
+                vertices_as_independent_endmember_proportions = (
+                    np.linalg.lstsq(
+                        np.array(ind.T).astype(float),
+                        np.array(occ.T).astype(float),
+                        rcond=None,
+                    )[0]
+                    .round(decimals=12)
+                    .T
+                )
             else:
-                raise Exception('grid_type not recognised. '
-                                'Should be one of '
-                                'independent endmember proportions '
-                                'or site occupancies')
+                raise Exception(
+                    "grid_type not recognised. "
+                    "Should be one of "
+                    "independent endmember proportions "
+                    "or site occupancies"
+                )
 
             simplices = self._decompose_vertices_into_simplices(
-                vertices_as_independent_endmember_proportions)
+                vertices_as_independent_endmember_proportions
+            )
 
         n_ind = f_occ.shape[1]
         n_simplices = len(simplices)
         dim = len(simplices[0])
         simplex_grid = SimplexGrid(dim, points_per_edge)
-        grid = simplex_grid.grid('array')
+        grid = simplex_grid.grid("array")
         points_per_simplex = simplex_grid.n_points()
-        n_points = n_simplices*points_per_simplex
+        n_points = n_simplices * points_per_simplex
 
         points = np.empty((n_points, n_ind))
         idx = 0
         for i in range(0, n_simplices):
-            points[idx:idx+points_per_simplex] = grid.dot(f_occ[simplices[i]])
+            points[idx : idx + points_per_simplex] = grid.dot(f_occ[simplices[i]])
             idx += points_per_simplex
 
         if unique_sorted:
             points = np.unique(points, axis=0)
         return points
```

### Comparing `burnman-1.1.0/burnman/classes/seismic.py` & `burnman-1.2.0/burnman/classes/seismic.py`

 * *Files 9% similar despite different names*

```diff
@@ -11,230 +11,185 @@
 import scipy.integrate
 
 from ..utils.misc import read_table
 from .. import constants
 
 
 class Seismic1DModel(object):
-
     """
     Base class for all the seismological models.
     """
 
     def __init__(self):
         pass
 
     def evaluate(self, vars_list, depth_list=None):
         """
         Returns the lists of data for a Seismic1DModel for the depths provided
 
-        Parameters
-        ----------
-        vars_list : array of str
-            Available variables depend on the seismic model, and can be chosen from 'pressure','density','gravity','v_s','v_p','v_phi','G','K','QG','QK'
-        depth_list : array of floats
-            Array of depths [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        Array of values shapes as (len(vars_list),len(depth_list)).
+        :param vars_list: Available variables depend on the seismic model,
+            and can be chosen from 'pressure', 'density', 'gravity',
+            'v_s', 'v_p', 'v_phi', 'G', 'K', 'QG' and 'QK'.
+        :type vars_list: array of str
+        :param depth_list: Array of depths [m] to evaluate seismic model at.
+        :type depth_list: array of floats
 
+        :returns: Array of values shapes as (len(vars_list),len(depth_list)).
+        :rtype: numpy.array
         """
         if depth_list is None:
             depth_list = self.internal_depth_list()
         values = np.empty((len(vars_list), len(depth_list)))
         for a in range(len(vars_list)):
             values[a, :] = getattr(self, vars_list[a])(depth_list)
         return values
 
-    def internal_depth_list(self, mindepth=0., maxdepth=1.e99, discontinuity_interval=1.):
-        """
-        Returns a sorted list of depths where this seismic data is specified at. This allows you to compare the seismic data without interpolation. The depths can be bounded by the mindepth and maxdepth parameters.
+    def internal_depth_list(
+        self, mindepth=0.0, maxdepth=1.0e99, discontinuity_interval=1.0
+    ):
+        """
+        Returns a sorted list of depths at which this seismic data is specified.
+        This allows you to compare the seismic data without interpolation.
+        The depths can be bounded by the mindepth and maxdepth parameters.
+
+        :param mindepth: Minimum depth value to be returned [m].
+        :type mindepth: float
+        :param maxdepth: Maximum depth value to be returned [m].
+        :type maxdepth: float
+        :param discontinuity_interval: Shift continuities to remove
+            ambigious values for depth [m].
+        :type discontinuity_interval: float
 
-        Parameters
-        ----------
-        mindepth  :  float
-            Minimum depth value to be returned [m]
-        maxdepth
-            Maximum depth value to be returned [m]
-        discontinuity interval
-            Shift continuities to remove ambigious values for depth, default value = 1 [m]
-
-        Returns
-        -------
-        depths : array of floats
-            Depths [m].
+        :returns: Depths [m].
+        :rtype: numpy.array
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def pressure(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        pressure : float or array of floats
-            Pressure(s) at given depth(s) in [Pa].
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Pressure(s) at given depth(s) in [Pa].
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def v_p(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        v_p : float or array of floats
-            P wave velocity at given depth(s) in [m/s].
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: P wave velocity at given depth(s) in [m/s].
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def v_s(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        v_s : float or array of floats
-            S wave velocity at given depth(s) in [m/s].
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: S wave velocity at given depth(s) in [m/s].
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def v_phi(self, depth):
         """
-        Parameters
-        ----------
-        depth_list : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        v_phi : float or array of floats
-            bulk sound wave velocity at given depth(s) in [m/s].
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Bulk sound wave velocity at given depth(s) in [m/s].
+        :rtype: float or numpy.array of floats
         """
         v_s = self.v_s(depth)
         v_p = self.v_p(depth)
-        return np.sqrt(v_p * v_p - 4. / 3. * v_s * v_s)
+        return np.sqrt(v_p * v_p - 4.0 / 3.0 * v_s * v_s)
 
     def density(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        density : float or array of floats
-            Density at given depth(s) in [kg/m^3].
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Density at given depth(s) in [kg/m^3].
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def G(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Shear modulus at given for depth(s) in [Pa].
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Shear modulus at given depth(s) in [Pa].
+        :rtype: float or numpy.array of floats
         """
-        return np.power(self.v_s(depth), 2.) * self.density(depth)
+        return np.power(self.v_s(depth), 2.0) * self.density(depth)
 
     def K(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Bulk modulus at given for depth(s) in [Pa]
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Bulk modulus at given depth(s) in [Pa]
+        :rtype: float or numpy.array of floats
         """
-        return np.power(self.v_phi(depth), 2.) * self.density(depth)
+        return np.power(self.v_phi(depth), 2.0) * self.density(depth)
 
     def QK(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        Qk : float or array of floats
-            Quality factor (dimensionless) for bulk modulus at given depth(s).
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Quality factor (dimensionless) for bulk modulus at given depth(s).
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def QG(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate seismic model at.
-
-        Returns
-        -------
-        QG : float or array of floats
-            Quality factor (dimensionless) for shear modulus at given depth(s).
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Quality factor (dimensionless) for shear modulus at given depth(s).
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def depth(self, pressure):
         """
-        Parameters
-        ----------
-        pressure : float or array of floats
-            Pressure(s) [Pa] to evaluate depth at.
-
-        Returns
-        -------
-        depth : float or array of floats
-            Depth(s) [m] for given pressure(s)
+        :param pressure: Pressure(s) [Pa] at which to evaluate depths.
+        :type pressure: float or numpy.array of floats
+
+        :returns: Depth(s) [m] for given pressure(s).
+        :type depth: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
     def gravity(self, depth):
         """
-        Parameters
-        ----------
-        depth : float or array of floats
-            Depth(s) [m] to evaluate gravity at.
-
-        Returns
-        -------
-        gravity : float or array of floats
-            Gravity for given depths in [m/s^2]
+        :param depth: Depth(s) [m] at which to evaluate seismic model.
+        :type depth: float or numpy.array of floats
+
+        :returns: Gravity at given depths in [m/s^2].
+        :rtype: float or numpy.array of floats
         """
-        raise NotImplementedError(
-            "abstract method to be implemented in derived class")
+        raise NotImplementedError("abstract method to be implemented in derived class")
 
 
 class SeismicTable(Seismic1DModel):
     """
     This is a base class that gets a 1D seismic model from a table indexed and
     sorted by radius. Fill the tables in the constructor after deriving
     from this class. This class uses :class:`burnman.seismic.Seismic1DModel`
 
-    Note: all tables need to be sorted by increasing depth. self.table_depth needs to be defined
-    Alternatively, you can also overwrite the _lookup function if you
-    want to access with something else.
+    Note: all tables need to be sorted by increasing depth.
+    self.table_depth needs to be defined. Alternatively, you can also overwrite
+    the _lookup function if you want to access with something else.
     """
 
     def __init__(self):
         Seismic1DModel.__init__(self)
 
         self.table_depth = []
         self.table_radius = []
@@ -244,138 +199,151 @@
         self.table_vp = []
         self.table_vs = []
         self.table_QG = []
         self.table_QK = []
 
         self.earth_radius = 6371.0e3
 
-    def internal_depth_list(self, mindepth=0., maxdepth=1.e10, discontinuity_interval=1.):
-        depths = np.array([self.table_depth[x] for x in range(len(
-            self.table_depth)) if self.table_depth[x] >= mindepth and self.table_depth[x] <= maxdepth])
+    def internal_depth_list(
+        self, mindepth=0.0, maxdepth=1.0e10, discontinuity_interval=1.0
+    ):
+        depths = np.array(
+            [
+                self.table_depth[x]
+                for x in range(len(self.table_depth))
+                if self.table_depth[x] >= mindepth and self.table_depth[x] <= maxdepth
+            ]
+        )
         discontinuities = np.where(depths[1:] - depths[:-1] == 0)[0]
         # Shift values at discontinities by 1 m to simplify evaluating values
         # around these.
         depths[discontinuities] = depths[discontinuities] - discontinuity_interval
-        depths[discontinuities + 1] = depths[discontinuities + 1] + discontinuity_interval
+        depths[discontinuities + 1] = (
+            depths[discontinuities + 1] + discontinuity_interval
+        )
         return depths
 
     def pressure(self, depth):
         if len(self.table_pressure) == 0:
             warnings.warn(
-                "Pressure is not given in " + self.__class__.__name__ + " and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk.")
+                "Pressure is not given in "
+                + self.__class__.__name__
+                + " and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk."
+            )
             self._compute_pressure()
         return self._lookup(depth, self.table_pressure)
 
     def gravity(self, depth):
         if len(self.table_gravity) == 0:
             warnings.warn(
-                "Gravity is not given in " + self.__class__.__name__ + " and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk.")
+                "Gravity is not given in "
+                + self.__class__.__name__
+                + " and is now being computed. This will only work when density is defined for the entire planet. Use at your own risk."
+            )
             self._compute_gravity()
         return self._lookup(depth, self.table_gravity)
 
     def v_p(self, depth):
-
         return self._lookup(depth, self.table_vp)
 
     def v_s(self, depth):
-
         return self._lookup(depth, self.table_vs)
 
     def QK(self, depth):
-
         return self._lookup(depth, self.table_QK)
 
     def QG(self, depth):
-
         return self._lookup(depth, self.table_QG)
 
     def density(self, depth):
         if len(self.table_density) == 0:
-            raise ValueError(
-                "Density has not been defined for this seismic model")
+            raise ValueError("Density has not been defined for this seismic model")
         return self._lookup(depth, self.table_density)
 
     def bullen(self, depth):
         """
         Returns the Bullen parameter only for significant arrays
         """
-        assert(len(depth) > 3)
+        assert len(depth) > 3
         v_phi = self.v_phi(depth)
         density = self.density(depth)
         phi = v_phi * v_phi
         kappa = phi * density
         try:
-            dkappadP = np.gradient(kappa, edge_order=2) / \
-                       np.gradient(self.pressure(depth), edge_order=2)
-            dphidz = np.gradient(phi,
-                                 edge_order=2) / np.gradient(depth,
-                                                             edge_order=2) / self.gravity(depth)
+            dkappadP = np.gradient(kappa, edge_order=2) / np.gradient(
+                self.pressure(depth), edge_order=2
+            )
+            dphidz = (
+                np.gradient(phi, edge_order=2)
+                / np.gradient(depth, edge_order=2)
+                / self.gravity(depth)
+            )
         except:
             dkappadP = np.gradient(kappa) / np.gradient(self.pressure(depth))
             dphidz = np.gradient(phi) / np.gradient(depth) / self.gravity(depth)
         bullen = dkappadP - dphidz
         return bullen
 
     def depth(self, pressure):
-        if max(pressure) > max(
-                self.table_pressure) or min(pressure) < min(
-                self.table_pressure):
+        if max(pressure) > max(self.table_pressure) or min(pressure) < min(
+            self.table_pressure
+        ):
             raise ValueError("Pressure outside range of SeismicTable")
 
         depth = np.interp(pressure, self.table_pressure, self.table_depth)
         return depth
 
     def radius(self, pressure):
-
-        radius = np.interp(pressure, self.table_pressure[
-                           ::-1], self.earth_radius - self.table_depth[::-1])
+        radius = np.interp(
+            pressure,
+            self.table_pressure[::-1],
+            self.earth_radius - self.table_depth[::-1],
+        )
         return radius
 
     def _lookup(self, depth, value_table):
         return np.interp(depth, self.table_depth, value_table)
 
     def _compute_gravity(self):
         # Calculate the gravity of the planet, based on a density profile.
         # There is a check of the surface value is within reason for this
         # model, otherwise values for PREM are used.
 
         density = self.table_density[::-1]
 
         if len(density) > 0:
             radii = self.table_radius[::-1]
-            g = scipy.integrate.cumtrapz(constants.G * 4. * np.pi
-                                         * density * radii * radii,
-                                         x=radii,
-                                         initial=0)
+            g = scipy.integrate.cumtrapz(
+                constants.G * 4.0 * np.pi * density * radii * radii, x=radii, initial=0
+            )
             g[1:] = g[1:] / radii[1:] / radii[1:]
 
             self.table_gravity = g[::-1]
         else:
-            raise ValueError('Density profile is an empty list '
-                             'in this SeismicTable instance.')
+            raise ValueError(
+                "Density profile is an empty list " "in this SeismicTable instance."
+            )
 
     def _compute_pressure(self):
         # Calculate the pressure profile based on density and gravity.
         # This integrates the equation for hydrostatic equilibrium P = rho g z.
         radii = self.table_radius
         density = self.table_density
         gravity = self.gravity(self.earth_radius - radii)
 
         # convert radii to depths
         depth = self.earth_radius - radii
-        pressure = scipy.integrate.cumtrapz(
-            gravity * density, x=depth, initial=0.)
+        pressure = scipy.integrate.cumtrapz(gravity * density, x=depth, initial=0.0)
 
         self.table_pressure = pressure
 
 
 class PREM(SeismicTable):
-
     """
-    Reads  PREM (1s) (input_seismic/prem.txt, :cite:`dziewonski1981`).
+    Reads PREM (1s) (input_seismic/prem.txt, :cite:`dziewonski1981`).
     See also :class:`burnman.seismic.SeismicTable`.
     """
 
     def __init__(self):
         SeismicTable.__init__(self)
         table = read_table("input_seismic/prem.txt")
         table = np.array(table)
@@ -386,18 +354,20 @@
         self.table_vp = table[:, 4]
         self.table_vs = table[:, 5]
         self.table_QK = table[:, 6]
         self.table_QG = table[:, 7]
 
 
 class Slow(SeismicTable):
-
     """
-    Inserts the mean profiles for slower regions in the lower mantle (Lekic et al. 2012).
-    We stitch together tables 'input_seismic/prem_lowermantle.txt', 'input_seismic/swave_slow.txt', 'input_seismic/pwave_slow.txt').
+    Inserts the mean profiles for slower regions in the lower mantle
+    (Lekic et al. 2012). We stitch together tables
+    'input_seismic/prem_lowermantle.txt',
+    'input_seismic/swave_slow.txt',
+    'input_seismic/pwave_slow.txt').
     See also :class:`burnman.seismic.SeismicTable`.
     """
 
     def __init__(self):
         SeismicTable.__init__(self)
 
         # data is: depth radius pressure density V_p V_s Q_K Q_G
@@ -408,35 +378,36 @@
         table3 = read_table("input_seismic/pwave_slow.txt")
         table3 = np.array(table3)
 
         min_radius = self.earth_radius - max(table2[:, 0])
         max_radius = self.earth_radius - min(table2[:, 0])
 
         table = np.array(
-            list(
-                filter(
-                    lambda x: (
-                        x[1] >= min_radius and x[1] <= max_radius),
-                    table)))
+            list(filter(lambda x: (x[1] >= min_radius and x[1] <= max_radius), table))
+        )
 
         self.table_depth = table[:, 0]
         self.table_radius = table[:, 1]
         self.table_pressure = table[:, 2]
         self.table_density = table[:, 3]
         self.table_vp = np.interp(
-            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1])
+            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1]
+        )
         self.table_vs = np.interp(
-            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1])
+            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1]
+        )
 
 
 class Fast(SeismicTable):
-
     """
-    Inserts the mean profiles for faster regions in the lower mantle (Lekic et al. 2012).
-    We stitch together tables 'input_seismic/prem_lowermantle.txt', 'input_seismic/swave_fast.txt', 'input_seismic/pwave_fast.txt').
+    Inserts the mean profiles for faster regions in the lower mantle
+    (Lekic et al. 2012). We stitch together tables
+    'input_seismic/prem_lowermantle.txt',
+    'input_seismic/swave_fast.txt',
+    'input_seismic/pwave_fast.txt').
     See also :class:`burnman.seismic.Seismic1DModel`.
     """
 
     def __init__(self):
         SeismicTable.__init__(self)
 
         # data is: radius pressure density V_p V_s Q_K Q_G
@@ -447,34 +418,32 @@
         table3 = read_table("input_seismic/pwave_fast.txt")
         table3 = np.array(table3)
 
         min_radius = self.earth_radius - max(table2[:, 0])
         max_radius = self.earth_radius - min(table2[:, 0])
 
         table = np.array(
-            list(
-                filter(
-                    lambda x: (
-                        x[1] >= min_radius and x[1] <= max_radius),
-                    table)))
+            list(filter(lambda x: (x[1] >= min_radius and x[1] <= max_radius), table))
+        )
 
         self.table_depth = table[:, 0]
         self.table_radius = table[:, 1]
         self.table_pressure = table[:, 2]
         self.table_density = table[:, 3]
         self.table_vp = np.interp(
-            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1])
+            self.table_depth, table3[:, 0][::-1], table3[:, 1][::-1]
+        )
         self.table_vs = np.interp(
-            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1])
+            self.table_depth, table2[:, 0][::-1], table2[:, 1][::-1]
+        )
 
 
 class STW105(SeismicTable):
-
     """
-    Reads  STW05 (a.k.a. REF) (1s) (input_seismic/STW105.txt, :cite:`kustowski2008`).
+    Reads STW05 (a.k.a. REF) (1s) (input_seismic/STW105.txt, :cite:`kustowski2008`).
     See also :class:`burnman.seismic.SeismicTable`.
     """
 
     def __init__(self):
         SeismicTable.__init__(self)
         # radius, pressure, density, v_p, v_s
         table = read_table("input_seismic/STW105.txt")
@@ -487,90 +456,92 @@
         self.table_QG = table[:, 5][::-1]
         self.table_vph = table[:, 6][::-1]
         self.table_vsh = table[:, 7][::-1]
 
         self.table_depth = self.earth_radius - self.table_radius
 
         # Voigt averages for Vs and Vp
-        self.table_vs = np.sqrt((2. * self.table_vsv * self.table_vsv + self.table_vsh * self.table_vsh) / 3.)
-        self.table_vp = np.sqrt((self.table_vpv * self.table_vpv + 4. * self.table_vph * self.table_vph) / 5.)
+        self.table_vs = np.sqrt(
+            (2.0 * self.table_vsv * self.table_vsv + self.table_vsh * self.table_vsh)
+            / 3.0
+        )
+        self.table_vp = np.sqrt(
+            (self.table_vpv * self.table_vpv + 4.0 * self.table_vph * self.table_vph)
+            / 5.0
+        )
 
 
 class IASP91(SeismicTable):
     """
-    Reads  REF/STW05 (input_seismic/STW105.txt, :cite:`kustowski2008`).
+    Reads REF/STW05 (input_seismic/STW105.txt, :cite:`kustowski2008`).
     See also :class:`burnman.seismic.SeismicTable`.
     """
 
     def __init__(self):
         SeismicTable.__init__(self)
-        table = read_table(
-            "input_seismic/iasp91.txt")  # depth, radius, v_p, v_s
+        table = read_table("input_seismic/iasp91.txt")  # depth, radius, v_p, v_s
         table = np.array(table)
         self.table_depth = table[:, 0]
         self.table_radius = table[:, 1]
         self.table_vp = table[:, 2]
         self.table_vs = table[:, 3]
 
 
 class AK135(SeismicTable):
     """
-    Reads  AK135 (input_seismic/ak135.txt, :cite:`kennett1995`).
+    Reads AK135 (input_seismic/ak135.txt, :cite:`kennett1995`).
     See also :class:`burnman.seismic.SeismicTable`.
     """
 
     def __init__(self):
         SeismicTable.__init__(self)
         table = read_table(
-            "input_seismic/ak135.txt")  # radius, pressure, density, v_p, v_s
+            "input_seismic/ak135.txt"
+        )  # radius, pressure, density, v_p, v_s
         table = np.array(table)
         self.table_depth = table[:, 0]
         self.table_radius = table[:, 1]
         self.table_density = table[:, 2]
         self.table_vp = table[:, 3]
         self.table_vs = table[:, 4]
         self.table_QG = table[:, 5]
         self.table_QK = table[:, 6]
 
 
 def attenuation_correction(v_p, v_s, v_phi, Qs, Qphi):
     """
-    Applies the attenuation correction following Matas et al. (2007), page 4. This is simplified, and there is also currently no 1D Q model implemented. The correction, however, only slightly reduces the velocities, and can be ignored for our current applications. Arguably, it might not be as relevant when comparing computations to PREM for periods of 1s as is implemented here.
+    Applies the attenuation correction following Matas et al. (2007), page 4.
+    This is simplified, and there is also currently no 1D Q model implemented.
+    The correction, however, only slightly reduces the velocities,
+    and can be ignored for our current applications.
+    Arguably, it might not be as relevant when comparing computations
+    to PREM for periods of 1s as is implemented here.
     Called from :func:`burnman.main.apply_attenuation_correction`
 
-    Parameters
-    ----------
-    v_p : float
-        P wave velocity in [m/s].
-    v_s : float
-        S wave velocitiy in [m/s].
-    v_phi : float
-        Bulk sound velocity in [m/s].
-    Qs : float
-        shear quality factor [dimensionless]
-    Qphi: float
-        bulk quality factor [dimensionless]
-
-
-    Returns
-    -------
-    v_p : float
-        corrected P wave velocity in [m/s].
-    v_s : float
-        corrected S wave velocitiy in [m/s].
-    v_phi : float
-        corrected Bulk sound velocity in [m/s].
+    :param v_p: P wave velocity in [m/s].
+    :type v_p: float
+    :param v_s: S wave velocitiy in [m/s].
+    :type v_s: float
+    :param v_phi: Bulk sound velocity in [m/s].
+    :type v_phi: float
+    :param Qs: Shear quality factor [dimensionless].
+    :type Qs: float
+    :param Qphi: Bulk quality factor [dimensionless].
+    :type Qphi: float
+
+    :returns: Corrected P wave, S wave and bulk sound velocities in [m/s].
+    :rtype: tuple
     """
     beta = 0.3  # Matas et al. (2007) page 4
-    Qp = 3. / 4. * pow((v_p / v_s), 2.) * Qs    # Matas et al. (2007) page 4
+    Qp = 3.0 / 4.0 * pow((v_p / v_s), 2.0) * Qs  # Matas et al. (2007) page 4
 
-    cot = 1. / np.tan(beta * np.pi / 2.)
-    v_p *= 1. - 1. / 2. * cot * 1. / Qp  # Matas et al. (2007) page 1
-    v_s *= 1. - 1. / 2. * cot * 1. / Qs
-    v_phi *= 1. - 1. / 2. * cot * 1. / Qphi
+    cot = 1.0 / np.tan(beta * np.pi / 2.0)
+    v_p *= 1.0 - 1.0 / 2.0 * cot * 1.0 / Qp  # Matas et al. (2007) page 1
+    v_s *= 1.0 - 1.0 / 2.0 * cot * 1.0 / Qs
+    v_phi *= 1.0 - 1.0 / 2.0 * cot * 1.0 / Qphi
     return v_p, v_s, v_phi
 
 
 """
 shared variable of prem, so that other routines do not need to create
 prem over and over. See geotherm for example.
 """
```

### Comparing `burnman-1.1.0/burnman/classes/solutionmodel.py` & `burnman-1.2.0/burnman/classes/solutionmodel.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,112 +6,128 @@
 from __future__ import absolute_import
 
 import importlib
 import numpy as np
 from ..utils.chemistry import process_solution_chemistry
 from .. import constants
 import warnings
+import sparse
+import string
+from copy import deepcopy
+from .material import material_property
 
 try:
-    ag = importlib.import_module('autograd')
+    ag = importlib.import_module("autograd")
 except ImportError as err:
-    print(f'Warning: {err}. '
-          'For full functionality of BurnMan, please install autograd.')
+    print(
+        f"Warning: {err}. "
+        "For full functionality of BurnMan, please install autograd."
+    )
 
 
-def _ideal_activities_fct(molar_fractions, endmember_noccupancies,
-                          n_endmembers, n_occupancies, site_multiplicities,
-                          endmember_configurational_entropies):
+def _ideal_activities_fct(
+    molar_fractions,
+    endmember_noccupancies,
+    n_endmembers,
+    n_occupancies,
+    site_multiplicities,
+    endmember_configurational_entropies,
+):
     site_noccupancies = np.dot(molar_fractions, endmember_noccupancies)
-    site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                    site_multiplicities)
+    site_multiplicities = np.einsum("i, ij", molar_fractions, site_multiplicities)
     site_occupancies = site_noccupancies * inverseish(site_multiplicities)
 
     a = np.power(site_occupancies, endmember_noccupancies).prod(-1)
-    normalisation_constants = np.exp(endmember_configurational_entropies
-                                     / constants.gas_constant)
+    normalisation_constants = np.exp(
+        endmember_configurational_entropies / constants.gas_constant
+    )
     return normalisation_constants * a
 
 
 def _non_ideal_hessian_fct(phi, molar_fractions, n_endmembers, alpha, W):
-    q = np.eye(n_endmembers) - phi*np.ones((n_endmembers, n_endmembers))
+    q = np.eye(n_endmembers) - phi * np.ones((n_endmembers, n_endmembers))
     sum_pa = np.dot(molar_fractions, alpha)
-    hess = np.einsum('m, i, ij, jk, mk->im', -alpha/sum_pa, -alpha, q, W, q)
+    hess = np.einsum("m, i, ij, jk, mk->im", -alpha / sum_pa, -alpha, q, W, q)
     hess += hess.T
     return hess
 
 
 def _non_ideal_interactions_fct(phi, molar_fractions, n_endmembers, alpha, W):
     # -sum(sum(qi.qj.Wij*)
     # equation (2) of Holland and Powell 2003
-    q = np.eye(n_endmembers) - phi*np.ones((n_endmembers, n_endmembers))
+    q = np.eye(n_endmembers) - phi * np.ones((n_endmembers, n_endmembers))
     # The following are equivalent to
     # np.einsum('i, ij, jk, ik->i', -self.alphas, q, self.Wx, q)
-    Wint = -alpha * (q.dot(W)*q).sum(-1)
+    Wint = -alpha * (q.dot(W) * q).sum(-1)
     return Wint
 
 
 def _non_ideal_hessian_subreg(p, n_endmembers, Wijk):
     Id = np.identity(n_endmembers)
-    IIp = np.einsum('il, jm, k->ijklm', Id, Id, p)
-    Ipp = np.einsum('il, j, k->ijkl', Id, p, p)
-    ppp = np.einsum('i, j, k->ijk', p, p, p)
-
-    A = (IIp
-         + np.transpose(IIp, axes=[0, 2, 1, 3, 4])
-         + np.transpose(IIp, axes=[1, 0, 2, 3, 4])
-         + np.transpose(IIp, axes=[1, 2, 0, 3, 4])
-         + np.transpose(IIp, axes=[2, 1, 0, 3, 4])
-         + np.transpose(IIp, axes=[2, 0, 1, 3, 4]))
-    B = 2.*(Ipp
-            + np.transpose(Ipp, axes=[1, 0, 2, 3])
-            + np.transpose(Ipp, axes=[2, 1, 0, 3]))
-
-    Asum = (A
-            - B[:, :, :, :, None]
-            - B[:, :, :, None, :]
-            + 6.*ppp[:, :, :, None, None])
-    hess = np.einsum('ijklm, ijk->lm', Asum, Wijk)
+    IIp = np.einsum("il, jm, k->ijklm", Id, Id, p)
+    Ipp = np.einsum("il, j, k->ijkl", Id, p, p)
+    ppp = np.einsum("i, j, k->ijk", p, p, p)
+
+    A = (
+        IIp
+        + np.transpose(IIp, axes=[0, 2, 1, 3, 4])
+        + np.transpose(IIp, axes=[1, 0, 2, 3, 4])
+        + np.transpose(IIp, axes=[1, 2, 0, 3, 4])
+        + np.transpose(IIp, axes=[2, 1, 0, 3, 4])
+        + np.transpose(IIp, axes=[2, 0, 1, 3, 4])
+    )
+    B = 2.0 * (
+        Ipp
+        + np.transpose(Ipp, axes=[1, 0, 2, 3])
+        + np.transpose(Ipp, axes=[2, 1, 0, 3])
+    )
+
+    Asum = (
+        A - B[:, :, :, :, None] - B[:, :, :, None, :] + 6.0 * ppp[:, :, :, None, None]
+    )
+    hess = np.einsum("ijklm, ijk->lm", Asum, Wijk)
     return hess
 
 
 def _non_ideal_interactions_subreg(p, n_endmembers, Wijk):
-    Aijkl = np.einsum('li, j, k->ijkl', np.identity(n_endmembers), p, p)
-    ppp = np.einsum('i, j, k->ijk', p, p, p)
+    Aijkl = np.einsum("li, j, k->ijkl", np.identity(n_endmembers), p, p)
+    ppp = np.einsum("i, j, k->ijk", p, p, p)
 
-    Asum = (Aijkl
-            + np.transpose(Aijkl, axes=[1, 0, 2, 3])
-            + np.transpose(Aijkl, axes=[1, 2, 0, 3])
-            - 2*ppp[:, :, :, None])
+    Asum = (
+        Aijkl
+        + np.transpose(Aijkl, axes=[1, 0, 2, 3])
+        + np.transpose(Aijkl, axes=[1, 2, 0, 3])
+        - 2 * ppp[:, :, :, None]
+    )
 
-    Wint = np.einsum('ijk, ijkl->l', Wijk, Asum)
+    Wint = np.einsum("ijk, ijkl->l", Wijk, Asum)
     return Wint
 
 
-def logish(x, eps=1.e-5):
+def logish(x, eps=1.0e-5):
     """
     2nd order series expansion of log(x) about eps:
     log(eps) - sum_k=1^infty (f_eps)^k / k
     Prevents infinities at x=0
     """
-    f_eps = 1. - x/eps
+    f_eps = 1.0 - x / eps
     mask = x > eps
-    ln = np.where(x <= eps, np.log(eps) - f_eps - f_eps*f_eps/2., 0.)
+    ln = np.where(x <= eps, np.log(eps) - f_eps - f_eps * f_eps / 2.0, 0.0)
     ln[mask] = np.log(x[mask])
     return ln
 
 
-def inverseish(x, eps=1.e-5):
+def inverseish(x, eps=1.0e-5):
     """
     1st order series expansion of 1/x about eps: 2/eps - x/eps/eps
     Prevents infinities at x=0
     """
     mask = x > eps
-    oneoverx = np.where(x <= eps, 2./eps - x/eps/eps, 0.)
-    oneoverx[mask] = 1./x[mask]
+    oneoverx = np.where(x <= eps, 2.0 / eps - x / eps / eps, 0.0)
+    oneoverx[mask] = 1.0 / x[mask]
     return oneoverx
 
 
 class SolutionModel(object):
 
     """
     This is the base class for a solution model,  intended for use
@@ -137,221 +153,213 @@
     def excess_gibbs_free_energy(self, pressure, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess Gibbs free energy of the solution.
         The base class implementation assumes that the excess gibbs
         free energy is zero.
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        G_excess : float
-            The excess Gibbs free energy
-        """
-        return np.dot(np.array(molar_fractions),
-                      self.excess_partial_gibbs_free_energies(pressure,
-                                                              temperature,
-                                                              molar_fractions))
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
+
+        :returns: The excess Gibbs energy.
+        :rtype: float
+        """
+        return np.dot(
+            np.array(molar_fractions),
+            self.excess_partial_gibbs_free_energies(
+                pressure, temperature, molar_fractions
+            ),
+        )
 
     def excess_volume(self, pressure, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess volume of the solution.
         The base class implementation assumes that the excess volume is zero.
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        V_excess : float
-            The excess volume of the solution
-        """
-        return np.dot(molar_fractions,
-                      self.excess_partial_volumes(pressure, temperature,
-                                                  molar_fractions))
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
+
+        :returns: The excess volume of the solution.
+        :rtype: float
+        """
+        return np.dot(
+            molar_fractions,
+            self.excess_partial_volumes(pressure, temperature, molar_fractions),
+        )
 
     def excess_entropy(self, pressure, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess entropy of the solution.
         The base class implementation assumes that the excess entropy is zero.
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        S_excess : float
-            The excess entropy of the solution
-        """
-        return np.dot(molar_fractions,
-                      self.excess_partial_entropies(pressure, temperature,
-                                                    molar_fractions))
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
+
+        :returns: The excess entropy of the solution.
+        :rtype: float
+        """
+        return np.dot(
+            molar_fractions,
+            self.excess_partial_entropies(pressure, temperature, molar_fractions),
+        )
 
     def excess_enthalpy(self, pressure, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess enthalpy of the solution.
         The base class implementation assumes that the excess enthalpy is zero.
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        H_excess : float
-            The excess enthalpy of the solution
-        """
-        return (self.excess_gibbs_free_energy(pressure, temperature,
-                                              molar_fractions)
-                + temperature*self.excess_entropy(pressure, temperature,
-                                                  molar_fractions))
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
 
-    def excess_partial_gibbs_free_energies(self, pressure, temperature,
-                                           molar_fractions):
+        :returns: The excess enthalpy of the solution.
+        :rtype: float
+        """
+        return self.excess_gibbs_free_energy(
+            pressure, temperature, molar_fractions
+        ) + temperature * self.excess_entropy(pressure, temperature, molar_fractions)
+
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
         """
         Given a list of molar fractions of different phases,
         compute the excess Gibbs free energy for each endmember
         of the solution.
         The base class implementation assumes that the excess gibbs
         free energy is zero.
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        partial_G_excess : numpy array
-            The excess Gibbs free energy of each endmember
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
+
+        :returns: The excess partial Gibbs free energy of each endmember.
+        :rtype: numpy.array
         """
         return np.zeros_like(molar_fractions)
 
     def excess_partial_entropies(self, pressure, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess entropy for each endmember of the solution.
         The base class implementation assumes that the excess entropy
         is zero (true for mechanical solutions).
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        partial_S_excess : numpy array
-            The excess entropy of each endmember
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
+
+        :returns: The excess partial entropy of each endmember.
+        :rtype: numpy.array
         """
         return np.zeros_like(molar_fractions)
 
     def excess_partial_volumes(self, pressure, temperature, molar_fractions):
         """
         Given a list of molar fractions of different phases,
         compute the excess volume for each endmember of the solution.
         The base class implementation assumes that the excess volume
         is zero.
 
-        Parameters
-        ----------
-        pressure : float
-            Pressure at which to evaluate the solution model. [Pa]
-
-        temperature : float
-            Temperature at which to evaluate the solution. [K]
-
-        molar_fractions : list of floats
-            List of molar fractions of the different endmembers in solution
-
-        Returns
-        -------
-        partial_V_excess : numpy array
-            The excess volume of each endmember
+        :param pressure: Pressure at which to evaluate the solution model [Pa].
+        :type pressure: float
+        :param temperature: Temperature at which to evaluate the solution model [K].
+        :type temperature: float
+        :param molar_fractions: List of molar fractions of the
+            different independent endmembers in the solution model.
+        :type molar_fractions: list of floats
+
+        :returns: The excess partial volume of each endmember.
+        :rtype: numpy.array
         """
         return np.zeros_like(np.array(molar_fractions))
 
+    def Cp_excess(self):
+        """
+        Returns the excess heat capacity of the solution model
+        at its current state
+        """
+        return 0.0
+
+    def alphaV_excess(self):
+        """
+        Returns the excess alpha*V of the solution model
+        at its current state
+        """
+        return 0.0
+
+    def VoverKT_excess(self):
+        """
+        Returns the excess V/K_T of the solution model
+        at its current state
+        """
+        return 0.0
+
 
-class MechanicalSolution (SolutionModel):
+class MechanicalSolution(SolutionModel):
 
     """
     An extremely simple class representing a mechanical solution model.
     A mechanical solution experiences no interaction between endmembers.
     Therefore, unlike ideal solutions there is no entropy of mixing;
     the total gibbs free energy of the solution is equal to the
     dot product of the molar gibbs free energies and molar fractions
     of the constituent materials.
     """
 
     def __init__(self, endmembers):
+        self.endmembers = endmembers
         self.n_endmembers = len(endmembers)
         self.formulas = [e[1] for e in endmembers]
 
     def excess_gibbs_free_energy(self, pressure, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
     def excess_volume(self, pressure, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
     def excess_entropy(self, pressure, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
     def excess_enthalpy(self, pressure, temperature, molar_fractions):
-        return 0.
+        return 0.0
 
-    def excess_partial_gibbs_free_energies(self, pressure, temperature,
-                                           molar_fractions):
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
         return np.zeros_like(molar_fractions)
 
     def excess_partial_volumes(self, pressure, temperature, molar_fractions):
         return np.zeros_like(molar_fractions)
 
     def excess_partial_entropies(self, pressure, temperature, molar_fractions):
         return np.zeros_like(molar_fractions)
@@ -359,135 +367,154 @@
     def activity_coefficients(self, pressure, temperature, molar_fractions):
         return np.ones_like(molar_fractions)
 
     def activities(self, pressure, temperature, molar_fractions):
         return np.ones_like(molar_fractions)
 
 
-class IdealSolution (SolutionModel):
+class IdealSolution(SolutionModel):
 
     """
     A class representing an ideal solution model.
     Calculates the excess gibbs free energy and entropy due to configurational
     entropy. Excess internal energy and volume are equal to zero.
 
     The multiplicity of each type of site in the structure is allowed to
     change linearly as a function of endmember proportions. This class
     is therefore equivalent to the entropic part of
-    a Temkin-type model :cite:`Temkin1945`. 
+    a Temkin-type model :cite:`Temkin1945`.
     """
 
     def __init__(self, endmembers):
+        self.endmembers = endmembers
         self.n_endmembers = len(endmembers)
         self.formulas = [e[1] for e in endmembers]
 
         # Process solution chemistry
         process_solution_chemistry(self)
 
         self._calculate_endmember_configurational_entropies()
 
     def _calculate_endmember_configurational_entropies(self):
-        S_conf = -(constants.gas_constant
-                   * (self.endmember_noccupancies
-                      * logish(self.endmember_occupancies)).sum(-1))
+        S_conf = -(
+            constants.gas_constant
+            * (self.endmember_noccupancies * logish(self.endmember_occupancies)).sum(-1)
+        )
         self.endmember_configurational_entropies = S_conf
 
-    def excess_partial_gibbs_free_energies(self, pressure, temperature,
-                                           molar_fractions):
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
         return self._ideal_excess_partial_gibbs(temperature, molar_fractions)
 
     def excess_partial_entropies(self, pressure, temperature, molar_fractions):
-        return self._ideal_excess_partial_entropies(temperature,
-                                                    molar_fractions)
+        return self._ideal_excess_partial_entropies(temperature, molar_fractions)
 
     def excess_partial_volumes(self, pressure, temperature, molar_fractions):
         return np.zeros((self.n_endmembers))
 
     def gibbs_hessian(self, pressure, temperature, molar_fractions):
         hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)
-        return -temperature*hess_S
+        return -temperature * hess_S
 
     def entropy_hessian(self, pressure, temperature, molar_fractions):
         hess_S = self._ideal_entropy_hessian(temperature, molar_fractions)
         return hess_S
 
     def volume_hessian(self, pressure, temperature, molar_fractions):
         return np.zeros((len(molar_fractions), len(molar_fractions)))
 
     def _configurational_entropy(self, molar_fractions):
-        site_noccupancies = np.einsum('i, ij', molar_fractions,
-                                      self.endmember_noccupancies)
-        site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                        self.site_multiplicities)
-        site_occupancies = (site_noccupancies
-                            * inverseish(site_multiplicities))
-        conf_entropy = -(constants.gas_constant
-                         * (site_noccupancies
-                            * logish(site_occupancies)).sum(-1))
+        site_noccupancies = np.einsum(
+            "i, ij", molar_fractions, self.endmember_noccupancies
+        )
+        site_multiplicities = np.einsum(
+            "i, ij", molar_fractions, self.site_multiplicities
+        )
+        site_occupancies = site_noccupancies * inverseish(site_multiplicities)
+        conf_entropy = -(
+            constants.gas_constant
+            * (site_noccupancies * logish(site_occupancies)).sum(-1)
+        )
         return conf_entropy
 
     def _ideal_excess_partial_gibbs(self, temperature, molar_fractions):
-        return -(temperature
-                 * self._ideal_excess_partial_entropies(temperature,
-                                                        molar_fractions))
+        return -(
+            temperature
+            * self._ideal_excess_partial_entropies(temperature, molar_fractions)
+        )
 
     def _ideal_excess_partial_entropies(self, temperature, molar_fractions):
-        return -(constants.gas_constant
-                 * self._log_ideal_activities(molar_fractions))
+        return -(constants.gas_constant * self._log_ideal_activities(molar_fractions))
 
     def _ideal_entropy_hessian(self, temperature, molar_fractions):
-        hessian = -(constants.gas_constant
-                    * self._log_ideal_activity_derivatives(molar_fractions))
+        hessian = -(
+            constants.gas_constant
+            * self._log_ideal_activity_derivatives(molar_fractions)
+        )
         return hessian
 
     def _log_ideal_activities(self, molar_fractions):
-        site_noccupancies = np.einsum('i, ij', molar_fractions,
-                                      self.endmember_noccupancies)
-        site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                        self.site_multiplicities)
-
-        lna = np.einsum('ij, j->i', self.endmember_noccupancies,
-                        logish(site_noccupancies)
-                        - logish(site_multiplicities))
-
-        normalisation_constants = (self.endmember_configurational_entropies
-                                   / constants.gas_constant)
+        site_noccupancies = np.einsum(
+            "i, ij", molar_fractions, self.endmember_noccupancies
+        )
+        site_multiplicities = np.einsum(
+            "i, ij", molar_fractions, self.site_multiplicities
+        )
+
+        lna = np.einsum(
+            "ij, j->i",
+            self.endmember_noccupancies,
+            logish(site_noccupancies) - logish(site_multiplicities),
+        )
+        normalisation_constants = (
+            self.endmember_configurational_entropies / constants.gas_constant
+        )
         return lna + normalisation_constants
 
     def _log_ideal_activity_derivatives(self, molar_fractions):
-        site_noccupancies = np.einsum('i, ij', molar_fractions,
-                                      self.endmember_noccupancies)
-        site_multiplicities = np.einsum('i, ij', molar_fractions,
-                                        self.site_multiplicities)
-
-        dlnadp = (np.einsum('pj, qj, j->pq', self.endmember_noccupancies,
-                            self.endmember_noccupancies,
-                            inverseish(site_noccupancies))
-                  - np.einsum('pj, qj, j->pq', self.endmember_noccupancies,
-                              self.site_multiplicities,
-                              inverseish(site_multiplicities)))
+        site_noccupancies = np.einsum(
+            "i, ij", molar_fractions, self.endmember_noccupancies
+        )
+        site_multiplicities = np.einsum(
+            "i, ij", molar_fractions, self.site_multiplicities
+        )
+
+        dlnadp = np.einsum(
+            "pj, qj, j->pq",
+            self.endmember_noccupancies,
+            self.endmember_noccupancies,
+            inverseish(site_noccupancies),
+        ) - np.einsum(
+            "pj, qj, j->pq",
+            self.endmember_noccupancies,
+            self.site_multiplicities,
+            inverseish(site_multiplicities),
+        )
 
         return dlnadp
 
     def _ideal_activities(self, molar_fractions):
-        return _ideal_activities_fct(molar_fractions,
-                                     self.endmember_noccupancies,
-                                     self.n_endmembers,
-                                     self.n_occupancies,
-                                     self.site_multiplicities,
-                                     self.endmember_configurational_entropies)
+        return _ideal_activities_fct(
+            molar_fractions,
+            self.endmember_noccupancies,
+            self.n_endmembers,
+            self.n_occupancies,
+            self.site_multiplicities,
+            self.endmember_configurational_entropies,
+        )
 
     def activity_coefficients(self, pressure, temperature, molar_fractions):
         return np.ones_like(molar_fractions)
 
     def activities(self, pressure, temperature, molar_fractions):
         return self._ideal_activities(molar_fractions)
 
 
-class AsymmetricRegularSolution (IdealSolution):
+class AsymmetricRegularSolution(IdealSolution):
 
     """
     Solution model implementing the asymmetric regular solution model
     formulation as described in :cite:`HP2003`.
 
     The excess nonconfigurational Gibbs energy is given by the
     expression:
@@ -499,40 +526,46 @@
     in the excess properties.
 
     .. math::
         \\phi_i = \\frac{\\alpha_i p_i}{\\sum_{k=1}^{n} \\alpha_k p_k},
         W_{ij} = \\frac{2 w_{ij}}{\\alpha_i + \\alpha_j} \\textrm{for i<j}
     """
 
-    def __init__(self, endmembers, alphas, energy_interaction,
-                 volume_interaction=None, entropy_interaction=None):
-
+    def __init__(
+        self,
+        endmembers,
+        alphas,
+        energy_interaction,
+        volume_interaction=None,
+        entropy_interaction=None,
+    ):
         self.n_endmembers = len(endmembers)
 
         # Create array of van Laar parameters
         self.alphas = np.array(alphas)
 
         # Create 2D arrays of interaction parameters
-        self.We = np.triu(2. / (self.alphas[:, np.newaxis] + self.alphas), 1)
-        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array([i for row in energy_interaction
-                                                                    for i in row])
+        self.We = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)
+        self.We[np.triu_indices(self.n_endmembers, 1)] *= np.array(
+            [i for row in energy_interaction for i in row]
+        )
 
         if entropy_interaction is not None:
-            self.Ws = np.triu(2. / (self.alphas[:, np.newaxis] + self.alphas),
-                              1)
-            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array([i for row in entropy_interaction
-                                                                        for i in row])
+            self.Ws = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)
+            self.Ws[np.triu_indices(self.n_endmembers, 1)] *= np.array(
+                [i for row in entropy_interaction for i in row]
+            )
         else:
             self.Ws = np.zeros((self.n_endmembers, self.n_endmembers))
 
         if volume_interaction is not None:
-            self.Wv = np.triu(2. / (self.alphas[:, np.newaxis] + self.alphas),
-                              1)
-            self.Wv[np.triu_indices(self.n_endmembers, 1)] *= np.array([i for row in volume_interaction
-                                                                        for i in row])
+            self.Wv = np.triu(2.0 / (self.alphas[:, np.newaxis] + self.alphas), 1)
+            self.Wv[np.triu_indices(self.n_endmembers, 1)] *= np.array(
+                [i for row in volume_interaction for i in row]
+            )
         else:
             self.Wv = np.zeros((self.n_endmembers, self.n_endmembers))
 
         # initialize ideal solution model
         IdealSolution.__init__(self, endmembers)
 
     def _phi(self, molar_fractions):
@@ -540,217 +573,238 @@
         phi = np.divide(phi, np.sum(phi))
         return phi
 
     def _non_ideal_interactions(self, W, molar_fractions):
         # -sum(sum(qi.qj.Wij*)
         # equation (2) of Holland and Powell 2003
         phi = self._phi(molar_fractions)
-        return _non_ideal_interactions_fct(phi, np.array(molar_fractions),
-                                           self.n_endmembers, self.alphas, W)
+        return _non_ideal_interactions_fct(
+            phi, np.array(molar_fractions), self.n_endmembers, self.alphas, W
+        )
 
-    def _non_ideal_excess_partial_gibbs(self, pressure, temperature,
-                                        molar_fractions):
+    def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):
         Eint = self._non_ideal_interactions(self.We, molar_fractions)
         Sint = self._non_ideal_interactions(self.Ws, molar_fractions)
         Vint = self._non_ideal_interactions(self.Wv, molar_fractions)
         return Eint - temperature * Sint + pressure * Vint
 
-    def excess_partial_gibbs_free_energies(self, pressure, temperature,
-                                           molar_fractions):
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
         ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(
-            pressure, temperature, molar_fractions)
+            pressure, temperature, molar_fractions
+        )
         return ideal_gibbs + non_ideal_gibbs
 
     def excess_partial_entropies(self, pressure, temperature, molar_fractions):
         ideal_entropies = IdealSolution._ideal_excess_partial_entropies(
-            self, temperature, molar_fractions)
-        non_ideal_entropies = self._non_ideal_interactions(self.Ws,
-                                                           molar_fractions)
+            self, temperature, molar_fractions
+        )
+        non_ideal_entropies = self._non_ideal_interactions(self.Ws, molar_fractions)
         return ideal_entropies + non_ideal_entropies
 
     def excess_partial_volumes(self, pressure, temperature, molar_fractions):
         return self._non_ideal_interactions(self.Wv, molar_fractions)
 
     def gibbs_hessian(self, pressure, temperature, molar_fractions):
-        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
         phi = self._phi(molar_fractions)
-        nonideal_gibbs_hessian = _non_ideal_hessian_fct(phi, molar_fractions,
-                                                        self.n_endmembers,
-                                                        self.alphas,
-                                                        self.We - temperature*self.Ws + pressure*self.Wv)
+        nonideal_gibbs_hessian = _non_ideal_hessian_fct(
+            phi,
+            molar_fractions,
+            self.n_endmembers,
+            self.alphas,
+            self.We - temperature * self.Ws + pressure * self.Wv,
+        )
 
-        return nonideal_gibbs_hessian - temperature*ideal_entropy_hessian
+        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian
 
     def entropy_hessian(self, pressure, temperature, molar_fractions):
-        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
         phi = self._phi(molar_fractions)
-        nonideal_entropy_hessian = _non_ideal_hessian_fct(phi, molar_fractions,
-                                                          self.n_endmembers,
-                                                          self.alphas,
-                                                          self.Ws)
+        nonideal_entropy_hessian = _non_ideal_hessian_fct(
+            phi, molar_fractions, self.n_endmembers, self.alphas, self.Ws
+        )
         return ideal_entropy_hessian + nonideal_entropy_hessian
 
     def volume_hessian(self, pressure, temperature, molar_fractions):
         phi = self._phi(molar_fractions)
-        return _non_ideal_hessian_fct(phi, molar_fractions,
-                                      self.n_endmembers, self.alphas,
-                                      self.Wv)
+        return _non_ideal_hessian_fct(
+            phi, molar_fractions, self.n_endmembers, self.alphas, self.Wv
+        )
 
     def activity_coefficients(self, pressure, temperature, molar_fractions):
-        if temperature > 1.e-10:
-            return np.exp(self._non_ideal_excess_partial_gibbs(pressure,
-                                                               temperature,
-                                                               molar_fractions)
-                          / (constants.gas_constant * temperature))
+        if temperature > 1.0e-10:
+            return np.exp(
+                self._non_ideal_excess_partial_gibbs(
+                    pressure, temperature, molar_fractions
+                )
+                / (constants.gas_constant * temperature)
+            )
         else:
             raise Exception("Activity coefficients not defined at 0 K.")
 
     def activities(self, pressure, temperature, molar_fractions):
-        return (IdealSolution.activities(self, pressure, temperature,
-                                         molar_fractions)
-                * self.activity_coefficients(pressure, temperature,
-                                             molar_fractions))
+        return IdealSolution.activities(
+            self, pressure, temperature, molar_fractions
+        ) * self.activity_coefficients(pressure, temperature, molar_fractions)
 
 
-class SymmetricRegularSolution (AsymmetricRegularSolution):
+class SymmetricRegularSolution(AsymmetricRegularSolution):
 
     """
     Solution model implementing the symmetric regular solution model.
     This is a special case of the
     :class:`burnman.solutionmodel.AsymmetricRegularSolution` class.
     """
 
-    def __init__(self, endmembers, energy_interaction,
-                 volume_interaction=None, entropy_interaction=None):
+    def __init__(
+        self,
+        endmembers,
+        energy_interaction,
+        volume_interaction=None,
+        entropy_interaction=None,
+    ):
         alphas = np.ones(len(endmembers))
         AsymmetricRegularSolution.__init__(
-            self, endmembers, alphas, energy_interaction, volume_interaction,
-            entropy_interaction)
+            self,
+            endmembers,
+            alphas,
+            energy_interaction,
+            volume_interaction,
+            entropy_interaction,
+        )
 
 
-class SubregularSolution (IdealSolution):
+class SubregularSolution(IdealSolution):
 
     """
     Solution model implementing the subregular solution model formulation
     as described in :cite:`HW1989`. The excess nonconfigurational
     Gibbs energy is given by the expression:
 
     .. math::
         \\mathcal{G}_{\\textrm{excess}} = \\sum_i \\sum_{j > i} (p_i p_j^2
         W_{ij} + p_j p_i^2 W_{ji} + \\sum_{k > j > i} p_i p_j p_k W_{ijk})
 
     Interaction parameters are inserted into a 3D interaction matrix during
     initialization to make use of numpy vector algebra.
 
-    Parameters
-    ----------
-    endmembers : list of lists
-        A list of all the independent endmembers in the solution.
+    :param endmembers: A list of all the independent endmembers in the solution.
         The first item of each list gives the Mineral object corresponding
         to the endmember. The second item gives the site-species formula.
-
-    energy_interaction : list of list of lists
-        The binary endmember interaction energies.
+    :type endmembers: list of lists
+    :param energy_interaction: The binary endmember interaction energies.
         Each interaction[i, j-i-1, 0] corresponds to W(i,j), while
         interaction[i, j-i-1, 1] corresponds to W(j,i).
-
-    volume_interaction : list of list of lists
-        The binary endmember interaction volumes.
+    :type energy_interaction: list of list of lists
+    :param volume_interaction: The binary endmember interaction volumes.
         Each interaction[i, j-i-1, 0] corresponds to W(i,j), while
         interaction[i, j-i-1, 1] corresponds to W(j,i).
-
-    entropy_interaction : list of list of lists
-        The binary endmember interaction entropies.
+    :type volume_interaction: list of list of lists
+    :param entropy_interaction: The binary endmember interaction entropies.
         Each interaction[i, j-i-1, 0] corresponds to W(i,j), while
         interaction[i, j-i-1, 1] corresponds to W(j,i).
+    :type entropy_interaction: list of list of lists
+    :param energy_ternary_terms: The ternary interaction energies.
+        Each list should contain four entries:
+        the indices i, j, k and the value of the interaction.
+    :type energy_ternary_terms: list of lists
+    :param volume_ternary_terms: The ternary interaction volumes.
+        Each list should contain four entries:
+        the indices i, j, k and the value of the interaction.
+    :type volume_ternary_terms: list of lists
+    :param entropy_ternary_terms: The ternary interaction entropies.
+        Each list should contain four entries:
+        the indices i, j, k and the value of the interaction.
+    :type entropy_ternary_terms: list of lists
+    """
 
-    energy_ternary_terms : list of lists
-        The ternary interaction energies. Each list should contain
-        four entries: the indices i, j, k and the value of the interaction.
-
-    volume_ternary_terms : list of lists
-        The ternary interaction volumes. Each list should contain
-        four entries: the indices i, j, k and the value of the interaction.
-
-    entropy_ternary_terms : list of lists
-        The ternary interaction entropies. Each list should contain
-        four entries: the indices i, j, k and the value of the interaction.
-    """
-
-    def __init__(self, endmembers, energy_interaction,
-                 volume_interaction=None, entropy_interaction=None,
-                 energy_ternary_terms=None,
-                 volume_ternary_terms=None, entropy_ternary_terms=None):
+    def __init__(
+        self,
+        endmembers,
+        energy_interaction,
+        volume_interaction=None,
+        entropy_interaction=None,
+        energy_ternary_terms=None,
+        volume_ternary_terms=None,
+        entropy_ternary_terms=None,
+    ):
         """
         Initialization function for the SubregularSolution class.
         """
 
         self.n_endmembers = len(endmembers)
 
         # Create 3D arrays of interaction parameters
-        self.Wijke = np.zeros(shape=(self.n_endmembers,
-                                     self.n_endmembers,
-                                     self.n_endmembers))
+        self.Wijke = np.zeros(
+            shape=(self.n_endmembers, self.n_endmembers, self.n_endmembers)
+        )
         self.Wijks = np.zeros_like(self.Wijke)
         self.Wijkv = np.zeros_like(self.Wijke)
 
         # setup excess enthalpy interaction matrix
         for i in range(self.n_endmembers):
             for j in range(i + 1, self.n_endmembers):
-                w0 = energy_interaction[i][j - i - 1][0]/2.
-                w1 = energy_interaction[i][j - i - 1][1]/2.
+                w0 = energy_interaction[i][j - i - 1][0] / 2.0
+                w1 = energy_interaction[i][j - i - 1][1] / 2.0
                 self.Wijke[:, i, j] += w0
                 self.Wijke[:, j, i] += w1
 
                 self.Wijke[i, j, j] += w0
                 self.Wijke[j, i, i] += w1
 
                 self.Wijke[i, j, i] -= w0
                 self.Wijke[j, i, j] -= w1
 
         if energy_ternary_terms is not None:
-            for (i, j, k, v) in energy_ternary_terms:
+            for i, j, k, v in energy_ternary_terms:
                 self.Wijke[i, j, k] += v
 
         if entropy_interaction is not None:
             for i in range(self.n_endmembers):
                 for j in range(i + 1, self.n_endmembers):
-                    w0 = entropy_interaction[i][j - i - 1][0]/2.
-                    w1 = entropy_interaction[i][j - i - 1][1]/2.
+                    w0 = entropy_interaction[i][j - i - 1][0] / 2.0
+                    w1 = entropy_interaction[i][j - i - 1][1] / 2.0
                     self.Wijks[:, i, j] += w0
                     self.Wijks[:, j, i] += w1
 
                     self.Wijks[i, j, j] += w0
                     self.Wijks[j, i, i] += w1
 
                     self.Wijks[i, j, i] -= w0
                     self.Wijks[j, i, j] -= w1
 
         if entropy_ternary_terms is not None:
-            for (i, j, k, v) in entropy_ternary_terms:
+            for i, j, k, v in entropy_ternary_terms:
                 self.Wijks[i, j, k] += v
 
         if volume_interaction is not None:
             for i in range(self.n_endmembers):
                 for j in range(i + 1, self.n_endmembers):
-                    w0 = volume_interaction[i][j - i - 1][0]/2.
-                    w1 = volume_interaction[i][j - i - 1][1]/2.
+                    w0 = volume_interaction[i][j - i - 1][0] / 2.0
+                    w1 = volume_interaction[i][j - i - 1][1] / 2.0
                     self.Wijkv[:, i, j] += w0
                     self.Wijkv[:, j, i] += w1
 
                     self.Wijkv[i, j, j] += w0
                     self.Wijkv[j, i, i] += w1
 
                     self.Wijkv[i, j, i] -= w0
                     self.Wijkv[j, i, j] -= w1
 
         if volume_ternary_terms is not None:
-            for (i, j, k, v) in volume_ternary_terms:
+            for i, j, k, v in volume_ternary_terms:
                 self.Wijkv[i, j, k] += v
 
         # initialize ideal solution model
         IdealSolution.__init__(self, endmembers)
 
     def _non_ideal_function(self, Wijk, molar_fractions):
         n = len(molar_fractions)
@@ -763,180 +817,650 @@
         Vint = self._non_ideal_function(self.Wijkv, molar_fractions)
         return Eint, Sint, Vint
 
     def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):
         Eint, Sint, Vint = self._non_ideal_interactions(molar_fractions)
         return Eint - temperature * Sint + pressure * Vint
 
-    def excess_partial_gibbs_free_energies(self, pressure, temperature, molar_fractions):
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
         ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(
-            pressure, temperature, molar_fractions)
+            pressure, temperature, molar_fractions
+        )
         return ideal_gibbs + non_ideal_gibbs
 
     def excess_partial_entropies(self, pressure, temperature, molar_fractions):
         ideal_entropies = IdealSolution._ideal_excess_partial_entropies(
-            self, temperature, molar_fractions)
-        non_ideal_entropies = self._non_ideal_function(self.Wijks,
-                                                       molar_fractions)
+            self, temperature, molar_fractions
+        )
+        non_ideal_entropies = self._non_ideal_function(self.Wijks, molar_fractions)
         return ideal_entropies + non_ideal_entropies
 
     def excess_partial_volumes(self, pressure, temperature, molar_fractions):
-        non_ideal_volumes = self._non_ideal_function(self.Wijkv,
-                                                     molar_fractions)
+        non_ideal_volumes = self._non_ideal_function(self.Wijkv, molar_fractions)
         return non_ideal_volumes
 
     def gibbs_hessian(self, pressure, temperature, molar_fractions):
         n = len(molar_fractions)
-        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
-        nonideal_gibbs_hessian = _non_ideal_hessian_subreg(molar_fractions, n,
-                                                           self.Wijke - temperature*self.Wijks
-                                                           + pressure*self.Wijkv)
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
+        nonideal_gibbs_hessian = _non_ideal_hessian_subreg(
+            molar_fractions,
+            n,
+            self.Wijke - temperature * self.Wijks + pressure * self.Wijkv,
+        )
 
-        return nonideal_gibbs_hessian - temperature*ideal_entropy_hessian
+        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian
 
     def entropy_hessian(self, pressure, temperature, molar_fractions):
         n = len(molar_fractions)
-        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
-        nonideal_entropy_hessian = _non_ideal_hessian_subreg(molar_fractions, n,
-                                                             self.Wijks)
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
+        nonideal_entropy_hessian = _non_ideal_hessian_subreg(
+            molar_fractions, n, self.Wijks
+        )
         return ideal_entropy_hessian + nonideal_entropy_hessian
 
     def volume_hessian(self, pressure, temperature, molar_fractions):
         n = len(molar_fractions)
         return _non_ideal_hessian_subreg(molar_fractions, n, self.Wijkv)
 
     def activity_coefficients(self, pressure, temperature, molar_fractions):
-        if temperature > 1.e-10:
-            return np.exp(self._non_ideal_excess_partial_gibbs(pressure,
-                                                               temperature,
-                                                               molar_fractions)
-                          / (constants.gas_constant * temperature))
+        if temperature > 1.0e-10:
+            return np.exp(
+                self._non_ideal_excess_partial_gibbs(
+                    pressure, temperature, molar_fractions
+                )
+                / (constants.gas_constant * temperature)
+            )
         else:
             raise Exception("Activity coefficients not defined at 0 K.")
 
     def activities(self, pressure, temperature, molar_fractions):
-        return (IdealSolution.activities(self, pressure, temperature,
-                                         molar_fractions)
-                * self.activity_coefficients(pressure, temperature,
-                                             molar_fractions))
+        return IdealSolution.activities(
+            self, pressure, temperature, molar_fractions
+        ) * self.activity_coefficients(pressure, temperature, molar_fractions)
 
 
-class FunctionSolution (IdealSolution):
+class FunctionSolution(IdealSolution):
     """
     Solution model implementing a generalized solution model.
     The extensive excess nonconfigurational Gibbs energy is
     provided as a function by the user.
 
     Derivatives are calculated using the autograd module,
     and so the user-defined excess Gibbs energy function
     should be defined using autograd-friendly expressions.
 
-    Parameters
-    ----------
-    endmembers : list of lists
-        A list of all the independent endmembers in the solution.
+    :param endmembers: A list of all the independent endmembers in the solution.
         The first item of each list gives the Mineral object corresponding
         to the endmember. The second item gives the site-species formula.
+    :type endmembers: list of lists
 
-    excess_gibbs_function : function
-        The nonconfigurational Gibbs energy function with arguments
-        pressure, temperature and molar_amounts, in that order.
+    :param excess_gibbs_function: The nonconfigurational Gibbs energy function
+        with arguments pressure, temperature and molar_amounts, in that order.
         Note that the function must be extensive; if the molar amounts
         are doubled, the Gibbs energy must also double.
+    :type excess_gibbs_function: function
     """
 
     def __init__(self, endmembers, excess_gibbs_function):
         """
         Initialization function for the GeneralSolution class.
         """
 
         # initialize ideal solution model
         IdealSolution.__init__(self, endmembers)
 
         self.n_endmembers = len(endmembers)
         self._excess_gibbs_function = excess_gibbs_function
 
-        self._non_ideal_excess_partial_gibbs = ag.jacobian(excess_gibbs_function,
-                                                           argnum=2)
+        self._non_ideal_excess_partial_gibbs = ag.jacobian(
+            excess_gibbs_function, argnum=2
+        )
 
         def partial_entropies(pressure, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return -ag.jacobian(self._non_ideal_excess_partial_gibbs,
-                                    argnum=1)(pressure, temperature,
-                                              molar_amounts)
+                return -ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=1)(
+                    pressure, temperature, molar_amounts
+                )
 
         self._non_ideal_excess_partial_entropies = partial_entropies
 
         def partial_volumes(pressure, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return ag.jacobian(self._non_ideal_excess_partial_gibbs,
-                                   argnum=0)(pressure, temperature,
-                                             molar_amounts)
+                return ag.jacobian(self._non_ideal_excess_partial_gibbs, argnum=0)(
+                    pressure, temperature, molar_amounts
+                )
 
         self.excess_partial_volumes = partial_volumes
 
-        self._non_ideal_gibbs_hessian = ag.jacobian(self._non_ideal_excess_partial_gibbs,
-                                                    argnum=2)
+        self._non_ideal_gibbs_hessian = ag.jacobian(
+            self._non_ideal_excess_partial_gibbs, argnum=2
+        )
 
         def entropy_hess(pressure, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return ag.jacobian(partial_entropies, argnum=2)(pressure,
-                                                                temperature,
-                                                                molar_amounts)
+                return ag.jacobian(partial_entropies, argnum=2)(
+                    pressure, temperature, molar_amounts
+                )
 
         self._non_ideal_entropy_hessian = entropy_hess
 
         def volume_hess(pressure, temperature, molar_amounts):
             with warnings.catch_warnings(record=True):
                 warnings.simplefilter("always")
-                return ag.jacobian(partial_volumes, argnum=2)(pressure,
-                                                              temperature,
-                                                              molar_amounts)
+                return ag.jacobian(partial_volumes, argnum=2)(
+                    pressure, temperature, molar_amounts
+                )
 
         self.volume_hessian = volume_hess
 
-    def excess_partial_gibbs_free_energies(self, pressure, temperature, molar_fractions):
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
         ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(
-            pressure, temperature, molar_fractions)
+            pressure, temperature, molar_fractions
+        )
         return ideal_gibbs + non_ideal_gibbs
 
     def excess_partial_entropies(self, pressure, temperature, molar_fractions):
         ideal_entropies = IdealSolution._ideal_excess_partial_entropies(
-            self, temperature, molar_fractions)
+            self, temperature, molar_fractions
+        )
         non_ideal_entropies = self._non_ideal_excess_partial_entropies(
-            pressure, temperature, molar_fractions)
+            pressure, temperature, molar_fractions
+        )
         return ideal_entropies + non_ideal_entropies
 
     def gibbs_hessian(self, pressure, temperature, molar_fractions):
-        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
         nonideal_gibbs_hessian = self._non_ideal_gibbs_hessian(
-            pressure, temperature, molar_fractions)
+            pressure, temperature, molar_fractions
+        )
 
-        return nonideal_gibbs_hessian - temperature*ideal_entropy_hessian
+        return nonideal_gibbs_hessian - temperature * ideal_entropy_hessian
 
     def entropy_hessian(self, pressure, temperature, molar_fractions):
-        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(self, temperature, molar_fractions)
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
         nonideal_entropy_hessian = self._non_ideal_entropy_hessian(
-            pressure, temperature, molar_fractions)
+            pressure, temperature, molar_fractions
+        )
         return ideal_entropy_hessian + nonideal_entropy_hessian
 
     def activity_coefficients(self, pressure, temperature, molar_fractions):
-        if temperature > 1.e-10:
-            return np.exp(self._non_ideal_excess_partial_gibbs(pressure,
-                                                               temperature,
-                                                               molar_fractions)
-                          / (constants.gas_constant * temperature))
+        if temperature > 1.0e-10:
+            return np.exp(
+                self._non_ideal_excess_partial_gibbs(
+                    pressure, temperature, molar_fractions
+                )
+                / (constants.gas_constant * temperature)
+            )
+        else:
+            raise Exception("Activity coefficients not defined at 0 K.")
+
+    def activities(self, pressure, temperature, molar_fractions):
+        return IdealSolution.activities(
+            self, pressure, temperature, molar_fractions
+        ) * self.activity_coefficients(pressure, temperature, molar_fractions)
+
+
+class PolynomialSolution(IdealSolution):
+    """
+    Solution model implementing a general polynomial solution model.
+
+    :param endmembers: A list of all the independent endmembers in the solution.
+        The first item of each list gives the Mineral object corresponding
+        to the endmember. The second item gives the site-species formula.
+    :type endmembers: list of lists
+    :param ESV_interactions: A list containing lists where the first three elements are
+        energy, entropy and volume interactions and the rest of the elements
+        are indices of the transformed endmembers to which those
+        interactions correspond.
+        For example, [2., 0., 0., 0, 1, 1] would correspond to an interaction
+        of 2*p'[0]*p'[1]*p'[1].
+    :type ESV_interactions: list of lists
+    :param interaction_endmembers: A list of minerals involved in the interaction terms.
+    :type interaction_endmembers: list of :class:`burnman.Mineral` objects
+    :param endmember_coefficients_and_interactions: list of lists
+        A list containing lists where the first n elements are
+        coefficients for each of the interaction_endmembers and the
+        rest of the elements are indices of the transformed
+        endmembers to which those interactions correspond.
+        For example, [1., 0., -1., 0, 1, 1] would correspond to an interaction
+        of (mbr[0].gibbs - mbr[2].gibbs)*p'[0]*p'[1]*p'[1].
+    :type endmember_coefficients_and_interactions: list of lists
+    :param transformation_matrix: The interactions for a given solution may
+        be most compactly expressed not as a polynomial function of the
+        proportions of the endmembers, but a polynomial function of a
+        linearly transformed set. This parameter is a square numpy array A,
+        where p'i = A_ij p_j
+    :type transformation_matrix: 2D numpy array
+    """
+
+    def __init__(
+        self,
+        endmembers,
+        ESV_interactions=None,
+        interaction_endmembers=[],
+        endmember_coefficients_and_interactions=None,
+        transformation_matrix=None,
+    ):
+        # initialize ideal solution model
+        IdealSolution.__init__(self, endmembers)
+
+        self.n_endmembers = len(endmembers)
+        self.endmembers = endmembers
+
+        self.W_ESV = None
+        if ESV_interactions is not None:
+            self.W_ESV = self.make_interaction_arrays(ESV_interactions)
+
+        self.n_interaction_endmembers = len(interaction_endmembers)
+        self.interaction_endmembers = interaction_endmembers
+
+        self.W_mbr = None
+        if self.n_interaction_endmembers > 0:
+            self.W_mbr = self.make_endmember_interaction_arrays(
+                endmember_coefficients_and_interactions
+            )
+
+        self.transformation_matrix = transformation_matrix
+        self.reset()
+
+    def reset(self):
+        """
+        Resets all cached material properties.
+        It is typically not required for the user to call this function.
+        """
+        self._cached = {}
+
+    def set_composition(self, molar_fractions):
+        """
+        Resets all cached material properties.
+        It is typically not required for the user to call this function.
+        """
+        self.reset()
+        self.molar_fractions = molar_fractions
+
+    def set_state(self, pressure, temperature):
+        """
+        Sets the states for the interaction endmembers.
+        It is typically not required for the user to call this function.
+        """
+        for mbr in self.interaction_endmembers:
+            mbr.set_state(pressure, temperature)
+
+    def make_interaction_arrays(self, Ws):
+        n_Ws = len(Ws)
+        for i, W in enumerate(Ws):
+            if not all(W[i] <= W[i + 1] for i in range(3, len(W) - 1)):
+                raise Exception(
+                    f"Interaction parameter {i+1}/{n_Ws} must be "
+                    "upper triangular (i<=j<=k<=...<=z)"
+                )
+            if not W[3] < W[-1]:
+                raise Exception(
+                    f"Interaction parameter {i+1}/{n_Ws} must not lie on the "
+                    "first diagonal (i=j=k=...=z)"
+                )
+
+        W_arrays = []
+
+        dims = sorted(list(set([len(W) - 3 for W in Ws])))
+        for dim in dims:
+            coords = [
+                [0, *W[3:]] for W in Ws if len(W) == dim + 3 and np.abs(W[0]) > 1.0e-10
+            ]
+            coords.extend(
+                [
+                    [1, *W[3:]]
+                    for W in Ws
+                    if len(W) == dim + 3 and np.abs(W[1]) > 1.0e-10
+                ]
+            )
+            coords.extend(
+                [
+                    [2, *W[3:]]
+                    for W in Ws
+                    if len(W) == dim + 3 and np.abs(W[2]) > 1.0e-10
+                ]
+            )
+            coords = list(zip(*coords))
+
+            data = [W[0] for W in Ws if len(W) == dim + 3 and np.abs(W[0]) > 1.0e-10]
+            data.extend(
+                [W[1] for W in Ws if len(W) == dim + 3 and np.abs(W[1]) > 1.0e-10]
+            )
+            data.extend(
+                [W[2] for W in Ws if len(W) == dim + 3 and np.abs(W[2]) > 1.0e-10]
+            )
+
+            shape = [3]  # First dimension is for E, S, V
+            shape.extend([self.n_endmembers for i in range(dim)])
+
+            shape = tuple(shape)
+            s = sparse.COO(coords, data, shape=shape).todense()
+            W_arrays.append((dim, s))
+        return W_arrays
+
+    def make_endmember_interaction_arrays(self, Ws):
+        n_Ws = len(Ws)
+        n_int = self.n_interaction_endmembers
+        for i, W in enumerate(Ws):
+            if not all(W[i] <= W[i + 1] for i in range(n_int, len(W) - 1)):
+                raise Exception(
+                    f"Interaction parameter {i+1}/{n_Ws} must be "
+                    "upper triangular (i<=j<=k<=...<=z)"
+                )
+            if not W[n_int] < W[-1]:
+                raise Exception(
+                    f"Interaction parameter {i+1}/{n_Ws} must not lie on the "
+                    "first diagonal (i=j=k=...=z)"
+                )
+
+        W_arrays = []
+
+        dims = sorted(list(set([len(W) - n_int for W in Ws])))
+        for dim in dims:
+            coords = []
+            data = []
+            for i in range(n_int):
+                coords.extend(
+                    [
+                        [i, *W[n_int:]]
+                        for W in Ws
+                        if len(W) == dim + n_int and np.abs(W[i]) > 1.0e-10
+                    ]
+                )
+                data.extend(
+                    [
+                        W[i]
+                        for W in Ws
+                        if len(W) == dim + n_int and np.abs(W[i]) > 1.0e-10
+                    ]
+                )
+
+            coords = list(zip(*coords))
+
+            shape = [n_int]  # First dimension is for the excess_endmembers
+            shape.extend([self.n_endmembers for i in range(dim)])
+
+            shape = tuple(shape)
+            s = sparse.COO(coords, data, shape=shape).todense()
+            W_arrays.append((dim, s))
+        return W_arrays
+
+    def transform_scalar_list(self, x, A):
+        if A is not None:
+            return A.dot(x)
+        else:
+            return x
+
+    def transform_gradient_list(self, W, A):
+        if A is not None:
+            return np.einsum("ij, jk->ik", W, A)
+        else:
+            return W
+
+    def transform_hessian_list(self, W, A):
+        if A is not None:
+            return np.einsum("ki, mij, lj->mkl", A, W, A)
+        else:
+            return W
+
+    def W_dots_x(self, dim, W_array, x):
+        if dim == 0:
+            return W_array
+        else:
+            ESVdim = [W_array]
+            ESVdim.extend([x for i in range(dim)])
+            strng = string.ascii_lowercase[: W_array.ndim]
+            strng2 = ", ".join(strng[-dim:])
+            strng += f", {strng2}"
+            return np.einsum(strng, *ESVdim)
+
+    def rolled_array(self, W, istart):
+        W_array_rolled = deepcopy(W)
+        dim = len(W.shape) - 1
+
+        W_roll = deepcopy(W)
+        for i in range(dim - istart):
+            W_roll = np.moveaxis(W_roll, istart, -1)
+            W_array_rolled += W_roll
+        return W_array_rolled
+
+    def get_scalar_list(self, x, W_arrays, A):
+        xp = self.transform_scalar_list(x, A)
+        xp_total = np.sum(xp)
+        ESV = np.zeros(W_arrays[0][-1].shape[0])
+        for dim, W_array in W_arrays:
+            ESV += self.W_dots_x(dim, W_array, xp) / np.power(xp_total, dim - 1.0)
+        return ESV
+
+    def get_gradient_list(self, x, W_arrays, A):
+        xp = self.transform_scalar_list(x, A)
+        xp_total = np.sum(xp)
+
+        dESVdx = np.zeros(W_arrays[0][-1].shape[:2])
+
+        for dim, W_array in W_arrays:
+            dESVdx += (
+                -(dim - 1)
+                / np.power(xp_total, dim)
+                * self.W_dots_x(dim, W_array, xp)[:, np.newaxis]
+            )
+
+            W_array_rolled = self.rolled_array(W_array, 1)
+            dESVdx += self.W_dots_x(dim - 1, W_array_rolled, xp) / np.power(
+                xp_total, dim - 1.0
+            )
+        return self.transform_gradient_list(dESVdx, A)
+
+    def get_hessian_list(self, x, W_arrays, A):
+        xp = self.transform_scalar_list(x, A)
+        xp_total = np.sum(xp)
+
+        d2ESVdx2 = np.zeros(W_arrays[0][-1].shape[:3])
+
+        for dim, W_array in W_arrays:
+            d2ESVdx2 += (
+                (dim - 1)
+                * dim
+                / np.power(xp_total, dim + 1)
+                * self.W_dots_x(dim, W_array, xp)[:, np.newaxis, np.newaxis]
+            )
+
+            W_array_rolled = self.rolled_array(W_array, 1)
+
+            f = self.W_dots_x(dim - 1, W_array_rolled, xp)
+            h = f[:, np.newaxis, :] + f[:, :, np.newaxis]
+
+            d2ESVdx2 += -(dim - 1) / np.power(xp_total, dim) * h
+
+            W_array_rolled_2 = self.rolled_array(W_array_rolled, 2)
+            g = self.W_dots_x(dim - 2, W_array_rolled_2, xp)
+
+            d2ESVdx2 += g / np.power(xp_total, dim - 1.0)
+
+        return self.transform_hessian_list(d2ESVdx2, A)
+
+    @material_property
+    def ESV_scalar_list(self):
+        if self.W_ESV is None:
+            return np.zeros((3))
+        else:
+            return self.get_scalar_list(
+                self.molar_fractions, self.W_ESV, self.transformation_matrix
+            )
+
+    @material_property
+    def ESV_gradient_list(self):
+        if self.W_ESV is None:
+            return np.zeros((3, self.n_endmembers))
+        else:
+            return self.get_gradient_list(
+                self.molar_fractions, self.W_ESV, self.transformation_matrix
+            )
+
+    @material_property
+    def ESV_hessian_list(self):
+        if self.W_ESV is None:
+            return np.zeros((3, self.n_endmembers, self.n_endmembers))
+        else:
+            return self.get_hessian_list(
+                self.molar_fractions, self.W_ESV, self.transformation_matrix
+            )
+
+    @material_property
+    def mbr_scalar_list(self):
+        if self.W_mbr is None:
+            return np.zeros((0))
+        else:
+            return self.get_scalar_list(
+                self.molar_fractions, self.W_mbr, self.transformation_matrix
+            )
+
+    @material_property
+    def mbr_gradient_list(self):
+        if self.W_mbr is None:
+            return np.zeros((0, self.n_endmembers))
+        else:
+            return self.get_gradient_list(
+                self.molar_fractions, self.W_mbr, self.transformation_matrix
+            )
+
+    @material_property
+    def mbr_hessian_list(self):
+        if self.W_mbr is None:
+            return np.zeros((0, self.n_endmembers, self.n_endmembers))
+        else:
+            return self.get_hessian_list(
+                self.molar_fractions, self.W_mbr, self.transformation_matrix
+            )
+
+    def _non_ideal_excess_partial_gibbs(self, pressure, temperature, molar_fractions):
+        dEdx, dSdx, dVdx = self.ESV_gradient_list
+        mbr_gradients = self.mbr_gradient_list
+        mbr_gibbs = np.array([mbr.gibbs for mbr in self.interaction_endmembers])
+        gibbs = dEdx - temperature * dSdx + pressure * dVdx
+        gibbs += np.einsum("i, ij->j", mbr_gibbs, mbr_gradients)
+        return gibbs
+
+    def excess_partial_gibbs_free_energies(
+        self, pressure, temperature, molar_fractions
+    ):
+        ideal_gibbs = IdealSolution._ideal_excess_partial_gibbs(
+            self, temperature, molar_fractions
+        )
+        non_ideal_gibbs = self._non_ideal_excess_partial_gibbs(
+            pressure, temperature, molar_fractions
+        )
+        return ideal_gibbs + non_ideal_gibbs
+
+    def excess_partial_entropies(self, pressure, temperature, molar_fractions):
+        ideal_entropies = IdealSolution._ideal_excess_partial_entropies(
+            self, temperature, molar_fractions
+        )
+
+        dSdx = self.ESV_gradient_list[1]
+        mbr_gradients = self.mbr_gradient_list
+        mbr_entropies = np.array([mbr.S for mbr in self.interaction_endmembers])
+
+        non_ideal_entropies = dSdx + np.einsum("i, ij->j", mbr_entropies, mbr_gradients)
+        return ideal_entropies + non_ideal_entropies
+
+    def excess_partial_volumes(self, pressure, temperature, molar_fractions):
+        dVdx = self.ESV_gradient_list[2]
+        mbr_gradients = self.mbr_gradient_list
+        mbr_volumes = np.array([mbr.V for mbr in self.interaction_endmembers])
+
+        return dVdx + np.einsum("i, ij->j", mbr_volumes, mbr_gradients)
+
+    def gibbs_hessian(self, pressure, temperature, molar_fractions):
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
+
+        d2Edx2, d2Sdx2, d2Vdx2 = self.ESV_hessian_list
+        mbr_hessian = self.mbr_hessian_list
+        mbr_gibbs = np.array([mbr.gibbs for mbr in self.interaction_endmembers])
+
+        d2Gdx2 = d2Edx2 - temperature * d2Sdx2 + pressure * d2Vdx2
+        d2Gdx2 += np.einsum("i, ijk->jk", mbr_gibbs, mbr_hessian)
+
+        return d2Gdx2 - temperature * ideal_entropy_hessian
+
+    def entropy_hessian(self, pressure, temperature, molar_fractions):
+        ideal_entropy_hessian = IdealSolution._ideal_entropy_hessian(
+            self, temperature, molar_fractions
+        )
+
+        d2Sdx2 = self.ESV_hessian_list[1]
+        mbr_hessian = self.mbr_hessian_list
+        mbr_entropies = np.array([mbr.S for mbr in self.interaction_endmembers])
+
+        d2Sdx2 += np.einsum("i, ijk->jk", mbr_entropies, mbr_hessian)
+
+        return d2Sdx2 + ideal_entropy_hessian
+
+    def volume_hessian(self, pressure, temperature, molar_fractions):
+        d2Vdx2 = self.ESV_hessian_list[2]
+        mbr_hessian = self.mbr_hessian_list
+        mbr_volumes = np.array([mbr.V for mbr in self.interaction_endmembers])
+
+        d2Vdx2 += np.einsum("i, ijk->jk", mbr_volumes, mbr_hessian)
+
+        return d2Vdx2
+
+    def Cp_excess(self):
+        mbr_scalar = self.mbr_scalar_list
+        mbr_Cp = np.array(
+            [mbr.molar_heat_capacity_p for mbr in self.interaction_endmembers]
+        )
+        return np.einsum("i, i", mbr_scalar, mbr_Cp)
+
+    def alphaV_excess(self):
+        mbr_scalar = self.mbr_scalar_list
+        mbr_d2gibbsdpdt = np.array(
+            [mbr.alpha * mbr.V for mbr in self.interaction_endmembers]
+        )
+        return np.einsum("i, i", mbr_scalar, mbr_d2gibbsdpdt)
+
+    def VoverKT_excess(self):
+        mbr_scalar = self.mbr_scalar_list
+        mbr_d2gibbsdpdp = np.array(
+            [mbr.V / mbr.K_T for mbr in self.interaction_endmembers]
+        )
+        return np.einsum("i, i", mbr_scalar, mbr_d2gibbsdpdp)
+
+    def activity_coefficients(self, pressure, temperature, molar_fractions):
+        if temperature > 1.0e-10:
+            return np.exp(
+                self._non_ideal_excess_partial_gibbs(
+                    pressure, temperature, molar_fractions
+                )
+                / (constants.gas_constant * temperature)
+            )
         else:
             raise Exception("Activity coefficients not defined at 0 K.")
 
     def activities(self, pressure, temperature, molar_fractions):
-        return (IdealSolution.activities(self, pressure, temperature,
-                                         molar_fractions)
-                * self.activity_coefficients(pressure, temperature,
-                                             molar_fractions))
+        return IdealSolution.activities(
+            self, pressure, temperature, molar_fractions
+        ) * self.activity_coefficients(pressure, temperature, molar_fractions)
```

### Comparing `burnman-1.1.0/burnman/constants.py` & `burnman-1.2.0/burnman/constants.py`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/AA1994_liq_iron_PTrho_reference_isentrope.png` & `burnman-1.2.0/burnman/data/input_figures/AA1994_liq_iron_PTrho_reference_isentrope.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/AA1994_liq_iron_TCv_different_densities.png` & `burnman-1.2.0/burnman/data/input_figures/AA1994_liq_iron_TCv_different_densities.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/AA1994_liq_iron_Trho_1bar.png` & `burnman-1.2.0/burnman/data/input_figures/AA1994_liq_iron_Trho_1bar.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/Ahmad.png` & `burnman-1.2.0/burnman/data/input_figures/Ahmad.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/Avseth_et_al_2010_fig3_K.png` & `burnman-1.2.0/burnman/data/input_figures/Avseth_et_al_2010_fig3_K.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/Dewaele.png` & `burnman-1.2.0/burnman/data/input_figures/Dewaele.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig1_K.png` & `burnman-1.2.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig1_K.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig2_G.png` & `burnman-1.2.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig2_G.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig3_E.png` & `burnman-1.2.0/burnman/data/input_figures/Hashin_Shtrikman_1963_fig3_E.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/berryman_fig4.png` & `burnman-1.2.0/burnman/data/input_figures/berryman_fig4.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/matas_vp_forcomparison.png` & `burnman-1.2.0/burnman/data/input_figures/matas_vp_forcomparison.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/matas_vs_forcomparison.png` & `burnman-1.2.0/burnman/data/input_figures/matas_vs_forcomparison.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/murakami_book_chapter.png` & `burnman-1.2.0/burnman/data/input_figures/murakami_book_chapter.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/murakami_book_chapter_b.png` & `burnman-1.2.0/burnman/data/input_figures/murakami_book_chapter_b.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/murakami_vs_cmp.png` & `burnman-1.2.0/burnman/data/input_figures/murakami_vs_cmp.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig1.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig1.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig10a.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig10a.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig3.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig3.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig7_Cp.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig7_Cp.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig7_G.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig7_G.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig7_K.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig7_K.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/slb_fig7_vol.png` & `burnman-1.2.0/burnman/data/input_figures/slb_fig7_vol.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/watt_1976_a1.png` & `burnman-1.2.0/burnman/data/input_figures/watt_1976_a1.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_figures/watt_1976_a2.png` & `burnman-1.2.0/burnman/data/input_figures/watt_1976_a2.png`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_fitting/Bertka_Fei_1997_mars_mantle.dat` & `burnman-1.2.0/burnman/data/input_fitting/Bertka_Fei_1997_mars_mantle.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_fitting/Dubrovinsky_Saxena_1997_TV_periclase.dat` & `burnman-1.2.0/burnman/data/input_fitting/Dubrovinsky_Saxena_1997_TV_periclase.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_fitting/PVT_MgO_Dewaele_et_al_2000.dat` & `burnman-1.2.0/burnman/data/input_fitting/PVT_MgO_Dewaele_et_al_2000.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_fitting/Victor_Douglas_1963_deltaH_MgO.dat` & `burnman-1.2.0/burnman/data/input_fitting/Victor_Douglas_1963_deltaH_MgO.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_geotherm/Stacey_1977_continents.txt` & `burnman-1.2.0/burnman/data/input_geotherm/Stacey_1977_continents.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_geotherm/Stacey_1977_oceans.txt` & `burnman-1.2.0/burnman/data/input_geotherm/Stacey_1977_oceans.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_geotherm/anderson_82.txt` & `burnman-1.2.0/burnman/data/input_geotherm/anderson_82.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_geotherm/brown_81.txt` & `burnman-1.2.0/burnman/data/input_geotherm/brown_81.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_masses/atomic_masses.dat` & `burnman-1.2.0/burnman/data/input_masses/atomic_masses.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_masses/atomic_numbers.dat` & `burnman-1.2.0/burnman/data/input_masses/atomic_numbers.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_minphys/slb_fig7.txt` & `burnman-1.2.0/burnman/data/input_minphys/slb_fig7.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_perplex/fo50_HP2011_params.dat` & `burnman-1.2.0/burnman/data/input_perplex/fo50_HP2011_params.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_perplex/fo_HP2011_params.dat` & `burnman-1.2.0/burnman/data/input_perplex/fo_HP2011_params.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_perplex/fo_SLB2011_params.dat` & `burnman-1.2.0/burnman/data/input_perplex/fo_SLB2011_params.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_perplex/in23_1.tab` & `burnman-1.2.0/burnman/data/input_perplex/in23_1.tab`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_perplex/test_SLB_entropy_and_landau.dat` & `burnman-1.2.0/burnman/data/input_perplex/test_SLB_entropy_and_landau.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/HGP633data_to_burnman.py` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HPdata_to_burnman.py`

 * *Files 25% similar despite different names*

```diff
@@ -10,268 +10,319 @@
 # - other endmembers are currently ignored.
 
 
 import sys
 import os.path
 import pprint
 from collections import OrderedDict
+
 # hack to allow scripts to be placed in subdirectories next to burnman:
-if not os.path.exists('burnman') and os.path.exists('../../../burnman'):
-    sys.path.insert(1, os.path.abspath('../../..'))
+if not os.path.exists("burnman") and os.path.exists("../../../burnman"):
+    sys.path.insert(1, os.path.abspath("../../.."))
 
 from burnman.tools.chemistry import dictionarize_formula, formula_mass
 
 
-if not os.path.isfile('tc-ds633.txt'):
-    print('This code requires the data file tc-ds633.txt.')
-    print(
-        'This file is bundled with the software package THERMOCALC, which can be found here:')
+if not os.path.isfile("tc-ds62.txt"):
+    print("This code requires the data file tc-ds62.txt.")
     print(
-        'https://www.esc.cam.ac.uk/research/research-groups/research-projects/tim-hollands-software-pages/thermocalc')
-    print('')
-    print('Please download the file and place it in this directory.')
+        "This file is bundled with the software package THERMOCALC, "
+        "which can be found here:"
+    )
+    print("http://www.metamorph.geo.uni-mainz.de/thermocalc/" "dataset6/index.html")
+    print("")
+    print("Please download the file and place it in this directory.")
     exit()
 
 # Components
-components = ['Si', 'Ti', 'Al', 'Fe', 'Mg', 'Mn', 'Ca', 'Na',
-              'K', 'O', 'H', 'C', 'Cl', 'e-', 'Ni', 'Zr', 'S', 'Cu', 'Cr']
+components = [
+    "Si",
+    "Ti",
+    "Al",
+    "Fe",
+    "Mg",
+    "Mn",
+    "Ca",
+    "Na",
+    "K",
+    "O",
+    "H",
+    "C",
+    "Cl",
+    "e-",
+    "Ni",
+    "Zr",
+    "S",
+    "Cu",
+    "Cr",
+]
 
 
 class Endmember:
-
-    def __init__(self, name, atoms, formula, sites, comp,
-                 H, S, V, Cp, a, k, flag, od):
+    def __init__(self, name, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od):
         if flag != -1 and flag != -2 and k[0] > 0:
             formula = dictionarize_formula(formula)
-            self.params = OrderedDict([('name', name),
-                                       ('formula', formula),
-                                       ('equation_of_state', 'hp_tmt'),
-                                       ('H_0', round(H * 1e3, 10)),
-                                       ('S_0', round(S * 1e3, 10)),
-                                       ('V_0', round(V * 1e-5, 15)),
-                                       ('Cp', [round(Cp[0] * 1e3, 10),
-                                               round(Cp[1] * 1e3, 10),
-                                               round(Cp[2] * 1e3, 10),
-                                               round(Cp[3] * 1e3, 10)]),
-                                       ('a_0', a),
-                                       ('K_0', round(k[0] * 1e8, 10)),
-                                       ('Kprime_0', k[1]),
-                                       ('Kdprime_0', round(k[2] * 1e-8, 15)),
-                                       ('n', sum(formula.values())),
-                                       ('molar_mass',
-                                        round(formula_mass(formula), 10))])
+            self.params = OrderedDict(
+                [
+                    ("name", name),
+                    ("formula", formula),
+                    ("equation_of_state", "hp_tmt"),
+                    ("H_0", round(H * 1e3, 10)),
+                    ("S_0", round(S * 1e3, 10)),
+                    ("V_0", round(V * 1e-5, 15)),
+                    (
+                        "Cp",
+                        [
+                            round(Cp[0] * 1e3, 10),
+                            round(Cp[1] * 1e3, 10),
+                            round(Cp[2] * 1e3, 10),
+                            round(Cp[3] * 1e3, 10),
+                        ],
+                    ),
+                    ("a_0", a),
+                    ("K_0", round(k[0] * 1e8, 10)),
+                    ("Kprime_0", k[1]),
+                    ("Kdprime_0", round(k[2] * 1e-8, 15)),
+                    ("n", sum(formula.values())),
+                    ("molar_mass", round(formula_mass(formula), 10)),
+                ]
+            )
         if flag == 1:
-            self.landau_hp = OrderedDict([('P_0', 1e5),
-                                          ('T_0', 298.15),
-                                          ('Tc_0', od[0]),
-                                          ('S_D', round(od[1] * 1e3, 10)),
-                                          ('V_D', round(od[2] * 1e-5, 10))])
+            self.landau_hp = OrderedDict(
+                [
+                    ("P_0", 1e5),
+                    ("T_0", 298.15),
+                    ("Tc_0", od[0]),
+                    ("S_D", round(od[1] * 1e3, 10)),
+                    ("V_D", round(od[2] * 1e-5, 10)),
+                ]
+            )
 
         if flag == 2:
-            self.bragg_williams = OrderedDict([('deltaH',
-                                                round(od[0] * 1e3, 10)),
-                                               ('deltaV',
-                                                round(od[1] * 1e-5, 15)),
-                                               ('Wh', round(od[2] * 1e3, 10)),
-                                               ('Wv', round(od[3] * 1e-5, 15)),
-                                               ('n', od[4]),
-                                               ('factor', od[5])])
+            self.bragg_williams = OrderedDict(
+                [
+                    ("deltaH", round(od[0] * 1e3, 10)),
+                    ("deltaV", round(od[1] * 1e-5, 15)),
+                    ("Wh", round(od[2] * 1e3, 10)),
+                    ("Wv", round(od[3] * 1e-5, 15)),
+                    ("n", od[4]),
+                    ("factor", od[5]),
+                ]
+            )
 
         if flag == -2:
             formula = dictionarize_formula(formula)
-            self.params = OrderedDict([('name', name),
-                                       ('formula', formula),
-                                       ('equation_of_state', 'hp_tmtL'),
-                                       ('H_0', round(H * 1e3, 10)),
-                                       ('S_0', round(S * 1e3, 10)),
-                                       ('V_0', round(V * 1e-5, 15)),
-                                       ('Cp', [round(Cp[0] * 1e3, 10),
-                                               round(Cp[1] * 1e3, 10),
-                                               round(Cp[2] * 1e3, 10),
-                                               round(Cp[3] * 1e3, 10)]),
-                                       ('a_0', a),
-                                       ('K_0', round(k[0] * 1e8, 10)),
-                                       ('Kprime_0', k[1]),
-                                       ('Kdprime_0', round(k[2] * 1e-8, 15)),
-                                       ('dKdT_0', round(k[3] * 1e8, 15)),
-                                       ('n', sum(formula.values())),
-                                       ('molar_mass',
-                                        round(formula_mass(formula), 10))])
+            self.params = OrderedDict(
+                [
+                    ("name", name),
+                    ("formula", formula),
+                    ("equation_of_state", "hp_tmtL"),
+                    ("H_0", round(H * 1e3, 10)),
+                    ("S_0", round(S * 1e3, 10)),
+                    ("V_0", round(V * 1e-5, 15)),
+                    (
+                        "Cp",
+                        [
+                            round(Cp[0] * 1e3, 10),
+                            round(Cp[1] * 1e3, 10),
+                            round(Cp[2] * 1e3, 10),
+                            round(Cp[3] * 1e3, 10),
+                        ],
+                    ),
+                    ("a_0", a),
+                    ("K_0", round(k[0] * 1e8, 10)),
+                    ("Kprime_0", k[1]),
+                    ("Kdprime_0", round(k[2] * 1e-8, 15)),
+                    ("dKdT_0", round(k[3] * 1e8, 15)),
+                    ("n", sum(formula.values())),
+                    ("molar_mass", round(formula_mass(formula), 10)),
+                ]
+            )
 
 
 # Read dataset
-with open('tc-ds633.txt', 'r') as f:
+with open("tc-ds62.txt", "r") as f:
     ds = [line.split() for line in f]
 
 
 def getmbr(ds, mbr):
     for i in range(0, int(ds[0][0])):
         if ds[i * 4 + 3][0] == mbr:
             atoms = 0.0
-            formula = ''
+            formula = ""
             for j in range(3, len(ds[i * 4 + 3]) - 1, 2):
                 atoms += float(ds[i * 4 + 3][j])
-                formula = formula + \
-                    components[int(ds[i * 4 + 3][j - 1]) - 1] + str(
-                        round(float(ds[i * 4 + 3][j]), 10))
+                formula = (
+                    formula
+                    + components[int(ds[i * 4 + 3][j - 1]) - 1]
+                    + str(round(float(ds[i * 4 + 3][j]), 10))
+                )
 
             sites = int(ds[i * 4 + 3][1])
-            comp = list(map(float, ds[i * 4 + 3][2:(len(ds[i * 4 + 3]) - 1)]))
+            comp = list(map(float, ds[i * 4 + 3][2 : (len(ds[i * 4 + 3]) - 1)]))
             H = float(ds[i * 4 + 4][0])
             S = float(ds[i * 4 + 4][1])
             V = float(ds[i * 4 + 4][2])
             Cp = list(map(float, ds[i * 4 + 5]))
             a = float(ds[i * 4 + 6][0])
             k = list(map(float, ds[i * 4 + 6][1:4]))
             od = list(map(float, ds[i * 4 + 6][5:]))
 
-            if mbr.endswith('L'):
+            if mbr.endswith("L"):
                 flag = -2
                 od = [0]
                 k.append(float(ds[i * 4 + 6][4]))
             else:
                 flag = int(ds[i * 4 + 6][4])
 
-            endmember = Endmember(mbr, atoms, formula, sites,
-                                  comp, H, S, V, Cp, a, k, flag, od)
+            endmember = Endmember(
+                mbr, atoms, formula, sites, comp, H, S, V, Cp, a, k, flag, od
+            )
             return endmember
 
 
-with open('HGP_2018_ds633.py', 'w') as outfile:
-    outfile.write('# This file is part of BurnMan - a thermoelastic and '
-                  'thermodynamic toolkit for the Earth and Planetary '
-                  'Sciences\n'
-                  '# Copyright (C) 2012 - 2021 by the BurnMan team, '
-                  'released under the GNU\n# GPL v2 or later.\n\n\n'
-                  '"""\n'
-                  'HGP_2018_ds633\n'
-                  '^^^^^^^^^^^^^^\n'
-                  '\n'
-                  'Endmember minerals from Holland, Green and Powell (2018) and references therein.\n'
-                  'Dataset version 6.33.\n'
-                  'The values in this document are all in S.I. units,\n'
-                  'unlike those in the original tc-ds633.txt.\n'
-                  'File autogenerated using HGP633data_to_burnman.py.\n'
-                  '"""\n\n'
-                  'from ..mineral import Mineral\n\n')
-
-    outfile.write('"""\n'
-                  'ENDMEMBERS\n'
-                  '"""\n\n')
+with open("HP_2011_ds62.py", "w") as outfile:
+    outfile.write(
+        "# This file is part of BurnMan - a thermoelastic and "
+        "thermodynamic toolkit\n# for the Earth and Planetary "
+        "Sciences\n"
+        "# Copyright (C) 2012 - 2021 by the BurnMan team, "
+        "released under the GNU\n# GPL v2 or later.\n\n\n"
+        '"""\n'
+        "HP_2011_ds62\n"
+        "^^^^^^^^^^^^\n"
+        "\n"
+        "Endmember minerals from Holland and Powell 2011 and "
+        "references therein.\n"
+        "Update to dataset version 6.2.\n"
+        "The values in this document are all in S.I. units,\n"
+        "unlike those in the original tc-ds62.txt.\n"
+        "File autogenerated using HPdata_to_burnman.py.\n"
+        '"""\n'
+        "\n\n"
+        "from ..mineral import Mineral\n\n"
+    )
+
+    outfile.write('"""\n' "ENDMEMBERS\n" '"""\n\n')
 
     def pprint_ordered_dict(d, leading_string, extra_whitespace=0, width=200):
-        old_leading_string = 'OrderedDict['
-        whitespace = ' ' * (len(leading_string) + extra_whitespace
-                            - len(old_leading_string))
+        old_leading_string = "OrderedDict["
+        whitespace = " " * (
+            len(leading_string) + extra_whitespace - len(old_leading_string)
+        )
         s = pprint.pformat(d, width=width)
-        s = s.replace('),\n', f',\n{whitespace}')
-        s = s.replace('), ', f',\n{whitespace}')
-        s = s.replace('\', ', '\': ').replace('(', '')
-        s = s.replace(old_leading_string,
-                      leading_string+'{').replace(')])', '}')
+        s = s.replace("),\n", f",\n{whitespace}")
+        s = s.replace("), ", f",\n{whitespace}")
+        s = s.replace("', ", "': ").replace("(", "")
+        s = s.replace(old_leading_string, leading_string + "{").replace(")])", "}")
         return s
 
-    formula = '0'
+    formula = "0"
     for i in range(int(ds[0][0])):
         mbr = ds[i * 4 + 3][0]
         M = getmbr(ds, mbr)
-        if mbr == 'and':  # change silly abbreviation
-            mbr = 'andalusite'
+        if mbr == "and":  # change silly abbreviation
+            mbr = "andalusite"
 
         # Print parameters
-        if hasattr(M, 'params'):
-            outfile.write('\n')
-            outfile.write('class {0} (Mineral):\n'.format(mbr)
-                          + '    def __init__(self):\n')
-
-            s = pprint_ordered_dict(
-                M.params, leading_string='        self.params = ')
-            s = s.replace('000000.0', 'e6')
+        if hasattr(M, "params"):
+            outfile.write("\n")
+            outfile.write(
+                "class {0} (Mineral):\n".format(mbr) + "    def __init__(self):\n"
+            )
+
+            s = pprint_ordered_dict(M.params, leading_string="        self.params = ")
+            s = s.replace("000000.0", "e6")
             outfile.write(s)
-            outfile.write('\n')
+            outfile.write("\n")
 
             # Print property modifiers (if they exist)
-            if hasattr(M, 'landau_hp'):
-                outfile.write('        self.property_modifiers = [[')
-                s = pprint_ordered_dict(M.landau_hp,
-                                        leading_string='\'landau_hp\', ',
-                                        extra_whitespace=49)
-                outfile.write(s)
-                outfile.write(']]\n')
-
-            if hasattr(M, 'bragg_williams'):
-                outfile.write('        self.property_modifiers = [[')
-                s = pprint_ordered_dict(M.bragg_williams,
-                                        leading_string='\'bragg_williams\', ',
-                                        extra_whitespace=49)
-                outfile.write(s)
-                outfile.write(']]\n')
-
-            outfile.write('        Mineral.__init__(self)\n\n')
-
-    outfile.write('\ndef cov():\n'
-                  '    \"\"\"\n'
-                  '    A function which loads and returns the '
-                  'variance-covariance matrix of the\n'
-                  '    zero-point energies of all the endmembers in the '
-                  'dataset.\n\n'
-                  '    Returns\n'
-                  '    -------\n'
-                  '    cov : dictionary\n'
-                  '        Dictionary keys are:\n'
-                  '        - endmember_names: a list of endmember names, and\n'
-                  '        - covariance_matrix: a 2D variance-covariance '
-                  'array for the\n'
-                  '          endmember zero-point energies of formation\n'
-                  '    \"\"\"\n\n'
-                  '    from .HGP_2018_ds633_cov import cov\n'
-                  '    return cov\n')
+            if hasattr(M, "landau_hp") or hasattr(M, "bragg_williams"):
+                outfile.write("        self.property_modifiers = [[")
+                if hasattr(M, "landau_hp"):
+                    s = pprint_ordered_dict(
+                        M.landau_hp, leading_string="'landau_hp', ", extra_whitespace=49
+                    )
+                    outfile.write(s)
+
+                if hasattr(M, "bragg_williams"):
+                    s = pprint_ordered_dict(
+                        M.bragg_williams,
+                        leading_string="'bragg_williams', ",
+                        extra_whitespace=49,
+                    )
+                    outfile.write(s)
+
+                outfile.write("]]\n")
+
+            outfile.write("        Mineral.__init__(self)\n\n")
+
+    outfile.write(
+        "\ndef cov():\n"
+        '    """\n'
+        "    A function which loads and returns the "
+        "variance-covariance matrix of the\n"
+        "    zero-point energies of all the endmembers "
+        "in the dataset.\n\n"
+        "    Returns\n"
+        "    -------\n"
+        "    cov : dictionary\n"
+        "        Dictionary keys are:\n"
+        "        - endmember_names: a list of endmember names, and\n"
+        "        - covariance_matrix: a 2D variance-covariance "
+        "array for the\n"
+        "          endmember zero-point energies of formation\n"
+        '    """\n\n'
+        "    from .HP_2011_ds62_cov import cov\n"
+        "    return cov\n"
+    )
 
 # Process uncertainties
-with open('HGP_2018_ds633_cov.py', 'w') as outfile:
-
-    outfile.write('# This file is part of BurnMan - a thermoelastic and '
-                  'thermodynamic toolkit for the Earth and Planetary '
-                  'Sciences\n'
-                  '# Copyright (C) 2012 - 2021 by the BurnMan team, '
-                  'released under the GNU\n# GPL v2 or later.\n\n\n'
-                  '"""\n'
-                  'HGP_2018 (ds-633) zero-point energy covariance matrix\n'
-                  'Derived from Holland, Green and Powell (2018) and '
-                  'references therein.\n'
-                  'Dataset version 6.33.\n'
-                  'The values in this document are all in S.I. units,\n'
-                  'unlike those in the original tc-ds633.txt.\n'
-                  'File autogenerated using HGP633data_to_burnman.py.\n'
-                  '"""\n\n'
-                  'from numpy import array\n\n'
-                  'cov = ')
+with open("HP_2011_ds62_cov.py", "w") as outfile:
+    outfile.write(
+        "# This file is part of BurnMan - a thermoelastic and "
+        "thermodynamic toolkit\n# for the Earth and Planetary "
+        "Sciences\n"
+        "# Copyright (C) 2012 - 2021 by the BurnMan team, "
+        "released under the GNU\n# GPL v2 or later.\n\n\n"
+        '"""\n'
+        "HP_2011 (ds-62) zero-point energy covariance matrix\n"
+        "Derived from Holland and Powell 2011 and references "
+        "therein\n"
+        "Update to dataset version 6.2\n"
+        "The values in this document are all in S.I. units,\n"
+        "unlike those in the original tc-ds62.txt\n"
+        "File autogenerated using HPdata_to_burnman.py\n"
+        '"""\n\n'
+        "from numpy import array\n\n"
+        "cov = "
+    )
 
     import numpy as np
+
     n_mbrs = int(ds[0][0])
 
     names = []
     for i in range(n_mbrs):
-        names.append(ds[i*4+3][0])
+        names.append(ds[i * 4 + 3][0])
 
     cov = []
-    for i in range(n_mbrs*4+4, len(ds)-2):
+    for i in range(n_mbrs * 4 + 4, len(ds) - 2):
         cov.extend(map(float, ds[i]))
 
     i_utr = np.triu_indices(n_mbrs)
     i_ltr = np.tril_indices(n_mbrs)
     M = np.zeros((n_mbrs, n_mbrs))
 
     M[i_utr] = cov[1:]
     M[i_ltr] = M.T[i_ltr]
 
-    M = M*1.e6  # (kJ/mol)^2 -> (J/mol)^2
+    M = M * 1.0e6  # (kJ/mol)^2 -> (J/mol)^2
 
-    d = {'endmember_names': names,
-         'covariance_matrix': M}
+    d = {"endmember_names": names, "covariance_matrix": M}
 
     np.set_printoptions(threshold=sys.maxsize)
 
     pp = pprint.PrettyPrinter(indent=0, width=160, depth=3, stream=outfile)
     pp.pprint(d)
 
-    outfile.write('\n')
+    outfile.write("\n")
```

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/HHPH2013_endmembers.dat` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/HHPH2013_endmembers.dat`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/SLBdata_to_burnman.py` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/SLBdata_to_burnman.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,177 +7,240 @@
 # Stixrude and Lithgow-Bertelloni data format into the standard burnman
 # format (printed to stdout)
 
 
 import sys
 import os.path
 
-if os.path.isfile('stx11ver.dat') == False:
-    print('This code requires the data file stx11ver.dat.')
-    print(
-        'This file is bundled with the Perple_X data files, which can be found here:')
-    print('http://www.perplex.ethz.ch/perplex/ibm_and_mac_archives/')
-    print('')
-    print('Please download the file and place it in this directory.')
+if os.path.isfile("stx11ver.dat") == False:
+    print("This code requires the data file stx11ver.dat.")
+    print("This file is bundled with the Perple_X data files, which can be found here:")
+    print("http://www.perplex.ethz.ch/perplex/ibm_and_mac_archives/")
+    print("")
+    print("Please download the file and place it in this directory.")
     exit()
 
 
 def read_dataset(datafile):
-    f = open(datafile, 'r')
+    f = open(datafile, "r")
     ds = []
     for line in f:
         ds.append(line.split())
     return ds
 
 
 def read_dataset_utf8(datafile):
-    f = open(datafile, 'r')
+    f = open(datafile, "r")
     ds = []
     for line in f:
-        ds.append(line.decode('utf-8').split())
+        ds.append(line.decode("utf-8").split())
     return ds
 
 
 def process_stixrude():
-
-    perplex_ds = read_dataset('stx11ver.dat')
-    alias_mapping = read_dataset('perplex_slb_2011_names.txt')
+    perplex_ds = read_dataset("stx11ver.dat")
+    alias_mapping = read_dataset("perplex_slb_2011_names.txt")
 
     alias = {}
     accurate_values = {}
     configurational_entropies = {}
     for line in alias_mapping:
         alias[line[0]] = line[2]
 
     process = 0  # flag to process data or not (to cut out first lines)
     n = 0  # line number for each record
     for line in perplex_ds:
         if len(line) != 0:
             if process == 1:
-                if line[0] == 'end':
+                if line[0] == "end":
                     n = 0
                 else:
                     n = n + 1
                 if n == 1:
                     name = alias[line[0]]
                     data = []
-                    configurational_entropy = 'None'
+                    configurational_entropy = "None"
                 elif n == 3:
                     # F0, (n, ignored), -V0
                     data.extend([float(line[2]), -1.0 * float(line[8])])
                 elif n == 4:
                     # K_0, K_prime, Debye_0, grueneisen_0, q_0, eta_s0,
                     # [configurational_and_magnetic_entropy]
                     data.extend(
-                        [float(line[2]), float(line[5]), float(line[8]),
-                         float(line[11]), float(line[14]), float(line[17])])
+                        [
+                            float(line[2]),
+                            float(line[5]),
+                            float(line[8]),
+                            float(line[11]),
+                            float(line[14]),
+                            float(line[17]),
+                        ]
+                    )
                     if len(line) == 21:
                         configurational_entropy = float(line[20])
                 elif n == 5:
                     # mu_S0, mu_S0_prime
                     data.extend([float(line[2]), float(line[5])])
                     # Sort into correct order for processing: F, V, K, K',
                     #                        Debye, gruen, q, G, Gprime, etaS0
-                    accurate_values[
-                        name] = [data[0] / 1.e3, data[1] * 10., data[2] / 1.e4, data[3],
-                                 data[4], data[5], data[6], data[8] / 1.e4, data[9], data[7]]
+                    accurate_values[name] = [
+                        data[0] / 1.0e3,
+                        data[1] * 10.0,
+                        data[2] / 1.0e4,
+                        data[3],
+                        data[4],
+                        data[5],
+                        data[6],
+                        data[8] / 1.0e4,
+                        data[9],
+                        data[7],
+                    ]
                     configurational_entropies[name] = configurational_entropy
 
-            if line[0] == 'end_components':
+            if line[0] == "end_components":
                 process = 1
 
     return accurate_values, configurational_entropies
 
 
 accurate_values, configurational_entropies = process_stixrude()
 
 
-ds = read_dataset_utf8('slb_2011.txt')
-landau = read_dataset_utf8('slb_2011_landau.txt')
+ds = read_dataset_utf8("slb_2011.txt")
+landau = read_dataset_utf8("slb_2011_landau.txt")
 landau_params = {}
 for line in landau:
     phase = str(line[0]).lower()
-    if phase != '#':
-        landau_params[phase] = [
-            float(line[1]), float(line[2]) * 1.e-6, float(line[3])]
-
-print '# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences'
-print '# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU GPL v2 or later.'
-print ''
-print ''
-print '"""'
-print 'SLB_2011'
-print 'Minerals from Stixrude & Lithgow-Bertelloni 2011 and references therein'
-print 'File autogenerated using SLBdata_to_burnman.py'
-print '"""'
-print ''
-print 'from __future__ import absolute_import'
-print ''
-print 'from ..mineral import Mineral'
-print 'from ..solution import Solution'
-print 'from ..solutionmodel import *'
-print 'from ..tools.chemistry import dictionarize_formula, formula_mass'
-print ''
-
-param_scales = [-1., -1.,  # not numbers, so we won't scale
-                1.e3, 1.e3,  # KJ -> J
-                1.e-6, 1.e-6,  # cm^3/mol -> m^3/mol
-                1.e9, 1.e9,  # GPa -> Pa
-                1.0, 1.0,  # no scale for K'
-                1.0, 1.0,  # no scale for Debye
-                1.0, 1.0,  # no scale for gruneisen
-                1.0, 1.0,  # no scale for q
-                1.e9, 1.e9,  # GPa -> Pa
-                1.0, 1.0,  # no scale for G'
-                1.0, 1.0]  # no scale for eta_s
-
-
-solutionfile = 'slb_2011_solutions.txt'
-with open(solutionfile, 'r') as fin:
-    print fin.read()
+    if phase != "#":
+        landau_params[phase] = [float(line[1]), float(line[2]) * 1.0e-6, float(line[3])]
+
+print(
+    "# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences"
+)
+print(
+    "# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU GPL v2 or later."
+)
+print("")
+print("")
+print('"""')
+print("SLB_2011")
+print("Minerals from Stixrude & Lithgow-Bertelloni 2011 and references therein")
+print("File autogenerated using SLBdata_to_burnman.py")
+print('"""')
+print("")
+print("from __future__ import absolute_import")
+print("")
+print("from ..mineral import Mineral")
+print("from ..solution import Solution")
+print("from ..solutionmodel import *")
+print("from ..tools.chemistry import dictionarize_formula, formula_mass")
+print("")
+
+param_scales = [
+    -1.0,
+    -1.0,  # not numbers, so we won't scale
+    1.0e3,
+    1.0e3,  # KJ -> J
+    1.0e-6,
+    1.0e-6,  # cm^3/mol -> m^3/mol
+    1.0e9,
+    1.0e9,  # GPa -> Pa
+    1.0,
+    1.0,  # no scale for K'
+    1.0,
+    1.0,  # no scale for Debye
+    1.0,
+    1.0,  # no scale for gruneisen
+    1.0,
+    1.0,  # no scale for q
+    1.0e9,
+    1.0e9,  # GPa -> Pa
+    1.0,
+    1.0,  # no scale for G'
+    1.0,
+    1.0,
+]  # no scale for eta_s
+
+
+solutionfile = "slb_2011_solutions.txt"
+with open(solutionfile, "r") as fin:
+    print(fin.read())
 fin.close()
 
-print '"""'
-print 'ENDMEMBERS'
-print '"""'
-print ''
-formula = '0'
+print('"""')
+print("ENDMEMBERS")
+print('"""')
+print("")
+formula = "0"
 for idx, m in enumerate(ds):
     if idx == 0:
         param_names = m
     else:
-        print 'class', m[0].lower(), '(Mineral):'
-        print '    def __init__(self):'
-        print ''.join(['        formula=\'', m[1], '\''])
-        print '        formula = dictionarize_formula(formula)'
-        print '        self.params = {'
-        print ''.join(['            \'name\': \'', m[0], '\','])
-        print '            \'formula\': formula,'
-        print '            \'equation_of_state\': \'slb3\','
+        print("class", m[0].lower(), "(Mineral):")
+        print("    def __init__(self):")
+        print("".join(["        formula='", m[1], "'"]))
+        print("        formula = dictionarize_formula(formula)")
+        print("        self.params = {")
+        print("".join(["            'name': '", m[0], "',"]))
+        print("            'formula': formula,")
+        print("            'equation_of_state': 'slb3',")
         for pid, param in enumerate(accurate_values[m[0].lower()]):
-            print '            \'' + param_names[(pid + 1) * 2] + '\':', float(param) * param_scales[(pid + 1) * 2], ','
-        print '            \'n\': sum(formula.values()),'
-        print '            \'molar_mass\': formula_mass(formula)}'
-        print ''
-        if landau_params.has_key(m[0].lower()) or configurational_entropies[m[0].lower()] != 'None':
-            print '        self.property_modifiers = [',
+            print(
+                "            '" + param_names[(pid + 1) * 2] + "':",
+                float(param) * param_scales[(pid + 1) * 2],
+                ",",
+            )
+        print("            'n': sum(formula.values()),")
+        print("            'molar_mass': formula_mass(formula)}")
+        print("")
+        if (
+            landau_params.has_key(m[0].lower())
+            or configurational_entropies[m[0].lower()] != "None"
+        ):
+            print(
+                "        self.property_modifiers = [",
+            )
             if landau_params.has_key(m[0].lower()):
-                print '[\'landau\', {\'Tc_0\':', landau_params[m[0].lower()][0], ', \'S_D\':', landau_params[m[0].lower()][2], ', \'V_D\':', landau_params[m[0].lower()][1], '}]',
-            if configurational_entropies[m[0].lower()] != 'None':
-                print '[\'linear\', {\'delta_E\':', 0., ', \'delta_S\':', configurational_entropies[m[0].lower()], ', \'delta_V\':', 0., '}]',
-            print ']'
-            print ''
-        print '        self.uncertainties = {'
+                print(
+                    "['landau', {'Tc_0':",
+                    landau_params[m[0].lower()][0],
+                    ", 'S_D':",
+                    landau_params[m[0].lower()][2],
+                    ", 'V_D':",
+                    landau_params[m[0].lower()][1],
+                    "}]",
+                )
+            if configurational_entropies[m[0].lower()] != "None":
+                print(
+                    "['linear', {'delta_E':",
+                    0.0,
+                    ", 'delta_S':",
+                    configurational_entropies[m[0].lower()],
+                    ", 'delta_V':",
+                    0.0,
+                    "}]",
+                )
+            print("]")
+            print("")
+        print("        self.uncertainties = {")
         for pid, param in enumerate(m):
             if pid > 1 and pid % 2 == 1 and pid < 21:
-                print '            \'' + param_names[pid] + '\':', float(param) * param_scales[pid], ','
+                print(
+                    "            '" + param_names[pid] + "':",
+                    float(param) * param_scales[pid],
+                    ",",
+                )
         pid = 21
         param = m[pid]
-        print '            \'' + param_names[pid] + '\':', float(param) * param_scales[pid], '}'
-        print '        Mineral.__init__(self)'
-        print ''
+        print(
+            "            '" + param_names[pid] + "':",
+            float(param) * param_scales[pid],
+            "}",
+        )
+        print("        Mineral.__init__(self)")
+        print("")
 
 
-aliasfile = 'slb_2011_aliases.txt'
-with open(aliasfile, 'r') as fin:
-    print fin.read()
+aliasfile = "slb_2011_aliases.txt"
+with open(aliasfile, "r") as fin:
+    print(fin.read())
 fin.close()
```

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/perplex_slb_2011_names.txt` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/perplex_slb_2011_names.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011.txt` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011_aliases.txt` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011_aliases.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/slb_2011_solutions.txt` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/slb_2011_solutions.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_raw_endmember_datasets/tc-ds62_solutions.txt` & `burnman-1.2.0/burnman/data/input_raw_endmember_datasets/tc-ds62_solutions.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/STW105.txt` & `burnman-1.2.0/burnman/data/input_seismic/STW105.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/ak135.txt` & `burnman-1.2.0/burnman/data/input_seismic/ak135.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/ak135_lowermantle.txt` & `burnman-1.2.0/burnman/data/input_seismic/ak135_lowermantle.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/axisem_prem_ani_noocean.txt` & `burnman-1.2.0/burnman/data/input_seismic/axisem_prem_ani_noocean.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/iasp91.txt` & `burnman-1.2.0/burnman/data/input_seismic/iasp91.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/mineos_prem_noocean.txt` & `burnman-1.2.0/burnman/data/input_seismic/mineos_prem_noocean.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/prem.txt` & `burnman-1.2.0/burnman/data/input_seismic/prem.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/pwave_fast.txt` & `burnman-1.2.0/burnman/data/input_seismic/pwave_fast.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/pwave_slow.txt` & `burnman-1.2.0/burnman/data/input_seismic/pwave_slow.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/swave_fast.txt` & `burnman-1.2.0/burnman/data/input_seismic/swave_fast.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/data/input_seismic/swave_slow.txt` & `burnman-1.2.0/burnman/data/input_seismic/swave_slow.txt`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/eos/__init__.py` & `burnman-1.2.0/burnman/eos/__init__.py`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/eos/aa.py` & `burnman-1.2.0/burnman/eos/slb.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,403 +1,492 @@
-# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
-# Copyright (C) 2012 - 2015 by the BurnMan team, released under the GNU GPL v2 or later.
+# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit
+# for the Earth and Planetary Sciences
+# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
+# GPL v2 or later.
 
 from __future__ import absolute_import
 
 import numpy as np
-from scipy.optimize import brentq
+import scipy.optimize as opt
 import warnings
 
-from . import equation_of_state as eos
-from ..constants import gas_constant
-
-class AA(eos.EquationOfState):
-    """
-    Class for the :math`E-V-S` liquid metal EOS detailed in :cite:`AA1994`.
-    Internal energy (:math:`E`) is first calculated
-    along a reference isentrope using a fourth order BM EoS
-    (:math:`V_0`, :math:`KS`, :math:`KS'`, :math:`KS''`),
-    which gives volume as a function of pressure,
-    coupled with the thermodynamic identity:
-
-    :math:`-\partial E/ \partial V |_S = P`.
-
-    The temperature along the isentrope is calculated via
-
-    :math:`\partial (\ln T)/\partial (\ln \\rho) |_S = \gamma`
-
-    which gives:
+# Try to import the jit from numba.  If it is
+# not available, just go with the standard
+# python interpreter
+try:
+    from numba import jit
+except ImportError:
 
-    :math:`T_S/T_0 = \exp(\int( \gamma/\\rho ) d \\rho)`
+    def jit(fn):
+        return fn
 
-    The thermal effect on internal energy is calculated at constant volume
-    using expressions for the kinetic, electronic and potential contributions
-    to the volumetric heat capacity, which can then be integrated with respect
-    to temperature:
 
-    :math:`\partial E/\partial T |_V = C_V`
-
-    :math:`\partial E/\partial S |_V = T`
-
-    We note that :cite:`AA1994` also include a detailed description
-    of the Gruneisen parameter as a function of volume and energy (Equation 15),
-    and use this to determine the temperature along the principal isentrope
-    (Equations B1-B10) and the thermal pressure away from that isentrope
-    (Equation 23). However, this expression is inconsistent with
-    the equation of state away from the principal isentrope. Here we choose
-    to calculate the thermal pressure and Grueneisen parameter thus:
+from . import birch_murnaghan as bm
+from . import debye
+from . import equation_of_state as eos
+from ..utils.math import bracket
 
-    1) As energy and entropy are defined by the equation of state at any
-    temperature and volume, pressure can be found by via the expression:
 
-    :math:`\partial E/\partial V |_S = P`
+@jit(nopython=True)
+def _grueneisen_parameter_fast(V_0, volume, gruen_0, q_0):
+    """global function with plain parameters so jit will work"""
+    x = V_0 / volume
+    f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+    a1_ii = 6.0 * gruen_0  # EQ 47
+    a2_iikk = -12.0 * gruen_0 + 36.0 * gruen_0 * gruen_0 - 18.0 * q_0 * gruen_0  # EQ 47
+    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41
+    return 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
+
+
+@jit(nopython=True)
+def _delta_pressure(
+    x, pressure, temperature, V_0, T_0, Debye_0, n, a1_ii, a2_iikk, b_iikk, b_iikkmm
+):
+    f = 0.5 * (pow(V_0 / x, 2.0 / 3.0) - 1.0)
+    nu_o_nu0_sq = 1.0 + a1_ii * f + 1.0 / 2.0 * a2_iikk * f * f
+    debye_temperature = Debye_0 * np.sqrt(nu_o_nu0_sq)
+    E_th = debye.thermal_energy(
+        temperature, debye_temperature, n
+    )  # thermal energy at temperature T
+    E_th_ref = debye.thermal_energy(
+        T_0, debye_temperature, n
+    )  # thermal energy at reference temperature
+    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41
+    gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
+
+    return (
+        (1.0 / 3.0)
+        * (pow(1.0 + 2.0 * f, 5.0 / 2.0))
+        * ((b_iikk * f) + (0.5 * b_iikkmm * f * f))
+        + gr * (E_th - E_th_ref) / x
+        - pressure
+    )  # EQ 21
 
-    2) The Grueneisen parameter can now be determined as
-    :math:`\gamma = V \partial P/\partial E |_V`
 
-    To reiterate: away from the reference isentrope, the Grueneisen parameter
-    calculated using these expressions is *not* equal to the
-    (thermodynamically inconsistent) analytical expression given by :cite:`AA1994`.
+class SLBBase(eos.EquationOfState):
 
-    A final note: the expression for :math:`\Lambda` (Equation 17).
-    does not reproduce Figure 5. We assume here that the figure matches the model
-    actually used by :cite:`AA1994`, which has the form:
-    :math:`F(-325.23 + 302.07 (\\rho/\\rho_0) + 30.45 (\\rho/\\rho_0)^{0.4})`.
+    """
+    Base class for the finite strain-Mie-Grueneiesen-Debye equation of state
+    detailed in :cite:`Stixrude2005`.  For the most part the equations are
+    all third order in strain, but see further the :class:`burnman.slb.SLB2`
+    and :class:`burnman.slb.SLB3` classes.
     """
 
-    def _ABTheta(self, V, params):
-        """
-        Electronic heat capacity functions
-        """
-        Vfrac = V/params['V_0']
-
-        A = params['a'][0] + params['a'][1]*Vfrac # A2
-        B = params['b'][0] + params['b'][1]*Vfrac*Vfrac # A3
-        Theta = params['Theta'][0]*np.power(Vfrac, -params['Theta'][1]) # A4
-
-        return A, B, Theta
-
-    def _lambdaxi(self, V, params):
-        """
-        Potential heat capacity functions
-        """
-        rhofrac = params['V_0']/V
-        xi = params['xi_0']*np.power(rhofrac, -0.6) # A16
-        F = 1./(1. + np.exp((rhofrac - params['F'][0])/params['F'][1])) # A18
-        #lmda = (F*(params['lmda'][0] + params['lmda'][1]*rhofrac) + params['lmda'][2])*np.power(rhofrac, 0.4) # A17
-        lmda = (F*(params['lmda'][0] + params['lmda'][1]*rhofrac + params['lmda'][2]*np.power(rhofrac, 0.4))) # this incorrect expression for lmda seems to provide a very close fit to figure 5
-
-        return lmda, xi
-
-    def _rhofracxksis(self, V, params):
-        """
-        Functions for the fourth order Birch-Murnaghan equation of state
-        """
-        rhofrac = params['V_0']/V # rho/rho0 = V0/V
-        x = np.power(rhofrac, 1./3.) # equation 18
-        ksi1 = 0.75*(4. - params['Kprime_S']) # equation 19
-        ksi2 = 0.375*(params['K_S']*params['Kprime_prime_S'] +
-                      params['Kprime_S']*(params['Kprime_S'] - 7.)) + 143./24. # equation 20
-        return rhofrac, x, ksi1, ksi2
-
-
-    def _isentropic_temperature(self, V, params):
-        """
-        Temperature along the reference isentrope
-        """
-
-        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)
-
-        # equation B6 -- B10
-        a1 = ksi2 / 8.
-        a2 = ( ksi1 + 3. * ksi2 ) / 6.
-        a3 = ( 1. + 2.*ksi1 + 3.*ksi2 ) / 4.
-        a4 = (1. + ksi1 + ksi2)/2.
-        a5 = (6. + 4.*ksi1 + 3.*ksi2)/24.
-
-        # equation B5
-        Ts = params['T_0']*np.exp(params['grueneisen_0']*np.log(rhofrac)
-                                + 13.5*params['grueneisen_prime']*params['V_0']*params['K_S'] *
-                                (   (a1/(3*params['grueneisen_n'] + 8.))*(np.power(x,(3*params['grueneisen_n'] + 8.)) - 1.)
-                                    - (a2/(3*params['grueneisen_n'] + 6.))*(np.power(x,(3*params['grueneisen_n'] + 6.)) - 1.)
-                                + (a3/(3*params['grueneisen_n'] + 4.))*(np.power(x,(3*params['grueneisen_n'] + 4.)) - 1.)
-                                - (a4/(3*params['grueneisen_n'] + 2.))*(np.power(x,(3*params['grueneisen_n'] + 2.)) - 1.)
-                                + (a5/(3*params['grueneisen_n'] + 0.))*(np.power(x,(3*params['grueneisen_n'] + 0.)) - 1.)))
-
-        return Ts
-
-
-
-    def _isentropic_pressure(self, V, params):
-        """
-        Pressure along the reference isentrope
-        """
-        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)
-        x2 = x*x
-        x3 = x*x*x
-        x5 = x3*x2
-        x7 = x5*x2
-
-        Ps = ( 1.5*params['K_S'] * (x7 - x5) *
-               (1. + ksi1 - ksi1*x2 +
-                ksi2 * (x2 - 1.) * (x2 - 1.)) ) # Eq. 17
-
-        return Ps
-
-    def _isentropic_energy_change(self, V, params):
-        """
-        Birch Murnaghan equation of state expression for the energy change along an isentrope
-        """
-        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)
-        x2 = x*x
-        x4 = x2*x2
-        x6 = x4*x2
-        x8 = x4*x4
-
-        E_S = 4.5*params['V_0']*params['K_S'] * ((ksi1 + 1.) * (x4/4. - x2/2. + 1./4.) -
-                                                 ksi1*(x6/6. - x4/4. + 1./12.) +
-                                                 ksi2*(x8/8. - x6/2. + 3.*x4/4. - x2/2. + 1./8.)) # Eq. 21
-        return E_S
-
-    def _isochoric_energy_change(self, Ts, T, V, params):
+    def _debye_temperature(self, x, params):
         """
-        int Cv dT
+        Finite strain approximation for Debye Temperature [K]
+        x = ref_vol/vol
         """
-        A, B, Theta = self._ABTheta(V, params)
-        lmda, xi = self._lambdaxi(V, params)
-
-        E_kin = 1.5*params['n']*gas_constant*(T - Ts)
-        E_el = A*(T - Ts - Theta*(np.arctan(T/Theta) - np.arctan(Ts/Theta))) + 5./8*B*(np.power(T, 1.6) - np.power(Ts, 1.6)) # A5
-        E_pot = (lmda*(T - Ts) + params['theta']*(xi - lmda)*np.log((params['theta'] + T)/(params['theta'] + Ts))) # A19
-
-        return E_kin + E_el + E_pot
-
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
+        nu_o_nu0_sq = 1.0 + a1_ii * f + 1.0 / 2.0 * a2_iikk * f * f
+        if nu_o_nu0_sq > 0.0:
+            return params["Debye_0"] * np.sqrt(nu_o_nu0_sq)
+        else:
+            raise Exception(
+                f"This volume (V = {1./x:.2f}*V_0) exceeds the "
+                "valid range of the thermal "
+                "part of the slb equation of state."
+            )
 
     def volume_dependent_q(self, x, params):
         """
         Finite strain approximation for :math:`q`, the isotropic volume strain
         derivative of the grueneisen parameter.
         """
-        raise NotImplementedError("")
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
+        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41
+        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
+        # avoids divide by zero if grueneisen_0 = 0.
+        if np.abs(params["grueneisen_0"]) < 1.0e-10:
+            q = 1.0 / 9.0 * (18.0 * gr - 6.0)
+        else:
+            q = (
+                1.0
+                / 9.0
+                * (
+                    18.0 * gr
+                    - 6.0
+                    - 1.0
+                    / 2.0
+                    / nu_o_nu0_sq
+                    * (2.0 * f + 1.0)
+                    * (2.0 * f + 1.0)
+                    * a2_iikk
+                    / gr
+                )
+            )
+        return q
 
     def _isotropic_eta_s(self, x, params):
         """
         Finite strain approximation for :math:`eta_{s0}`, the isotropic shear
         strain derivative of the grueneisen parameter.
-        Zero for a liquid
         """
-        return 0.
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        a2_s = -2.0 * params["grueneisen_0"] - 2.0 * params["eta_s_0"]  # EQ 47
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
+        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * pow(f, 2.0)  # EQ 41
+        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
+        # EQ 46 NOTE the typo from Stixrude 2005:
+        eta_s = -gr - (
+            1.0 / 2.0 * pow(nu_o_nu0_sq, -1.0) * pow((2.0 * f) + 1.0, 2.0) * a2_s
+        )
+
+        return eta_s
+
+    # calculate isotropic thermal pressure, see
+    # Matas et. al. (2007) eq B4
+    def _thermal_pressure(self, T, V, params):
+        Debye_T = self._debye_temperature(params["V_0"] / V, params)
+        gr = self.grueneisen_parameter(0.0, T, V, params)  # P not important
+        P_th = gr * debye.thermal_energy(T, Debye_T, params["n"]) / V
+        return P_th
 
     def volume(self, pressure, temperature, params):
         """
         Returns molar volume. :math:`[m^3]`
         """
-
-        _volume = lambda V, P, T, params: ( P -
-                                            self.pressure(T, V, params) )
-
-        return brentq(_volume, params['V_0']*0.1, params['V_0']*2., args=(pressure, temperature, params))
-
-    def pressure( self, temperature, volume, params):
-        """
-        Returns the pressure of the mineral at a given temperature and volume [Pa]
-        """
-
-        '''
-        Ts = self._isentropic_temperature(volume, params)
-
-
-        dE = self._isochoric_energy_change(Ts, temperature, volume, params)
-        E1 = self._isentropic_energy_change(volume, params) - params['E_0']
-        E2 = E1 + dE
-
-        # Integrate at constant volume (V \int dP = \int gr dE)
-        dP = (params['grueneisen_0']*(E2 - E1) +
-              (0.5*params['grueneisen_prime'] *
-               np.power(params['V_0']/volume, params['grueneisen_n']) *
-               (E2*E2 - E1*E1))) / volume # eq. 23
-
-        P = self._isentropic_pressure(volume, params) + dP
-        '''
-
-        dV = volume*1.e-4
-        S = self.entropy(0., temperature, volume, params)
-
-        delta_S = lambda T, S, V: S - self.entropy(0., T, V, params)
-
-        T0 = brentq(delta_S, temperature*0.97, temperature*1.03, args=(S, volume - 0.5*dV))
-        T1 = brentq(delta_S, temperature*0.97, temperature*1.03, args=(S, volume + 0.5*dV))
-
-        E0 = self.molar_internal_energy(0., T0, volume - 0.5*dV, params)
-        E1 = self.molar_internal_energy(0., T1, volume + 0.5*dV, params)
-
-        P = -(E1 - E0)/dV # |S
+        T_0 = params["T_0"]
+        Debye_0 = params["Debye_0"]
+        V_0 = params["V_0"]
+        dV = 1.0e-2 * params["V_0"]
+        n = params["n"]
+
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
+
+        b_iikk = 9.0 * params["K_0"]  # EQ 28
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29z
+
+        # Finding the volume at a given pressure requires a
+        # root-finding scheme. Here we use brentq to find the root.
+
+        # Root-finding using brentq requires bounds to be specified.
+        # We do this using a bracketing function.
+        args = (
+            pressure,
+            temperature,
+            V_0,
+            T_0,
+            Debye_0,
+            n,
+            a1_ii,
+            a2_iikk,
+            b_iikk,
+            b_iikkmm,
+        )
+
+        try:
+            # The first attempt to find a bracket for
+            # root finding uses V_0 as a starting point
+            sol = bracket(_delta_pressure, V_0, dV, args)
+        except Exception:
+            # At high temperature, the naive bracketing above may
+            # try a volume guess that exceeds the point at which the
+            # bulk modulus goes negative at that temperature.
+            # In this case, we try a more nuanced approach by
+            # first finding the volume at which the bulk modulus goes
+            # negative, and then either (a) raising an exception if the
+            # desired pressure is less than the pressure at that volume,
+            # or (b) using that pressure to create a better bracket for
+            # brentq.
+            def _K_T(V, T, params):
+                return self.isothermal_bulk_modulus(0.0, T, V, params)
+
+            sol_K_T = bracket(_K_T, V_0, dV, args=(temperature, params))
+            V_crit = opt.brentq(
+                _K_T, sol_K_T[0], sol_K_T[1], args=(temperature, params)
+            )
+            P_min = self.pressure(temperature, V_crit, params)
+            if P_min > pressure:
+                raise Exception(
+                    "The desired pressure is not achievable "
+                    "at this temperature. The minimum pressure "
+                    f"achievable is {P_min:.2e} Pa."
+                )
+            else:
+                try:
+                    sol = bracket(_delta_pressure, V_crit - dV, dV, args)
+                except Exception:
+                    raise Exception(
+                        "Cannot find a volume, perhaps you are "
+                        "outside of the range of validity for "
+                        "the equation of state?"
+                    )
+
+        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)
+
+    def pressure(self, temperature, volume, params):
+        """
+        Returns the pressure of the mineral at a given temperature and volume
+        [Pa]
+        """
+        debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        gr = self.grueneisen_parameter(
+            0.0, temperature, volume, params
+        )  # does not depend on pressure
+        # thermal energy at temperature T
+        E_th = debye.thermal_energy(temperature, debye_T, params["n"])
+        # thermal energy at reference temperature
+        E_th_ref = debye.thermal_energy(params["T_0"], debye_T, params["n"])
+
+        b_iikk = 9.0 * params["K_0"]  # EQ 28
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29
+        f = 0.5 * (pow(params["V_0"] / volume, 2.0 / 3.0) - 1.0)  # EQ 24
+        P = (1.0 / 3.0) * (pow(1.0 + 2.0 * f, 5.0 / 2.0)) * (
+            (b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.0))
+        ) + gr * (
+            E_th - E_th_ref
+        ) / volume  # EQ 21
 
         return P
 
-
-
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter :math:`[unitless]`
         """
-        '''
-        gr = (params['grueneisen_0'] +
-              params['grueneisen_prime'] *
-              (np.power(params['V_0']/volume, params['grueneisen_n']) *
-               (self.molar_internal_energy(pressure, temperature, volume, params) -
-                params['E_0'])))
-        '''
-        dT = 1.
-        dE = (self.molar_internal_energy(0., temperature + 0.5*dT, volume, params) -
-              self.molar_internal_energy(0., temperature - 0.5*dT, volume, params))
-        dP = (self.pressure(temperature + 0.5*dT, volume, params) -
-              self.pressure(temperature - 0.5*dT, volume, params))
-        gr = volume*dP/dE
+        return _grueneisen_parameter_fast(
+            params["V_0"], volume, params["grueneisen_0"], params["q_0"]
+        )
 
-        return gr
-
-    def isothermal_bulk_modulus(self, pressure,temperature, volume, params):
+    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`[Pa]`
         """
-        # K_T = -V * dP/dV
-        dV = volume*1.e-3
-        P0 = self.pressure(temperature, volume - 0.5*dV, params)
-        P1 = self.pressure(temperature, volume + 0.5*dV, params)
+        T_0 = params["T_0"]
+        debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        gr = self.grueneisen_parameter(pressure, temperature, volume, params)
 
-        K_T = -volume*(P1 - P0)/dV
-        return K_T
+        # thermal energy at temperature T
+        E_th = debye.thermal_energy(temperature, debye_T, params["n"])
+        # thermal energy at reference temperature
+        E_th_ref = debye.thermal_energy(T_0, debye_T, params["n"])
+
+        # heat capacity at temperature T
+        C_v = debye.molar_heat_capacity_v(temperature, debye_T, params["n"])
+        # heat capacity at reference temperature
+        C_v_ref = debye.molar_heat_capacity_v(T_0, debye_T, params["n"])
+
+        q = self.volume_dependent_q(params["V_0"] / volume, params)
+
+        K = (
+            bm.bulk_modulus(volume, params)
+            + (gr + 1.0 - q) * (gr / volume) * (E_th - E_th_ref)
+            - (pow(gr, 2.0) / volume) * (C_v * temperature - C_v_ref * T_0)
+        )
+
+        return K
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus. :math:`[Pa]`
         """
-        K_T=self.isothermal_bulk_modulus(pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
-        K_S = K_T*(1. + gr * alpha * temperature)
+        K_S = K_T * (1.0 + gr * alpha * temperature)
         return K_S
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus. :math:`[Pa]`
-        Zero for a liquid
         """
-        return 0.
+        T_0 = params["T_0"]
+        debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        eta_s = self._isotropic_eta_s(params["V_0"] / volume, params)
+
+        E_th = debye.thermal_energy(temperature, debye_T, params["n"])
+        E_th_ref = debye.thermal_energy(T_0, debye_T, params["n"])
+
+        if self.order == 2:
+            return (
+                bm.shear_modulus_second_order(volume, params)
+                - eta_s * (E_th - E_th_ref) / volume
+            )
+        elif self.order == 3:
+            return (
+                bm.shear_modulus_third_order(volume, params)
+                - eta_s * (E_th - E_th_ref) / volume
+            )
+        else:
+            raise NotImplementedError("")
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume. :math:`[J/K/mol]`
         """
-
-        A, B, Theta = self._ABTheta(volume, params)
-        lmda, xi = self._lambdaxi(volume, params)
-
-        C_kin = 1.5*params['n']*gas_constant # HT limit of kinetic contribution (just after equation 29.)
-        C_e = A*(1. - (Theta*Theta)/(Theta*Theta + temperature*temperature)) + B*np.power(temperature, 0.6) # Equation A1
-        C_pot = (lmda*temperature + xi*params['theta']) / (params['theta'] + temperature) # Equation A15
-
-        return C_kin + C_e + C_pot
-
+        debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        return debye.molar_heat_capacity_v(temperature, debye_T, params["n"])
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure. :math:`[J/K/mol]`
         """
-
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        C_p = C_v*(1. + gr * alpha * temperature)
-
+        C_p = C_v * (1.0 + gr * alpha * temperature)
         return C_p
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity. :math:`[1/K]`
-        Currently found by numerical differentiation (1/V * dV/dT)
         """
+        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
+        gr = self.grueneisen_parameter(pressure, temperature, volume, params)
+        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
+        alpha = gr * C_v / K / volume
+        return alpha
 
-        delta_T = 1.
-        V0 = self.volume(pressure, temperature-0.5*delta_T, params)
-        V1 = self.volume(pressure, temperature+0.5*delta_T, params)
-
-        return (1./volume)*(V1 - V0)/delta_T
-
-    def gibbs_free_energy( self, pressure, temperature, volume, params):
+    def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
-        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]
-        E + PV
+        Returns the Gibbs free energy at the pressure and temperature
+        of the mineral [J/mol]
         """
+        G = (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
+        return G
 
-        return self.helmholtz_free_energy( pressure, temperature, volume, params) + \
-            pressure * self.volume( pressure, temperature, params)
-
-    def molar_internal_energy( self, pressure, temperature, volume, params):
+    def molar_internal_energy(self, pressure, temperature, volume, params):
         """
-        Returns the internal energy at the pressure and temperature of the mineral [J/mol]
+        Returns the internal energy at the pressure and temperature
+        of the mineral [J/mol]
         """
-        Ts = self._isentropic_temperature(volume, params)
-        E = (params['E_0'] + self._isentropic_energy_change(volume, params)
-                + self._isochoric_energy_change(Ts, temperature, volume, params))
+        return self.helmholtz_free_energy(
+            pressure, temperature, volume, params
+        ) + temperature * self.entropy(pressure, temperature, volume, params)
 
-        return E
-
-    def entropy( self, pressure, temperature, volume, params):
+    def entropy(self, pressure, temperature, volume, params):
         """
-        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]
+        Returns the entropy at the pressure and temperature
+        of the mineral [J/K/mol]
         """
-        T = temperature
-        Ts = self._isentropic_temperature(volume, params)
-
-        if np.abs(T- Ts) < 1.e-10:
-            Delta_S = 0.
-        else:
-            A, B, Theta = self._ABTheta(volume, params)
-            lmda, xi = self._lambdaxi(volume, params)
-            S_kin = 1.5*params['n']*gas_constant*(np.log(T) - np.log(Ts))
-            S_el = (A*(np.log(T/Ts) - 0.5*np.log(T*T*(Theta*Theta + Ts*Ts)/(Ts*Ts*(Theta*Theta + T*T)))) + 5./3.*B*(np.power(T, 0.6) - np.power(Ts, 0.6))) # A6
-            S_pot = (lmda*np.log((params['theta'] + T)/(params['theta'] + Ts)) + xi*np.log((T*(params['theta'] + Ts))/(Ts*(params['theta'] + T)))) # A20
-            Delta_S = S_kin + S_el + S_pot
-
-        S = params['S_0'] + Delta_S
+        Debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        S = debye.entropy(temperature, Debye_T, params["n"])
         return S
 
-    def enthalpy( self, pressure, temperature, volume, params):
+    def enthalpy(self, pressure, temperature, volume, params):
         """
-        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]
-        E + PV
+        Returns the enthalpy at the pressure and temperature
+        of the mineral [J/mol]
         """
 
-        return self.molar_internal_energy(pressure, temperature, volume, params) + \
-            pressure * self.volume( pressure, temperature, params)
+        return (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + temperature * self.entropy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
 
-    def helmholtz_free_energy( self, pressure, temperature, volume, params):
+    def helmholtz_free_energy(self, pressure, temperature, volume, params):
         """
-        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]
-        E - TS
+        Returns the Helmholtz free energy at the pressure and temperature
+        of the mineral [J/mol]
         """
-        return self.molar_internal_energy(pressure, temperature, volume, params) - temperature*self.entropy(pressure, temperature, volume, params)
+        x = params["V_0"] / volume
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        Debye_T = self._debye_temperature(params["V_0"] / volume, params)
+
+        F_quasiharmonic = debye.helmholtz_free_energy(
+            temperature, Debye_T, params["n"]
+        ) - debye.helmholtz_free_energy(params["T_0"], Debye_T, params["n"])
 
+        b_iikk = 9.0 * params["K_0"]  # EQ 28
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29
+
+        F = (
+            params["F_0"]
+            + 0.5 * b_iikk * f * f * params["V_0"]
+            + (1.0 / 6.0) * params["V_0"] * b_iikkmm * f * f * f
+            + F_quasiharmonic
+        )
+
+        return F
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
+        if "T_0" not in params:
+            params["T_0"] = 300.0
 
-        # Now check all the required keys for the
-        # thermal part of the EoS are in the dictionary
-        expected_keys = ['P_0', 'T_0', 'S_0', 'molar_mass', 'grueneisen_0']
+        # If eta_s_0 is not included this is presumably deliberate,
+        # as we can model density and bulk modulus just fine without it,
+        # so just add it to the dictionary as nan
+        # The same goes for the standard state Helmholtz free energy
+        if "eta_s_0" not in params:
+            params["eta_s_0"] = float("nan")
+        if "F_0" not in params:
+            params["F_0"] = float("nan")
 
+        # First, let's check the EoS parameters for Tref
+        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)
 
+        # Now check all the required keys for the
+        # thermal part of the EoS are in the dictionary
+        expected_keys = ["molar_mass", "n", "Debye_0", "grueneisen_0", "q_0", "eta_s_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn( 'Unusual value for T_0', stacklevel=2 )
-        if params['molar_mass'] < 0.001 or params['molar_mass'] > 10.:
-            warnings.warn( 'Unusual value for molar_mass', stacklevel=2 )
-        if params['n'] < 1. or params['n'] > 1000.:
-            warnings.warn( 'Unusual value for n', stacklevel=2 )
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["molar_mass"] < 0.001 or params["molar_mass"] > 10.0:
+            warnings.warn("Unusual value for molar_mass", stacklevel=2)
+        if params["n"] < 1.0 or params["n"] > 1000.0:
+            warnings.warn("Unusual value for n", stacklevel=2)
+        if params["Debye_0"] < 1.0 or params["Debye_0"] > 10000.0:
+            warnings.warn("Unusual value for Debye_0", stacklevel=2)
+        if params["grueneisen_0"] < -1.0 or params["grueneisen_0"] > 10.0:
+            warnings.warn("Unusual value for grueneisen_0", stacklevel=2)
+        if params["q_0"] < -20.0 or params["q_0"] > 20.0:
+            warnings.warn("Unusual value for q_0", stacklevel=2)
+        if params["eta_s_0"] < -10.0 or params["eta_s_0"] > 10.0:
+            warnings.warn("Unusual value for eta_s_0", stacklevel=2)
+
+
+class SLB3(SLBBase):
+
+    """
+    SLB equation of state with third order finite strain expansion for the
+    shear modulus (this should be preferred, as it is more thermodynamically
+    consistent.)
+    """
+
+    def __init__(self):
+        self.order = 3
+
+
+class SLB2(SLBBase):
+
+    """
+    SLB equation of state with second order finite strain expansion for the
+    shear modulus.  In general, this should not be used, but sometimes
+    shear modulus data is fit to a second order equation of state.  In that
+    case, you should use this.  The moral is, be careful!
+    """
+
+    def __init__(self):
+        self.order = 2
```

### Comparing `burnman-1.1.0/burnman/eos/birch_murnaghan.py` & `burnman-1.2.0/burnman/eos/birch_murnaghan.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from __future__ import absolute_import
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
 # the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 import numpy as np
 import scipy.optimize as opt
@@ -15,72 +16,104 @@
     """
     compute the bulk modulus as per the third order
     birch-murnaghan equation of state.  Returns bulk
     modulus in the same units as the reference bulk
     modulus.  Pressure must be in :math:`[Pa]`.
     """
 
-    x = params['V_0'] / volume
-    f = 0.5 * (pow(x, 2. / 3.) - 1.0)
+    x = params["V_0"] / volume
+    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)
 
-    K = pow(1. + 2. * f, 5. / 2.) * (params['K_0'] + (3. * params['K_0'] * params['Kprime_0'] -
-                                                      5 * params['K_0']) * f + 27. / 2. * (params['K_0'] * params['Kprime_0'] - 4. * params['K_0']) * f * f)
+    K = pow(1.0 + 2.0 * f, 5.0 / 2.0) * (
+        params["K_0"]
+        + (3.0 * params["K_0"] * params["Kprime_0"] - 5 * params["K_0"]) * f
+        + 27.0
+        / 2.0
+        * (params["K_0"] * params["Kprime_0"] - 4.0 * params["K_0"])
+        * f
+        * f
+    )
     return K
 
 
 def birch_murnaghan(x, params):
     """
     equation for the third order birch-murnaghan equation of state, returns
     pressure in the same units that are supplied for the reference bulk
     modulus (params['K_0'])
     """
 
-    return 3. * params['K_0'] / 2. * (pow(x, 7. / 3.) - pow(x, 5. / 3.)) \
-        * (1. - .75 * (4. - params['Kprime_0']) * (pow(x, 2. / 3.) - 1.)) + params['P_0']
+    return (
+        3.0
+        * params["K_0"]
+        / 2.0
+        * (pow(x, 7.0 / 3.0) - pow(x, 5.0 / 3.0))
+        * (1.0 - 0.75 * (4.0 - params["Kprime_0"]) * (pow(x, 2.0 / 3.0) - 1.0))
+        + params["P_0"]
+    )
 
 
 def volume(pressure, params):
     """
     Get the birch-murnaghan volume at a reference temperature for a given
     pressure :math:`[Pa]`. Returns molar volume in :math:`[m^3]`
     """
 
-    func = lambda x: birch_murnaghan(params['V_0'] / x, params) - pressure
+    func = lambda x: birch_murnaghan(params["V_0"] / x, params) - pressure
     try:
-        sol = bracket(func, params['V_0'], 1.e-2 * params['V_0'])
+        sol = bracket(func, params["V_0"], 1.0e-2 * params["V_0"])
     except:
         raise ValueError(
-            'Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?')
+            "Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?"
+        )
     return opt.brentq(func, sol[0], sol[1])
 
 
 def shear_modulus_second_order(volume, params):
     """
     Get the birch murnaghan shear modulus at a reference temperature, for a
     given volume.  Returns shear modulus in :math:`[Pa]` (the same units as in
     params['G_0']).  This uses a second order finite strain expansion
     """
 
-    x = params['V_0'] / volume
-    G = params['G_0'] * pow(x, 5. / 3.) * (
-        1. - 0.5 * (pow(x, 2. / 3.) - 1.) * (5. - 3. * params['Gprime_0'] * params['K_0'] / params['G_0']))
+    x = params["V_0"] / volume
+    G = (
+        params["G_0"]
+        * pow(x, 5.0 / 3.0)
+        * (
+            1.0
+            - 0.5
+            * (pow(x, 2.0 / 3.0) - 1.0)
+            * (5.0 - 3.0 * params["Gprime_0"] * params["K_0"] / params["G_0"])
+        )
+    )
     return G
 
 
 def shear_modulus_third_order(volume, params):
     """
     Get the birch murnaghan shear modulus at a reference temperature, for a
     given volume.  Returns shear modulus in :math:`[Pa]` (the same units as in
     params['G_0']).  This uses a third order finite strain expansion
     """
 
-    x = params['V_0'] / volume
-    f = 0.5 * (pow(x, 2. / 3.) - 1.0)
-    G = pow((1. + 2. * f), 5. / 2.) * (params['G_0'] + (3. * params['K_0'] * params['Gprime_0'] - 5. * params['G_0']) * f + (
-        6. * params['K_0'] * params['Gprime_0'] - 24. * params['K_0'] - 14. * params['G_0'] + 9. / 2. * params['K_0'] * params['Kprime_0']) * f * f)
+    x = params["V_0"] / volume
+    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)
+    G = pow((1.0 + 2.0 * f), 5.0 / 2.0) * (
+        params["G_0"]
+        + (3.0 * params["K_0"] * params["Gprime_0"] - 5.0 * params["G_0"]) * f
+        + (
+            6.0 * params["K_0"] * params["Gprime_0"]
+            - 24.0 * params["K_0"]
+            - 14.0 * params["G_0"]
+            + 9.0 / 2.0 * params["K_0"] * params["Kprime_0"]
+        )
+        * f
+        * f
+    )
     return G
 
 
 class BirchMurnaghanBase(eos.EquationOfState):
 
     """
     Base class for the isothermal Birch Murnaghan equation of state.  This is third order in strain, and
@@ -91,15 +124,15 @@
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
         return volume(pressure, params)
 
     def pressure(self, temperature, volume, params):
-        return birch_murnaghan(params['V_0'] / volume, params)
+        return birch_murnaghan(params["V_0"] / volume, params)
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,
         temperature :math:`[K]` and volume :math:`[m^3]`.
         """
         return bulk_modulus(volume, params)
@@ -110,112 +143,122 @@
         """
         return bulk_modulus(volume, params)
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`
         """
-        if(self.order == 2):
+        if self.order == 2:
             return shear_modulus_second_order(volume, params)
-        elif(self.order == 3):
+        elif self.order == 3:
             return shear_modulus_third_order(volume, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy :math:`\mathcal{S}` of the mineral. :math:`[J/K/mol]`
         """
-        return 0.
+        return 0.0
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy :math:`\mathcal{E}` of the mineral. :math:`[J/mol]`
         """
-        x = np.power(volume/params['V_0'], -1./3.)
-        x2 = x*x
-        x4 = x2*x2
-        x6 = x4*x2
-        x8 = x4*x4
-
-        xi1 = 3.*(4. - params['Kprime_0'])/4.
-
-        intPdV = (-9./2. * params['V_0'] * params['K_0'] *
-                  ((xi1 + 1.)*(x4/4. - x2/2. + 1./4.) -
-                   xi1*(x6/6. - x4/4. + 1./12.)))
+        x = np.power(volume / params["V_0"], -1.0 / 3.0)
+        x2 = x * x
+        x4 = x2 * x2
+        x6 = x4 * x2
+        x8 = x4 * x4
+
+        xi1 = 3.0 * (4.0 - params["Kprime_0"]) / 4.0
+
+        intPdV = (
+            -9.0
+            / 2.0
+            * params["V_0"]
+            * params["K_0"]
+            * (
+                (xi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)
+                - xi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)
+            )
+        )
 
-        return - intPdV + params['E_0']
+        return -intPdV + params["E_0"]
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy :math:`\mathcal{G}` of the mineral. :math:`[J/mol]`
         """
         # G = int VdP = [PV] - int PdV = E + PV
 
-        return self.molar_internal_energy(pressure, temperature, volume, params) + volume*pressure
+        return (
+            self.molar_internal_energy(pressure, temperature, volume, params)
+            + volume * pressure
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`
         """
-        return 0.
+        return 0.0
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        if 'E_0' not in params:
-            params['E_0'] = 0.
-        if 'P_0' not in params:
-            params['P_0'] = 0.
+        if "E_0" not in params:
+            params["E_0"] = 0.0
+        if "P_0" not in params:
+            params["P_0"] = 0.0
 
         # If G and Gprime are not included this is presumably deliberate,
         # as we can model density and bulk modulus just fine without them,
         # so just add them to the dictionary as nans
-        if 'G_0' not in params:
-            params['G_0'] = float('nan')
-        if 'Gprime_0' not in params:
-            params['Gprime_0'] = float('nan')
+        if "G_0" not in params:
+            params["G_0"] = float("nan")
+        if "Gprime_0" not in params:
+            params["Gprime_0"] = float("nan")
 
         # Check that all the required keys are in the dictionary
-        expected_keys = ['V_0', 'K_0', 'Kprime_0', 'G_0', 'Gprime_0']
+        expected_keys = ["V_0", "K_0", "Kprime_0", "G_0", "Gprime_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['P_0'] < 0.:
-            warnings.warn('Unusual value for P_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-3:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < 0. or params['Kprime_0'] > 10.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
-        if params['G_0'] < 0.0 or params['G_0'] > 1.e13:
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if params['Gprime_0'] < -5. or params['Gprime_0'] > 10.:
-            warnings.warn('Unusual value for Gprime_0', stacklevel=2)
+        if params["P_0"] < 0.0:
+            warnings.warn("Unusual value for P_0", stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < 0.0 or params["Kprime_0"] > 20.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
+        if params["G_0"] < 0.0 or params["G_0"] > 1.0e13:
+            warnings.warn("Unusual value for G_0", stacklevel=2)
+        if params["Gprime_0"] < -5.0 or params["Gprime_0"] > 10.0:
+            warnings.warn("Unusual value for Gprime_0", stacklevel=2)
 
 
 class BM3(BirchMurnaghanBase):
 
     """
     Third order Birch Murnaghan isothermal equation of state.
     This uses the third order expansion for shear modulus.
```

### Comparing `burnman-1.1.0/burnman/eos/birch_murnaghan_4th.py` & `burnman-1.2.0/burnman/eos/morse_potential.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,191 +1,205 @@
 from __future__ import absolute_import
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
-# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
+# Copyright (C) 2012 - 2015 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
-import numpy as np
+
 import scipy.optimize as opt
 from . import equation_of_state as eos
 from ..utils.math import bracket
 import warnings
+import numpy as np
 
 
-def bulk_modulus_fourth(volume, params):
-    """
-    compute the bulk modulus as per the fourth order
-    birch-murnaghan equation of state.  Returns bulk
-    modulus in the same units as the reference bulk
-    modulus.  Pressure must be in :math:`[Pa]`.
+def bulk_modulus(volume, params):
     """
+    Compute the bulk modulus as per the Morse potential
+    equation of state.
+    Returns bulk modulus in the same units as
+    the reference bulk modulus.
+    Pressure must be in :math:`[Pa]`.
+    """
+
+    VoverV0 = volume / params["V_0"]
+    x = (params["Kprime_0"] - 1.0) * (1.0 - np.power(VoverV0, 1.0 / 3.0))
+    K = params["K_0"] * (
+        (
+            2.0
+            / (params["Kprime_0"] - 1.0)
+            * np.power(VoverV0, -2.0 / 3.0)
+            * (np.exp(2.0 * x) - np.exp(x))
+        )
+        + (np.power(VoverV0, -1.0 / 3.0) * (2.0 * np.exp(2.0 * x) - np.exp(x)))
+    )
+    return K
 
-    x = params['V_0'] / volume
-    f = 0.5 * (pow(x, 2. / 3.) - 1.0)
 
-    Xi = (3. / 4.) * (4. - params['Kprime_0'])
-    Zeta = (3. / 8.) * ((params['K_0'] * params['Kprime_prime_0']) + params[
-        'Kprime_0'] * (params['Kprime_0'] - 7.) + 143. / 9.)
+def shear_modulus(volume, params):
+    """
+    Shear modulus not currently implemented for this equation of state
+    """
+    return 0.0
 
-    K = (5. * f * pow((1. + 2. * f), 5. / 2.) * params['K_0'] * (1. - (2. * Xi * f) + (4. * Zeta * pow(f, 2.)))) + \
-        (pow(1. + (2. * f), 7. / 2.) * params['K_0'] * (
-            1. - (4. * Xi * f) + (12. * Zeta * pow(f, 2.))))
 
-    return K
+def morse_potential(VoverV0, params):
+    """
+    Equation for the Morse Potential equation of state,
+    returns pressure in the same units that are supplied
+    for the reference bulk modulus (params['K_0'])
+    """
+    x = (params["Kprime_0"] - 1.0) * (1.0 - np.power(VoverV0, 1.0 / 3.0))
+    return (
+        3.0
+        * params["K_0"]
+        / (params["Kprime_0"] - 1.0)
+        * np.power(VoverV0, -2.0 / 3.0)
+        * (np.exp(2.0 * x) - np.exp(x))
+    ) + params["P_0"]
 
 
-def volume_fourth_order(pressure, params):
-    func = lambda x: birch_murnaghan_fourth(
-        params['V_0'] / x, params) - pressure
+def volume(pressure, params):
+    """
+    Get the Morse Potential volume at a
+    reference temperature for a given pressure :math:`[Pa]`.
+    Returns molar volume in :math:`[m^3]`
+    """
+    func = lambda V: morse_potential(V / params["V_0"], params) - pressure
     try:
-        sol = bracket(func, params['V_0'], 1.e-2 * params['V_0'])
+        sol = bracket(func, params["V_0"], 1.0e-2 * params["V_0"])
     except:
         raise ValueError(
-            'Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?')
+            "Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?"
+        )
     return opt.brentq(func, sol[0], sol[1])
 
 
-def birch_murnaghan_fourth(x, params):
-    """
-    equation for the fourth order birch-murnaghan equation of state, returns
-    pressure in the same units that are supplied for the reference bulk
-    modulus (params['K_0'])
-    """
-
-    f = 0.5 * (pow(x, 2. / 3.) - 1.0)
-    Xi = (3. / 4.) * (4. - params['Kprime_0'])
-    Zeta = (3. / 8.) * ((params['K_0'] * params['Kprime_prime_0']) + params[
-        'Kprime_0'] * (params['Kprime_0'] - 7.) + 143. / 9.)
-
-    return 3. * f * pow(1. + 2. * f, 5. / 2.) * params['K_0'] * (1. - (2. * Xi * f) + (4. * Zeta * pow(f, 2.))) + params['P_0']
-
-
-class BM4(eos.EquationOfState):
+class Morse(eos.EquationOfState):
 
     """
-    Base class for the isothermal Birch Murnaghan equation of state.  This is fourth order in strain, and
-    has no temperature dependence.
+    Class for the isothermal Morse Potential equation of state
+    detailed in :cite:`Stacey1981`.
+    This equation of state has no temperature dependence.
     """
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
-        return volume_fourth_order(pressure, params)
+        return volume(pressure, params)
 
     def pressure(self, temperature, volume, params):
-        return birch_murnaghan_fourth(volume / params['V_0'], params)
+        return morse_potential(volume / params["V_0"], params)
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,
         temperature :math:`[K]` and volume :math:`[m^3]`.
         """
-        return bulk_modulus_fourth(volume, params)
+        return bulk_modulus(volume, params)
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.
         """
-        return bulk_modulus_fourth(volume, params)
+        return bulk_modulus(volume, params)
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`
         """
-        return 0.
+        return shear_modulus(volume, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy :math:`\mathcal{S}` of the mineral. :math:`[J/K/mol]`
         """
-        return 0.
+        return 0.0
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy :math:`\mathcal{E}` of the mineral. :math:`[J/mol]`
         """
-        x = np.power(volume/params['V_0'], -1./3.)
-        x2 = x*x
-        x4 = x2*x2
-        x6 = x4*x2
-        x8 = x4*x4
-
-        xi1 = 3.*(4. - params['Kprime_0'])/4.
-        xi2 = 3./8.*(params['K_0'] *
-                     params['Kprime_prime_0'] +
-                     params['Kprime_0'] *
-                     (params['Kprime_0'] - 7.)) + 143./24.
-
-        intPdV = (-9./2. * params['V_0'] * params['K_0'] *
-                  ((xi1 + 1.)*(x4/4. - x2/2. + 1./4.) -
-                   xi1*(x6/6. - x4/4. + 1./12.) +
-                   xi2*(x8/8 - x6/2 + 3.*x4/4. - x2/2. + 1./8.)))
 
-        return - intPdV + params['E_0']
+        x = (params["Kprime_0"] - 1) * (1 - np.power(volume / params["V_0"], 1.0 / 3.0))
+        intPdV = (
+            9.0
+            / 2.0
+            * params["V_0"]
+            * params["K_0"]
+            / np.power(params["Kprime_0"] - 1.0, 2.0)
+            * (2.0 * np.exp(x) - np.exp(2.0 * x) - 1.0)
+        )
+
+        return -intPdV + params["E_0"]
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy :math:`\mathcal{G}` of the mineral. :math:`[J/mol]`
         """
-        # G = int VdP = [PV] - int PdV = E + PV
-
-        return self.molar_internal_energy(pressure, temperature, volume, params) + volume*pressure
+        return (
+            self.molar_internal_energy(pressure, temperature, volume, params)
+            + volume * pressure
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`
         """
-        return 0.
+        return 0.0
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        if 'E_0' not in params:
-            params['E_0'] = 0.
-        if 'P_0' not in params:
-            params['P_0'] = 0.
+        if "E_0" not in params:
+            params["E_0"] = 0.0
+        if "P_0" not in params:
+            params["P_0"] = 0.0
 
         # If G and Gprime are not included this is presumably deliberate,
         # as we can model density and bulk modulus just fine without them,
         # so just add them to the dictionary as nans
-        if 'G_0' not in params:
-            params['G_0'] = float('nan')
-        if 'Gprime_0' not in params:
-            params['Gprime_0'] = float('nan')
+        if "G_0" not in params:
+            params["G_0"] = float("nan")
+        if "Gprime_0" not in params:
+            params["Gprime_0"] = float("nan")
 
         # Check that all the required keys are in the dictionary
-        expected_keys = ['V_0', 'K_0', 'Kprime_0']
+        expected_keys = ["V_0", "K_0", "Kprime_0", "G_0", "Gprime_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['P_0'] < 0.:
-            warnings.warn('Unusual value for P_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-3:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < 0. or params['Kprime_0'] > 10.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
-        if params['Kprime_prime_0'] > 0. or params['Kprime_prime_0'] < -10.:
-            warnings.warn('Unusual value for Kprime_prime_0', stacklevel=2)
+        if params["P_0"] < 0.0:
+            warnings.warn("Unusual value for P_0", stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < 0.0 or params["Kprime_0"] > 10.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
+        if params["G_0"] < 0.0 or params["G_0"] > 1.0e13:
+            warnings.warn("Unusual value for G_0", stacklevel=2)
+        if params["Gprime_0"] < -5.0 or params["Gprime_0"] > 10.0:
+            warnings.warn("Unusual value for Gprime_0", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/brosh_calphad.py` & `burnman-1.2.0/burnman/eos/brosh_calphad.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from __future__ import absolute_import
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
 # the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2021 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 import numpy as np
 import warnings
@@ -21,408 +22,560 @@
     :cite:`Brosh2007`.
     """
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
-        X = [1./(1. - params['a'][i-2]
-                 + params['a'][i-2]
-                 * np.power(1.
-                            + i/(3.*params['a'][i-2])*pressure/params['K_0'],
-                            1./float(i)))
-             for i in range(2, 6)]
-        V_c = params['V_0']*np.sum([params['c'][i-2]*np.power(X[i-2], 3.)
-                                    for i in range(2, 6)])
-
-        nu = self._theta(pressure, params)/temperature
-        dP = 1000.
-        dthetadP = (self._theta(pressure+dP/2., params)
-                    - self._theta(pressure-dP/2., params))/dP
-        V_qh = (3. * params['n'] * gas_constant
-                * np.exp(-nu)/(1. - np.exp(-nu)) * dthetadP)  # eq. 6
-
-        f = np.sqrt(1. + 2.*params['b'][1]
-                    * (1. + params['delta'][1])*pressure/params['K_0'])
-        dIdP = ((1. + params['delta'][1])/(params['K_0']
-                                           * (1. + params['b'][1]))
-                * np.exp((1. - f)/params['b'][1]))
-        V_th = self._C_T(temperature, params)*dIdP
+        X = [
+            1.0
+            / (
+                1.0
+                - params["a"][i - 2]
+                + params["a"][i - 2]
+                * np.power(
+                    1.0 + i / (3.0 * params["a"][i - 2]) * pressure / params["K_0"],
+                    1.0 / float(i),
+                )
+            )
+            for i in range(2, 6)
+        ]
+        V_c = params["V_0"] * np.sum(
+            [params["c"][i - 2] * np.power(X[i - 2], 3.0) for i in range(2, 6)]
+        )
+
+        nu = self._theta(pressure, params) / temperature
+        dP = 1000.0
+        dthetadP = (
+            self._theta(pressure + dP / 2.0, params)
+            - self._theta(pressure - dP / 2.0, params)
+        ) / dP
+        V_qh = (
+            3.0
+            * params["n"]
+            * gas_constant
+            * np.exp(-nu)
+            / (1.0 - np.exp(-nu))
+            * dthetadP
+        )  # eq. 6
+
+        f = np.sqrt(
+            1.0
+            + 2.0
+            * params["b"][1]
+            * (1.0 + params["delta"][1])
+            * pressure
+            / params["K_0"]
+        )
+        dIdP = (
+            (1.0 + params["delta"][1])
+            / (params["K_0"] * (1.0 + params["b"][1]))
+            * np.exp((1.0 - f) / params["b"][1])
+        )
+        V_th = self._C_T(temperature, params) * dIdP
 
         # V = dG_c/dP + dG_qh/dP - C_T*(dI_P/dP)
         return V_c + V_qh + V_th
 
     def pressure(self, temperature, volume, params):
         def _delta_volume(pressure):
-            return (self.volume(pressure, temperature, params) - volume)
+            return self.volume(pressure, temperature, params) - volume
 
         try:
-            sol = bracket(_delta_volume, 300.e9, 1.e5, ())
+            sol = bracket(_delta_volume, 300.0e9, 1.0e5, ())
         except ValueError:
-            raise Exception('Cannot find a pressure, perhaps you are outside '
-                            'the range of validity for the equation of state?')
+            raise Exception(
+                "Cannot find a pressure, perhaps you are outside "
+                "the range of validity for the equation of state?"
+            )
 
         return brentq(_delta_volume, sol[0], sol[1])
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns the isothermal bulk modulus :math:`K_T` :math:`[Pa]`
         as a function of pressure :math:`[Pa]`,
         temperature :math:`[K]` and volume :math:`[m^3]`.
         """
-        dP = 1000.
-        dV = (self.volume(pressure + dP/2., temperature, params)
-              - self.volume(pressure - dP/2., temperature, params))
+        dP = 1000.0
+        dV = self.volume(pressure + dP / 2.0, temperature, params) - self.volume(
+            pressure - dP / 2.0, temperature, params
+        )
 
-        return -volume*dP/dV
+        return -volume * dP / dV
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns the adiabatic bulk modulus of the mineral. :math:`[Pa]`.
         """
-        if temperature < 1.e-10:
-            return self.isothermal_bulk_modulus(pressure, temperature, volume,
-                                                params)
+        if temperature < 1.0e-10:
+            return self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         else:
-            return (self.isothermal_bulk_modulus(pressure, temperature,
-                                                 volume, params)
-                    * self.molar_heat_capacity_p(pressure, temperature,
-                                                 volume, params)
-                    / self.molar_heat_capacity_v(pressure, temperature,
-                                                 volume, params))
+            return (
+                self.isothermal_bulk_modulus(pressure, temperature, volume, params)
+                * self.molar_heat_capacity_p(pressure, temperature, volume, params)
+                / self.molar_heat_capacity_v(pressure, temperature, volume, params)
+            )
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns the shear modulus :math:`G` of the mineral. :math:`[Pa]`
         """
-        return 0.
+        return 0.0
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy of the mineral. :math:`[J/mol]`
         """
 
-        return (self.gibbs_free_energy(pressure, temperature, volume, params)
-                - pressure * self.volume(pressure, temperature, params)
-                + temperature
-                * self.entropy(pressure, temperature, volume, params))
+        return (
+            self.gibbs_free_energy(pressure, temperature, volume, params)
+            - pressure * self.volume(pressure, temperature, params)
+            + temperature * self.entropy(pressure, temperature, volume, params)
+        )
 
     def _Cp_1bar(self, temperature, params):
         # first, identify which of the piecewise segments we're in
-        i = np.argmax([T > temperature
-                       for T in list(zip(*params['gibbs_coefficients']))[0]])
+        i = np.argmax(
+            [T > temperature for T in list(zip(*params["gibbs_coefficients"]))[0]]
+        )
 
         # select the appropriate coefficients
-        coeffs = params['gibbs_coefficients'][i][1]
-        Cp = -(coeffs[2]
-               + 2.*coeffs[3]/temperature/temperature
-               + 6.*coeffs[4]/(temperature*temperature*temperature)
-               + 12.*coeffs[5]*np.power(temperature, -4.)
-               + 90.*coeffs[6]*np.power(temperature, -10.)
-               + 2.*coeffs[7]*temperature
-               + 6.*coeffs[8]*temperature*temperature
-               + 12.*coeffs[9]*temperature*temperature*temperature
-               + 42.*coeffs[10]*np.power(temperature, 6.)
-               - 0.25*coeffs[11]/np.sqrt(temperature)
-               - coeffs[12]/temperature)
+        coeffs = params["gibbs_coefficients"][i][1]
+        Cp = -(
+            coeffs[2]
+            + 2.0 * coeffs[3] / temperature / temperature
+            + 6.0 * coeffs[4] / (temperature * temperature * temperature)
+            + 12.0 * coeffs[5] * np.power(temperature, -4.0)
+            + 90.0 * coeffs[6] * np.power(temperature, -10.0)
+            + 2.0 * coeffs[7] * temperature
+            + 6.0 * coeffs[8] * temperature * temperature
+            + 12.0 * coeffs[9] * temperature * temperature * temperature
+            + 42.0 * coeffs[10] * np.power(temperature, 6.0)
+            - 0.25 * coeffs[11] / np.sqrt(temperature)
+            - coeffs[12] / temperature
+        )
         return Cp
 
     def _S_1bar(self, temperature, params):
         # first, identify which of the piecewise segments we're in
-        i = np.argmax([T > temperature
-                       for T in list(zip(*params['gibbs_coefficients']))[0]])
+        i = np.argmax(
+            [T > temperature for T in list(zip(*params["gibbs_coefficients"]))[0]]
+        )
 
         # select the appropriate coefficients
-        coeffs = params['gibbs_coefficients'][i][1]
-        S = -(coeffs[1]
-              + coeffs[2]*(1. + np.log(temperature))
-              - coeffs[3]/temperature/temperature
-              - 2.*coeffs[4]/(temperature*temperature*temperature)
-              - 3.*coeffs[5]*np.power(temperature, -4.)
-              - 9.*coeffs[6]*np.power(temperature, -10.)
-              + 2.*coeffs[7]*temperature
-              + 3.*coeffs[8]*temperature*temperature
-              + 4.*coeffs[9]*temperature*temperature*temperature
-              + 7.*coeffs[10]*np.power(temperature, 6.)
-              + 0.5*coeffs[11]/np.sqrt(temperature)
-              + coeffs[12]/temperature)
+        coeffs = params["gibbs_coefficients"][i][1]
+        S = -(
+            coeffs[1]
+            + coeffs[2] * (1.0 + np.log(temperature))
+            - coeffs[3] / temperature / temperature
+            - 2.0 * coeffs[4] / (temperature * temperature * temperature)
+            - 3.0 * coeffs[5] * np.power(temperature, -4.0)
+            - 9.0 * coeffs[6] * np.power(temperature, -10.0)
+            + 2.0 * coeffs[7] * temperature
+            + 3.0 * coeffs[8] * temperature * temperature
+            + 4.0 * coeffs[9] * temperature * temperature * temperature
+            + 7.0 * coeffs[10] * np.power(temperature, 6.0)
+            + 0.5 * coeffs[11] / np.sqrt(temperature)
+            + coeffs[12] / temperature
+        )
         return S
 
     def _gibbs_1bar(self, temperature, params):
         # first, identify which of the piecewise segments we're in
-        i = np.argmax([T > temperature
-                       for T in list(zip(*params['gibbs_coefficients']))[0]])
+        i = np.argmax(
+            [T > temperature for T in list(zip(*params["gibbs_coefficients"]))[0]]
+        )
 
         # select the appropriate coefficients
-        coeffs = params['gibbs_coefficients'][i][1]
-        gibbs = (coeffs[0]
-                 + coeffs[1]*temperature
-                 + coeffs[2]*temperature*np.log(temperature)
-                 + coeffs[3]/temperature
-                 + coeffs[4]/(temperature*temperature)
-                 + coeffs[5]/(temperature*temperature*temperature)
-                 + coeffs[6]*np.power(temperature, -9.)
-                 + coeffs[7]*temperature*temperature
-                 + coeffs[8]*temperature*temperature*temperature
-                 + coeffs[9]*np.power(temperature, 4.)
-                 + coeffs[10]*np.power(temperature, 7.)
-                 + coeffs[11]*np.sqrt(temperature)
-                 + coeffs[12]*np.log(temperature))
+        coeffs = params["gibbs_coefficients"][i][1]
+        gibbs = (
+            coeffs[0]
+            + coeffs[1] * temperature
+            + coeffs[2] * temperature * np.log(temperature)
+            + coeffs[3] / temperature
+            + coeffs[4] / (temperature * temperature)
+            + coeffs[5] / (temperature * temperature * temperature)
+            + coeffs[6] * np.power(temperature, -9.0)
+            + coeffs[7] * temperature * temperature
+            + coeffs[8] * temperature * temperature * temperature
+            + coeffs[9] * np.power(temperature, 4.0)
+            + coeffs[10] * np.power(temperature, 7.0)
+            + coeffs[11] * np.sqrt(temperature)
+            + coeffs[12] * np.log(temperature)
+        )
         return gibbs
 
     def _X(self, pressure, params):
-        return [1./(1. - params['a'][n-2] + params['a'][n-2]
-                    * np.power(1. + float(n)/(3.*params['a'][n-2])
-                               * pressure/params['K_0'], 1./float(n)))
-                for n in range(2, 6)]  # eq. A2
+        return [
+            1.0
+            / (
+                1.0
+                - params["a"][n - 2]
+                + params["a"][n - 2]
+                * np.power(
+                    1.0
+                    + float(n) / (3.0 * params["a"][n - 2]) * pressure / params["K_0"],
+                    1.0 / float(n),
+                )
+            )
+            for n in range(2, 6)
+        ]  # eq. A2
 
     def _Gamma(self, n, an, Xn):
         def d(k, Xn):
-            return (np.power(Xn, 3. - float(k)) * float(k)
-                    / (float(k) - 3.) if k != 3
-                    else -3.*np.log(Xn))  # eq. A9
-
-        return (3.*np.power(an, 1. - float(n)) / float(n)
-                * np.sum([binom(n, k)
-                          * np.power(an - 1., float(n-k)) * d(k, Xn)
-                         for k in range(0, n+1)]))  # eq. A9, CHECKED
+            return (
+                np.power(Xn, 3.0 - float(k)) * float(k) / (float(k) - 3.0)
+                if k != 3
+                else -3.0 * np.log(Xn)
+            )  # eq. A9
+
+        return (
+            3.0
+            * np.power(an, 1.0 - float(n))
+            / float(n)
+            * np.sum(
+                [
+                    binom(n, k) * np.power(an - 1.0, float(n - k)) * d(k, Xn)
+                    for k in range(0, n + 1)
+                ]
+            )
+        )  # eq. A9, CHECKED
 
     def _theta(self, pressure, params):
         # Theta (for quasiharmonic term)
-        ab2 = (1./(3.*params['b'][0] - 1.))
-        K0b = params['K_0']/(1. + params['delta'][0])  # eq. B1b
-        XT2 = 1./(1. - ab2 + ab2
-                  * np.power(1. + 2./(3.*ab2)
-                             * pressure/K0b, 0.5))  # eq. 6 b of SE2015
+        ab2 = 1.0 / (3.0 * params["b"][0] - 1.0)
+        K0b = params["K_0"] / (1.0 + params["delta"][0])  # eq. B1b
+        XT2 = 1.0 / (
+            1.0 - ab2 + ab2 * np.power(1.0 + 2.0 / (3.0 * ab2) * pressure / K0b, 0.5)
+        )  # eq. 6 b of SE2015
 
         # eq. B1 (6 of SE2015)
-        return (params['theta_0']
-                * np.exp(params['grueneisen_0'] / (1. + params['delta'][0])
-                         * (self._Gamma(2, ab2, XT2)
-                            - self._Gamma(2, ab2, 1.))))
+        return params["theta_0"] * np.exp(
+            params["grueneisen_0"]
+            / (1.0 + params["delta"][0])
+            * (self._Gamma(2, ab2, XT2) - self._Gamma(2, ab2, 1.0))
+        )
 
     def _interpolating_function(self, pressure, params):
-        f = np.sqrt(1. + 2.*params['b'][1]
-                    * (1. + params['delta'][1])*pressure/params['K_0'])
+        f = np.sqrt(
+            1.0
+            + 2.0
+            * params["b"][1]
+            * (1.0 + params["delta"][1])
+            * pressure
+            / params["K_0"]
+        )
 
         # eq. D2 (9 of SE2015)
-        return (1. / (1. + params['b'][1]) * (params['b'][1] + f)
-                * np.exp((1. - f)/params['b'][1]))
+        return (
+            1.0
+            / (1.0 + params["b"][1])
+            * (params["b"][1] + f)
+            * np.exp((1.0 - f) / params["b"][1])
+        )
 
     def _gibbs_qh(self, temperature, theta, n):
-        return (3. * n * gas_constant * temperature
-                * np.log(1. - np.exp(-theta/temperature)))  # eq. 5
+        return (
+            3.0
+            * n
+            * gas_constant
+            * temperature
+            * np.log(1.0 - np.exp(-theta / temperature))
+        )  # eq. 5
 
     def _S_qh(self, temperature, theta, n):
-        nu = theta/temperature
-        return (3. * n * gas_constant * (nu / (np.exp(nu) - 1.)
-                                         - np.log(1. - np.exp(-nu))))
+        nu = theta / temperature
+        return (
+            3.0
+            * n
+            * gas_constant
+            * (nu / (np.exp(nu) - 1.0) - np.log(1.0 - np.exp(-nu)))
+        )
 
     def _C_T(self, temperature, params):
         # C, which is the (G_qh(t,p0) - G_sgte(t,p0)) term
         G_SGTE = self._gibbs_1bar(temperature, params)
-        G_qh0 = self._gibbs_qh(temperature, params['theta_0'], params['n'])
-        if temperature < params['T_0']:
-            C_T = (temperature * temperature
-                   / (2.*params['T_0']) * params['delta_Cpr'])
+        G_qh0 = self._gibbs_qh(temperature, params["theta_0"], params["n"])
+        if temperature < params["T_0"]:
+            C_T = (
+                temperature * temperature / (2.0 * params["T_0"]) * params["delta_Cpr"]
+            )
 
         else:
-            C_T = ((G_qh0 - G_SGTE) + params['delta_Gr']
-                   - (temperature - params['T_0'])*params['delta_Sr']
-                   + (temperature - params['T_0']/2.)*params['delta_Cpr'])
+            C_T = (
+                (G_qh0 - G_SGTE)
+                + params["delta_Gr"]
+                - (temperature - params["T_0"]) * params["delta_Sr"]
+                + (temperature - params["T_0"] / 2.0) * params["delta_Cpr"]
+            )
 
         return C_T
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy of the mineral. :math:`[J/mol]`
         """
         # Cold compression term, eq. A8
         X = self._X(pressure, params)
-        G_c = (params['K_0']*params['V_0']
-               * np.sum([params['c'][n-2]*(self._Gamma(n, params['a'][n-2],
-                                                       X[n-2])
-                                           - self._Gamma(n, params['a'][n-2],
-                                                         1.))
-                         for n in range(2, 6)]))
+        G_c = (
+            params["K_0"]
+            * params["V_0"]
+            * np.sum(
+                [
+                    params["c"][n - 2]
+                    * (
+                        self._Gamma(n, params["a"][n - 2], X[n - 2])
+                        - self._Gamma(n, params["a"][n - 2], 1.0)
+                    )
+                    for n in range(2, 6)
+                ]
+            )
+        )
 
         # G_SGTE
         G_SGTE = self._gibbs_1bar(temperature, params)
 
         # G_qh
         theta = self._theta(pressure, params)
-        G_qh = self._gibbs_qh(temperature, theta, params['n'])
-        G_qh0 = self._gibbs_qh(temperature, params['theta_0'], params['n'])
+        G_qh = self._gibbs_qh(temperature, theta, params["n"])
+        G_qh0 = self._gibbs_qh(temperature, params["theta_0"], params["n"])
 
         C_T = self._C_T(temperature, params)
         I_P = self._interpolating_function(pressure, params)
-        return G_SGTE + G_c + G_qh - G_qh0 + C_T*(1. - I_P)
+        return G_SGTE + G_c + G_qh - G_qh0 + C_T * (1.0 - I_P)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy of the mineral. :math:`[J/K/mol]`
         """
 
         S_SGTE = self._S_1bar(temperature, params)
 
         # S_qh
         theta = self._theta(pressure, params)
-        S_qh = self._S_qh(temperature, theta, params['n'])
-        S_qh0 = self._S_qh(temperature, params['theta_0'], params['n'])
+        S_qh = self._S_qh(temperature, theta, params["n"])
+        S_qh0 = self._S_qh(temperature, params["theta_0"], params["n"])
 
         # dCdT, which is the (S_qh(t,p0) - S_sgte(t,p0)) term
-        if temperature < params['T_0']:
-            dC_TdT = temperature / params['T_0'] * params['delta_Cpr']
+        if temperature < params["T_0"]:
+            dC_TdT = temperature / params["T_0"] * params["delta_Cpr"]
 
         else:
-            dC_TdT = (-(S_qh0 - S_SGTE)
-                      - params['delta_Sr'] + params['delta_Cpr'])
+            dC_TdT = -(S_qh0 - S_SGTE) - params["delta_Sr"] + params["delta_Cpr"]
 
         I_P = self._interpolating_function(pressure, params)
-        return S_SGTE + S_qh - S_qh0 - dC_TdT*(1. - I_P)
+        return S_SGTE + S_qh - S_qh0 - dC_TdT * (1.0 - I_P)
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns the molar isobaric heat capacity :math:`[J/K/mol]`.
         For now, this is calculated by numerical differentiation.
         """
         dT = 0.1
-        if temperature < dT/2.:
-            return 0.
+        if temperature < dT / 2.0:
+            return 0.0
         else:
-            dS = (self.entropy(pressure, temperature+dT/2., volume, params)
-                  - self.entropy(pressure, temperature-dT/2., volume, params))
-            return temperature*dS/dT
+            dS = self.entropy(
+                pressure, temperature + dT / 2.0, volume, params
+            ) - self.entropy(pressure, temperature - dT / 2.0, volume, params)
+            return temperature * dS / dT
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns the volumetric thermal expansivity :math:`[1/K]`.
         For now, this is calculated by numerical differentiation.
         """
         dT = 0.1
-        if temperature < dT/2.:
-            return 0.
+        if temperature < dT / 2.0:
+            return 0.0
         else:
-            dV = (self.volume(pressure, temperature+dT/2., params)
-                  - self.volume(pressure, temperature-dT/2., params))
-            return dV/dT/volume
+            dV = self.volume(pressure, temperature + dT / 2.0, params) - self.volume(
+                pressure, temperature - dT / 2.0, params
+            )
+            return dV / dT / volume
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns the grueneisen parameter.
         This is a dependent thermodynamic variable in this equation of state.
         """
         Cv = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        if Cv == 0.:
-            return 0.
+        if Cv == 0.0:
+            return 0.0
         else:
-            return (self.thermal_expansivity(pressure, temperature,
-                                             volume, params)
-                    * self.isothermal_bulk_modulus(pressure, temperature,
-                                                   volume, params)
-                    * self.volume(pressure, temperature, params))/Cv
+            return (
+                self.thermal_expansivity(pressure, temperature, volume, params)
+                * self.isothermal_bulk_modulus(pressure, temperature, volume, params)
+                * self.volume(pressure, temperature, params)
+            ) / Cv
 
     def calculate_transformed_parameters(self, params):
         """
         This function calculates the "c" parameters of the :cite:`Brosh2007`
         equation of state.
         """
-        Zs = pkgutil.get_data('burnman',
-                              'data/input_masses/atomic_numbers.dat')
-        Zs = Zs.decode('ascii').split('\n')
-        Z = {str(sl[0]): int(sl[1])
-             for sl in [line.split() for line
-                        in Zs if len(line) > 0 and line[0] != '#']}
+        Zs = pkgutil.get_data("burnman", "data/input_masses/atomic_numbers.dat")
+        Zs = Zs.decode("ascii").split("\n")
+        Z = {
+            str(sl[0]): int(sl[1])
+            for sl in [line.split() for line in Zs if len(line) > 0 and line[0] != "#"]
+        }
 
-        nZs = [(n_at, float(Z[el]))
-               for (el, n_at) in params['formula'].items()]
+        nZs = [(n_at, float(Z[el])) for (el, n_at) in params["formula"].items()]
 
         # eq. A2 at 300 TPa
-        X3_300TPa = [np.power(1. - params['a'][i-2]
-                              + params['a'][i-2]
-                              * np.power((1. + float(i)/(3.*params['a'][i-2])
-                                          * 300.e12/params['K_0']),
-                                         1./float(i)), -3.)
-                     for i in range(2, 6)]
+        X3_300TPa = [
+            np.power(
+                1.0
+                - params["a"][i - 2]
+                + params["a"][i - 2]
+                * np.power(
+                    (
+                        1.0
+                        + float(i)
+                        / (3.0 * params["a"][i - 2])
+                        * 300.0e12
+                        / params["K_0"]
+                    ),
+                    1.0 / float(i),
+                ),
+                -3.0,
+            )
+            for i in range(2, 6)
+        ]
 
         # eq. A2 at 330 TPa
-        X3_330TPa = [np.power(1. - params['a'][i-2]
-                              + params['a'][i-2]
-                              * np.power((1. + float(i)/(3.*params['a'][i-2])
-                                          * 330.e12/params['K_0']),
-                                         1./float(i)), -3.)
-                     for i in range(2, 6)]
+        X3_330TPa = [
+            np.power(
+                1.0
+                - params["a"][i - 2]
+                + params["a"][i - 2]
+                * np.power(
+                    (
+                        1.0
+                        + float(i)
+                        / (3.0 * params["a"][i - 2])
+                        * 330.0e12
+                        / params["K_0"]
+                    ),
+                    1.0 / float(i),
+                ),
+                -3.0,
+            )
+            for i in range(2, 6)
+        ]
 
         # eq. A6a, m^3/mol
-        V_QSM_300TPa = np.sum([n_at
-                               * (0.02713
-                                  * np.exp(0.97626*np.log(Zi)
-                                           - 0.057848 * np.log(Zi)*np.log(Zi)))
-                               for (n_at, Zi) in nZs])*1.e-6
+        V_QSM_300TPa = (
+            np.sum(
+                [
+                    n_at
+                    * (
+                        0.02713
+                        * np.exp(
+                            0.97626 * np.log(Zi) - 0.057848 * np.log(Zi) * np.log(Zi)
+                        )
+                    )
+                    for (n_at, Zi) in nZs
+                ]
+            )
+            * 1.0e-6
+        )
 
         # eq. A6b, m^3/mol
-        V_QSM_330TPa = np.sum([n_at
-                               * (0.025692
-                                  * np.exp(0.97914*np.log(Zi)
-                                           - 0.057741*np.log(Zi)*np.log(Zi)))
-                               for (n_at, Zi) in nZs])*1.e-6
-
-        A = np.array([[1., 1., 1., 1.],  # eq A3
-                      [0., 6., 8., 9.],  # eq A4
-                      X3_300TPa,  # eq A5a
-                      X3_330TPa])  # eq A5b
-
-        b = np.array([1., 8., V_QSM_300TPa/params['V_0'],
-                      V_QSM_330TPa/params['V_0']])
+        V_QSM_330TPa = (
+            np.sum(
+                [
+                    n_at
+                    * (
+                        0.025692
+                        * np.exp(
+                            0.97914 * np.log(Zi) - 0.057741 * np.log(Zi) * np.log(Zi)
+                        )
+                    )
+                    for (n_at, Zi) in nZs
+                ]
+            )
+            * 1.0e-6
+        )
+
+        A = np.array(
+            [
+                [1.0, 1.0, 1.0, 1.0],  # eq A3
+                [0.0, 6.0, 8.0, 9.0],  # eq A4
+                X3_300TPa,  # eq A5a
+                X3_330TPa,
+            ]
+        )  # eq A5b
+
+        b = np.array(
+            [1.0, 8.0, V_QSM_300TPa / params["V_0"], V_QSM_330TPa / params["V_0"]]
+        )
 
         # does not quite reproduce the published values of c
         # A.c consistently gives b[2], b[3] ~1% larger than Brosh
         return np.linalg.solve(A, b)
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        params['T_0'] = 298.15
-        if 'P_0' not in params:
-            params['P_0'] = 1.e5
-
-        if 'a' not in params:
-            params['a'] = [(float(i)-1.)/(3.*params['Kprime_0'] - 1.)
-                           for i in range(2, 6)]  # eq. A2
+        params["T_0"] = 298.15
+        if "P_0" not in params:
+            params["P_0"] = 1.0e5
+
+        if "a" not in params:
+            params["a"] = [
+                (float(i) - 1.0) / (3.0 * params["Kprime_0"] - 1.0) for i in range(2, 6)
+            ]  # eq. A2
 
-        if 'c' not in params:
-            params['c'] = self.calculate_transformed_parameters(params)
+        if "c" not in params:
+            params["c"] = self.calculate_transformed_parameters(params)
 
         # Calculate reference values for gibbs free energy and heat capacity
-        nur = params['theta_0']/params['T_0']
-        G_qhr = self._gibbs_qh(params['T_0'], params['theta_0'], params['n'])
-        S_qhr = self._S_qh(params['T_0'], params['theta_0'], params['n'])
-        Cp_qhr = (3. * params['n'] * gas_constant
-                  * nur * nur * np.exp(nur) / np.power(np.exp(nur) - 1., 2.))
-
-        G_SGTEr = self._gibbs_1bar(params['T_0'], params)
-        S_SGTEr = self._S_1bar(params['T_0'], params)
-        Cp_SGTEr = self._Cp_1bar(params['T_0'], params)
-
-        params['delta_Cpr'] = (Cp_SGTEr - Cp_qhr)
-        params['delta_Gr'] = (G_SGTEr - G_qhr)
-        params['delta_Sr'] = (S_SGTEr - S_qhr)
+        nur = params["theta_0"] / params["T_0"]
+        G_qhr = self._gibbs_qh(params["T_0"], params["theta_0"], params["n"])
+        S_qhr = self._S_qh(params["T_0"], params["theta_0"], params["n"])
+        Cp_qhr = (
+            3.0
+            * params["n"]
+            * gas_constant
+            * nur
+            * nur
+            * np.exp(nur)
+            / np.power(np.exp(nur) - 1.0, 2.0)
+        )
+
+        G_SGTEr = self._gibbs_1bar(params["T_0"], params)
+        S_SGTEr = self._S_1bar(params["T_0"], params)
+        Cp_SGTEr = self._Cp_1bar(params["T_0"], params)
+
+        params["delta_Cpr"] = Cp_SGTEr - Cp_qhr
+        params["delta_Gr"] = G_SGTEr - G_qhr
+        params["delta_Sr"] = S_SGTEr - S_qhr
 
         # Check that all the required keys are in the dictionary
-        expected_keys = ['gibbs_coefficients',
-                         'V_0', 'K_0', 'Kprime_0',
-                         'theta_0', 'grueneisen_0', 'delta', 'b']
+        expected_keys = [
+            "gibbs_coefficients",
+            "V_0",
+            "K_0",
+            "Kprime_0",
+            "theta_0",
+            "grueneisen_0",
+            "delta",
+            "b",
+        ]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['P_0'] < 0.:
-            warnings.warn('Unusual value for P_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-3:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < 0. or params['Kprime_0'] > 10.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
+        if params["P_0"] < 0.0:
+            warnings.warn("Unusual value for P_0", stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < 0.0 or params["Kprime_0"] > 10.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/cork.py` & `burnman-1.2.0/burnman/eos/cork.py`

 * *Files 14% similar despite different names*

```diff
@@ -12,21 +12,27 @@
 from . import equation_of_state as eos
 from .. import constants
 
 import warnings
 
 
 def cork_variables(cork, cork_P, cork_T, temperature):
-    a = cork[0][0] * cork_T ** (2.5) / cork_P + cork[
-        0][1] * cork_T ** (1.5) / cork_P * temperature
+    a = (
+        cork[0][0] * cork_T ** (2.5) / cork_P
+        + cork[0][1] * cork_T ** (1.5) / cork_P * temperature
+    )
     b = cork[1][0] * cork_T / cork_P
-    c = cork[2][0] * cork_T / cork_P ** (
-        1.5) + cork[2][1] / cork_P ** (1.5) * temperature
-    d = cork[3][0] * cork_T / cork_P ** (
-        2.0) + cork[3][1] / cork_P ** (2.0) * temperature
+    c = (
+        cork[2][0] * cork_T / cork_P ** (1.5)
+        + cork[2][1] / cork_P ** (1.5) * temperature
+    )
+    d = (
+        cork[3][0] * cork_T / cork_P ** (2.0)
+        + cork[3][1] / cork_P ** (2.0) * temperature
+    )
     return [a, b, c, d]
 
 
 class CORK(eos.EquationOfState):
 
     """
     Class for the CoRK equation of state detailed in :cite:`HP1991`. The
@@ -38,148 +44,199 @@
     """
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter [unitless] as a function of pressure,
         temperature, and volume.
         """
-        return 0.
+        return 0.0
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume [m^3] as a function of pressure [Pa] and temperature [K]
         Eq. 7 in Holland and Powell, 1991
         """
         cork = cork_variables(
-            params['cork_params'], params['cork_P'], params['cork_T'], temperature)
-        V = constants.gas_constant * temperature / pressure + (cork[1] - cork[0] * constants.gas_constant * np.sqrt(temperature) / (
-            (constants.gas_constant * temperature + cork[1] * pressure) * (constants.gas_constant * temperature + 2. * cork[1] * pressure)) + cork[2] * np.sqrt(pressure) + cork[3] * pressure)
+            params["cork_params"], params["cork_P"], params["cork_T"], temperature
+        )
+        V = constants.gas_constant * temperature / pressure + (
+            cork[1]
+            - cork[0]
+            * constants.gas_constant
+            * np.sqrt(temperature)
+            / (
+                (constants.gas_constant * temperature + cork[1] * pressure)
+                * (constants.gas_constant * temperature + 2.0 * cork[1] * pressure)
+            )
+            + cork[2] * np.sqrt(pressure)
+            + cork[3] * pressure
+        )
         return V
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].  EQ 13+2
         """
-        return 0.
+        return 0.0
 
     # calculate the shear modulus as a function of P, V, and T
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Not implemented.
         Returns 0.
         Could potentially apply a fixed Poissons ratio as a rough estimate.
         """
-        return 0.
+        return 0.0
 
     # Cv, heat capacity at constant volume
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume at the pressure, temperature, and volume [J/K/mol].
         """
-        return 0.
+        return 0.0
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity at the pressure, temperature, and volume [1/K]
         Replace -Pth in EQ 13+1 with P-Pth for non-ambient temperature
         """
-        return 0.
+        return 0.0
 
     # Heat capacity at ambient pressure
     def molar_heat_capacity_p0(self, temperature, params):
         """
         Returns heat capacity at ambient pressure as a function of temperature [J/K/mol]
         Cp = a + bT + cT^-2 + dT^-0.5 in Holland and Powell, 2011
         """
-        Cp = params['Cp'][0] + params['Cp'][1] * temperature + params['Cp'][2] * \
-            np.power(temperature, -2.) + params[
-                'Cp'][3] * np.power(temperature, -0.5)
+        Cp = (
+            params["Cp"][0]
+            + params["Cp"][1] * temperature
+            + params["Cp"][2] * np.power(temperature, -2.0)
+            + params["Cp"][3] * np.power(temperature, -0.5)
+        )
         return Cp
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure at the pressure, temperature, and volume [J/K/mol]
         """
         return 0
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].
         """
-        return 0.
+        return 0.0
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the gibbs free energy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
-        T_0 = params['T_0']
-        P_relative = pressure - params['P_0']
+        T_0 = params["T_0"]
+        P_relative = pressure - params["P_0"]
 
         # Calculate temperature and pressure integrals
-        intCpdT = (params['Cp'][0] * temperature + 0.5 * params['Cp'][1] * np.power(temperature, 2.) - params['Cp'][2] / temperature + 2. * params['Cp'][
-                   3] * np.sqrt(temperature)) - (params['Cp'][0] * T_0 + 0.5 * params['Cp'][1] * T_0 * T_0 - params['Cp'][2] / T_0 + 2.0 * params['Cp'][3] * np.sqrt(T_0))
+        intCpdT = (
+            params["Cp"][0] * temperature
+            + 0.5 * params["Cp"][1] * np.power(temperature, 2.0)
+            - params["Cp"][2] / temperature
+            + 2.0 * params["Cp"][3] * np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * T_0
+            + 0.5 * params["Cp"][1] * T_0 * T_0
+            - params["Cp"][2] / T_0
+            + 2.0 * params["Cp"][3] * np.sqrt(T_0)
+        )
+
+        intCpoverTdT = (
+            params["Cp"][0] * np.log(temperature)
+            + params["Cp"][1] * temperature
+            - 0.5 * params["Cp"][2] / np.power(temperature, 2.0)
+            - 2.0 * params["Cp"][3] / np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * np.log(T_0)
+            + params["Cp"][1] * T_0
+            - 0.5 * params["Cp"][2] / (T_0 * T_0)
+            - 2.0 * params["Cp"][3] / np.sqrt(T_0)
+        )
 
-        intCpoverTdT = (params['Cp'][0] * np.log(temperature) + params['Cp'][1] * temperature - 0.5 * params['Cp'][2] / np.power(temperature, 2.) - 2.0 * params['Cp'][
-                        3] / np.sqrt(temperature)) - (params['Cp'][0] * np.log(T_0) + params['Cp'][1] * T_0 - 0.5 * params['Cp'][2] / (T_0 * T_0) - 2.0 * params['Cp'][3] / np.sqrt(T_0))
-
-        if params['cork_T'] == 0:
-            RTlnf = 0.
+        if params["cork_T"] == 0:
+            RTlnf = 0.0
         else:
             cork = cork_variables(
-                params['cork_params'], params['cork_P'], params['cork_T'], temperature)
-
-            RTlnf = constants.gas_constant * temperature * np.log(1e-5 * P_relative) + cork[1] * P_relative + cork[0] / (cork[1] * np.sqrt(temperature)) * (np.log(constants.gas_constant * temperature + cork[1] * P_relative) - np.log(
-                constants.gas_constant * temperature + 2. * cork[1] * P_relative)) + 2. / 3. * cork[2] * P_relative * np.sqrt(P_relative) + cork[3] / 2. * P_relative * P_relative  # Eq. 8 in Holland and Powell, 1991
+                params["cork_params"], params["cork_P"], params["cork_T"], temperature
+            )
 
-        return params['H_0'] + intCpdT - temperature * (params['S_0'] + intCpoverTdT) + RTlnf
+            RTlnf = (
+                constants.gas_constant * temperature * np.log(1e-5 * P_relative)
+                + cork[1] * P_relative
+                + cork[0]
+                / (cork[1] * np.sqrt(temperature))
+                * (
+                    np.log(constants.gas_constant * temperature + cork[1] * P_relative)
+                    - np.log(
+                        constants.gas_constant * temperature
+                        + 2.0 * cork[1] * P_relative
+                    )
+                )
+                + 2.0 / 3.0 * cork[2] * P_relative * np.sqrt(P_relative)
+                + cork[3] / 2.0 * P_relative * P_relative
+            )  # Eq. 8 in Holland and Powell, 1991
+
+        return (
+            params["H_0"]
+            + intCpdT
+            - temperature * (params["S_0"] + intCpoverTdT)
+            + RTlnf
+        )
 
     # calculate P = P(T0) + Pth
     def pressure(self, temperature, volume, params):
         """
         Returns pressure [Pa] as a function of temperature [K] and volume[m^3]
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        if 'T_0' not in params:
-            params['T_0'] = 298.15
-        if 'P_0' not in params:
-            params['P_0'] = 0.
+        if "T_0" not in params:
+            params["T_0"] = 298.15
+        if "P_0" not in params:
+            params["P_0"] = 0.0
 
         # if G and Gprime are not included this is presumably deliberate,
         # as we can model density and bulk modulus just fine without them,
         # so just add them to the dictionary as nans
-        if 'H_0' not in params:
-            params['H_0'] = float('nan')
-        if 'S_0' not in params:
-            params['S_0'] = float('nan')
+        if "H_0" not in params:
+            params["H_0"] = float("nan")
+        if "S_0" not in params:
+            params["S_0"] = float("nan")
 
         # check that all the required keys are in the dictionary
-        expected_keys = ['cork_params', 'cork_T', 'cork_P', 'Cp']
+        expected_keys = ["cork_params", "cork_T", "cork_P", "Cp"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # now check that the values are reasonable.  I mostly just
         # made up these values from experience, and we are only
         # raising a warning.  Better way to do this? [IR]
 
         # no test for H_0
-        if params['S_0'] is not float('nan') and params['S_0'] < 0.:
-            warnings.warn('Unusual value for S_0', stacklevel=2)
+        if params["S_0"] is not float("nan") and params["S_0"] < 0.0:
+            warnings.warn("Unusual value for S_0", stacklevel=2)
 
-        if params['cork_T'] < -1.:
-            warnings.warn('Unusual value for cork_T', stacklevel=2)
-        if params['cork_P'] < 1.e4 or params['cork_P'] > 1.e8:
-            warnings.warn('Unusual value for cork_P', stacklevel=2)
-
-        if self.molar_heat_capacity_p0(params['T_0'], params) < 0.:
-            warnings.warn('Negative heat capacity at T_0', stacklevel=2)
-        if self.molar_heat_capacity_p0(2000., params) < 0.:
-            warnings.warn('Negative heat capacity at 2000K', stacklevel=2)
+        if params["cork_T"] < -1.0:
+            warnings.warn("Unusual value for cork_T", stacklevel=2)
+        if params["cork_P"] < 1.0e4 or params["cork_P"] > 1.0e8:
+            warnings.warn("Unusual value for cork_P", stacklevel=2)
+
+        if self.molar_heat_capacity_p0(params["T_0"], params) < 0.0:
+            warnings.warn("Negative heat capacity at T_0", stacklevel=2)
+        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:
+            warnings.warn("Negative heat capacity at 2000K", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/dks_liquid.py` & `burnman-1.2.0/burnman/eos/dks_liquid.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,28 +3,29 @@
 # GPL v2 or later.
 
 from __future__ import absolute_import
 
 from os import path
 import numpy as np
 import scipy.optimize as opt
+
 try:
     # scipy's factorial was moved to special in scipy 1.3.0+
     from scipy.special import factorial
 except ImportError:
     from scipy.misc import factorial
 
 import warnings
 
 from . import equation_of_state as eos
 from .. import constants as constants
 from ..utils.chemistry import read_masses
 from ..utils.math import bracket
 
-atomic_masses=read_masses()
+atomic_masses = read_masses()
 # energy_states should provide the energies and degeneracies of each electronic level in a variety of elements
 
 
 class DKS_L(eos.EquationOfState):
     """
     Base class for the finite strain liquid equation of state detailed
     in :cite:`deKoker2013` (supplementary materials).
@@ -35,547 +36,725 @@
     to thermodynamic properties
     """
 
     def _ln_partition_function(self, mass, temperature):
         """
         Calculates the natural log of the partition function
         """
-        return 3./2.*np.log(temperature) \
-            + 3./2.*np.log(mass*constants.Boltzmann \
-                           /(2*np.pi*constants.Dirac*constants.Dirac)) \
+        return 3.0 / 2.0 * np.log(temperature) + 3.0 / 2.0 * np.log(
+            mass * constants.Boltzmann / (2 * np.pi * constants.Dirac * constants.Dirac)
+        )
 
     def _F_ig(self, temperature, volume, params):
         """
         The ideal gas contribution to the helmholtz free energy
         Eq. S6, see also eq. 16.72 of Callen., 1985; p. 373
         """
 
-        V = volume/constants.Avogadro
-        figoverRT=0.
-        for element, N in params['formula'].items(): # N is a.p.f.u
-            if N > 1.e-5:
-                mass = atomic_masses[element]/constants.Avogadro
-                figoverRT += -N*(np.log(V) + self._ln_partition_function(mass, temperature) \
-                                     + 1.) + N*np.log(N)
-        return constants.gas_constant*temperature*figoverRT
-
+        V = volume / constants.Avogadro
+        figoverRT = 0.0
+        for element, N in params["formula"].items():  # N is a.p.f.u
+            if N > 1.0e-5:
+                mass = atomic_masses[element] / constants.Avogadro
+                figoverRT += -N * (
+                    np.log(V) + self._ln_partition_function(mass, temperature) + 1.0
+                ) + N * np.log(N)
+        return constants.gas_constant * temperature * figoverRT
 
     def _S_ig(self, temperature, volume, params):
         """
         The ideal gas contribution to the entropy
         """
 
-        V = volume/constants.Avogadro
-        entropy_sum=0.
-        for element, N in params['formula'].items(): # N is a.p.f.u
-            if N > 1.e-5:
-                mass = atomic_masses[element]/constants.Avogadro
-                entropy_sum -= -N*(np.log(V) + self._ln_partition_function(mass, temperature) \
-                                     + 5./2.) + N*np.log(N)
-        return constants.gas_constant*entropy_sum
+        V = volume / constants.Avogadro
+        entropy_sum = 0.0
+        for element, N in params["formula"].items():  # N is a.p.f.u
+            if N > 1.0e-5:
+                mass = atomic_masses[element] / constants.Avogadro
+                entropy_sum -= -N * (
+                    np.log(V)
+                    + self._ln_partition_function(mass, temperature)
+                    + 5.0 / 2.0
+                ) + N * np.log(N)
+        return constants.gas_constant * entropy_sum
 
     def _C_v_ig(self, temperature, volume, params):
         """
         The ideal gas contribution to the heat capacity
         """
 
-        n_atoms=0
-        for element, N in params['formula'].items():
+        n_atoms = 0
+        for element, N in params["formula"].items():
             n_atoms += N
-        return 1.5*constants.gas_constant*n_atoms
+        return 1.5 * constants.gas_constant * n_atoms
 
     def _P_ig(self, temperature, volume, params):
         """
         The ideal gas contribution to the pressure
         PV = nRT
         """
 
-        n_atoms=0
-        for element, N in params['formula'].items():
+        n_atoms = 0
+        for element, N in params["formula"].items():
             n_atoms += N
-        return n_atoms*constants.gas_constant*temperature / volume
+        return n_atoms * constants.gas_constant * temperature / volume
 
     def _K_T_ig(self, temperature, volume, params):
         """
         The ideal gas contribution to the isothermal bulk modulus
         V * d/dV(-nRT/V) = V*nRT/V^2
         """
-        n_atoms=0
-        for element, N in params['formula'].items():
+        n_atoms = 0
+        for element, N in params["formula"].items():
             n_atoms += N
-        return n_atoms*constants.gas_constant*temperature / volume
+        return n_atoms * constants.gas_constant * temperature / volume
 
     def _alphaK_T_ig(self, temperature, volume, params):
         """
         The ideal gas contribution to the product of the
         thermal expansivity and isothermal bulk modulus
         d/dT(nRT/V) = nR/V
         """
 
-        n_atoms=0
-        for element, N in params['formula'].items():
+        n_atoms = 0
+        for element, N in params["formula"].items():
             n_atoms += N
-        return n_atoms*constants.gas_constant / volume
+        return n_atoms * constants.gas_constant / volume
 
     """
     Electronic contributions to thermodynamic properties
     """
 
-    def _zeta(self, temperature, volume, params): # eq. S5a, beta in deKoker thesis (3.34)
-        return params['zeta_0']*(np.power(volume/params['el_V_0'], params['xi']))
+    def _zeta(
+        self, temperature, volume, params
+    ):  # eq. S5a, beta in deKoker thesis (3.34)
+        return params["zeta_0"] * (np.power(volume / params["el_V_0"], params["xi"]))
 
     def _dzetadV(self, temperature, volume, params):
-        return params['zeta_0']*params['xi']*(np.power(volume/params['el_V_0'], params['xi']))/volume
+        return (
+            params["zeta_0"]
+            * params["xi"]
+            * (np.power(volume / params["el_V_0"], params["xi"]))
+            / volume
+        )
 
     def _d2zetadV2(self, temperature, volume, params):
-        return params['zeta_0'] \
-            * params['xi'] * (params['xi'] - 1.) \
-            * (np.power(volume/params['el_V_0'], params['xi'])) \
-            / volume / volume
+        return (
+            params["zeta_0"]
+            * params["xi"]
+            * (params["xi"] - 1.0)
+            * (np.power(volume / params["el_V_0"], params["xi"]))
+            / volume
+            / volume
+        )
 
-    def _Tel(self, temperature, volume, params): # eq. S5b
-        return params['Tel_0']*(np.power(volume/params['el_V_0'], params['eta']))
+    def _Tel(self, temperature, volume, params):  # eq. S5b
+        return params["Tel_0"] * (np.power(volume / params["el_V_0"], params["eta"]))
 
     def _dTeldV(self, temperature, volume, params):
-        return params['Tel_0'] * params['eta'] \
-            * (np.power(volume/params['el_V_0'], params['eta'])) \
+        return (
+            params["Tel_0"]
+            * params["eta"]
+            * (np.power(volume / params["el_V_0"], params["eta"]))
             / volume
+        )
 
     def _d2TeldV2(self, temperature, volume, params):
-        return params['Tel_0'] \
-            * params['eta'] * (params['eta'] - 1.) \
-            * (np.power(volume/params['el_V_0'], params['eta'])) \
-            / volume / volume
-
-    def _gimel(self, temperature_el, temperature, volume, params): # -F_el/zeta, 3.30 in de Koker thesis
-        return 0.5*(temperature*temperature - temperature_el*temperature_el) \
-            - temperature*temperature_el*np.log(temperature/temperature_el)
+        return (
+            params["Tel_0"]
+            * params["eta"]
+            * (params["eta"] - 1.0)
+            * (np.power(volume / params["el_V_0"], params["eta"]))
+            / volume
+            / volume
+        )
+
+    def _gimel(
+        self, temperature_el, temperature, volume, params
+    ):  # -F_el/zeta, 3.30 in de Koker thesis
+        return 0.5 * (
+            temperature * temperature - temperature_el * temperature_el
+        ) - temperature * temperature_el * np.log(temperature / temperature_el)
 
     def _dgimeldTel(self, temperature_el, temperature, volume, params):
-        return (temperature-temperature_el) - temperature*np.log(temperature/temperature_el)
+        return (temperature - temperature_el) - temperature * np.log(
+            temperature / temperature_el
+        )
 
     def _dgimeldT(self, temperature_el, temperature, volume, params):
-        return (temperature-temperature_el) - temperature_el*np.log(temperature/temperature_el)
+        return (temperature - temperature_el) - temperature_el * np.log(
+            temperature / temperature_el
+        )
 
     def _d2gimeldTdTel(self, temperature_el, temperature, volume, params):
-        return -np.log(temperature/temperature_el)
+        return -np.log(temperature / temperature_el)
 
     def _d2gimeldTel2(self, temperature_el, temperature, volume, params):
-        return (temperature/temperature_el)  - 1.
+        return (temperature / temperature_el) - 1.0
 
-    def _F_el(self, temperature, volume, params): # F_el
+    def _F_el(self, temperature, volume, params):  # F_el
         temperature_el = self._Tel(temperature, volume, params)
         if temperature < temperature_el:
             F_el = 0
         else:
-            F_el = -self._zeta(temperature, volume, params) \
-                * self._gimel(temperature_el, temperature, volume, params)
+            F_el = -self._zeta(temperature, volume, params) * self._gimel(
+                temperature_el, temperature, volume, params
+            )
         return F_el
 
-    def _S_el(self, temperature, volume, params): # S_el
+    def _S_el(self, temperature, volume, params):  # S_el
         temperature_el = self._Tel(temperature, volume, params)
         if temperature < temperature_el:
             S_el = 0
         else:
-            S_el = self._zeta(temperature, volume, params) \
-                * self._dgimeldT(temperature_el, temperature, volume, params)
+            S_el = self._zeta(temperature, volume, params) * self._dgimeldT(
+                temperature_el, temperature, volume, params
+            )
         return S_el
 
-
-    def _P_el(self, temperature, volume, params): # P_el
+    def _P_el(self, temperature, volume, params):  # P_el
         temperature_el = self._Tel(temperature, volume, params)
         if temperature < temperature_el:
             P_el = 0
         else:
-            P_el =  self._dzetadV(temperature, volume, params) \
-                * self._gimel(temperature_el, temperature, volume, params) \
-                + self._zeta(temperature, volume, params) \
-                * self._dTeldV(temperature, volume, params) \
-                * self._dgimeldTel(temperature_el, temperature, volume, params)
+            P_el = self._dzetadV(temperature, volume, params) * self._gimel(
+                temperature_el, temperature, volume, params
+            ) + self._zeta(temperature, volume, params) * self._dTeldV(
+                temperature, volume, params
+            ) * self._dgimeldTel(
+                temperature_el, temperature, volume, params
+            )
         return P_el
 
-    def _K_T_el(self, temperature, volume, params): # K_T_el
+    def _K_T_el(self, temperature, volume, params):  # K_T_el
         temperature_el = self._Tel(temperature, volume, params)
         if temperature < temperature_el:
             K_T_el = 0
         else:
-            K_T_el =  -volume \
-                * ( self._d2zetadV2(temperature, volume, params) \
-                        * self._gimel(temperature_el, temperature, volume, params) \
-                        + 2. * self._dzetadV(temperature, volume, params) \
-                        * self._dgimeldTel(temperature_el, temperature, volume, params) \
-                        * self._dTeldV(temperature, volume, params) \
-                        + self._zeta(temperature, volume, params) \
-                        * ( self._d2TeldV2(temperature, volume, params) \
-                                * self._dgimeldTel(temperature_el, temperature, volume, params) \
-                                + self._dTeldV(temperature, volume, params) \
-                                * self._dTeldV(temperature, volume, params) \
-                                * self._d2gimeldTel2(temperature_el, temperature, volume, params)))
+            K_T_el = -volume * (
+                self._d2zetadV2(temperature, volume, params)
+                * self._gimel(temperature_el, temperature, volume, params)
+                + 2.0
+                * self._dzetadV(temperature, volume, params)
+                * self._dgimeldTel(temperature_el, temperature, volume, params)
+                * self._dTeldV(temperature, volume, params)
+                + self._zeta(temperature, volume, params)
+                * (
+                    self._d2TeldV2(temperature, volume, params)
+                    * self._dgimeldTel(temperature_el, temperature, volume, params)
+                    + self._dTeldV(temperature, volume, params)
+                    * self._dTeldV(temperature, volume, params)
+                    * self._d2gimeldTel2(temperature_el, temperature, volume, params)
+                )
+            )
         return K_T_el
 
-    def _alphaK_T_el(self, temperature, volume, params): # (alphaK_T)_el
+    def _alphaK_T_el(self, temperature, volume, params):  # (alphaK_T)_el
         temperature_el = self._Tel(temperature, volume, params)
         if temperature < temperature_el:
             alphaK_T_el = 0
         else:
-            alphaK_T_el = self._dzetadV(temperature, volume, params) \
-                * self._dgimeldT(temperature_el, temperature, volume, params) \
-                + self._zeta(temperature, volume, params) \
-                * self._d2gimeldTdTel(temperature_el, temperature, volume, params) \
-                * self._dTeldV(temperature, volume, params)
+            alphaK_T_el = self._dzetadV(temperature, volume, params) * self._dgimeldT(
+                temperature_el, temperature, volume, params
+            ) + self._zeta(temperature, volume, params) * self._d2gimeldTdTel(
+                temperature_el, temperature, volume, params
+            ) * self._dTeldV(
+                temperature, volume, params
+            )
         return alphaK_T_el
 
-    def _C_v_el(self, temperature, volume, params): # C_el, eq. 3.28 of de Koker thesis
+    def _C_v_el(self, temperature, volume, params):  # C_el, eq. 3.28 of de Koker thesis
         temperature_el = self._Tel(temperature, volume, params)
         zeta = self._zeta(temperature, volume, params)
 
         if temperature > temperature_el:
-            Cv_el = zeta*(temperature - temperature_el)
+            Cv_el = zeta * (temperature - temperature_el)
         else:
-            Cv_el = 0.
+            Cv_el = 0.0
         return Cv_el
 
-
-
     """
     Excess (bonding) contributions to thermodynamic properties
     """
 
     # Finite strain
-    def _finite_strain(self, temperature, volume, params): # f(V), eq. S3a
-        return (1./2.)*(np.power(params['V_0']/volume, 2./3.) - 1.0)
+    def _finite_strain(self, temperature, volume, params):  # f(V), eq. S3a
+        return (1.0 / 2.0) * (np.power(params["V_0"] / volume, 2.0 / 3.0) - 1.0)
 
-    def _dfdV(self, temperature, volume, params): # f(V), eq. S3a
-        return (-1./3.)*np.power(params['V_0']/volume, 2./3.)/volume
+    def _dfdV(self, temperature, volume, params):  # f(V), eq. S3a
+        return (-1.0 / 3.0) * np.power(params["V_0"] / volume, 2.0 / 3.0) / volume
 
-    def _d2fdV2(self,temperature, volume, params):
-        return (5./9.)*np.power(params['V_0']/volume, 2./3.)/volume/volume
+    def _d2fdV2(self, temperature, volume, params):
+        return (
+            (5.0 / 9.0) * np.power(params["V_0"] / volume, 2.0 / 3.0) / volume / volume
+        )
 
     # Temperature
-    def _theta(self, temperature, volume, params): # theta, eq. S3b
-        return np.power(temperature/params['T_0'], params['m']) - 1.
+    def _theta(self, temperature, volume, params):  # theta, eq. S3b
+        return np.power(temperature / params["T_0"], params["m"]) - 1.0
 
     def _dthetadT(self, temperature, volume, params):
-        return params['m']*np.power(temperature/params['T_0'], params['m']) \
+        return (
+            params["m"]
+            * np.power(temperature / params["T_0"], params["m"])
             / temperature
+        )
 
     def _d2thetadT2(self, temperature, volume, params):
-        return params['m']*(params['m']-1.)*np.power(temperature/params['T_0'], params['m']) \
-            / temperature / temperature
+        return (
+            params["m"]
+            * (params["m"] - 1.0)
+            * np.power(temperature / params["T_0"], params["m"])
+            / temperature
+            / temperature
+        )
 
-    def _F_xs(self, temperature, volume, params): # F_xs, eq. S2
+    def _F_xs(self, temperature, volume, params):  # F_xs, eq. S2
         f = self._finite_strain(temperature, volume, params)
         theta = self._theta(temperature, volume, params)
-        energy = 0.
-        for i in range(len(params['a'])):
-            ifact=factorial(i, exact=False)
-            for j in range(len(params['a'][0])):
-                jfact=factorial(j, exact=False)
-                energy += params['a'][i][j]*np.power(f, i)*np.power(theta, j)/ifact/jfact
+        energy = 0.0
+        for i in range(len(params["a"])):
+            ifact = factorial(i, exact=False)
+            for j in range(len(params["a"][0])):
+                jfact = factorial(j, exact=False)
+                energy += (
+                    params["a"][i][j]
+                    * np.power(f, i)
+                    * np.power(theta, j)
+                    / ifact
+                    / jfact
+                )
         return energy
 
-    def _S_xs(self, temperature, volume, params): # F_xs, eq. 3.18
+    def _S_xs(self, temperature, volume, params):  # F_xs, eq. 3.18
         f = self._finite_strain(temperature, volume, params)
         theta = self._theta(temperature, volume, params)
-        entropy = 0.
-        for i in range(len(params['a'])):
+        entropy = 0.0
+        for i in range(len(params["a"])):
             ifact = factorial(i, exact=False)
-            for j in range(len(params['a'][0])):
+            for j in range(len(params["a"][0])):
                 if j > 0:
                     jfact = factorial(j, exact=False)
-                    entropy += j*params['a'][i][j]*np.power(f, i)*np.power(theta, j-1.)/ifact/jfact
-        return -self._dthetadT(temperature, volume, params)*entropy
+                    entropy += (
+                        j
+                        * params["a"][i][j]
+                        * np.power(f, i)
+                        * np.power(theta, j - 1.0)
+                        / ifact
+                        / jfact
+                    )
+        return -self._dthetadT(temperature, volume, params) * entropy
 
-    def _P_xs(self, temperature, volume, params): # P_xs, eq. 3.17 of de Koker thesis
+    def _P_xs(self, temperature, volume, params):  # P_xs, eq. 3.17 of de Koker thesis
         f = self._finite_strain(temperature, volume, params)
         theta = self._theta(temperature, volume, params)
-        pressure=0.
-        for i in range(len(params['a'])):
-            ifact=factorial(i, exact=False)
+        pressure = 0.0
+        for i in range(len(params["a"])):
+            ifact = factorial(i, exact=False)
             if i > 0:
-                for j in range(len(params['a'][0])):
-                    jfact=factorial(j, exact=False)
-                    pressure += float(i)*params['a'][i][j]*np.power(f, float(i)-1.)*np.power(theta, float(j))/ifact/jfact
-        return -self._dfdV(temperature, volume, params)*pressure
-
-    def _K_T_xs(self, temperature, volume, params): # K_T_xs, eq. 3.20 of de Koker thesis
+                for j in range(len(params["a"][0])):
+                    jfact = factorial(j, exact=False)
+                    pressure += (
+                        float(i)
+                        * params["a"][i][j]
+                        * np.power(f, float(i) - 1.0)
+                        * np.power(theta, float(j))
+                        / ifact
+                        / jfact
+                    )
+        return -self._dfdV(temperature, volume, params) * pressure
+
+    def _K_T_xs(
+        self, temperature, volume, params
+    ):  # K_T_xs, eq. 3.20 of de Koker thesis
         f = self._finite_strain(temperature, volume, params)
         theta = self._theta(temperature, volume, params)
-        K_ToverV=0.
-        for i in range(len(params['a'])):
-            ifact=factorial(i, exact=False)
-            for j in range(len(params['a'][0])):
+        K_ToverV = 0.0
+        for i in range(len(params["a"])):
+            ifact = factorial(i, exact=False)
+            for j in range(len(params["a"][0])):
                 if i > 0:
-                    jfact=factorial(j, exact=False)
-                    prefactor = float(i) * params['a'][i][j] \
-                        * np.power(theta, float(j)) / ifact / jfact
-                    K_ToverV += prefactor*self._d2fdV2(temperature, volume, params) \
-                        * np.power(f, float(i-1))
+                    jfact = factorial(j, exact=False)
+                    prefactor = (
+                        float(i)
+                        * params["a"][i][j]
+                        * np.power(theta, float(j))
+                        / ifact
+                        / jfact
+                    )
+                    K_ToverV += (
+                        prefactor
+                        * self._d2fdV2(temperature, volume, params)
+                        * np.power(f, float(i - 1))
+                    )
                 if i > 1:
                     dfdV = self._dfdV(temperature, volume, params)
-                    K_ToverV += prefactor * dfdV * dfdV \
-                        * float(i-1) * np.power(f, float(i-2))
-        return volume*K_ToverV
+                    K_ToverV += (
+                        prefactor
+                        * dfdV
+                        * dfdV
+                        * float(i - 1)
+                        * np.power(f, float(i - 2))
+                    )
+        return volume * K_ToverV
 
-    def _alphaK_T_xs(self, temperature, volume, params): # eq. 3.21 of de Koker thesis
+    def _alphaK_T_xs(self, temperature, volume, params):  # eq. 3.21 of de Koker thesis
         f = self._finite_strain(temperature, volume, params)
         theta = self._theta(temperature, volume, params)
-        sum_factors = 0.
-        for i in range(len(params['a'])):
-            ifact=factorial(i, exact=False)
+        sum_factors = 0.0
+        for i in range(len(params["a"])):
+            ifact = factorial(i, exact=False)
             if i > 0:
-                for j in range(len(params['a'][0])):
+                for j in range(len(params["a"][0])):
                     if j > 0:
-                        jfact=factorial(j, exact=False)
-                        sum_factors += float(i)*float(j)*params['a'][i][j] \
-                            * np.power(f, float(i-1)) * np.power(theta, float(j-1)) \
-                            / ifact / jfact
-
-        return -self._dfdV(temperature, volume, params) \
-            * self._dthetadT(temperature, volume, params) \
+                        jfact = factorial(j, exact=False)
+                        sum_factors += (
+                            float(i)
+                            * float(j)
+                            * params["a"][i][j]
+                            * np.power(f, float(i - 1))
+                            * np.power(theta, float(j - 1))
+                            / ifact
+                            / jfact
+                        )
+
+        return (
+            -self._dfdV(temperature, volume, params)
+            * self._dthetadT(temperature, volume, params)
             * sum_factors
+        )
 
-
-    def _C_v_xs(self, temperature, volume, params): # Cv_xs, eq. 3.22 of de Koker thesis
+    def _C_v_xs(
+        self, temperature, volume, params
+    ):  # Cv_xs, eq. 3.22 of de Koker thesis
         f = self._finite_strain(temperature, volume, params)
         theta = self._theta(temperature, volume, params)
-        C_voverT=0.
-        for i in range(len(params['a'])):
-            ifact=factorial(i, exact=False)
-            for j in range(len(params['a'][0])):
+        C_voverT = 0.0
+        for i in range(len(params["a"])):
+            ifact = factorial(i, exact=False)
+            for j in range(len(params["a"][0])):
                 if j > 0:
-                    jfact=factorial(j, exact=False)
-                    prefactor = float(j)*params['a'][i][j]*np.power(f, float(i))/ifact/jfact
-                    C_voverT += prefactor * self._d2thetadT2(temperature, volume, params) \
-                        * np.power(theta, float(j-1))
+                    jfact = factorial(j, exact=False)
+                    prefactor = (
+                        float(j)
+                        * params["a"][i][j]
+                        * np.power(f, float(i))
+                        / ifact
+                        / jfact
+                    )
+                    C_voverT += (
+                        prefactor
+                        * self._d2thetadT2(temperature, volume, params)
+                        * np.power(theta, float(j - 1))
+                    )
                 if j > 1:
                     dthetadT = self._dthetadT(temperature, volume, params)
-                    C_voverT += prefactor * dthetadT * dthetadT \
-                        * float(j-1) * np.power(theta, float(j-2))
-        return -temperature*C_voverT
-
+                    C_voverT += (
+                        prefactor
+                        * dthetadT
+                        * dthetadT
+                        * float(j - 1)
+                        * np.power(theta, float(j - 2))
+                    )
+        return -temperature * C_voverT
 
     """
     Magnetic contributions to thermodynamic properties
     (as found in Ramo and Stixrude, 2014)
     """
 
     def _spin(self, temperature, volume, params):
-        S_a = 0.
-        S_b = 0.
-        numerator = 0.
-        numerator_2 = 0.
-        n_atoms = 0.
-        if 'spin_a' in params:
-            for element, N in params['formula'].items():
-                if element == 'Fe':
+        S_a = 0.0
+        S_b = 0.0
+        numerator = 0.0
+        numerator_2 = 0.0
+        n_atoms = 0.0
+        if "spin_a" in params:
+            for element, N in params["formula"].items():
+                if element == "Fe":
                     n_atoms += N
 
-            VoverVx = volume/params['V_0']
-            S_a = params['spin_a'][0] + params['spin_a'][1]*VoverVx
-            S_b = (params['spin_b'][0]
-                   + params['spin_b'][1]/VoverVx
-                   + params['spin_b'][2]/(np.power(VoverVx, 2.))
-                   + params['spin_b'][3]/(np.power(VoverVx, 3.)))
+            VoverVx = volume / params["V_0"]
+            S_a = params["spin_a"][0] + params["spin_a"][1] * VoverVx
+            S_b = (
+                params["spin_b"][0]
+                + params["spin_b"][1] / VoverVx
+                + params["spin_b"][2] / (np.power(VoverVx, 2.0))
+                + params["spin_b"][3] / (np.power(VoverVx, 3.0))
+            )
 
             # S = S_a*T + S_b
             # d(2S + 1)/dV
-            numerator=-2.*(-params['spin_a'][1]*temperature
-                           + params['spin_b'][1]/(np.power(VoverVx, 2.))
-                           + 2.*params['spin_b'][2]/(np.power(VoverVx, 3.))
-                           + 3.*params['spin_b'][3]/(np.power(VoverVx, 4.)))/params['V_0']
+            numerator = (
+                -2.0
+                * (
+                    -params["spin_a"][1] * temperature
+                    + params["spin_b"][1] / (np.power(VoverVx, 2.0))
+                    + 2.0 * params["spin_b"][2] / (np.power(VoverVx, 3.0))
+                    + 3.0 * params["spin_b"][3] / (np.power(VoverVx, 4.0))
+                )
+                / params["V_0"]
+            )
 
             # d2S/dV2
-            numerator_2 = 2.*((2.*params['spin_b'][1]/(np.power(VoverVx, 3.))
-                               + 6.*params['spin_b'][2]/(np.power(VoverVx, 4.))
-                               + 12.*params['spin_b'][3]/(np.power(VoverVx, 5.)))
-                              /np.power(params['V_0'], 2.))
+            numerator_2 = 2.0 * (
+                (
+                    2.0 * params["spin_b"][1] / (np.power(VoverVx, 3.0))
+                    + 6.0 * params["spin_b"][2] / (np.power(VoverVx, 4.0))
+                    + 12.0 * params["spin_b"][3] / (np.power(VoverVx, 5.0))
+                )
+                / np.power(params["V_0"], 2.0)
+            )
         return S_a, S_b, numerator, numerator_2, n_atoms
 
-
     def _F_mag(self, temperature, volume, params):
-        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(temperature, volume, params)
-        S = S_a*temperature + S_b
-        return -n_atoms*constants.gas_constant*temperature*np.log(2.*S + 1.)
-
+        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(
+            temperature, volume, params
+        )
+        S = S_a * temperature + S_b
+        return -n_atoms * constants.gas_constant * temperature * np.log(2.0 * S + 1.0)
 
     def _S_mag(self, temperature, volume, params):
-        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(temperature, volume, params)
-        S = S_a*temperature + S_b
-        return n_atoms*constants.gas_constant * ((2.*S_a*temperature/(2.*S + 1.)
-                                                   + np.log(2.*S + 1.)))
+        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(
+            temperature, volume, params
+        )
+        S = S_a * temperature + S_b
+        return (
+            n_atoms
+            * constants.gas_constant
+            * ((2.0 * S_a * temperature / (2.0 * S + 1.0) + np.log(2.0 * S + 1.0)))
+        )
 
     def _P_mag(self, temperature, volume, params):
-        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(temperature, volume, params)
-        S = S_a*temperature + S_b
-        dFdV = -n_atoms*constants.gas_constant*temperature*numerator/(2.*S + 1.)
+        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(
+            temperature, volume, params
+        )
+        S = S_a * temperature + S_b
+        dFdV = (
+            -n_atoms
+            * constants.gas_constant
+            * temperature
+            * numerator
+            / (2.0 * S + 1.0)
+        )
         return -dFdV
 
-
     def _K_T_mag(self, temperature, volume, params):
-        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(temperature, volume, params)
-        S = S_a*temperature + S_b
-        dFdV = numerator/(2.*S + 1.)
-        d2FdV2 = numerator_2/(2.*S + 1.) - np.power(dFdV, 2.)
-
-        return -volume*n_atoms*constants.gas_constant*temperature*d2FdV2
-
-    def _alphaK_T_mag(self, temperature, volume, params): # WARNING: numeric differentiation a.t.m.
-        return (self._P_mag(temperature + 0.5, volume, params)
-                - self._P_mag(temperature - 0.5, volume, params))
-
+        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(
+            temperature, volume, params
+        )
+        S = S_a * temperature + S_b
+        dFdV = numerator / (2.0 * S + 1.0)
+        d2FdV2 = numerator_2 / (2.0 * S + 1.0) - np.power(dFdV, 2.0)
+
+        return -volume * n_atoms * constants.gas_constant * temperature * d2FdV2
+
+    def _alphaK_T_mag(
+        self, temperature, volume, params
+    ):  # WARNING: numeric differentiation a.t.m.
+        return self._P_mag(temperature + 0.5, volume, params) - self._P_mag(
+            temperature - 0.5, volume, params
+        )
 
     def _C_v_mag(self, temperature, volume, params):
-        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(temperature, volume, params)
-        S = S_a*temperature + S_b
-        return n_atoms * constants.gas_constant * temperature * 4.*S_a*(S_a*temperature + 2.*S_b + 1.)/np.power(2.*S + 1., 2.)
-
+        S_a, S_b, numerator, numerator_2, n_atoms = self._spin(
+            temperature, volume, params
+        )
+        S = S_a * temperature + S_b
+        return (
+            n_atoms
+            * constants.gas_constant
+            * temperature
+            * 4.0
+            * S_a
+            * (S_a * temperature + 2.0 * S_b + 1.0)
+            / np.power(2.0 * S + 1.0, 2.0)
+        )
 
     def _aK_T(self, temperature, volume, params):
-        aK_T =  (self._alphaK_T_ig(temperature, volume, params)
-                 + self._alphaK_T_el(temperature, volume, params)
-                 + self._alphaK_T_xs(temperature, volume, params)
-                 + self._alphaK_T_mag(temperature, volume, params))
+        aK_T = (
+            self._alphaK_T_ig(temperature, volume, params)
+            + self._alphaK_T_el(temperature, volume, params)
+            + self._alphaK_T_xs(temperature, volume, params)
+            + self._alphaK_T_mag(temperature, volume, params)
+        )
         return aK_T
 
     # Pressure
     def pressure(self, temperature, volume, params):
-        P = (self._P_ig(temperature, volume, params)
-             + self._P_el(temperature, volume, params)
-             + self._P_xs(temperature, volume, params)
-             + self._P_mag(temperature, volume, params))
+        P = (
+            self._P_ig(temperature, volume, params)
+            + self._P_el(temperature, volume, params)
+            + self._P_xs(temperature, volume, params)
+            + self._P_mag(temperature, volume, params)
+        )
         return P
 
     def volume(self, pressure, temperature, params):
-        _delta_pressure = lambda x, pressure, temperature, params: pressure - self.pressure(temperature, x, params)
+        _delta_pressure = (
+            lambda x, pressure, temperature, params: pressure
+            - self.pressure(temperature, x, params)
+        )
 
         # we need to have a sign change in [a,b] to find a zero. Let us start with a
         # conservative guess:
         args = (pressure, temperature, params)
         try:
-            sol = bracket(_delta_pressure, params['V_0'],
-                          1.e-2 * params['V_0'], args)
+            sol = bracket(_delta_pressure, params["V_0"], 1.0e-2 * params["V_0"], args)
         except ValueError:
             raise Exception(
-                'Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?')
+                "Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?"
+            )
         return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)
 
-    def isothermal_bulk_modulus(self, pressure,temperature, volume, params):
+    def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`[Pa]`
         """
-        K_T = (self._K_T_ig(temperature, volume, params)
-               + self._K_T_el(temperature, volume, params)
-               + self._K_T_xs(temperature, volume, params)
-               + self._K_T_mag(temperature, volume, params))
+        K_T = (
+            self._K_T_ig(temperature, volume, params)
+            + self._K_T_el(temperature, volume, params)
+            + self._K_T_xs(temperature, volume, params)
+            + self._K_T_mag(temperature, volume, params)
+        )
         return K_T
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus. :math:`[Pa]`
         """
-        K_S = (self.isothermal_bulk_modulus(pressure,temperature, volume, params)
-               * ( 1. + temperature
-                   * self.thermal_expansivity(pressure, temperature, volume, params)
-                   * self.grueneisen_parameter(pressure, temperature, volume, params)))
+        K_S = self.isothermal_bulk_modulus(pressure, temperature, volume, params) * (
+            1.0
+            + temperature
+            * self.thermal_expansivity(pressure, temperature, volume, params)
+            * self.grueneisen_parameter(pressure, temperature, volume, params)
+        )
         return K_S
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter. :math:`[unitless]`
         """
-        gamma = (self._aK_T(temperature, volume, params)
-                 * volume
-                 / self.molar_heat_capacity_v(pressure, temperature, volume, params))
+        gamma = (
+            self._aK_T(temperature, volume, params)
+            * volume
+            / self.molar_heat_capacity_v(pressure, temperature, volume, params)
+        )
         return gamma
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus. :math:`[Pa]`
         Zero for fluids
         """
-        return 0.
+        return 0.0
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume. :math:`[J/K/mol]`
         """
-        C_v = (self._C_v_ig(temperature, volume, params)
-               + self._C_v_el(temperature, volume, params)
-               + self._C_v_xs(temperature, volume, params)
-               + self._C_v_mag(temperature, volume, params))
+        C_v = (
+            self._C_v_ig(temperature, volume, params)
+            + self._C_v_el(temperature, volume, params)
+            + self._C_v_xs(temperature, volume, params)
+            + self._C_v_mag(temperature, volume, params)
+        )
         return C_v
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure. :math:`[J/K/mol]`
         """
-        C_p = (self.molar_heat_capacity_v(pressure,temperature, volume, params)
-               * ( 1. + temperature
-                   * self.thermal_expansivity(pressure, temperature, volume, params)
-                   * self.grueneisen_parameter(pressure, temperature, volume, params) ))
+        C_p = self.molar_heat_capacity_v(pressure, temperature, volume, params) * (
+            1.0
+            + temperature
+            * self.thermal_expansivity(pressure, temperature, volume, params)
+            * self.grueneisen_parameter(pressure, temperature, volume, params)
+        )
         return C_p
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity. :math:`[1/K]`
         """
-        alpha = (self._aK_T(temperature, volume, params)
-                 / self.isothermal_bulk_modulus(0., temperature, volume, params))
+        alpha = self._aK_T(temperature, volume, params) / self.isothermal_bulk_modulus(
+            0.0, temperature, volume, params
+        )
         return alpha
 
-    def gibbs_free_energy( self, pressure, temperature, volume, params):
+    def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]
         """
-        G = self.helmholtz_free_energy( pressure, temperature, volume, params) + pressure * volume
+        G = (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
         return G
 
-    def entropy( self, pressure, temperature, volume, params):
+    def entropy(self, pressure, temperature, volume, params):
         """
         Returns the entropy at the pressure and temperature of the mineral [J/K/mol]
         """
-        S = (self._S_ig(temperature, volume, params)
-             + self._S_el(temperature, volume, params)
-             + self._S_xs(temperature, volume, params)
-             + self._S_mag(temperature, volume, params))
+        S = (
+            self._S_ig(temperature, volume, params)
+            + self._S_el(temperature, volume, params)
+            + self._S_xs(temperature, volume, params)
+            + self._S_mag(temperature, volume, params)
+        )
         return S
 
-    def enthalpy( self, pressure, temperature, volume, params):
+    def enthalpy(self, pressure, temperature, volume, params):
         """
         Returns the enthalpy at the pressure and temperature of the mineral [J/mol]
         """
-        H = self.helmholtz_free_energy( pressure, temperature, volume, params) + \
-            temperature * self.entropy( pressure, temperature, volume, params) + \
-            pressure * self.volume( pressure, temperature, params)
+        H = (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + temperature * self.entropy(pressure, temperature, volume, params)
+            + pressure * self.volume(pressure, temperature, params)
+        )
         return H
 
-    def helmholtz_free_energy( self, pressure, temperature, volume, params):
+    def helmholtz_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]
         """
-        F = (self._F_ig(temperature, volume, params)
-             + self._F_el(temperature, volume, params)
-             + self._F_xs(temperature, volume, params)
-             + self._F_mag(temperature, volume, params))
+        F = (
+            self._F_ig(temperature, volume, params)
+            + self._F_el(temperature, volume, params)
+            + self._F_xs(temperature, volume, params)
+            + self._F_mag(temperature, volume, params)
+        )
         return F
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
-        E = self.helmholtz_free_energy(pressure, temperature, volume, params) + \
-            temperature*self.entropy(pressure, temperature, volume, params)
+        E = self.helmholtz_free_energy(
+            pressure, temperature, volume, params
+        ) + temperature * self.entropy(pressure, temperature, volume, params)
         return E
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
         # Check that all the required keys are in the dictionary
-        expected_keys = ['V_0', 'T_0', 'O_theta', 'O_f', 'm', 'a', 'zeta_0', 'xi', 'Tel_0', 'eta']
+        expected_keys = [
+            "V_0",
+            "T_0",
+            "O_theta",
+            "O_f",
+            "m",
+            "a",
+            "zeta_0",
+            "xi",
+            "Tel_0",
+            "eta",
+        ]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Sometimes the standard electronic volume is different to V_0.
         # If not, make it the same.
-        if 'el_V_0' not in params:
-            params['el_V_0'] = params['V_0']
+        if "el_V_0" not in params:
+            params["el_V_0"] = params["V_0"]
```

### Comparing `burnman-1.1.0/burnman/eos/dks_solid.py` & `burnman-1.2.0/burnman/eos/dks_solid.py`

 * *Files 17% similar despite different names*

```diff
@@ -11,197 +11,238 @@
 
 # Try to import the jit from numba.  If it is
 # not available, just go with the standard
 # python interpreter
 try:
     from numba import jit
 except ImportError:
+
     def jit(fn):
         return fn
 
 
 from . import birch_murnaghan as bm
 from . import debye
 from . import equation_of_state as eos
 from ..utils.math import bracket
 
 
-@jit
+@jit(nopython=True)
 def _grueneisen_parameter_fast(V_0, volume, gruen_0, q_0):
     """global function with plain parameters so jit will work"""
     x = V_0 / volume
-    f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-    a1_ii = 6. * gruen_0  # EQ 47
-    a2_iikk = -12. * gruen_0 + 36. * \
-        gruen_0 * gruen_0 - 18. * q_0 * gruen_0  # EQ 47
-    nu_o_nu0_sq = 1. + a1_ii * f + (1. / 2.) * a2_iikk * f * f  # EQ 41
-    return 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
-
-def _intgroverVdV(V_0, volume, gruen_0, q_0):
-    return integrate.quad(lambda x: _grueneisen_parameter_fast(V_0, x, gruen_0, q_0)/x, V_0, volume)[0]
+    f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+    a1_ii = 6.0 * gruen_0  # EQ 47
+    a2_iikk = -12.0 * gruen_0 + 36.0 * gruen_0 * gruen_0 - 18.0 * q_0 * gruen_0  # EQ 47
+    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41
+    return 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
 
-@jit
-def _delta_pressure(x, pressure, temperature, V_0, T_0, Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm):
-    f = 0.5 * (pow(V_0 / x, 2. / 3.) - 1.)
-    nu_o_nu0_sq = 1. + a1_ii * f + (1. / 2.) * a2_iikk * f * f  # EQ 41
-    gr = 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
 
-    return (1. / 3.) * (pow(1. + 2. * f, 5. / 2.)) * ((b_iikk * f) + (0.5 * b_iikkmm * f * f)) \
-        + gr * Cv * (temperature - T_0) / x - pressure  # EQ 21
+def _intgroverVdV(V_0, volume, gruen_0, q_0):
+    return integrate.quad(
+        lambda x: _grueneisen_parameter_fast(V_0, x, gruen_0, q_0) / x, V_0, volume
+    )[0]
+
+
+@jit(nopython=True)
+def _delta_pressure(
+    x, pressure, temperature, V_0, T_0, Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm
+):
+    f = 0.5 * (pow(V_0 / x, 2.0 / 3.0) - 1.0)
+    nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41
+    gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
+
+    return (
+        (1.0 / 3.0)
+        * (pow(1.0 + 2.0 * f, 5.0 / 2.0))
+        * ((b_iikk * f) + (0.5 * b_iikkmm * f * f))
+        + gr * Cv * (temperature - T_0) / x
+        - pressure
+    )  # EQ 21
 
 
 class DKS_S(eos.EquationOfState):
 
     """
     Base class for the finite strain solid equation of state detailed
     in :cite:`deKoker2013` (supplementary materials).
     """
 
     def volume_dependent_q(self, x, params):
         """
         Finite strain approximation for :math:`q`, the isotropic volume strain
         derivative of the grueneisen parameter.
         """
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = -12. * params['grueneisen_0'] + 36. * pow(
-            params['grueneisen_0'], 2.) - 18. * params['q_0'] * params['grueneisen_0']  # EQ 47
-        nu_o_nu0_sq = 1. + a1_ii * f + (1. / 2.) * a2_iikk * f * f  # EQ 41
-        gr = 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
-        if np.abs(params['grueneisen_0']) < 1.e-10:  # avoids divide by zero if grueneisen_0 = 0.
-            q = 1. / 9. * (18. * gr - 6.)
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
+        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * f * f  # EQ 41
+        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
+        if (
+            np.abs(params["grueneisen_0"]) < 1.0e-10
+        ):  # avoids divide by zero if grueneisen_0 = 0.
+            q = 1.0 / 9.0 * (18.0 * gr - 6.0)
         else:
-            q = 1. / 9. * \
-                (18. * gr - 6. - 1. / 2. / nu_o_nu0_sq *
-                 (2. * f + 1.) * (2. * f + 1.) * a2_iikk / gr)
+            q = (
+                1.0
+                / 9.0
+                * (
+                    18.0 * gr
+                    - 6.0
+                    - 1.0
+                    / 2.0
+                    / nu_o_nu0_sq
+                    * (2.0 * f + 1.0)
+                    * (2.0 * f + 1.0)
+                    * a2_iikk
+                    / gr
+                )
+            )
         return q
 
     def _isotropic_eta_s(self, x, params):
         """
         Finite strain approximation for :math:`eta_{s0}`, the isotropic shear
         strain derivative of the grueneisen parameter.
         """
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        a2_s = -2. * params['grueneisen_0'] - 2. * params['eta_s_0']  # EQ 47
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = -12. * params['grueneisen_0'] + 36. * pow(
-            params['grueneisen_0'], 2.) - 18. * params['q_0'] * params['grueneisen_0']  # EQ 47
-        nu_o_nu0_sq = 1. + a1_ii * f + \
-            (1. / 2.) * a2_iikk * pow(f, 2.)  # EQ 41
-        gr = 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        a2_s = -2.0 * params["grueneisen_0"] - 2.0 * params["eta_s_0"]  # EQ 47
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
+        nu_o_nu0_sq = 1.0 + a1_ii * f + (1.0 / 2.0) * a2_iikk * pow(f, 2.0)  # EQ 41
+        gr = 1.0 / 6.0 / nu_o_nu0_sq * (2.0 * f + 1.0) * (a1_ii + a2_iikk * f)
         # EQ 46 NOTE the typo from Stixrude 2005:
-        eta_s = - gr - \
-            (1. / 2. * pow(nu_o_nu0_sq, -1.) * pow((2. * f) + 1., 2.) * a2_s)
+        eta_s = -gr - (
+            1.0 / 2.0 * pow(nu_o_nu0_sq, -1.0) * pow((2.0 * f) + 1.0, 2.0) * a2_s
+        )
 
         return eta_s
 
     # calculate isotropic thermal pressure, see
     # Matas et. al. (2007) eq B4
     def _thermal_pressure(self, T, V, params):
-        gr = self.grueneisen_parameter(0., T, V, params)  # P not important
-        return params['Cv'] * (T - params['T_0']) * gr
+        gr = self.grueneisen_parameter(0.0, T, V, params)  # P not important
+        return params["Cv"] * (T - params["T_0"]) * gr
 
     def volume(self, pressure, temperature, params):
         """
         Returns molar volume. :math:`[m^3]`
         """
-        T_0 = params['T_0']
-        V_0 = params['V_0']
-        Cv = params['Cv']
-
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = -12. * params['grueneisen_0'] + 36. * pow(
-            params['grueneisen_0'], 2.) - 18. * params['q_0'] * params['grueneisen_0']  # EQ 47
+        T_0 = params["T_0"]
+        V_0 = params["V_0"]
+        Cv = params["Cv"]
+
+        a1_ii = 6.0 * params["grueneisen_0"]  # EQ 47
+        a2_iikk = (
+            -12.0 * params["grueneisen_0"]
+            + 36.0 * pow(params["grueneisen_0"], 2.0)
+            - 18.0 * params["q_0"] * params["grueneisen_0"]
+        )  # EQ 47
 
-        b_iikk = 9. * params['K_0']  # EQ 28
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29z
+        b_iikk = 9.0 * params["K_0"]  # EQ 28
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29z
 
         # we need to have a sign change in [a,b] to find a zero. Let us start with a
         # conservative guess:
-        args = (pressure, temperature, V_0, T_0,
-                Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm)
+        args = (pressure, temperature, V_0, T_0, Cv, a1_ii, a2_iikk, b_iikk, b_iikkmm)
         try:
-            sol = bracket(_delta_pressure, params[
-                          'V_0'], 1.e-2 * params['V_0'], args)
+            sol = bracket(_delta_pressure, params["V_0"], 1.0e-2 * params["V_0"], args)
         except ValueError:
             raise Exception(
-                'Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?')
+                "Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?"
+            )
         return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)
 
     def pressure(self, temperature, volume, params):
         """
         Returns the pressure of the mineral at a given temperature and volume [Pa]
         """
         gr = self.grueneisen_parameter(
-            0.0, temperature, volume, params)  # does not depend on pressure
+            0.0, temperature, volume, params
+        )  # does not depend on pressure
 
-        b_iikk = 9. * params['K_0']  # EQ 28
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29
-        f = 0.5 * (pow(params['V_0'] / volume, 2. / 3.) - 1.)  # EQ 24
-        P = (1. / 3.) * (pow(1. + 2. * f, 5. / 2.)) \
-            * ((b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.)))\
-            + gr * params['Cv'] * (temperature - params['T_0']) / volume  # EQ 21
+        b_iikk = 9.0 * params["K_0"]  # EQ 28
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29
+        f = 0.5 * (pow(params["V_0"] / volume, 2.0 / 3.0) - 1.0)  # EQ 24
+        P = (1.0 / 3.0) * (pow(1.0 + 2.0 * f, 5.0 / 2.0)) * (
+            (b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.0))
+        ) + gr * params["Cv"] * (
+            temperature - params["T_0"]
+        ) / volume  # EQ 21
 
         return P
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter :math:`[unitless]`
         """
-        return _grueneisen_parameter_fast(params['V_0'], volume, params['grueneisen_0'], params['q_0'])
+        return _grueneisen_parameter_fast(
+            params["V_0"], volume, params["grueneisen_0"], params["q_0"]
+        )
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`[Pa]`
         """
 
-        E_th_diff = params['Cv'] * (temperature - params['T_0'])
+        E_th_diff = params["Cv"] * (temperature - params["T_0"])
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
-        q = self.volume_dependent_q(params['V_0'] / volume, params)
-        K = bm.bulk_modulus(volume, params) \
-            + (gr + 1. - q) * (gr / volume) * E_th_diff \
-            - (pow(gr, 2.) / volume) * E_th_diff
+        q = self.volume_dependent_q(params["V_0"] / volume, params)
+        K = (
+            bm.bulk_modulus(volume, params)
+            + (gr + 1.0 - q) * (gr / volume) * E_th_diff
+            - (pow(gr, 2.0) / volume) * E_th_diff
+        )
 
         return K
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus. :math:`[Pa]`
         """
-        K_T = self.isothermal_bulk_modulus(
-            pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
-        K_S = K_T * (1. + gr * alpha * temperature)
+        K_S = K_T * (1.0 + gr * alpha * temperature)
         return K_S
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus. :math:`[Pa]`
         """
-        T_0 = params['T_0']
-        eta_s = self._isotropic_eta_s(params['V_0'] / volume, params)
+        T_0 = params["T_0"]
+        eta_s = self._isotropic_eta_s(params["V_0"] / volume, params)
 
-        E_th_diff = params['Cv'] * (temperature - params['T_0'])
-        return bm.shear_modulus_third_order(volume, params) - eta_s * (E_th_diff) / volume
+        E_th_diff = params["Cv"] * (temperature - params["T_0"])
+        return (
+            bm.shear_modulus_third_order(volume, params) - eta_s * (E_th_diff) / volume
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume. :math:`[J/K/mol]`
         """
-        return params['Cv']
+        return params["Cv"]
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure. :math:`[J/K/mol]`
         """
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        C_p = C_v * (1. + gr * alpha * temperature)
+        C_p = C_v * (1.0 + gr * alpha * temperature)
         return C_p
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity. :math:`[1/K]`
         """
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
@@ -210,102 +251,109 @@
         alpha = gr * C_v / K / volume
         return alpha
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]
         """
-        G = self.helmholtz_free_energy(
-            pressure, temperature, volume, params) + pressure * volume
+        G = (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
         return G
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy at the pressure and temperature of the mineral [J/mol]
         """
-        return self.helmholtz_free_energy(pressure, temperature, volume, params) + \
-            temperature * \
-            self.entropy(pressure, temperature, volume, params)
+        return self.helmholtz_free_energy(
+            pressure, temperature, volume, params
+        ) + temperature * self.entropy(pressure, temperature, volume, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the entropy at the pressure and temperature of the mineral [J/K/mol]
         """
-        S_0 = params['S_0']
-        gruen_0 = params['grueneisen_0']
-        q_0 = params['q_0']
-        S_th = params['Cv'] * (np.log(temperature/params['T_0']) +
-                               _intgroverVdV(params['V_0'], volume, gruen_0, q_0))
+        S_0 = params["S_0"]
+        gruen_0 = params["grueneisen_0"]
+        q_0 = params["q_0"]
+        S_th = params["Cv"] * (
+            np.log(temperature / params["T_0"])
+            + _intgroverVdV(params["V_0"], volume, gruen_0, q_0)
+        )
 
         return S_0 + S_th
 
     def enthalpy(self, pressure, temperature, volume, params):
         """
         Returns the enthalpy at the pressure and temperature of the mineral [J/mol]
         """
 
-        return self.helmholtz_free_energy(pressure, temperature, volume, params) + \
-            temperature * self.entropy(pressure, temperature, volume, params) + \
-            pressure * volume
+        return (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + temperature * self.entropy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
 
     def helmholtz_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]
         """
-        V_0 = params['V_0']
-        gruen_0 = params['grueneisen_0']
-        q_0 = params['q_0']
+        V_0 = params["V_0"]
+        gruen_0 = params["grueneisen_0"]
+        q_0 = params["q_0"]
         x = V_0 / volume
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        b_iikk = 9. * params['K_0']  # EQ 28
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        b_iikk = 9.0 * params["K_0"]  # EQ 28
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29
 
-        T_0 = params['T_0']
+        T_0 = params["T_0"]
         T = temperature
-        S_0 = params['S_0']
-        Cv = params['Cv']
-        F_0 = params['E_0'] - T_0 * S_0
-        F_cmp = 0.5 * b_iikk * f * f * V_0 + (1. / 6.) * V_0 * b_iikkmm * f * f * f
-        F_th = - S_0 * (T - T_0) - \
-               Cv * (T * np.log(T/T_0) - (T - T_0)) - \
-               Cv * (T - T_0) * _intgroverVdV(V_0, volume, gruen_0, q_0)
+        S_0 = params["S_0"]
+        Cv = params["Cv"]
+        F_0 = params["E_0"] - T_0 * S_0
+        F_cmp = 0.5 * b_iikk * f * f * V_0 + (1.0 / 6.0) * V_0 * b_iikkmm * f * f * f
+        F_th = (
+            -S_0 * (T - T_0)
+            - Cv * (T * np.log(T / T_0) - (T - T_0))
+            - Cv * (T - T_0) * _intgroverVdV(V_0, volume, gruen_0, q_0)
+        )
 
         return F_0 + F_cmp + F_th
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
-        if 'T_0' not in params:
-            params['T_0'] = 300.
+        if "T_0" not in params:
+            params["T_0"] = 300.0
 
         # If eta_s_0 is not included this is presumably deliberate,
         # as we can model density and bulk modulus just fine without it,
         # so just add it to the dictionary as nan
         # The same goes for the standard state Helmholtz free energy
-        if 'eta_s_0' not in params:
-            params['eta_s_0'] = float('nan')
-        if 'E_0' not in params:
-            params['E_0'] = float('nan')
+        if "eta_s_0" not in params:
+            params["eta_s_0"] = float("nan")
+        if "E_0" not in params:
+            params["E_0"] = float("nan")
 
         # First, let's check the EoS parameters for Tref
-        bm.BirchMurnaghanBase.validate_parameters(
-            bm.BirchMurnaghanBase(), params)
+        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)
 
         # Now check all the required keys for the
         # thermal part of the EoS are in the dictionary
-        expected_keys = ['Cv', 'grueneisen_0', 'q_0', 'eta_s_0']
+        expected_keys = ["Cv", "grueneisen_0", "q_0", "eta_s_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn('Unusual value for T_0', stacklevel=2)
-        if params['Cv'] < 0. or params['Cv'] > 1000.:
-            warnings.warn('Unusual value for Cv', stacklevel=2)
-        if params['grueneisen_0'] < -0.005 or params['grueneisen_0'] > 10.:
-            warnings.warn('Unusual value for grueneisen_0', stacklevel=2)
-        if params['q_0'] < -10. or params['q_0'] > 10.:
-            warnings.warn('Unusual value for q_0', stacklevel=2)
-        if params['eta_s_0'] < -10. or params['eta_s_0'] > 10.:
-            warnings.warn('Unusual value for eta_s_0', stacklevel=2)
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["Cv"] < 0.0 or params["Cv"] > 1000.0:
+            warnings.warn("Unusual value for Cv", stacklevel=2)
+        if params["grueneisen_0"] < -0.005 or params["grueneisen_0"] > 10.0:
+            warnings.warn("Unusual value for grueneisen_0", stacklevel=2)
+        if params["q_0"] < -10.0 or params["q_0"] > 10.0:
+            warnings.warn("Unusual value for q_0", stacklevel=2)
+        if params["eta_s_0"] < -10.0 or params["eta_s_0"] > 10.0:
+            warnings.warn("Unusual value for eta_s_0", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/einstein.py` & `burnman-1.2.0/burnman/eos/einstein.py`

 * *Files 27% similar despite different names*

```diff
@@ -3,39 +3,112 @@
 # GPL v2 or later.
 
 from __future__ import absolute_import
 
 import numpy as np
 from .. import constants
 
+# Try to import the jit from numba.  If it is
+# not available, just go with the standard
+# python interpreter
+try:
+    import os
+
+    if "NUMBA_DISABLE_JIT" in os.environ and int(os.environ["NUMBA_DISABLE_JIT"]) == 1:
+        raise ImportError("NOOOO!")
+    from numba import jit
+except ImportError:
+
+    def jit(fn):
+        return fn
+
+
 """
 Functions for the Einstein model of a solid.
 """
 
 eps = np.finfo(float).eps
 
 
+@jit(nopython=True)
 def thermal_energy(T, einstein_T, n):
     """
     calculate the thermal energy of a substance.  Takes the temperature,
     the Einstein temperature, and n, the number of atoms per molecule.
     Returns thermal energy in J/mol
     """
     if T <= eps:
-        # zero point energy
-        return 3. * n * constants.gas_constant * einstein_T * 0.5
+        return 0.0
     x = einstein_T / T
-    E_th = 3. * n * constants.gas_constant * einstein_T * \
-        (0.5 + 1. / (np.exp(x) - 1.0))  # include the zero point energy
+    E_th = 3.0 * n * constants.gas_constant * einstein_T * (1.0 / (np.exp(x) - 1.0))
     return E_th
 
 
+@jit(nopython=True)
 def molar_heat_capacity_v(T, einstein_T, n):
     """
     Heat capacity at constant volume.  In J/K/mol
     """
     if T <= eps:
-        return 0.
+        return 0.0
     x = einstein_T / T
-    C_v = 3.0 * n * constants.gas_constant * \
-        (x * x * np.exp(x) / np.power(np.exp(x) - 1.0, 2.0))
+    C_v = (
+        3.0
+        * n
+        * constants.gas_constant
+        * (x * x * np.exp(x) / np.power(np.exp(x) - 1.0, 2.0))
+    )
     return C_v
+
+
+@jit(nopython=True)
+def helmholtz_free_energy(T, einstein_T, n):
+    """
+    Helmholtz free energy of lattice vibrations in the Einstein model [J].
+    It is important to note that this does NOT include the zero
+    point energy for the lattice.  As long as you are
+    calculating relative differences in F, this should cancel anyway.
+    """
+    E = thermal_energy(T, einstein_T, n)
+    S = entropy(T, einstein_T, n)
+    return E - T * S
+
+
+@jit(nopython=True)
+def entropy(T, einstein_T, n):
+    """
+    Entropy due to lattice vibrations in the Einstein model [J/K]
+    """
+    if T <= eps:
+        return 0.0
+    x = einstein_T / T
+    S = (
+        3.0
+        * n
+        * constants.gas_constant
+        * (-x * np.exp(-x) / (np.exp(-x) - 1.0) - np.log(1.0 - np.exp(-x)))
+    )
+    return S
+
+
+@jit(nopython=True)
+def dmolar_heat_capacity_v_dT(T, einstein_T, n):
+    """
+    First temperature derivative of the heat capacity at constant volume
+    according to the Einstein model [J/K^2/mol].
+    """
+    if T <= eps:
+        return 0.0
+
+    x = einstein_T / T
+    dCvdT = (
+        3.0
+        * n
+        * constants.gas_constant
+        * x
+        * x
+        * np.exp(x)
+        * ((x - 2.0) * np.exp(x) + (x + 2.0))
+        / (T * np.power(np.exp(x) - 1.0, 3.0))
+    )
+
+    return dCvdT
```

### Comparing `burnman-1.1.0/burnman/eos/helper.py` & `burnman-1.2.0/burnman/eos/helper.py`

 * *Files 1% similar despite different names*

```diff
@@ -28,14 +28,15 @@
     from a mechanical Solution.
     Solution needs a method to call Mineral.set_state(),
     but a CombinedMineral should never have a method that
     is used for solutions."""
 
     def validate_parameters(self, params):
         pass
+
     pass
 
 
 def create(method):
     """
     Creates an instance of an EquationOfState from a string,
     a class EquationOfState, or an instance of EquationOfState.
@@ -86,9 +87,8 @@
         else:
             raise Exception("unsupported material method " + method)
     elif isinstance(method, EquationOfState):
         return method
     elif inspect.isclass(method) and issubclass(method, EquationOfState):
         return method()
     else:
-        raise Exception(
-            "unsupported material method " + method.__class__.__name__)
+        raise Exception("unsupported material method " + method.__class__.__name__)
```

### Comparing `burnman-1.1.0/burnman/eos/hp.py` & `burnman-1.2.0/burnman/eos/hp.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from __future__ import absolute_import
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for
 # the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2021 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 
 import numpy as np
@@ -39,25 +40,23 @@
 
     def pressure(self, temperature, volume, params):
         """
         Returns pressure [Pa] as a function of temperature [K] and volume[m^3]
         EQ B7
         """
         Pth = self.__relative_thermal_pressure(temperature, params)
-        return mt.modified_tait(params['V_0'] / volume, params) + Pth
+        return mt.modified_tait(params["V_0"] / volume, params) + Pth
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter [unitless] as a function of pressure,
         temperature, and volume.
         """
-        alpha = self.thermal_expansivity(
-            pressure, temperature, volume, params)
-        K_T = self.isothermal_bulk_modulus(
-            pressure, temperature, volume, params)
+        alpha = self.thermal_expansivity(pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)
         return alpha * K_T * volume / C_V
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].  EQ 13+2
@@ -68,117 +67,152 @@
     # calculate the shear modulus as a function of P, V, and T
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Not implemented.
         Returns 0.
         Could potentially apply a fixed Poissons ratio as a rough estimate.
         """
-        return 0.
+        return 0.0
 
     # Cv, heat capacity at constant volume
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume at the pressure, temperature,
         and volume [J/K/mol].
         """
         C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)
         V = self.volume(pressure, temperature, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        K_T = self.isothermal_bulk_modulus(
-            pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         return C_p - V * temperature * alpha * alpha * K_T
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity at the pressure, temperature,
         and volume [1/K]. This function replaces -Pth in EQ 13+1
         with P-Pth for non-ambient temperature
         """
         a, b, c = mt.tait_constants(params)
         Pth = self.__relative_thermal_pressure(temperature, params)
-        psubpth = pressure - params['P_0'] - Pth
+        psubpth = pressure - params["P_0"] - Pth
 
         C_V0 = einstein.molar_heat_capacity_v(
-            params['T_0'], params['T_einstein'], params['n'])
+            params["T_0"], params["T_einstein"], params["n"]
+        )
         C_V = einstein.molar_heat_capacity_v(
-            temperature, params['T_einstein'], params['n'])
-        alpha = params['a_0'] * (C_V / C_V0) * 1. / (
-            (1. + b * psubpth) * (a + (1. - a) * np.power((1 + b * psubpth), c)))
+            temperature, params["T_einstein"], params["n"]
+        )
+        alpha = (
+            params["a_0"]
+            * (C_V / C_V0)
+            * 1.0
+            / ((1.0 + b * psubpth) * (a + (1.0 - a) * np.power((1 + b * psubpth), c)))
+        )
         return alpha
 
     def molar_heat_capacity_p0(self, temperature, params):
         """
         Returns heat capacity at ambient pressure as a function of temperature
         [J/K/mol]. Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP2011`.
         """
-        Cp = params['Cp'][0] + params['Cp'][1] * temperature + params['Cp'][2] * \
-            np.power(temperature, -2.) + params[
-                'Cp'][3] * np.power(temperature, -0.5)
+        Cp = (
+            params["Cp"][0]
+            + params["Cp"][1] * temperature
+            + params["Cp"][2] * np.power(temperature, -2.0)
+            + params["Cp"][3] * np.power(temperature, -0.5)
+        )
         return Cp
 
     def molar_heat_capacity_p_einstein(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure at the pressure,
         temperature, and volume, using the C_v and Einstein model [J/K/mol]
         WARNING: Only for comparison with internally self-consistent C_p
         """
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        C_p = C_v * (1. + gr * alpha * temperature)
+        C_p = C_v * (1.0 + gr * alpha * temperature)
         return C_p
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].
         """
-        K_T = self.isothermal_bulk_modulus(
-            pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
         K_S = K_T * C_p / C_v
         return K_S
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the gibbs free energy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         # Calculate temperature and pressure integrals
         a, b, c = mt.tait_constants(params)
         Pth = self.__relative_thermal_pressure(temperature, params)
 
-        psubpth = pressure - params['P_0'] - Pth
+        psubpth = pressure - params["P_0"] - Pth
 
         # EQ 13
-        if pressure != params['P_0']:
-            intVdP = (pressure - params['P_0']) * params['V_0'] * (
-                1. - a + (a * (np.power((1. - b * Pth), 1. - c) - np.power((1. + b * (psubpth)), 1. - c)) / (b * (c - 1.) * (pressure - params['P_0']))))
+        if pressure != params["P_0"]:
+            intVdP = (
+                (pressure - params["P_0"])
+                * params["V_0"]
+                * (
+                    1.0
+                    - a
+                    + (
+                        a
+                        * (
+                            np.power((1.0 - b * Pth), 1.0 - c)
+                            - np.power((1.0 + b * (psubpth)), 1.0 - c)
+                        )
+                        / (b * (c - 1.0) * (pressure - params["P_0"]))
+                    )
+                )
+            )
         else:
-            intVdP = 0.
-        return params['H_0'] + self.__intCpdT(temperature, params) - temperature * (params['S_0'] + self.__intCpoverTdT(temperature, params)) + intVdP
+            intVdP = 0.0
+        return (
+            params["H_0"]
+            + self.__intCpdT(temperature, params)
+            - temperature * (params["S_0"] + self.__intCpoverTdT(temperature, params))
+            + intVdP
+        )
 
     def helmholtz_free_energy(self, pressure, temperature, volume, params):
-        return self.gibbs_free_energy(pressure, temperature, volume, params) - pressure * self.volume(pressure, temperature, params)
+        return self.gibbs_free_energy(
+            pressure, temperature, volume, params
+        ) - pressure * self.volume(pressure, temperature, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the entropy [J/K/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         a, b, c = mt.tait_constants(params)
         Pth = self.__relative_thermal_pressure(temperature, params)
 
-        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(temperature, params['T_einstein'], params[
-                                                  'n']) / einstein.molar_heat_capacity_v(params['T_0'], params['T_einstein'], params['n'])
-
-        dintVdpdT = (params['V_0'] * params['a_0'] * params['K_0'] * a * ksi_over_ksi_0) * (
-            np.power((1. + b * (pressure - params['P_0'] - Pth)), 0. - c) - np.power((1. - b * Pth), 0. - c))
-        return params['S_0'] + self.__intCpoverTdT(temperature, params) + dintVdpdT
+        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(
+            temperature, params["T_einstein"], params["n"]
+        ) / einstein.molar_heat_capacity_v(
+            params["T_0"], params["T_einstein"], params["n"]
+        )
+
+        dintVdpdT = (
+            params["V_0"] * params["a_0"] * params["K_0"] * a * ksi_over_ksi_0
+        ) * (
+            np.power((1.0 + b * (pressure - params["P_0"] - Pth)), 0.0 - c)
+            - np.power((1.0 - b * Pth), 0.0 - c)
+        )
+        return params["S_0"] + self.__intCpoverTdT(temperature, params) + dintVdpdT
 
     def enthalpy(self, pressure, temperature, volume, params):
         """
         Returns the enthalpy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)
@@ -188,34 +222,48 @@
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns the heat capacity [J/K/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         a, b, c = mt.tait_constants(params)
         T = temperature
-        T_e = params['T_einstein']
-        n = params['n']
+        T_e = params["T_einstein"]
+        n = params["n"]
         Pth = self.__relative_thermal_pressure(T, params)
 
-        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(T, T_e, n) \
-                         / einstein.molar_heat_capacity_v(params['T_0'], T_e, n)
-
-        dintVdpdT = (params['V_0'] * params['a_0'] * params['K_0'] * a * ksi_over_ksi_0) * (
-            np.power((1. + b * (pressure - params['P_0'] - Pth)), 0. - c) - np.power((1. - b * Pth), 0. - c))
+        ksi_over_ksi_0 = einstein.molar_heat_capacity_v(
+            T, T_e, n
+        ) / einstein.molar_heat_capacity_v(params["T_0"], T_e, n)
+
+        dintVdpdT = (
+            params["V_0"] * params["a_0"] * params["K_0"] * a * ksi_over_ksi_0
+        ) * (
+            np.power((1.0 + b * (pressure - params["P_0"] - Pth)), 0.0 - c)
+            - np.power((1.0 - b * Pth), 0.0 - c)
+        )
+
+        dSdT0 = (
+            params["V_0"]
+            * params["K_0"]
+            * np.power((ksi_over_ksi_0 * params["a_0"]), 2.0)
+            * (
+                np.power((1.0 + b * (pressure - params["P_0"] - Pth)), -1.0 - c)
+                - np.power((1.0 + b * (-Pth)), -1.0 - c)
+            )
+        )
+
+        x = T_e / T
+        dCv_einstdT = -(
+            einstein.molar_heat_capacity_v(T, T_e, n)
+            * (1 - 2.0 / x + 2.0 / (np.exp(x) - 1.0))
+            * x
+            / T
+        )
 
-        dSdT0 = params['V_0'] * params['K_0'] * np.power((ksi_over_ksi_0 * params['a_0']), 2.0) * \
-                (np.power((1. + b * (pressure - params['P_0'] - Pth)), -1. - c)
-                 - np.power((1. + b * (-Pth)), -1. - c))
-
-        x = T_e/T
-        dCv_einstdT = -(einstein.molar_heat_capacity_v(T, T_e, n)
-                        * (1 - 2./x + 2./(np.exp(x) - 1.)) * x/T)
-
-        dSdT1 = -dintVdpdT * dCv_einstdT \
-                / einstein.molar_heat_capacity_v(T, T_e, n)
+        dSdT1 = -dintVdpdT * dCv_einstdT / einstein.molar_heat_capacity_v(T, T_e, n)
 
         dSdT = dSdT0 + dSdT1
         return self.molar_heat_capacity_p0(temperature, params) + temperature * dSdT
 
     def __thermal_pressure(self, T, params):
         """
         Returns thermal pressure [Pa] as a function of T [K]
@@ -228,101 +276,126 @@
         # constant over a wide range of compressions.
 
         # Note that the xi function in HP2011 is just the Einstein heat capacity
         # divided by 3nR. This function is *not* used to calculate the
         # heat capacity - Holland and Powell (2011) prefer the additional
         # freedom provided by their polynomial expression.
 
-        E_th = einstein.thermal_energy(T, params['T_einstein'], params['n'])
+        E_th = einstein.thermal_energy(T, params["T_einstein"], params["n"])
         C_V0 = einstein.molar_heat_capacity_v(
-            params['T_0'], params['T_einstein'], params['n'])
-        P_th = params['a_0'] * params['K_0'] / C_V0 * E_th
+            params["T_0"], params["T_einstein"], params["n"]
+        )
+        P_th = params["a_0"] * params["K_0"] / C_V0 * E_th
         return P_th
 
     def __relative_thermal_pressure(self, T, params):
         """
         Returns relative thermal pressure [Pa] as a function of T-params['T_0'] [K]
         EQ 12 - 1 of :cite:`HP2011`.
         """
-        return self.__thermal_pressure(T, params) - \
-            self.__thermal_pressure(params['T_0'], params)
+        return self.__thermal_pressure(T, params) - self.__thermal_pressure(
+            params["T_0"], params
+        )
 
     def __intCpdT(self, temperature, params):
         """
         Returns the thermal addition to the standard state enthalpy [J/mol]
         at ambient pressure [Pa]
         """
-        return (params['Cp'][0] * temperature + 0.5 * params['Cp'][1] * np.power(temperature, 2.) - params['Cp'][2] / temperature + 2. * params['Cp'][3] * np.sqrt(temperature)) - (params['Cp'][0] * params['T_0'] + 0.5 * params['Cp'][1] * params['T_0'] * params['T_0'] - params['Cp'][2] / params['T_0'] + 2.0 * params['Cp'][3] * np.sqrt(params['T_0']))
+        return (
+            params["Cp"][0] * temperature
+            + 0.5 * params["Cp"][1] * np.power(temperature, 2.0)
+            - params["Cp"][2] / temperature
+            + 2.0 * params["Cp"][3] * np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * params["T_0"]
+            + 0.5 * params["Cp"][1] * params["T_0"] * params["T_0"]
+            - params["Cp"][2] / params["T_0"]
+            + 2.0 * params["Cp"][3] * np.sqrt(params["T_0"])
+        )
 
     def __intCpoverTdT(self, temperature, params):
         """
         Returns the thermal addition to the standard state entropy [J/K/mol]
         at ambient pressure [Pa]
         """
-        return (params['Cp'][0] * np.log(temperature) + params['Cp'][1] * temperature - 0.5 * params['Cp'][2] / np.power(temperature, 2.) - 2.0 * params['Cp'][3] / np.sqrt(temperature)) - (params['Cp'][0] * np.log(params['T_0']) + params['Cp'][1] * params['T_0'] - 0.5 * params['Cp'][2] / (params['T_0'] * params['T_0']) - 2.0 * params['Cp'][3] / np.sqrt(params['T_0']))
+        return (
+            params["Cp"][0] * np.log(temperature)
+            + params["Cp"][1] * temperature
+            - 0.5 * params["Cp"][2] / np.power(temperature, 2.0)
+            - 2.0 * params["Cp"][3] / np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * np.log(params["T_0"])
+            + params["Cp"][1] * params["T_0"]
+            - 0.5 * params["Cp"][2] / (params["T_0"] * params["T_0"])
+            - 2.0 * params["Cp"][3] / np.sqrt(params["T_0"])
+        )
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
-        if 'T_0' not in params:
-            params['T_0'] = 298.15
+        if "T_0" not in params:
+            params["T_0"] = 298.15
 
         # If standard state enthalpy and entropy are not included
         # this is presumably deliberate, as we can model density
         # and bulk modulus just fine without them.
         # Just add them to the dictionary as nans.
-        if 'H_0' not in params:
-            params['H_0'] = float('nan')
-        if 'S_0' not in params:
-            params['S_0'] = float('nan')
+        if "H_0" not in params:
+            params["H_0"] = float("nan")
+        if "S_0" not in params:
+            params["S_0"] = float("nan")
 
         # First, let's check the EoS parameters for Tref
         mt.MT.validate_parameters(mt.MT(), params)
 
         # Now check all the required keys for the
         # thermal part of the EoS are in the dictionary
-        expected_keys = ['H_0', 'S_0', 'V_0', 'Cp', 'a_0', 'n', 'molar_mass']
+        expected_keys = ["H_0", "S_0", "V_0", "Cp", "a_0", "n", "molar_mass"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # The following line estimates the Einstein temperature
         # according to the empirical equation of
         # Holland and Powell, 2011; base of p.346, para.1
-        if 'T_einstein' not in params:
-            params['T_einstein'] = 10636. / \
-                (params['S_0'] / params['n'] + 6.44)
+        if "T_einstein" not in params:
+            params["T_einstein"] = 10636.0 / (params["S_0"] / params["n"] + 6.44)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn('Unusual value for T_0', stacklevel=2)
-        if params['G_0'] is not float('nan') and (params['G_0'] < 0. or params['G_0'] > 1.e13):
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if params['Gprime_0'] is not float('nan') and (params['Gprime_0'] < -5. or params['Gprime_0'] > 10.):
-            warnings.warn('Unusual value for Gprime_0', stacklevel=2)
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["G_0"] is not float("nan") and (
+            params["G_0"] < 0.0 or params["G_0"] > 1.0e13
+        ):
+            warnings.warn("Unusual value for G_0", stacklevel=2)
+        if params["Gprime_0"] is not float("nan") and (
+            params["Gprime_0"] < -5.0 or params["Gprime_0"] > 10.0
+        ):
+            warnings.warn("Unusual value for Gprime_0", stacklevel=2)
 
         # no test for H_0
-        if params['S_0'] is not float('nan') and params['S_0'] < 0.:
-            warnings.warn('Unusual value for S_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-2:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-
-        if self.molar_heat_capacity_p0(params['T_0'], params) < 0.:
-            warnings.warn('Negative heat capacity at T_0', stacklevel=2)
-        if self.molar_heat_capacity_p0(2000., params) < 0.:
-            warnings.warn('Negative heat capacity at 2000K', stacklevel=2)
-
-        if params['a_0'] < 0. or params['a_0'] > 1.e-3:
-            warnings.warn('Unusual value for a_0', stacklevel=2)
-
-        if params['n'] < 1. or params['n'] > 1000.:
-            warnings.warn('Unusual value for n', stacklevel=2)
-        if params['molar_mass'] < 0.001 or params['molar_mass'] > 10.:
-            warnings.warn('Unusual value for molar_mass', stacklevel=2)
+        if params["S_0"] is not float("nan") and params["S_0"] < 0.0:
+            warnings.warn("Unusual value for S_0", stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-2:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+
+        if self.molar_heat_capacity_p0(params["T_0"], params) < 0.0:
+            warnings.warn("Negative heat capacity at T_0", stacklevel=2)
+        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:
+            warnings.warn("Negative heat capacity at 2000K", stacklevel=2)
+
+        if params["a_0"] < 0.0 or params["a_0"] > 1.0e-3:
+            warnings.warn("Unusual value for a_0", stacklevel=2)
+
+        if params["n"] < 1.0 or params["n"] > 1000.0:
+            warnings.warn("Unusual value for n", stacklevel=2)
+        if params["molar_mass"] < 0.001 or params["molar_mass"] > 10.0:
+            warnings.warn("Unusual value for molar_mass", stacklevel=2)
 
 
 class HP_TMTL(eos.EquationOfState):
 
     """
     Base class for the thermal equation of state
     described in :cite:`HP1998`, but with the Modified Tait as the static part,
@@ -333,150 +406,151 @@
     (or by initialising the class with the param
     equation_of_state = 'hp_tmtL'
     """
 
     def _V_T_1bar(self, temperature, params):
         # Constant thermal expansivity at standard state pressure
         # (p.348 of HP2011)
-        return params['V_0']*np.exp(params['a_0']*(temperature - params['T_0']))
+        return params["V_0"] * np.exp(params["a_0"] * (temperature - params["T_0"]))
 
     def _K_T_1bar(self, temperature, params):
         # Linear bulk modulus dependence as in HP1998 (p.348 of HP2011)
-        return params['K_0'] + params['dKdT_0']*(temperature - params['T_0'])
+        return params["K_0"] + params["dKdT_0"] * (temperature - params["T_0"])
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume [m^3] as a function of pressure [Pa] and temperature [K]
         """
-        self.static_params['V_0'] = self._V_T_1bar(temperature, params)
-        self.static_params['K_0'] = self._K_T_1bar(temperature, params)
+        self.static_params["V_0"] = self._V_T_1bar(temperature, params)
+        self.static_params["K_0"] = self._K_T_1bar(temperature, params)
         return mt.volume(pressure, self.static_params)
 
     def pressure(self, temperature, volume, params):
         """
         Returns pressure [Pa] as a function of temperature [K] and volume[m^3]
         """
-        self.static_params['V_0'] = self._V_T_1bar(temperature, params)
-        self.static_params['K_0'] = self._K_T_1bar(temperature, params)
+        self.static_params["V_0"] = self._V_T_1bar(temperature, params)
+        self.static_params["K_0"] = self._K_T_1bar(temperature, params)
         return mt.pressure(volume, self.static_params)
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter [unitless] as a function of pressure,
         temperature, and volume.
         """
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        K_T = self.isothermal_bulk_modulus(pressure, temperature,
-                                           volume, params)
-        C_V = self.molar_heat_capacity_v(pressure, temperature,
-                                         volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
+        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)
         return alpha * K_T * volume / C_V
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].
         """
-        self.static_params['V_0'] = self._V_T_1bar(temperature, params)
-        self.static_params['K_0'] = self._K_T_1bar(temperature, params)
+        self.static_params["V_0"] = self._V_T_1bar(temperature, params)
+        self.static_params["K_0"] = self._K_T_1bar(temperature, params)
         return mt.bulk_modulus(pressure, self.static_params)
 
     # calculate the shear modulus as a function of P, V, and T
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Not implemented.
         Returns 0.
         Could potentially apply a fixed Poissons ratio as a rough estimate.
         """
-        return 0.
+        return 0.0
 
     # Cv, heat capacity at constant volume
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume at the pressure, temperature,
         and volume [J/K/mol].
         """
         C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)
         V = self.volume(pressure, temperature, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        K_T = self.isothermal_bulk_modulus(pressure, temperature,
-                                           volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         return C_p - V * temperature * alpha * alpha * K_T
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity at the pressure, temperature,
         and volume [1/K]
         """
         # The derivation of the high pressure thermal expansivity is tedious,
         # so here we take a numerical derivative.
         # TODO Derive and use the analytical derivative.
         dT = 0.1
-        self.static_params['V_0'] = self._V_T_1bar(temperature+dT/2., params)
-        self.static_params['K_0'] = self._K_T_1bar(temperature+dT/2., params)
+        self.static_params["V_0"] = self._V_T_1bar(temperature + dT / 2.0, params)
+        self.static_params["K_0"] = self._K_T_1bar(temperature + dT / 2.0, params)
         volume1 = mt.volume(pressure, self.static_params)
-        self.static_params['V_0'] = self._V_T_1bar(temperature-dT/2., params)
-        self.static_params['K_0'] = self._K_T_1bar(temperature-dT/2., params)
+        self.static_params["V_0"] = self._V_T_1bar(temperature - dT / 2.0, params)
+        self.static_params["K_0"] = self._K_T_1bar(temperature - dT / 2.0, params)
         volume0 = mt.volume(pressure, self.static_params)
 
-        return 2.*(volume1 - volume0)/(volume1 + volume0)/dT
+        return 2.0 * (volume1 - volume0) / (volume1 + volume0) / dT
 
     def molar_heat_capacity_p0(self, temperature, params):
         """
         Returns heat capacity at ambient pressure as a function of temperature
         [J/K/mol]
         Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP1998`.
         """
-        Cp = (params['Cp'][0]
-              + params['Cp'][1] * temperature
-              + params['Cp'][2] * np.power(temperature, -2.)
-              + params['Cp'][3] * np.power(temperature, -0.5))
+        Cp = (
+            params["Cp"][0]
+            + params["Cp"][1] * temperature
+            + params["Cp"][2] * np.power(temperature, -2.0)
+            + params["Cp"][3] * np.power(temperature, -0.5)
+        )
         return Cp
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].
         """
-        K_T = self.isothermal_bulk_modulus(pressure, temperature,
-                                           volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
         K_S = K_T * C_p / C_v
         return K_S
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the gibbs free energy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
-        self.static_params['V_0'] = self._V_T_1bar(temperature, params)
-        self.static_params['K_0'] = self._K_T_1bar(temperature, params)
-        return (params['H_0'] + self.__intCpdT(temperature, params)
-                - temperature * (params['S_0']
-                                 + self.__intCpoverTdT(temperature, params))
-                + mt.intVdP(pressure, self.static_params))
+        self.static_params["V_0"] = self._V_T_1bar(temperature, params)
+        self.static_params["K_0"] = self._K_T_1bar(temperature, params)
+        return (
+            params["H_0"]
+            + self.__intCpdT(temperature, params)
+            - temperature * (params["S_0"] + self.__intCpoverTdT(temperature, params))
+            + mt.intVdP(pressure, self.static_params)
+        )
 
     def helmholtz_free_energy(self, pressure, temperature, volume, params):
-        return (self.gibbs_free_energy(pressure, temperature, volume, params)
-                - pressure * self.volume(pressure, temperature, params))
+        return self.gibbs_free_energy(
+            pressure, temperature, volume, params
+        ) - pressure * self.volume(pressure, temperature, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the entropy [J/K/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         # The derivation of the entropy is tedious,
         # so here we take a numerical derivative.
         # TODO Derive and use the analytical derivative.
         dT = 0.1
-        G1 = self.gibbs_free_energy(pressure, temperature+dT/2., volume, params)
-        G0 = self.gibbs_free_energy(pressure, temperature-dT/2., volume, params)
+        G1 = self.gibbs_free_energy(pressure, temperature + dT / 2.0, volume, params)
+        G0 = self.gibbs_free_energy(pressure, temperature - dT / 2.0, volume, params)
 
-        return (G0 - G1)/dT
+        return (G0 - G1) / dT
 
     def enthalpy(self, pressure, temperature, volume, params):
         """
         Returns the enthalpy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)
@@ -488,104 +562,113 @@
         Returns the heat capacity [J/K/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         # The differentiation is tedious, so for now we just take the
         # numerical derivative of S
         # TODO Derive and use the analytical derivative.
         dT = 0.1
-        S1 = self.entropy(pressure, temperature+dT/2., volume, params)
-        S0 = self.entropy(pressure, temperature-dT/2., volume, params)
-        return temperature * (S1 - S0)/dT
+        S1 = self.entropy(pressure, temperature + dT / 2.0, volume, params)
+        S0 = self.entropy(pressure, temperature - dT / 2.0, volume, params)
+        return temperature * (S1 - S0) / dT
 
     def __intCpdT(self, temperature, params):
         """
         Returns the thermal addition to the standard state enthalpy [J/mol]
         at ambient pressure [Pa]
         """
-        return ((params['Cp'][0] * temperature
-                 + 0.5 * params['Cp'][1] * np.power(temperature, 2.)
-                 - params['Cp'][2] / temperature
-                 + 2. * params['Cp'][3] * np.sqrt(temperature))
-                - (params['Cp'][0] * params['T_0']
-                   + 0.5 * params['Cp'][1] * params['T_0'] * params['T_0']
-                   - params['Cp'][2] / params['T_0']
-                   + 2.0 * params['Cp'][3] * np.sqrt(params['T_0'])))
+        return (
+            params["Cp"][0] * temperature
+            + 0.5 * params["Cp"][1] * np.power(temperature, 2.0)
+            - params["Cp"][2] / temperature
+            + 2.0 * params["Cp"][3] * np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * params["T_0"]
+            + 0.5 * params["Cp"][1] * params["T_0"] * params["T_0"]
+            - params["Cp"][2] / params["T_0"]
+            + 2.0 * params["Cp"][3] * np.sqrt(params["T_0"])
+        )
 
     def __intCpoverTdT(self, temperature, params):
         """
         Returns the thermal addition to the standard state entropy [J/K/mol]
         at ambient pressure [Pa]
         """
-        return ((params['Cp'][0] * np.log(temperature)
-                 + params['Cp'][1] * temperature
-                 - 0.5 * params['Cp'][2] / np.power(temperature, 2.)
-                 - 2.0 * params['Cp'][3] / np.sqrt(temperature))
-                - (params['Cp'][0] * np.log(params['T_0'])
-                   + params['Cp'][1] * params['T_0']
-                   - 0.5 * params['Cp'][2] / (params['T_0'] * params['T_0'])
-                   - 2.0 * params['Cp'][3] / np.sqrt(params['T_0'])))
+        return (
+            params["Cp"][0] * np.log(temperature)
+            + params["Cp"][1] * temperature
+            - 0.5 * params["Cp"][2] / np.power(temperature, 2.0)
+            - 2.0 * params["Cp"][3] / np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * np.log(params["T_0"])
+            + params["Cp"][1] * params["T_0"]
+            - 0.5 * params["Cp"][2] / (params["T_0"] * params["T_0"])
+            - 2.0 * params["Cp"][3] / np.sqrt(params["T_0"])
+        )
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
-        if 'T_0' not in params:
-            params['T_0'] = 298.15
+        if "T_0" not in params:
+            params["T_0"] = 298.15
 
         # If standard state enthalpy and entropy are not included
         # this is presumably deliberate, as we can model density
         # and bulk modulus just fine without them.
         # Just add them to the dictionary as nans.
-        if 'H_0' not in params:
-            params['H_0'] = float('nan')
-        if 'S_0' not in params:
-            params['S_0'] = float('nan')
+        if "H_0" not in params:
+            params["H_0"] = float("nan")
+        if "S_0" not in params:
+            params["S_0"] = float("nan")
 
         # First, let's check the EoS parameters for Tref
         mt.MT.validate_parameters(mt.MT(), params)
-        self.static_params = {'V_0': params['V_0'],
-                              'K_0': params['K_0'],
-                              'Kprime_0': params['Kprime_0'],
-                              'Kdprime_0': params['Kdprime_0'],
-                              'P_0': params['P_0']}
+        self.static_params = {
+            "V_0": params["V_0"],
+            "K_0": params["K_0"],
+            "Kprime_0": params["Kprime_0"],
+            "Kdprime_0": params["Kdprime_0"],
+            "P_0": params["P_0"],
+        }
 
         # Now check all the required keys for the
         # thermal part of the EoS are in the dictionary
-        expected_keys = ['H_0', 'S_0', 'V_0', 'Cp', 'a_0', 'dKdT_0',
-                         'n', 'molar_mass']
+        expected_keys = ["H_0", "S_0", "V_0", "Cp", "a_0", "dKdT_0", "n", "molar_mass"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn('Unusual value for T_0', stacklevel=2)
-        if ((params['G_0'] is not float('nan')
-             and (params['G_0'] < 0. or params['G_0'] > 1.e13))):
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if ((params['Gprime_0'] is not float('nan')
-             and (params['Gprime_0'] < -5. or params['Gprime_0'] > 10.))):
-            warnings.warn('Unusual value for Gprime_0', stacklevel=2)
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["G_0"] is not float("nan") and (
+            params["G_0"] < 0.0 or params["G_0"] > 1.0e13
+        ):
+            warnings.warn("Unusual value for G_0", stacklevel=2)
+        if params["Gprime_0"] is not float("nan") and (
+            params["Gprime_0"] < -5.0 or params["Gprime_0"] > 10.0
+        ):
+            warnings.warn("Unusual value for Gprime_0", stacklevel=2)
 
         # no test for H_0 or S_0 (several HP endmembers have S_0 < 0)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-2:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-2:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
 
-        if self.molar_heat_capacity_p0(params['T_0'], params) < 0.:
-            warnings.warn('Negative heat capacity at T_0', stacklevel=2)
-        if self.molar_heat_capacity_p0(2000., params) < 0.:
-            warnings.warn('Negative heat capacity at 2000K', stacklevel=2)
-
-        if params['a_0'] < 0. or params['a_0'] > 1.e-3:
-            warnings.warn('Unusual value for a_0', stacklevel=2)
-
-        if params['n'] < 1. or params['n'] > 1000.:
-            warnings.warn('Unusual value for n', stacklevel=2)
-        if params['molar_mass'] < 0.001 or params['molar_mass'] > 10.:
-            warnings.warn('Unusual value for molar_mass', stacklevel=2)
+        if self.molar_heat_capacity_p0(params["T_0"], params) < 0.0:
+            warnings.warn("Negative heat capacity at T_0", stacklevel=2)
+        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:
+            warnings.warn("Negative heat capacity at 2000K", stacklevel=2)
+
+        if params["a_0"] < 0.0 or params["a_0"] > 1.0e-3:
+            warnings.warn("Unusual value for a_0", stacklevel=2)
+
+        if params["n"] < 1.0 or params["n"] > 1000.0:
+            warnings.warn("Unusual value for n", stacklevel=2)
+        if params["molar_mass"] < 0.001 or params["molar_mass"] > 10.0:
+            warnings.warn("Unusual value for molar_mass", stacklevel=2)
 
 
 class HP98(eos.EquationOfState):
 
     """
     Base class for the thermal equation of state
     described in :cite:`HP1998`.
@@ -593,160 +676,174 @@
     An instance "m" of a Mineral can be assigned this
     equation of state with the command m.set_method('hp98')
     (or by initialising the class with the param
     equation_of_state = 'hp98'
     """
 
     def _V_T_1bar(self, temperature, params):
-        return params['V_0']*(1. + params['a_0']*(temperature - params['T_0'])
-                              - 20.*params['a_0']*(np.sqrt(temperature)
-                                                   - np.sqrt(params['T_0'])))
+        return params["V_0"] * (
+            1.0
+            + params["a_0"] * (temperature - params["T_0"])
+            - 20.0 * params["a_0"] * (np.sqrt(temperature) - np.sqrt(params["T_0"]))
+        )
 
     def _K_T_1bar(self, temperature, params):
-        return params['K_0'] + params['dKdT_0']*(temperature - params['T_0'])
+        return params["K_0"] + params["dKdT_0"] * (temperature - params["T_0"])
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume [m^3] as a function of pressure [Pa] and temperature [K]
         """
-        return murn.volume(pressure,
-                           self._V_T_1bar(temperature, params),
-                           self._K_T_1bar(temperature, params),
-                           params['Kprime_0'])
+        return murn.volume(
+            pressure,
+            self._V_T_1bar(temperature, params),
+            self._K_T_1bar(temperature, params),
+            params["Kprime_0"],
+        )
 
     def pressure(self, temperature, volume, params):
         """
         Returns pressure [Pa] as a function of temperature [K] and volume[m^3]
         """
-        return murn.pressure(volume,
-                             self._V_T_1bar(temperature, params),
-                             self._K_T_1bar(temperature, params),
-                             params['Kprime_0'])
+        return murn.pressure(
+            volume,
+            self._V_T_1bar(temperature, params),
+            self._K_T_1bar(temperature, params),
+            params["Kprime_0"],
+        )
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter [unitless] as a function of pressure,
         temperature, and volume.
         """
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        K_T = self.isothermal_bulk_modulus(pressure, temperature,
-                                           volume, params)
-        C_V = self.molar_heat_capacity_v(pressure, temperature,
-                                         volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
+        C_V = self.molar_heat_capacity_v(pressure, temperature, volume, params)
         return alpha * K_T * volume / C_V
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].
         """
-        return murn.bulk_modulus(pressure,
-                                 self._K_T_1bar(temperature, params),
-                                 params['Kprime_0'])
+        return murn.bulk_modulus(
+            pressure, self._K_T_1bar(temperature, params), params["Kprime_0"]
+        )
 
     # calculate the shear modulus as a function of P, V, and T
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Not implemented.
         Returns 0.
         Could potentially apply a fixed Poissons ratio as a rough estimate.
         """
-        return 0.
+        return 0.0
 
     # Cv, heat capacity at constant volume
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume at the pressure, temperature,
         and volume [J/K/mol].
         """
         C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)
         V = self.volume(pressure, temperature, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        K_T = self.isothermal_bulk_modulus(pressure, temperature,
-                                           volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         return C_p - V * temperature * alpha * alpha * K_T
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity at the pressure, temperature,
         and volume [1/K]
         """
         VT = self._V_T_1bar(temperature, params)
         KT = self._K_T_1bar(temperature, params)
-        volume = murn.volume(pressure, VT, KT, params['Kprime_0'])
-        dVTdT = params['V_0']*params['a_0']*(1. - 10./np.sqrt(temperature))
+        volume = murn.volume(pressure, VT, KT, params["Kprime_0"])
+        dVTdT = params["V_0"] * params["a_0"] * (1.0 - 10.0 / np.sqrt(temperature))
         g = volume / VT
-        dgdKT = (pressure
-                 * np.power(1. + pressure*params['Kprime_0']/KT,
-                            -1-1./params['Kprime_0'])
-                 / (KT*KT))
-        dVdT = dVTdT*g + VT*dgdKT*params['dKdT_0']
+        dgdKT = (
+            pressure
+            * np.power(
+                1.0 + pressure * params["Kprime_0"] / KT, -1 - 1.0 / params["Kprime_0"]
+            )
+            / (KT * KT)
+        )
+        dVdT = dVTdT * g + VT * dgdKT * params["dKdT_0"]
         return dVdT / volume
 
     def molar_heat_capacity_p0(self, temperature, params):
         """
         Returns heat capacity at ambient pressure as a function of temperature
         [J/K/mol]
         Cp = a + bT + cT^-2 + dT^-0.5 in :cite:`HP1998`.
         """
-        Cp = (params['Cp'][0]
-              + params['Cp'][1] * temperature
-              + params['Cp'][2] * np.power(temperature, -2.)
-              + params['Cp'][3] * np.power(temperature, -0.5))
+        Cp = (
+            params["Cp"][0]
+            + params["Cp"][1] * temperature
+            + params["Cp"][2] * np.power(temperature, -2.0)
+            + params["Cp"][3] * np.power(temperature, -0.5)
+        )
         return Cp
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].
         """
-        K_T = self.isothermal_bulk_modulus(pressure, temperature,
-                                           volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         C_p = self.molar_heat_capacity_p(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
         K_S = K_T * C_p / C_v
         return K_S
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the gibbs free energy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
-        return (params['H_0'] + self.__intCpdT(temperature, params)
-                - temperature * (params['S_0']
-                                 + self.__intCpoverTdT(temperature, params))
-                + murn.intVdP(pressure,
-                              self._V_T_1bar(temperature, params),
-                              self._K_T_1bar(temperature, params),
-                              params['Kprime_0']))
+        return (
+            params["H_0"]
+            + self.__intCpdT(temperature, params)
+            - temperature * (params["S_0"] + self.__intCpoverTdT(temperature, params))
+            + murn.intVdP(
+                pressure,
+                self._V_T_1bar(temperature, params),
+                self._K_T_1bar(temperature, params),
+                params["Kprime_0"],
+            )
+        )
 
     def helmholtz_free_energy(self, pressure, temperature, volume, params):
-        return (self.gibbs_free_energy(pressure, temperature, volume, params)
-                - pressure * self.volume(pressure, temperature, params))
+        return self.gibbs_free_energy(
+            pressure, temperature, volume, params
+        ) - pressure * self.volume(pressure, temperature, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the entropy [J/K/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         # The entropy involves differentiating intdVdp
         # with respect to temperature.
         # We do this using the product and chain rules
 
         VT = self._V_T_1bar(temperature, params)
         KT = self._K_T_1bar(temperature, params)
-        dVTdT = params['V_0']*params['a_0']*(1. - 10./np.sqrt(temperature))
-        g = murn.intVdP(pressure, VT, KT, params['Kprime_0']) / VT
-        dgdKT = (((pressure/KT + 1.)
-                 * np.power(1. + pressure*params['Kprime_0']/KT,
-                            -1./params['Kprime_0']) - 1.)
-                 / (params['Kprime_0'] - 1.))
-        dintVdpdT = dVTdT*g + VT*dgdKT*params['dKdT_0']
-        return (params['S_0'] + self.__intCpoverTdT(temperature, params)
-                - dintVdpdT)
+        dVTdT = params["V_0"] * params["a_0"] * (1.0 - 10.0 / np.sqrt(temperature))
+        g = murn.intVdP(pressure, VT, KT, params["Kprime_0"]) / VT
+        dgdKT = (
+            (pressure / KT + 1.0)
+            * np.power(
+                1.0 + pressure * params["Kprime_0"] / KT, -1.0 / params["Kprime_0"]
+            )
+            - 1.0
+        ) / (params["Kprime_0"] - 1.0)
+        dintVdpdT = dVTdT * g + VT * dgdKT * params["dKdT_0"]
+        return params["S_0"] + self.__intCpoverTdT(temperature, params) - dintVdpdT
 
     def enthalpy(self, pressure, temperature, volume, params):
         """
         Returns the enthalpy [J/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         gibbs = self.gibbs_free_energy(pressure, temperature, volume, params)
@@ -758,92 +855,99 @@
         Returns the heat capacity [J/K/mol] as a function of pressure [Pa]
         and temperature [K].
         """
         # The differentiation is tedious, so for now we just take the
         # numerical derivative of S
         # TODO calculate the analytical derivative
         dT = 0.1
-        S1 = self.entropy(pressure, temperature+dT/2., volume, params)
-        S0 = self.entropy(pressure, temperature-dT/2., volume, params)
-        return temperature * (S1 - S0)/dT
+        S1 = self.entropy(pressure, temperature + dT / 2.0, volume, params)
+        S0 = self.entropy(pressure, temperature - dT / 2.0, volume, params)
+        return temperature * (S1 - S0) / dT
 
     def __intCpdT(self, temperature, params):
         """
         Returns the thermal addition to the standard state enthalpy [J/mol]
         at ambient pressure [Pa]
         """
-        return ((params['Cp'][0] * temperature
-                 + 0.5 * params['Cp'][1] * np.power(temperature, 2.)
-                 - params['Cp'][2] / temperature
-                 + 2. * params['Cp'][3] * np.sqrt(temperature))
-                - (params['Cp'][0] * params['T_0']
-                   + 0.5 * params['Cp'][1] * params['T_0'] * params['T_0']
-                   - params['Cp'][2] / params['T_0']
-                   + 2.0 * params['Cp'][3] * np.sqrt(params['T_0'])))
+        return (
+            params["Cp"][0] * temperature
+            + 0.5 * params["Cp"][1] * np.power(temperature, 2.0)
+            - params["Cp"][2] / temperature
+            + 2.0 * params["Cp"][3] * np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * params["T_0"]
+            + 0.5 * params["Cp"][1] * params["T_0"] * params["T_0"]
+            - params["Cp"][2] / params["T_0"]
+            + 2.0 * params["Cp"][3] * np.sqrt(params["T_0"])
+        )
 
     def __intCpoverTdT(self, temperature, params):
         """
         Returns the thermal addition to the standard state entropy [J/K/mol]
         at ambient pressure [Pa]
         """
-        return ((params['Cp'][0] * np.log(temperature)
-                 + params['Cp'][1] * temperature
-                 - 0.5 * params['Cp'][2] / np.power(temperature, 2.)
-                 - 2.0 * params['Cp'][3] / np.sqrt(temperature))
-                - (params['Cp'][0] * np.log(params['T_0'])
-                   + params['Cp'][1] * params['T_0']
-                   - 0.5 * params['Cp'][2] / (params['T_0'] * params['T_0'])
-                   - 2.0 * params['Cp'][3] / np.sqrt(params['T_0'])))
+        return (
+            params["Cp"][0] * np.log(temperature)
+            + params["Cp"][1] * temperature
+            - 0.5 * params["Cp"][2] / np.power(temperature, 2.0)
+            - 2.0 * params["Cp"][3] / np.sqrt(temperature)
+        ) - (
+            params["Cp"][0] * np.log(params["T_0"])
+            + params["Cp"][1] * params["T_0"]
+            - 0.5 * params["Cp"][2] / (params["T_0"] * params["T_0"])
+            - 2.0 * params["Cp"][3] / np.sqrt(params["T_0"])
+        )
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
-        if 'T_0' not in params:
-            params['T_0'] = 298.15
+        if "T_0" not in params:
+            params["T_0"] = 298.15
 
         # If standard state enthalpy and entropy are not included
         # this is presumably deliberate, as we can model density
         # and bulk modulus just fine without them.
         # Just add them to the dictionary as nans.
-        if 'H_0' not in params:
-            params['H_0'] = float('nan')
-        if 'S_0' not in params:
-            params['S_0'] = float('nan')
+        if "H_0" not in params:
+            params["H_0"] = float("nan")
+        if "S_0" not in params:
+            params["S_0"] = float("nan")
 
         # First, let's check the EoS parameters for Tref
         murn.Murnaghan.validate_parameters(murn.Murnaghan(), params)
 
         # Now check all the required keys for the
         # thermal part of the EoS are in the dictionary
-        expected_keys = ['H_0', 'S_0', 'V_0', 'Cp', 'a_0', 'dKdT_0',
-                         'n', 'molar_mass']
+        expected_keys = ["H_0", "S_0", "V_0", "Cp", "a_0", "dKdT_0", "n", "molar_mass"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn('Unusual value for T_0', stacklevel=2)
-        if ((params['G_0'] is not float('nan')
-             and (params['G_0'] < 0. or params['G_0'] > 1.e13))):
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if ((params['Gprime_0'] is not float('nan')
-             and (params['Gprime_0'] < -5. or params['Gprime_0'] > 10.))):
-            warnings.warn('Unusual value for Gprime_0', stacklevel=2)
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["G_0"] is not float("nan") and (
+            params["G_0"] < 0.0 or params["G_0"] > 1.0e13
+        ):
+            warnings.warn("Unusual value for G_0", stacklevel=2)
+        if params["Gprime_0"] is not float("nan") and (
+            params["Gprime_0"] < -5.0 or params["Gprime_0"] > 10.0
+        ):
+            warnings.warn("Unusual value for Gprime_0", stacklevel=2)
 
         # no test for H_0 or S_0 (several HP endmembers have S_0 < 0)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-2:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-2:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
 
-        if self.molar_heat_capacity_p0(params['T_0'], params) < 0.:
-            warnings.warn('Negative heat capacity at T_0', stacklevel=2)
-        if self.molar_heat_capacity_p0(2000., params) < 0.:
-            warnings.warn('Negative heat capacity at 2000K', stacklevel=2)
-
-        if params['a_0'] < 0. or params['a_0'] > 1.e-3:
-            warnings.warn('Unusual value for a_0', stacklevel=2)
-
-        if params['n'] < 1. or params['n'] > 1000.:
-            warnings.warn('Unusual value for n', stacklevel=2)
-        if params['molar_mass'] < 0.001 or params['molar_mass'] > 10.:
-            warnings.warn('Unusual value for molar_mass', stacklevel=2)
+        if self.molar_heat_capacity_p0(params["T_0"], params) < 0.0:
+            warnings.warn("Negative heat capacity at T_0", stacklevel=2)
+        if self.molar_heat_capacity_p0(2000.0, params) < 0.0:
+            warnings.warn("Negative heat capacity at 2000K", stacklevel=2)
+
+        if params["a_0"] < 0.0 or params["a_0"] > 1.0e-3:
+            warnings.warn("Unusual value for a_0", stacklevel=2)
+
+        if params["n"] < 1.0 or params["n"] > 1000.0:
+            warnings.warn("Unusual value for n", stacklevel=2)
+        if params["molar_mass"] < 0.001 or params["molar_mass"] > 10.0:
+            warnings.warn("Unusual value for molar_mass", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/mie_grueneisen_debye.py` & `burnman-1.2.0/burnman/eos/mie_grueneisen_debye.py`

 * *Files 9% similar despite different names*

```diff
@@ -27,244 +27,284 @@
     """
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter [unitless] as a function of pressure,
         temperature, and volume (EQ B6)
         """
-        return self._grueneisen_parameter(params['V_0'] / volume, params)
+        return self._grueneisen_parameter(params["V_0"] / volume, params)
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume [m^3] as a function of pressure [Pa] and temperature [K]
         EQ B7
         """
-        T_0 = params['T_0']
-        func = lambda x: bm.birch_murnaghan(params['V_0'] / x, params) + \
-            self._thermal_pressure(temperature, x, params) - \
-            self._thermal_pressure(T_0, x, params) - pressure
+        T_0 = params["T_0"]
+        func = (
+            lambda x: bm.birch_murnaghan(params["V_0"] / x, params)
+            + self._thermal_pressure(temperature, x, params)
+            - self._thermal_pressure(T_0, x, params)
+            - pressure
+        )
         try:
-            sol = bracket(func, params['V_0'], 1.e-2 * params['V_0'])
+            sol = bracket(func, params["V_0"], 1.0e-2 * params["V_0"])
         except:
             raise ValueError(
-                'Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?')
+                "Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?"
+            )
         return opt.brentq(func, sol[0], sol[1])
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].  EQ B8
         """
-        T_0 = params['T_0']
-        K_T = bm.bulk_modulus(volume, params) + \
-            self._thermal_bulk_modulus(temperature, volume, params) - \
-            self._thermal_bulk_modulus(T_0, volume, params)  # EQB13
+        T_0 = params["T_0"]
+        K_T = (
+            bm.bulk_modulus(volume, params)
+            + self._thermal_bulk_modulus(temperature, volume, params)
+            - self._thermal_bulk_modulus(T_0, volume, params)
+        )  # EQB13
         return K_T
 
     # calculate the mgd shear modulus as a function of P, V, and T
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].  EQ B11
         """
-        T_0 = params['T_0']
+        T_0 = params["T_0"]
         if self.order == 2:
-            return bm.shear_modulus_second_order(volume, params) + \
-                self._thermal_shear_modulus(temperature, volume, params) - \
-                self._thermal_shear_modulus(T_0, volume, params)  # EQ B11
+            return (
+                bm.shear_modulus_second_order(volume, params)
+                + self._thermal_shear_modulus(temperature, volume, params)
+                - self._thermal_shear_modulus(T_0, volume, params)
+            )  # EQ B11
         elif self.order == 3:
-            return bm.shear_modulus_third_order(volume, params) + \
-                self._thermal_shear_modulus(temperature, volume, params) - \
-                self._thermal_shear_modulus(T_0, volume, params)  # EQ B11
+            return (
+                bm.shear_modulus_third_order(volume, params)
+                + self._thermal_shear_modulus(temperature, volume, params)
+                - self._thermal_shear_modulus(T_0, volume, params)
+            )  # EQ B11
         else:
             raise NotImplementedError("")
 
     # heat capacity at constant volume
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume at the pressure, temperature, and volume [J/K/mol]
         """
-        Debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        C_v = debye.molar_heat_capacity_v(temperature, Debye_T, params['n'])
+        Debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        C_v = debye.molar_heat_capacity_v(temperature, Debye_T, params["n"])
         return C_v
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity at the pressure, temperature, and volume [1/K]
         """
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        gr = self._grueneisen_parameter(params['V_0'] / volume, params)
+        gr = self._grueneisen_parameter(params["V_0"] / volume, params)
         K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         alpha = gr * C_v / K / volume
         return alpha
 
     # heat capacity at constant pressure
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure at the pressure, temperature, and volume [J/K/mol]
         """
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        gr = self._grueneisen_parameter(params['V_0'] / volume, params)
+        gr = self._grueneisen_parameter(params["V_0"] / volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        C_p = C_v * (1. + gr * alpha * temperature)
+        C_p = C_v * (1.0 + gr * alpha * temperature)
         return C_p
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus [Pa] as a function of pressure [Pa],
         temperature [K], and volume [m^3].  EQ D6
         """
-        K_T = self.isothermal_bulk_modulus(
-            pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
-        gr = self._grueneisen_parameter(params['V_0'] / volume, params)
-        K_S = K_T * (1. + gr * alpha * temperature)
+        gr = self._grueneisen_parameter(params["V_0"] / volume, params)
+        K_S = K_T * (1.0 + gr * alpha * temperature)
         return K_S
 
     def pressure(self, temperature, volume, params):
         """
         Returns pressure [Pa] as a function of temperature [K] and volume[m^3]
         EQ B7
         """
-        T_0 = params['T_0']
-        return bm.birch_murnaghan(params['V_0'] / volume, params) + \
-            self._thermal_pressure(temperature, volume, params) - \
-            self._thermal_pressure(T_0, volume, params)
+        T_0 = params["T_0"]
+        return (
+            bm.birch_murnaghan(params["V_0"] / volume, params)
+            + self._thermal_pressure(temperature, volume, params)
+            - self._thermal_pressure(T_0, volume, params)
+        )
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]
         """
-        G = self.helmholtz_free_energy(
-            pressure, temperature, volume, params) + pressure * volume
+        G = (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
         return G
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy at the pressure and temperature of the mineral [J/mol]
         """
-        return self.helmholtz_free_energy(pressure, temperature, volume, params) + \
-            temperature * \
-            self.entropy(pressure, temperature, volume, params)
+        return self.helmholtz_free_energy(
+            pressure, temperature, volume, params
+        ) + temperature * self.entropy(pressure, temperature, volume, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the entropy at the pressure and temperature of the mineral [J/K/mol]
         """
-        Debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        S = debye.entropy(temperature, Debye_T, params['n'])
+        Debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        S = debye.entropy(temperature, Debye_T, params["n"])
         return S
 
     def enthalpy(self, pressure, temperature, volume, params):
         """
         Returns the enthalpy at the pressure and temperature of the mineral [J/mol]
         """
 
-        return self.helmholtz_free_energy(pressure, temperature, volume, params) + \
-            temperature * self.entropy(pressure, temperature, volume, params) + \
-            pressure * volume
+        return (
+            self.helmholtz_free_energy(pressure, temperature, volume, params)
+            + temperature * self.entropy(pressure, temperature, volume, params)
+            + pressure * volume
+        )
 
     def helmholtz_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]
         """
-        x = params['V_0'] / volume
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        b_iikk = 9. * params['K_0']  # EQ 28, SLB2005
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29, SLB2005
-
-        F_pressure = ( 0.5 * b_iikk * f * f * params['V_0'] +
-                       (1. / 6.) * params['V_0'] * b_iikkmm * f * f * f )
-
-        Debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        F_thermal = debye.helmholtz_free_energy(temperature, Debye_T, params['n']) - \
-                    debye.helmholtz_free_energy(params['T_0'], Debye_T, params['n'])
+        x = params["V_0"] / volume
+        f = 1.0 / 2.0 * (pow(x, 2.0 / 3.0) - 1.0)
+        b_iikk = 9.0 * params["K_0"]  # EQ 28, SLB2005
+        b_iikkmm = 27.0 * params["K_0"] * (params["Kprime_0"] - 4.0)  # EQ 29, SLB2005
+
+        F_pressure = (
+            0.5 * b_iikk * f * f * params["V_0"]
+            + (1.0 / 6.0) * params["V_0"] * b_iikkmm * f * f * f
+        )
+
+        Debye_T = self._debye_temperature(params["V_0"] / volume, params)
+        F_thermal = debye.helmholtz_free_energy(
+            temperature, Debye_T, params["n"]
+        ) - debye.helmholtz_free_energy(params["T_0"], Debye_T, params["n"])
 
-        return params['F_0'] + F_pressure + F_thermal
+        return params["F_0"] + F_pressure + F_thermal
 
     # calculate the thermal correction to the shear modulus as a function of
     # V, T
     def _thermal_shear_modulus(self, T, V, params):
-        if T > 1.e-10:
-            gr = self._grueneisen_parameter(params['V_0'] / V, params)
-            Debye_T = self._debye_temperature(params['V_0'] / V, params)
-            G_th = 3. / 5. * (self._thermal_bulk_modulus(T, V, params) -
-                              6 * constants.gas_constant * T * params['n'] / V * gr * debye.debye_fn(Debye_T / T))  # EQ B10
+        if T > 1.0e-10:
+            gr = self._grueneisen_parameter(params["V_0"] / V, params)
+            Debye_T = self._debye_temperature(params["V_0"] / V, params)
+            G_th = (
+                3.0
+                / 5.0
+                * (
+                    self._thermal_bulk_modulus(T, V, params)
+                    - 6
+                    * constants.gas_constant
+                    * T
+                    * params["n"]
+                    / V
+                    * gr
+                    * debye.debye_fn(Debye_T / T)
+                )
+            )  # EQ B10
             return G_th
         else:
-            return 0.
+            return 0.0
 
     # compute the Debye temperature in K.  Takes the
     # parameter x, which is V_0/V (molar volumes).
     # Depends on the reference grueneisen parameter,
     # the reference Debye temperature, and the factor
     # q_0, see Matas eq B6
     def _debye_temperature(self, x, params):
-        return params['Debye_0'] * np.exp((params['grueneisen_0'] -
-                                           self._grueneisen_parameter(x, params)) / params['q_0'])
+        return params["Debye_0"] * np.exp(
+            (params["grueneisen_0"] - self._grueneisen_parameter(x, params))
+            / params["q_0"]
+        )
 
     # compute the grueneisen parameter with depth, according
     # to q_0.  Takes x=V_0/V. See Matas eq B6
     def _grueneisen_parameter(self, x, params):
-        return params['grueneisen_0'] * pow(1. / x, params['q_0'])
+        return params["grueneisen_0"] * pow(1.0 / x, params["q_0"])
 
     # calculate isotropic thermal pressure, see
     # Matas et. al. (2007) eq B4
     def _thermal_pressure(self, T, V, params):
-        Debye_T = self._debye_temperature(params['V_0'] / V, params)
-        gr = self._grueneisen_parameter(params['V_0'] / V, params)
-        P_th = gr * debye.thermal_energy(T, Debye_T, params['n']) / V
+        Debye_T = self._debye_temperature(params["V_0"] / V, params)
+        gr = self._grueneisen_parameter(params["V_0"] / V, params)
+        P_th = gr * debye.thermal_energy(T, Debye_T, params["n"]) / V
         return P_th
 
     # calculate the thermal correction for the mgd
     # bulk modulus (see matas et al, 2007)
     def _thermal_bulk_modulus(self, T, V, params):
-        if T > 1.e-10:
-            gr = self._grueneisen_parameter(params['V_0'] / V, params)
-            Debye_T = self._debye_temperature(params['V_0'] / V, params)
-            K_th = 3. * params['n'] * constants.gas_constant * T / V * gr * \
-                ((1. - params['q_0'] - 3. * gr) * debye.debye_fn(
-                 Debye_T / T) + 3. * gr * (Debye_T / T) / (np.exp(Debye_T / T) - 1.))  # EQ B5
+        if T > 1.0e-10:
+            gr = self._grueneisen_parameter(params["V_0"] / V, params)
+            Debye_T = self._debye_temperature(params["V_0"] / V, params)
+            K_th = (
+                3.0
+                * params["n"]
+                * constants.gas_constant
+                * T
+                / V
+                * gr
+                * (
+                    (1.0 - params["q_0"] - 3.0 * gr) * debye.debye_fn(Debye_T / T)
+                    + 3.0 * gr * (Debye_T / T) / (np.exp(Debye_T / T) - 1.0)
+                )
+            )  # EQ B5
             return K_th
         else:
-            return 0.
+            return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
-        if 'T_0' not in params:
-            params['T_0'] = 300.
-        if 'F_0' not in params:
-            params['F_0'] = 0.
+        if "T_0" not in params:
+            params["T_0"] = 300.0
+        if "F_0" not in params:
+            params["F_0"] = 0.0
 
         # First, let's check the EoS parameters for Tref
-        bm.BirchMurnaghanBase.validate_parameters(
-            bm.BirchMurnaghanBase(), params)
+        bm.BirchMurnaghanBase.validate_parameters(bm.BirchMurnaghanBase(), params)
 
         # Now check all the required keys for the
         # thermal part of the EoS are in the dictionary
-        expected_keys = ['molar_mass', 'n', 'Debye_0', 'grueneisen_0', 'q_0']
+        expected_keys = ["molar_mass", "n", "Debye_0", "grueneisen_0", "q_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn('Unusual value for T_0', stacklevel=2)
-        if params['molar_mass'] < 0.001 or params['molar_mass'] > 1.:
-            warnings.warn('Unusual value for molar_mass', stacklevel=2)
-        if params['n'] < 1. or params['n'] > 1000.:
-            warnings.warn('Unusual value for n', stacklevel=2)
-        if params['Debye_0'] < 1. or params['Debye_0'] > 10000.:
-            warnings.warn('Unusual value for Debye_0', stacklevel=2)
-        if params['grueneisen_0'] < 0. or params['grueneisen_0'] > 10.:
-            warnings.warn('Unusual value for grueneisen_0', stacklevel=2)
-        if params['q_0'] < -10. or params['q_0'] > 10.:
-            warnings.warn('Unusual value for q_0', stacklevel=2)
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["molar_mass"] < 0.001 or params["molar_mass"] > 1.0:
+            warnings.warn("Unusual value for molar_mass", stacklevel=2)
+        if params["n"] < 1.0 or params["n"] > 1000.0:
+            warnings.warn("Unusual value for n", stacklevel=2)
+        if params["Debye_0"] < 1.0 or params["Debye_0"] > 10000.0:
+            warnings.warn("Unusual value for Debye_0", stacklevel=2)
+        if params["grueneisen_0"] < 0.0 or params["grueneisen_0"] > 10.0:
+            warnings.warn("Unusual value for grueneisen_0", stacklevel=2)
+        if params["q_0"] < -10.0 or params["q_0"] > 10.0:
+            warnings.warn("Unusual value for q_0", stacklevel=2)
 
 
 class MGD3(MGDBase):
 
     """
     MGD equation of state with third order finite strain expansion for the
     shear modulus (this should be preferred, as it is more thermodynamically
```

### Comparing `burnman-1.1.0/burnman/eos/modified_tait.py` & `burnman-1.2.0/burnman/eos/birch_murnaghan_4th.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,210 +1,228 @@
+from __future__ import absolute_import
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
-from __future__ import absolute_import
-
-import warnings
 import numpy as np
-
+import scipy.optimize as opt
 from . import equation_of_state as eos
+from ..utils.math import bracket
+import warnings
 
 
-def tait_constants(params):
-    """
-    returns parameters for the modified Tait equation of state
-    derived from K_T and its two first pressure derivatives
-    EQ 4 from Holland and Powell, 2011
+def bulk_modulus_fourth(volume, params):
     """
-    a = (1. + params['Kprime_0']) / (
-        1. + params['Kprime_0'] + params['K_0'] * params['Kdprime_0'])
-    b = params['Kprime_0'] / params['K_0'] - \
-        params['Kdprime_0'] / (1. + params['Kprime_0'])
-    c = (1. + params['Kprime_0'] + params['K_0'] * params['Kdprime_0']) / (
-        params['Kprime_0'] * params['Kprime_0'] + params['Kprime_0'] - params['K_0'] * params['Kdprime_0'])
-    return a, b, c
+    compute the bulk modulus as per the fourth order
+    birch-murnaghan equation of state.  Returns bulk
+    modulus in the same units as the reference bulk
+    modulus.  Pressure must be in :math:`[Pa]`.
+    """
+
+    x = params["V_0"] / volume
+    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)
+
+    Xi = (3.0 / 4.0) * (4.0 - params["Kprime_0"])
+    Zeta = (3.0 / 8.0) * (
+        (params["K_0"] * params["Kprime_prime_0"])
+        + params["Kprime_0"] * (params["Kprime_0"] - 7.0)
+        + 143.0 / 9.0
+    )
+
+    K = (
+        5.0
+        * f
+        * pow((1.0 + 2.0 * f), 5.0 / 2.0)
+        * params["K_0"]
+        * (1.0 - (2.0 * Xi * f) + (4.0 * Zeta * pow(f, 2.0)))
+    ) + (
+        pow(1.0 + (2.0 * f), 7.0 / 2.0)
+        * params["K_0"]
+        * (1.0 - (4.0 * Xi * f) + (12.0 * Zeta * pow(f, 2.0)))
+    )
+
+    return K
+
+
+def volume_fourth_order(pressure, params):
+    func = lambda x: birch_murnaghan_fourth(params["V_0"] / x, params) - pressure
+    try:
+        sol = bracket(func, params["V_0"], 1.0e-2 * params["V_0"])
+    except:
+        raise ValueError(
+            "Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?"
+        )
+    return opt.brentq(func, sol[0], sol[1])
 
 
-def modified_tait(x, params):
+def birch_murnaghan_fourth(x, params):
     """
-    equation for the modified Tait equation of state, returns
+    equation for the fourth order birch-murnaghan equation of state, returns
     pressure in the same units that are supplied for the reference bulk
     modulus (params['K_0'])
-    EQ 2 from Holland and Powell, 2011
     """
-    a, b, c = tait_constants(params)
-    return (np.power((x + a - 1.) / a, -1. / c) - 1.) / b + params['P_0']
 
+    f = 0.5 * (pow(x, 2.0 / 3.0) - 1.0)
+    Xi = (3.0 / 4.0) * (4.0 - params["Kprime_0"])
+    Zeta = (3.0 / 8.0) * (
+        (params["K_0"] * params["Kprime_prime_0"])
+        + params["Kprime_0"] * (params["Kprime_0"] - 7.0)
+        + 143.0 / 9.0
+    )
+
+    return (
+        3.0
+        * f
+        * pow(1.0 + 2.0 * f, 5.0 / 2.0)
+        * params["K_0"]
+        * (1.0 - (2.0 * Xi * f) + (4.0 * Zeta * pow(f, 2.0)))
+        + params["P_0"]
+    )
 
-def volume(pressure, params):
-    """
-    Returns volume [m^3] as a function of pressure [Pa] and temperature [K]
-    EQ 12
-    """
-    a, b, c = tait_constants(params)
-    x = 1 - a * \
-        (1. - np.power((1. + b * (pressure - params['P_0'])), -1.0 * c))
-    return x * params['V_0']
 
+class BM4(eos.EquationOfState):
 
-def bulk_modulus(pressure, params):
     """
-    Returns isothermal bulk modulus :math:`K_T` of the mineral. :math:`[Pa]`.
-    EQ 13+2
-    """
-    a, b, c = tait_constants(params)
-    return params['K_0'] * (1. + b * (pressure - params['P_0'])) * (a + (1. - a) * np.power((1. + b * (pressure - params['P_0'])), c))
-
-
-def intVdP(pressure, params):
-    """
-    Returns the integral of VdP for the mineral. :math:`[J]`.
-    EQ 13
-    """
-    a, b, c = tait_constants(params)
-    psubpth = pressure - params['P_0']
-
-    if pressure != params['P_0']:
-        intVdP = ((pressure - params['P_0'])
-                  * params['V_0']
-                  * (1. - a + (a * (1. - np.power((1. + b * (psubpth)), 1. - c))
-                               / (b * (c - 1.)
-                                  * (pressure - params['P_0'])))))
-    else:
-        intVdP = 0.
-    return intVdP
-
-class MT(eos.EquationOfState):
-
-    """
-    Base class for the generic modified Tait equation of state.
-    References for this can be found in :cite:`HC1974`
-    and :cite:`HP2011` (followed here).
-
-    An instance "m" of a Mineral can be assigned this
-    equation of state with the command m.set_method('mt')
-    (or by initialising the class with the param
-    equation_of_state = 'mt').
+    Base class for the isothermal Birch Murnaghan equation of state.  This is fourth order in strain, and
+    has no temperature dependence.
     """
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
-        return volume(pressure, params)
+        return volume_fourth_order(pressure, params)
 
     def pressure(self, temperature, volume, params):
-        """
-        Returns pressure [Pa] as a function of temperature [K] and volume[m^3]
-        """
-        return modified_tait(params['V_0'] / volume, params)
+        return birch_murnaghan_fourth(volume / params["V_0"], params)
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
-        Returns isothermal bulk modulus :math:`K_T` of the mineral. :math:`[Pa]`.
+        Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,
+        temperature :math:`[K]` and volume :math:`[m^3]`.
         """
-        return bulk_modulus(pressure, params)
+        return bulk_modulus_fourth(volume, params)
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
-        Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[Pa]`
+        Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.
         """
-        return 1.e99
+        return bulk_modulus_fourth(volume, params)
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
-        Not implemented in the Modified Tait EoS. :math:`[Pa]`
-        Returns 0.
-        Could potentially apply a fixed Poissons ratio as a rough estimate.
+        Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`
         """
-        return 0.
+        return 0.0
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy :math:`\mathcal{S}` of the mineral. :math:`[J/K/mol]`
         """
-        return 0.
+        return 0.0
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy :math:`\mathcal{E}` of the mineral. :math:`[J/mol]`
         """
+        x = np.power(volume / params["V_0"], -1.0 / 3.0)
+        x2 = x * x
+        x4 = x2 * x2
+        x6 = x4 * x2
+        x8 = x4 * x4
+
+        xi1 = 3.0 * (4.0 - params["Kprime_0"]) / 4.0
+        xi2 = (
+            3.0
+            / 8.0
+            * (
+                params["K_0"] * params["Kprime_prime_0"]
+                + params["Kprime_0"] * (params["Kprime_0"] - 7.0)
+            )
+            + 143.0 / 24.0
+        )
+
+        intPdV = (
+            -9.0
+            / 2.0
+            * params["V_0"]
+            * params["K_0"]
+            * (
+                (xi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)
+                - xi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)
+                + xi2 * (x8 / 8 - x6 / 2 + 3.0 * x4 / 4.0 - x2 / 2.0 + 1.0 / 8.0)
+            )
+        )
 
-        return self.gibbs_free_energy(pressure, temperature, volume, params) - volume*pressure
+        return -intPdV + params["E_0"]
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy :math:`\mathcal{G}` of the mineral. :math:`[J/mol]`
         """
         # G = int VdP = [PV] - int PdV = E + PV
-        a, b, c = tait_constants(params)
-
-        intVdP = params['V_0']*( a/(b*(1. - c)) *
-                                 (np.power(b*(pressure - params['P_0']) + 1.,
-                                           1. - c) - 1.) +
-                                 (1. - a)*(pressure - params['P_0']))
 
-        return intVdP + params['E_0'] + params['V_0']*params['P_0']
+        return (
+            self.molar_internal_energy(pressure, temperature, volume, params)
+            + volume * pressure
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`
         """
-        return 0.
+        return 0.0
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        if 'E_0' not in params:
-            params['E_0'] = 0.
-        if 'P_0' not in params:
-            params['P_0'] = 1.e5
+        if "E_0" not in params:
+            params["E_0"] = 0.0
+        if "P_0" not in params:
+            params["P_0"] = 0.0
 
-        # G and Gprime are not defined in this equation of state,
-        # We can model density and bulk modulus just fine without them,
+        # If G and Gprime are not included this is presumably deliberate,
+        # as we can model density and bulk modulus just fine without them,
         # so just add them to the dictionary as nans
-        if 'G_0' not in params:
-            params['G_0'] = float('nan')
-        if 'Gprime_0' not in params:
-            params['Gprime_0'] = float('nan')
+        if "G_0" not in params:
+            params["G_0"] = float("nan")
+        if "Gprime_0" not in params:
+            params["Gprime_0"] = float("nan")
 
         # Check that all the required keys are in the dictionary
-        expected_keys = [
-            'V_0', 'K_0', 'Kprime_0', 'Kdprime_0', 'G_0', 'Gprime_0']
+        expected_keys = ["V_0", "K_0", "Kprime_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['P_0'] < 0.:
-            warnings.warn('Unusual value for P_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-2:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < 0. or params['Kprime_0'] > 40.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
-        if params['G_0'] < 0.0 or params['G_0'] > 1.e13:
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if params['Gprime_0'] < -5. or params['Gprime_0'] > 10.:
-            warnings.warn('Unusual value for Gprime_0', stacklevel=2)
+        if params["P_0"] < 0.0:
+            warnings.warn("Unusual value for P_0", stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < 0.0 or params["Kprime_0"] > 10.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
+        if params["Kprime_prime_0"] > 0.0 or params["Kprime_prime_0"] < -10.0:
+            warnings.warn("Unusual value for Kprime_prime_0", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/morse_potential.py` & `burnman-1.2.0/burnman/eos/vinet.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,86 +1,82 @@
-from __future__ import absolute_import
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
-# Copyright (C) 2012 - 2015 by the BurnMan team, released under the GNU
+# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 
 import scipy.optimize as opt
 from . import equation_of_state as eos
-from ..utils.math import bracket
 import warnings
-import numpy as np
+from math import exp
+
 
 def bulk_modulus(volume, params):
     """
-    Compute the bulk modulus as per the Morse potential
-    equation of state.
-    Returns bulk modulus in the same units as
-    the reference bulk modulus.
-    Pressure must be in :math:`[Pa]`.
+    compute the bulk modulus as per the
+    Vinet equation of state.  Reference bulk
+    modulus should be in :math:`[Pa]`.
     """
 
-    VoverV0 = volume / params['V_0']
-    x = (params['Kprime_0']  - 1.)*(1. - np.power(VoverV0, 1./3.))
-    K = params['K_0']*( ( 2./(params['Kprime_0']  - 1.) *
-                          np.power(VoverV0, -2./3.) *
-                          (np.exp(2.*x) - np.exp(x)) ) +
-                        ( np.power(VoverV0, -1./3.) *
-                          (2.*np.exp(2.*x) - np.exp(x)) ) )
+    x = volume / params["V_0"]
+    eta = (3.0 / 2.0) * (params["Kprime_0"] - 1.0)
+
+    K = (
+        (params["K_0"] * pow(x, -2.0 / 3.0))
+        * (1 + ((eta * pow(x, 1.0 / 3.0) + 1.0) * (1.0 - pow(x, 1.0 / 3.0))))
+        * exp(eta * (1.0 - pow(x, 1.0 / 3.0)))
+    )
     return K
 
-def shear_modulus(volume, params):
-    """
-    Shear modulus not currently implemented for this equation of state
-    """
-    return 0.
 
-def morse_potential(VoverV0, params):
+def vinet(x, params):
     """
-    Equation for the Morse Potential equation of state,
-    returns pressure in the same units that are supplied
-    for the reference bulk modulus (params['K_0'])
-    """
-    x = (params['Kprime_0']  - 1.)*(1. - np.power(VoverV0, 1./3.))
-    return ( 3. * params['K_0'] / (params['Kprime_0']  - 1.) *
-             np.power(VoverV0, -2./3.) *
-             (np.exp(2.*x) - np.exp(x)) ) + params['P_0']
+    equation for the  Vinet equation of state, returns
+    pressure in the same units that are supplied for the reference bulk
+    modulus (params['K_0']), which should be in math:`[Pa]`.
+    """
+    eta = (3.0 / 2.0) * (params["Kprime_0"] - 1.0)
+    return (
+        3.0
+        * params["K_0"]
+        * (pow(x, -2.0 / 3.0))
+        * (1.0 - (pow(x, 1.0 / 3.0)))
+        * exp(eta * (1.0 - pow(x, 1.0 / 3.0)))
+        + params["P_0"]
+    )
+
 
 def volume(pressure, params):
     """
-    Get the Morse Potential volume at a
-    reference temperature for a given pressure :math:`[Pa]`.
-    Returns molar volume in :math:`[m^3]`
+    Get the Vinet volume at a reference temperature for a given
+    pressure :math:`[Pa]`. Returns molar volume in :math:`[m^3]`
     """
-    func = lambda V: morse_potential(V / params['V_0'], params) - pressure
-    try:
-        sol = bracket(func, params['V_0'], 1.e-2 * params['V_0'])
-    except:
-        raise ValueError(
-            'Cannot find a volume, perhaps you are outside of the range of validity for the equation of state?')
-    return opt.brentq(func, sol[0], sol[1])
 
+    func = lambda x: vinet(x / params["V_0"], params) - pressure
+    V = opt.brentq(func, 0.1 * params["V_0"], 1.5 * params["V_0"])
+    return V
 
 
-class Morse(eos.EquationOfState):
+class Vinet(eos.EquationOfState):
 
     """
-    Class for the isothermal Morse Potential equation of state
-    detailed in :cite:`Stacey1981`.
-    This equation of state has no temperature dependence.
+    Base class for the isothermal Vinet equation of state.
+    References for this equation of state are :cite:`vinet1986`
+    and :cite:`vinet1987`. This equation of state actually
+    predates Vinet by 55 years :cite:`Rydberg1932`,
+    and was investigated further by :cite:`Stacey1981`.
     """
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
         return volume(pressure, params)
 
     def pressure(self, temperature, volume, params):
-        return morse_potential(volume / params['V_0'], params)
+        return vinet(volume / params["V_0"], params)
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,
         temperature :math:`[K]` and volume :math:`[m^3]`.
         """
         return bulk_modulus(volume, params)
@@ -90,95 +86,100 @@
         Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.
         """
         return bulk_modulus(volume, params)
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`
+        Currently not included in the Vinet EOS, so omitted.
         """
-        return shear_modulus(volume, params)
+        return 0.0
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy :math:`\mathcal{S}` of the mineral. :math:`[J/K/mol]`
         """
-        return 0.
+        return 0.0
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy :math:`\mathcal{E}` of the mineral. :math:`[J/mol]`
         """
+        x = pow(volume / params["V_0"], 1.0 / 3.0)
+        eta = (3.0 / 2.0) * (params["Kprime_0"] - 1.0)
 
-        x = (params['Kprime_0'] - 1)*(1 - np.power(volume/params['V_0'], 1./3.))
-        intPdV = ( 9./2. * params['V_0'] * params['K_0'] /
-                   np.power(params['Kprime_0'] - 1., 2.) *
-                   (2.*np.exp(x) - np.exp(2.*x) - 1.) )
+        intPdV = (
+            9.0
+            * params["V_0"]
+            * params["K_0"]
+            / (eta * eta)
+            * ((1.0 - eta * (1.0 - x)) * exp(eta * (1.0 - x)) - 1.0)
+        )
 
-        return -intPdV + params['E_0']
+        return -intPdV + params["E_0"]
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy :math:`\mathcal{G}` of the mineral. :math:`[J/mol]`
         """
-        return self.molar_internal_energy(pressure, temperature, volume, params) + volume*pressure
+        # G = int VdP = [PV] - int PdV = E + PV
+
+        return (
+            self.molar_internal_energy(pressure, temperature, volume, params)
+            + volume * pressure
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`
         """
-        return 0.
+        return 0.0
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        if 'E_0' not in params:
-            params['E_0'] = 0.
-        if 'P_0' not in params:
-            params['P_0'] = 0.
-
-        # If G and Gprime are not included this is presumably deliberate,
-        # as we can model density and bulk modulus just fine without them,
-        # so just add them to the dictionary as nans
-        if 'G_0' not in params:
-            params['G_0'] = float('nan')
-        if 'Gprime_0' not in params:
-            params['Gprime_0'] = float('nan')
+        if "E_0" not in params:
+            params["E_0"] = 0.0
+        if "P_0" not in params:
+            params["P_0"] = 0.0
+
+        # G is not included in the Vinet EOS so we shall set them to NaN's
+        if "G_0" not in params:
+            params["G_0"] = float("nan")
+        if "Gprime_0" not in params:
+            params["Gprime_0"] = float("nan")
 
-        # Check that all the required keys are in the dictionary
-        expected_keys = ['V_0', 'K_0', 'Kprime_0', 'G_0', 'Gprime_0']
+        # check that all the required keys are in the dictionary
+        expected_keys = ["V_0", "K_0", "Kprime_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
-        # Finally, check that the values are reasonable.
-        if params['P_0'] < 0.:
-            warnings.warn('Unusual value for P_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-3:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < 0. or params['Kprime_0'] > 10.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
-        if params['G_0'] < 0.0 or params['G_0'] > 1.e13:
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if params['Gprime_0'] < -5. or params['Gprime_0'] > 10.:
-            warnings.warn('Unusual value for Gprime_0', stacklevel=2)
+        # now check that the values are reasonable.  I mostly just
+        # made up these values from experience, and we are only
+        # raising a warning.  Better way to do this? [IR]
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < -5.0 or params["Kprime_0"] > 10.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/murnaghan.py` & `burnman-1.2.0/burnman/eos/murnaghan.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,156 +5,159 @@
 
 from . import equation_of_state as eos
 import warnings
 import numpy as np
 
 
 def volume(pressure, V_0, K_0, Kprime_0):
-    return V_0 * np.power(1. + (pressure * Kprime_0 / K_0), -1./Kprime_0)
+    return V_0 * np.power(1.0 + (pressure * Kprime_0 / K_0), -1.0 / Kprime_0)
 
 
 def pressure(volume, V_0, K_0, Kprime_0):
-    return K_0 / Kprime_0 * (np.power(volume / V_0, -Kprime_0) - 1.)
+    return K_0 / Kprime_0 * (np.power(volume / V_0, -Kprime_0) - 1.0)
 
 
 def bulk_modulus(pressure, K_0, Kprime_0):
     return K_0 + pressure * Kprime_0
 
 
 def energy(volume, E_0, V_0, K_0, Kprime_0):
     Vrel = volume / V_0
-    return (E_0 + K_0*V_0 * (np.power(Vrel, 1. - Kprime_0)
-                             / (Kprime_0*(Kprime_0 - 1))
-                             + Vrel / Kprime_0 - 1./(Kprime_0 - 1.)))
+    return E_0 + K_0 * V_0 * (
+        np.power(Vrel, 1.0 - Kprime_0) / (Kprime_0 * (Kprime_0 - 1))
+        + Vrel / Kprime_0
+        - 1.0 / (Kprime_0 - 1.0)
+    )
 
 
 def intVdP(pressure, V_0, K_0, Kprime_0):
-    return (V_0 * K_0
-            * ((np.power(1. + (pressure * Kprime_0 / K_0),
-                         1.-(1./Kprime_0))) - 1.)
-            / (Kprime_0 - 1.))
+    return (
+        V_0
+        * K_0
+        * ((np.power(1.0 + (pressure * Kprime_0 / K_0), 1.0 - (1.0 / Kprime_0))) - 1.0)
+        / (Kprime_0 - 1.0)
+    )
 
 
 class Murnaghan(eos.EquationOfState):
 
     """
     Base class for the isothermal Murnaghan equation of state,
     as described in :cite:`Murnaghan1944`.
     """
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
-        return volume(pressure,
-                      params['V_0'], params['K_0'], params['Kprime_0'])
+        return volume(pressure, params["V_0"], params["K_0"], params["Kprime_0"])
 
     def pressure(self, temperature, volume, params):
-        return pressure(volume,
-                        params['V_0'], params['K_0'], params['Kprime_0'])
+        return pressure(volume, params["V_0"], params["K_0"], params["Kprime_0"])
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]`
         as a function of pressure :math:`[Pa]`,
         temperature :math:`[K]` and volume :math:`[m^3]`.
         """
-        return bulk_modulus(pressure, params['K_0'], params['Kprime_0'])
+        return bulk_modulus(pressure, params["K_0"], params["Kprime_0"])
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus :math:`K_s` of the mineral. :math:`[Pa]`.
         """
-        return bulk_modulus(pressure, params['K_0'], params['Kprime_0'])
+        return bulk_modulus(pressure, params["K_0"], params["Kprime_0"])
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus :math:`G` of the mineral. :math:`[Pa]`
         Currently not included in the Murnghan EOS, so omitted.
         """
-        return 0.
+        return 0.0
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy :math:`\mathcal{S}` of the mineral.
         :math:`[J/K/mol]`
         """
-        return 0.
+        return 0.0
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy :math:`\mathcal{E}` of the mineral.
         :math:`[J/mol]`
         """
-        return energy(volume,
-                      params['E_0'], params['V_0'],
-                      params['K_0'], params['Kprime_0'])
+        return energy(
+            volume, params["E_0"], params["V_0"], params["K_0"], params["Kprime_0"]
+        )
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy :math:`\mathcal{G}` of the mineral.
         :math:`[J/mol]`
         """
         # G = E + PV
-        return (self.molar_internal_energy(pressure, temperature,
-                                           volume, params)
-                + volume*pressure)
+        return (
+            self.molar_internal_energy(pressure, temperature, volume, params)
+            + volume * pressure
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects,
         return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects,
         return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects,
         return zero. :math:`[1/K]`
         """
-        return 0.
+        return 0.0
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects,
         return zero. :math:`[unitless]`
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
 
-        if 'E_0' not in params:
-            params['E_0'] = 0.
-        if 'P_0' not in params:
-            params['P_0'] = 0.
+        if "E_0" not in params:
+            params["E_0"] = 0.0
+        if "P_0" not in params:
+            params["P_0"] = 0.0
 
         # G is not included in the Murnaghan EOS so we shall set them to NaN's
-        if 'G_0' not in params:
-            params['G_0'] = float('nan')
-        if 'Gprime_0' not in params:
-            params['Gprime_0'] = float('nan')
+        if "G_0" not in params:
+            params["G_0"] = float("nan")
+        if "Gprime_0" not in params:
+            params["Gprime_0"] = float("nan")
 
         # check that all the required keys are in the dictionary
-        expected_keys = ['V_0', 'K_0', 'Kprime_0']
+        expected_keys = ["V_0", "K_0", "Kprime_0"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # now check that the values are reasonable.  I mostly just
         # made up these values from experience, and we are only
         # raising a warning.  Better way to do this? [IR]
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-3:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < -5. or params['Kprime_0'] > 30.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < -5.0 or params["Kprime_0"] > 30.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/property_modifiers.py` & `burnman-1.2.0/burnman/eos/property_modifiers.py`

 * *Files 24% similar despite different names*

```diff
@@ -2,19 +2,20 @@
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 from __future__ import absolute_import
 import numpy as np
 import scipy.optimize as opt
 from ..constants import gas_constant
+from . import debye, einstein
 
 """
 Functions for modifying the thermodynamic properties of minerals
 Currently includes modifications for:
-- second order transitions (landau, landau_hp),
+- second order transitions (landau, landau_slb_2022, landau_hp),
 - order-disorder (bragg_williams),
 - magnetism (magnetic_chs),
 - and a linear modification (linear).
 """
 
 
 def _landau_excesses(pressure, temperature, params):
@@ -24,124 +25,236 @@
     This correction follows Putnis (1992), and is done relative to
     the completely *ordered* state (at 0 K).
     It therefore differs in implementation from both
     Stixrude and Lithgow-Bertelloni (2011) and
     Holland and Powell (2011), who compute properties relative to
     the completely disordered state and standard states respectively.
 
-    The current implementation is preferred, as the excess
-    entropy (and heat capacity) terms are equal to zero at 0 K.
+    The excess entropy (and heat capacity) terms are equal to zero at 0 K.
 
     N.B. The excesses are for a *completely relaxed* mineral;
     for example, seismic wave propagation is *slow* compared to the
-    rate of reaction.
+    rate of change in order parameter.
     """
 
-    Tc = params['Tc_0'] + params['V_D'] * pressure / params['S_D']
+    Tc = params["Tc_0"] + params["V_D"] * pressure / params["S_D"]
 
-    G_disordered = -params['S_D'] * ((temperature - Tc) + params['Tc_0'] / 3.)
-    dGdT_disordered = -params['S_D']
-    dGdP_disordered = params['V_D']
+    G_disordered = -params["S_D"] * ((temperature - Tc) + params["Tc_0"] / 3.0)
+    dGdT_disordered = -params["S_D"]
+    dGdP_disordered = params["V_D"]
 
     if temperature < Tc:
         # Wolfram input to check partial differentials
         # x = T, y = P, a = S, c = Tc0, d = V
         # D[D[a ((x - c - d*y/a)*(1 - x/(c + d*y/a))^0.5 + c/3*(1 - x/(c +
         # d*y/a))^1.5), x], x]
-        Q2 = np.sqrt(1. - temperature / Tc)
-        G = (params['S_D']
-             * ((temperature - Tc) * Q2
-                + params['Tc_0'] * Q2 * Q2 * Q2 / 3.) + G_disordered)
-        dGdP = (-params['V_D'] * Q2 * (1. + 0.5 * temperature / Tc
-                                       * (1. - params['Tc_0'] / Tc))
-                + dGdP_disordered)
-        dGdT = (params['S_D'] * Q2 * (1.5 - 0.5 * params['Tc_0'] / Tc)
-                + dGdT_disordered)
-        d2GdP2 = (params['V_D'] * params['V_D'] * temperature
-                  / (params['S_D'] * Tc * Tc * Q2)
-                  * (temperature * (1. + params['Tc_0'] / Tc) / (4. * Tc)
-                     + Q2 * Q2 * (1. - params['Tc_0'] / Tc) - 1.))
-        d2GdT2 = -params['S_D'] / (Tc * Q2) * (0.75 - 0.25 * params['Tc_0']
-                                               / Tc)
-        d2GdPdT = (params['V_D'] / (2. * Tc * Q2)
-                   * (1. + (temperature / (2. * Tc) - Q2 * Q2)
-                      * (1. - params['Tc_0'] / Tc)))
+        Q2 = np.sqrt(1.0 - temperature / Tc)
+        G = (
+            params["S_D"]
+            * ((temperature - Tc) * Q2 + params["Tc_0"] * Q2 * Q2 * Q2 / 3.0)
+            + G_disordered
+        )
+        dGdP = (
+            -params["V_D"]
+            * Q2
+            * (1.0 + 0.5 * temperature / Tc * (1.0 - params["Tc_0"] / Tc))
+            + dGdP_disordered
+        )
+        dGdT = params["S_D"] * Q2 * (1.5 - 0.5 * params["Tc_0"] / Tc) + dGdT_disordered
+        d2GdP2 = (
+            params["V_D"]
+            * params["V_D"]
+            * temperature
+            / (params["S_D"] * Tc * Tc * Q2)
+            * (
+                temperature * (1.0 + params["Tc_0"] / Tc) / (4.0 * Tc)
+                + Q2 * Q2 * (1.0 - params["Tc_0"] / Tc)
+                - 1.0
+            )
+        )
+        d2GdT2 = -params["S_D"] / (Tc * Q2) * (0.75 - 0.25 * params["Tc_0"] / Tc)
+        d2GdPdT = (
+            params["V_D"]
+            / (2.0 * Tc * Q2)
+            * (1.0 + (temperature / (2.0 * Tc) - Q2 * Q2) * (1.0 - params["Tc_0"] / Tc))
+        )
 
     else:
-        Q2 = 0.
+        Q2 = 0.0
         G = G_disordered
         dGdT = dGdT_disordered
         dGdP = dGdP_disordered
-        d2GdT2 = 0.
-        d2GdP2 = 0.
-        d2GdPdT = 0.
+        d2GdT2 = 0.0
+        d2GdP2 = 0.0
+        d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
+
+    return (excesses, {"Q": np.sqrt(Q2)})
+
+
+def _landau_slb_2022_excesses(pressure, temperature, params):
+    """
+    Applies a tricritical Landau correction to the properties
+    of an endmember which undergoes a displacive phase transition.
+    This correction follows Stixrude and Lithgow-Bertelloni (2022),
+    and is done relative to the state with order parameter Q=1.
+
+    The order parameter of this formulation can exceed one,
+    at odds with Putnis (above), but in better agreement with
+    atomic intuition (Stixrude and Lithgow-Bertelloni, 2022).
+    Nevertheless, this implementation is still not perfect,
+    as the excess entropy (and heat capacity) terms are not equal
+    to zero at 0 K. Q is limited to values less than or equal to 2
+    to avoid unrealistic stabilisation at ultrahigh pressure.
+
+    N.B. These excesses are for a *completely relaxed* mineral;
+    for example, seismic wave propagation is *slow* compared to the
+    rate of change in order parameter.
+    """
 
-    excesses = {'G': G, 'dGdT': dGdT, 'dGdP': dGdP,
-                'd2GdT2': d2GdT2, 'd2GdP2': d2GdP2, 'd2GdPdT': d2GdPdT}
+    Tc = params["Tc_0"] + params["V_D"] * pressure / params["S_D"]
 
-    return (excesses, {'Q': np.sqrt(Q2)})
+    G_disordered = -params["S_D"] * ((temperature - Tc) + params["Tc_0"] / 3.0)
+    dGdT_disordered = -params["S_D"]
+    dGdP_disordered = params["V_D"]
+
+    if temperature < Tc:
+        Q2 = np.sqrt((Tc - temperature) / params["Tc_0"])
+
+        if Q2 < 4.0:
+            # Wolfram input to check partial differentials
+            # x = T, y = P, a = S, c = Tc0, d = V
+            # D[D[a ((x - c - d*y/a)*((c + d*y/a - x)/c)^0.5
+            # + c/3*((c + d*y/a - x)/c)^1.5), x], x]
+            # where Q2 = ((c + d*y/a - x)/c)^0.5
+            G = (
+                params["S_D"]
+                * ((temperature - Tc) * Q2 + params["Tc_0"] * Q2 * Q2 * Q2 / 3.0)
+                + G_disordered
+            )
+            dGdP = -params["V_D"] * Q2 + dGdP_disordered
+            dGdT = params["S_D"] * Q2 + dGdT_disordered
+            d2GdP2 = (
+                -0.5
+                * params["V_D"]
+                * params["V_D"]
+                / (params["S_D"] * params["Tc_0"] * Q2)
+            )
+            d2GdT2 = -0.5 * params["S_D"] / (Tc * Q2)
+            d2GdPdT = 0.5 * params["V_D"] / (Tc * Q2)
+        else:
+            # Wolfram input to check partial differentials
+            # x = T, y = P, a = S, c = Tc0, d = V
+            # D[D[a ((x - c - d*y/a)*4 + c/3*64), x], x]
+            G = (
+                params["S_D"] * ((temperature - Tc) * 4.0 + params["Tc_0"] * 64.0 / 3.0)
+                + G_disordered
+            )
+            dGdP = -params["V_D"] * 4.0 + dGdP_disordered
+            dGdT = params["S_D"] * 4.0 + dGdT_disordered
+            d2GdP2 = 0.0
+            d2GdT2 = 0.0
+            d2GdPdT = 0.0
+
+    else:
+        Q2 = 0.0
+        G = G_disordered
+        dGdT = dGdT_disordered
+        dGdP = dGdP_disordered
+        d2GdT2 = 0.0
+        d2GdP2 = 0.0
+        d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
+
+    return (excesses, {"Q": np.sqrt(Q2)})
 
 
 def _landau_hp_excesses(pressure, temperature, params):
     """
     Applies a tricritical Landau correction to the properties
     of an endmember which undergoes a displacive phase transition.
     This correction is done relative to the standard state, as per
     Holland and Powell (1998).
 
     Includes the correction published within landaunote.pdf
     (Holland, pers. comm), which 'corrects' the terms involving
     the critical temperature Tc / Tc*
 
-    Note that this formalism is still inconsistent, as it predicts that
-    the order parameter can be greater than one. For this reason
-    _landau_excesses is preferred.
+    This formalism predicts that the order parameter can be greater
+    than one, unlike _landau_excesses.
 
     N.B. The excesses are for a *completely relaxed* mineral;
     i.e. the seismic wave propagation is *slow* compared to the
-    rate of reaction.
+    rate of change in order parameter.
     """
 
     P = pressure
     T = temperature
 
-    if params['T_0'] < params['Tc_0']:
-        Q_0 = np.power((params['Tc_0'] - params['T_0']) / params['Tc_0'], 0.25)
+    if params["T_0"] < params["Tc_0"]:
+        Q_0 = np.power((params["Tc_0"] - params["T_0"]) / params["Tc_0"], 0.25)
     else:
-        Q_0 = 0.
+        Q_0 = 0.0
 
-    Tc = params['Tc_0'] + params['V_D'] * (P - params['P_0']) / params['S_D']
+    Tc = params["Tc_0"] + params["V_D"] * (P - params["P_0"]) / params["S_D"]
     if T < Tc:
-        Q = np.power((Tc - T) / params['Tc_0'], 0.25)
+        Q = np.power((Tc - T) / params["Tc_0"], 0.25)
     else:
-        Q = 0.
+        Q = 0.0
 
     # Gibbs
-    G = (params['Tc_0'] * params['S_D'] * (Q_0 * Q_0 - np.power(Q_0, 6.) / 3.)
-         - params['S_D'] * (Tc * Q * Q - params['Tc_0'] * np.power(Q, 6.) / 3.)
-         - T * params['S_D'] * (Q_0 * Q_0 - Q * Q)
-         + (P - params['P_0']) * params['V_D'] * Q_0 * Q_0)
-
-    dGdT = params['S_D'] * (Q * Q - Q_0 * Q_0)
-    dGdP = -params['V_D'] * (Q * Q - Q_0 * Q_0)
-
-    if Q > 1.e-12:
-        d2GdT2 = -params['S_D'] / (2. * params['Tc_0'] * Q * Q)
-        d2GdP2 = (-params['V_D'] * params['V_D']
-                  / (2. * params['S_D'] * params['Tc_0'] * Q * Q))
-        d2GdPdT = params['V_D'] / (2. * params['Tc_0'] * Q * Q)
+    G = (
+        params["Tc_0"] * params["S_D"] * (Q_0 * Q_0 - np.power(Q_0, 6.0) / 3.0)
+        - params["S_D"] * (Tc * Q * Q - params["Tc_0"] * np.power(Q, 6.0) / 3.0)
+        - T * params["S_D"] * (Q_0 * Q_0 - Q * Q)
+        + (P - params["P_0"]) * params["V_D"] * Q_0 * Q_0
+    )
+
+    dGdT = params["S_D"] * (Q * Q - Q_0 * Q_0)
+    dGdP = -params["V_D"] * (Q * Q - Q_0 * Q_0)
+
+    if Q > 1.0e-12:
+        d2GdT2 = -params["S_D"] / (2.0 * params["Tc_0"] * Q * Q)
+        d2GdP2 = (
+            -params["V_D"]
+            * params["V_D"]
+            / (2.0 * params["S_D"] * params["Tc_0"] * Q * Q)
+        )
+        d2GdPdT = params["V_D"] / (2.0 * params["Tc_0"] * Q * Q)
     else:
-        d2GdT2 = 0.
-        d2GdP2 = 0.
-        d2GdPdT = 0.
+        d2GdT2 = 0.0
+        d2GdP2 = 0.0
+        d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
 
-    excesses = {'G': G, 'dGdT': dGdT, 'dGdP': dGdP,
-                'd2GdT2': d2GdT2, 'd2GdP2': d2GdP2, 'd2GdPdT': d2GdPdT}
-
-    return (excesses, {'Q': Q})
+    return (excesses, {"Q": Q})
 
 
 def _linear_excesses(pressure, temperature, params):
     """
     Applies a 'Darken's quadratic formalism' correction (Powell, 1987)
     to the thermodynamic properties of a mineral endmember.
     This correction is relative to P = 0 and T = 0 and linear in P and T
@@ -150,26 +263,33 @@
     Applying either a volume or entropy term will generally break
     equations of state (i.e. the properties of the mineral will
     no longer obey the equation of state defined in the
     params dictionary. However, this form of excess is extremely
     useful as a first order tweak to free energies
     (especially in solid solution calculations)
     """
-
-    G = params['delta_E'] \
-        - (temperature) * params['delta_S'] \
-        + (pressure) * params['delta_V']
-    dGdT = -params['delta_S']
-    dGdP = params['delta_V']
-    d2GdT2 = 0.
-    d2GdP2 = 0.
-    d2GdPdT = 0.
-
-    excesses = {'G': G, 'dGdT': dGdT, 'dGdP': dGdP,
-                'd2GdT2': d2GdT2, 'd2GdP2': d2GdP2, 'd2GdPdT': d2GdPdT}
+    G = (
+        params["delta_E"]
+        - (temperature) * params["delta_S"]
+        + (pressure) * params["delta_V"]
+    )
+    dGdT = -params["delta_S"]
+    dGdP = params["delta_V"]
+    d2GdT2 = 0.0
+    d2GdP2 = 0.0
+    d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
 
     return (excesses, None)
 
 
 def _bragg_williams_excesses(pressure, temperature, params):
     """
     Applies a Bragg-Williams type correction to the thermodynamic
@@ -184,171 +304,358 @@
     This may not be reasonable for order-disorder, especially
     for slow or coupled diffusers (Si-Al, for example).
     The completely *unrelaxed* mineral (in terms of order-disorder)
     can be calculated with a solid solution model.
     """
 
     R = gas_constant
-    n = params['n']
-    if params['factor'] > 0.:
-        f = [params['factor'], params['factor']]
+    n = params["n"]
+    if params["factor"] > 0.0:
+        f = [params["factor"], params["factor"]]
     else:
-        f = [1., -params['factor']]
+        f = [1.0, -params["factor"]]
 
     # Equation A2-2
     def flnarxn(n, Q, f):
-        return (n / (n + 1.) * (f[0] * np.log(n*(1. - Q))
-                                + f[1] * np.log(1. - Q)
-                                - f[0] * np.log(1. + n*Q)
-                                - f[1] * np.log(n + Q)))
+        return (
+            n
+            / (n + 1.0)
+            * (
+                f[0] * np.log(n * (1.0 - Q))
+                + f[1] * np.log(1.0 - Q)
+                - f[0] * np.log(1.0 + n * Q)
+                - f[1] * np.log(n + Q)
+            )
+        )
 
     # Equation A2-4
     # Can be derived from A2-2 noting that
     # delta_H + f*R*T*lnarxn = delta_G + f*R*T*(lnadisord - lnaord)
     def reaction_bragg_williams(Q, delta_H, temperature, n, f, W):
-        return (delta_H + R * temperature * flnarxn(n, Q, f)
-                + (2. * Q - 1.) * W)
+        return delta_H + R * temperature * flnarxn(n, Q, f) + (2.0 * Q - 1.0) * W
 
     def order_gibbs(pressure, temperature, params):
-        W = params['Wh'] + pressure * params['Wv']
-        H_disord = (params['deltaH']
-                    + pressure * params['deltaV'])
+        W = params["Wh"] + pressure * params["Wv"]
+        H_disord = params["deltaH"] + pressure * params["deltaV"]
 
         # We can use brentq, but don't let the lower bracket = 0
         try:
-            Q = opt.brentq(reaction_bragg_williams, 1.e-12, 1. - 1.e-12,
-                           args=(H_disord, temperature, n, f, W))
+            Q = opt.brentq(
+                reaction_bragg_williams,
+                1.0e-12,
+                1.0 - 1.0e-12,
+                args=(H_disord, temperature, n, f, W),
+            )
         except ValueError:
-            Q = 0.
+            Q = 0.0
 
-        S = - R * (f[0] * ((1. + n*Q)*np.log((1. + n * Q)/(n + 1.))
-                    + n * (1. - Q) * np.log(n * (1. - Q) / (n + 1.)))
-                   + f[1] * (n * (1. - Q) * np.log((1. - Q) / (n + 1.))
-                             + n * (n + Q) * np.log((n + Q) / (n + 1.)))
-                   ) / (n + 1.)
+        S = (
+            -R
+            * (
+                f[0]
+                * (
+                    (1.0 + n * Q) * np.log((1.0 + n * Q) / (n + 1.0))
+                    + n * (1.0 - Q) * np.log(n * (1.0 - Q) / (n + 1.0))
+                )
+                + f[1]
+                * (
+                    n * (1.0 - Q) * np.log((1.0 - Q) / (n + 1.0))
+                    + n * (n + Q) * np.log((n + Q) / (n + 1.0))
+                )
+            )
+            / (n + 1.0)
+        )
 
-        G = (1. - Q)*H_disord + (1. - Q)*Q*W - temperature*S
+        G = (1.0 - Q) * H_disord + (1.0 - Q) * Q * W - temperature * S
         return Q, G
 
     # Calculating partial differentials with respect to P and T
     # are complicated by the fact that Q changes with P and T
-    # Since there's no analytical solution for Q(P, T), we are
-    # unfortunately driven to numerical differentiation. Schade.
+    # TODO: Calculate the analytical derivatives of G via the chain rule.
+    # For now, just use numerical differentiation.
     dT = 0.1
-    dP = 1000.
+    dP = 1000.0
 
     Q, G = order_gibbs(pressure, temperature, params)
     Q, GsubPsubT = order_gibbs(pressure - dP, temperature - dT, params)
     Q, GsubPaddT = order_gibbs(pressure - dP, temperature + dT, params)
     Q, GaddPsubT = order_gibbs(pressure + dP, temperature - dT, params)
     Q, GaddPaddT = order_gibbs(pressure + dP, temperature + dT, params)
     Q, GsubP = order_gibbs(pressure - dP, temperature, params)
     Q, GaddP = order_gibbs(pressure + dP, temperature, params)
     Q, GsubT = order_gibbs(pressure, temperature - dT, params)
     Q, GaddT = order_gibbs(pressure, temperature + dT, params)
 
-    dGdT = (GaddT - GsubT) / (2. * dT)
-    dGdP = (GaddP - GsubP) / (2. * dP)
-    d2GdT2 = (GaddT + GsubT - 2. * G) / (dT * dT)
-    d2GdP2 = (GaddP + GsubP - 2. * G) / (dP * dP)
-    d2GdPdT = (GaddPaddT - GsubPaddT - GaddPsubT + GsubPsubT) / (4. * dT * dP)
-
-    excesses = {'G': G, 'dGdT': dGdT, 'dGdP': dGdP,
-                'd2GdT2': d2GdT2, 'd2GdP2': d2GdP2, 'd2GdPdT': d2GdPdT}
+    dGdT = (GaddT - GsubT) / (2.0 * dT)
+    dGdP = (GaddP - GsubP) / (2.0 * dP)
+    d2GdT2 = (GaddT + GsubT - 2.0 * G) / (dT * dT)
+    d2GdP2 = (GaddP + GsubP - 2.0 * G) / (dP * dP)
+    d2GdPdT = (GaddPaddT - GsubPaddT - GaddPsubT + GsubPsubT) / (4.0 * dT * dP)
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
 
-    return (excesses, {'Q': Q})
+    return (excesses, {"Q": Q})
 
 
 def _magnetic_excesses_chs(pressure, temperature, params):
     """
     Applies a magnetic contribution to the thermodynamic
     properties of a mineral endmember.
     The expression for the gibbs energy contribution is that
     used by Chin, Hertzman and Sundman (1987) as reported
     in the Journal of Phase Equilibria (Sundman, 1991).
     """
 
-    structural_parameter = params['structural_parameter']
-    curie_temperature = params['curie_temperature'][
-        0] + pressure * params['curie_temperature'][1]
+    structural_parameter = params["structural_parameter"]
+    curie_temperature = (
+        params["curie_temperature"][0] + pressure * params["curie_temperature"][1]
+    )
     tau = temperature / curie_temperature
-    dtaudT = 1. / curie_temperature
-    dtaudP = -(temperature * params['curie_temperature'][1]) / (
-        curie_temperature * curie_temperature)
-    d2taudPdT = params['curie_temperature'][
-        1] / (curie_temperature * curie_temperature)
-    d2taudP2 = (2. * temperature * params['curie_temperature'][1]
-                * params['curie_temperature'][1]
-                / (curie_temperature * curie_temperature * curie_temperature))
-    magnetic_moment = params['magnetic_moment'][
-        0] + pressure * params['magnetic_moment'][1]
-    dmagnetic_momentdP = params['magnetic_moment'][1]
+    dtaudT = 1.0 / curie_temperature
+    dtaudP = -(temperature * params["curie_temperature"][1]) / (
+        curie_temperature * curie_temperature
+    )
+    d2taudPdT = params["curie_temperature"][1] / (curie_temperature * curie_temperature)
+    d2taudP2 = (
+        2.0
+        * temperature
+        * params["curie_temperature"][1]
+        * params["curie_temperature"][1]
+        / (curie_temperature * curie_temperature * curie_temperature)
+    )
+    magnetic_moment = (
+        params["magnetic_moment"][0] + pressure * params["magnetic_moment"][1]
+    )
+    dmagnetic_momentdP = params["magnetic_moment"][1]
 
-    A = (518. / 1125.) + (11692. / 15975.) * ((1. / structural_parameter) - 1.)
+    A = (518.0 / 1125.0) + (11692.0 / 15975.0) * ((1.0 / structural_parameter) - 1.0)
     if tau < 1:
-        f = 1. - (1. / A) * (79. / (140. * structural_parameter * tau)
-                             + (474. / 497.) * (1. / structural_parameter - 1.)
-                             * (np.power(tau, 3.) / 6.
-                                + np.power(tau, 9.) / 135.
-                                + np.power(tau, 15.) / 600.))
-        dfdtau = -(1. / A) * (-79. / (140. * structural_parameter * tau * tau)
-                              + (474. / 497.) * (1. / structural_parameter
-                                                 - 1.)
-                              * (tau * tau / 2.
-                                 + np.power(tau, 8.) / 15.
-                                 + np.power(tau, 14.) / 40.))
-        d2fdtau2 = -(1. / A) * (2. * 79. / (140. * structural_parameter
-                                            * np.power(tau, 3.))
-                                + (474. / 497.) * (1. / structural_parameter
-                                                   - 1.)
-                                * (tau
-                                   + 8. * np.power(tau, 7.) / 15.
-                                   + 14. * np.power(tau, 13.) / 40.))
+        f = 1.0 - (1.0 / A) * (
+            79.0 / (140.0 * structural_parameter * tau)
+            + (474.0 / 497.0)
+            * (1.0 / structural_parameter - 1.0)
+            * (
+                np.power(tau, 3.0) / 6.0
+                + np.power(tau, 9.0) / 135.0
+                + np.power(tau, 15.0) / 600.0
+            )
+        )
+        dfdtau = -(1.0 / A) * (
+            -79.0 / (140.0 * structural_parameter * tau * tau)
+            + (474.0 / 497.0)
+            * (1.0 / structural_parameter - 1.0)
+            * (tau * tau / 2.0 + np.power(tau, 8.0) / 15.0 + np.power(tau, 14.0) / 40.0)
+        )
+        d2fdtau2 = -(1.0 / A) * (
+            2.0 * 79.0 / (140.0 * structural_parameter * np.power(tau, 3.0))
+            + (474.0 / 497.0)
+            * (1.0 / structural_parameter - 1.0)
+            * (
+                tau
+                + 8.0 * np.power(tau, 7.0) / 15.0
+                + 14.0 * np.power(tau, 13.0) / 40.0
+            )
+        )
 
     else:
-        f = - (1. / A) * (np.power(tau, -5.) / 10. + np.power(
-                tau, -15.) / 315. + np.power(tau, -25.) / 1500.)
-        dfdtau = (1. / A) * (np.power(tau, -6.) / 2.
-                             + np.power(tau, -16.) / 21.
-                             + np.power(tau, -26.)
-                             / 60.)
-        d2fdtau2 = - (1. / A) * (6. * np.power(tau, -7.) / 2. + 16.
-                                 * np.power(tau, -17.) / 21. + 26.
-                                 * np.power(tau, -27.)
-                                 / 60.)
+        f = -(1.0 / A) * (
+            np.power(tau, -5.0) / 10.0
+            + np.power(tau, -15.0) / 315.0
+            + np.power(tau, -25.0) / 1500.0
+        )
+        dfdtau = (1.0 / A) * (
+            np.power(tau, -6.0) / 2.0
+            + np.power(tau, -16.0) / 21.0
+            + np.power(tau, -26.0) / 60.0
+        )
+        d2fdtau2 = -(1.0 / A) * (
+            6.0 * np.power(tau, -7.0) / 2.0
+            + 16.0 * np.power(tau, -17.0) / 21.0
+            + 26.0 * np.power(tau, -27.0) / 60.0
+        )
 
     dfdT = dfdtau * dtaudT
     d2fdT2 = d2fdtau2 * dtaudT * dtaudT
     dfdP = dfdtau * dtaudP
     d2fdP2 = d2fdtau2 * dtaudP * dtaudP + dfdtau * d2taudP2
     d2fdPdT = d2fdtau2 * dtaudT * dtaudP - dfdtau * d2taudPdT
 
-    G = gas_constant * temperature * np.log(magnetic_moment + 1.) * f
-    dGdT = gas_constant * \
-        np.log(magnetic_moment + 1.) * (f + temperature * dfdT)
-    d2GdT2 = gas_constant * \
-        np.log(magnetic_moment + 1.) * (2. * dfdT + temperature * d2fdT2)
-
-    dGdP = gas_constant * temperature * (f * dmagnetic_momentdP
-                                         / (magnetic_moment + 1.)
-                                         + dfdP * np.log(magnetic_moment + 1.))
-    d2GdP2 = gas_constant * temperature * (-f * np.power(dmagnetic_momentdP
-                                                         / (magnetic_moment + 1.), 2.)
-                                           + 2 * dfdP * dmagnetic_momentdP
-                                           / (magnetic_moment + 1.)
-                                           + d2fdP2 * np.log(magnetic_moment + 1.))
-    d2GdPdT = dGdP / temperature + (gas_constant * temperature
-                                    * np.log(magnetic_moment + 1.)
-                                    * d2fdPdT
-                                    + gas_constant * temperature
-                                    * dmagnetic_momentdP
-                                    / (magnetic_moment + 1.) * dfdT)
+    G = gas_constant * temperature * np.log(magnetic_moment + 1.0) * f
+    dGdT = gas_constant * np.log(magnetic_moment + 1.0) * (f + temperature * dfdT)
+    d2GdT2 = (
+        gas_constant
+        * np.log(magnetic_moment + 1.0)
+        * (2.0 * dfdT + temperature * d2fdT2)
+    )
+
+    dGdP = (
+        gas_constant
+        * temperature
+        * (
+            f * dmagnetic_momentdP / (magnetic_moment + 1.0)
+            + dfdP * np.log(magnetic_moment + 1.0)
+        )
+    )
+    d2GdP2 = (
+        gas_constant
+        * temperature
+        * (
+            -f * np.power(dmagnetic_momentdP / (magnetic_moment + 1.0), 2.0)
+            + 2 * dfdP * dmagnetic_momentdP / (magnetic_moment + 1.0)
+            + d2fdP2 * np.log(magnetic_moment + 1.0)
+        )
+    )
+    d2GdPdT = dGdP / temperature + (
+        gas_constant * temperature * np.log(magnetic_moment + 1.0) * d2fdPdT
+        + gas_constant
+        * temperature
+        * dmagnetic_momentdP
+        / (magnetic_moment + 1.0)
+        * dfdT
+    )
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
+
+    return (excesses, None)
+
+
+def _debye_excesses(pressure, temperature, params):
+    """
+    Applies an excess contribution based
+    on a Debye model. The excess heat capacity
+    tends toward a constant value at high temperature.
+    """
+    f = params["Cv_inf"] / 3.0 / gas_constant
+    theta = params["Theta_0"]
+
+    G = debye.helmholtz_free_energy(temperature, theta, f)
+    dGdT = -debye.entropy(temperature, theta, f)
+    dGdP = 0.0
+    if temperature > 1.0e-20:
+        d2GdT2 = -debye.molar_heat_capacity_v(temperature, theta, f) / temperature
+    else:
+        d2GdT2 = 0.0
+    d2GdP2 = 0.0
+    d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
+
+    return (excesses, None)
+
 
-    excesses = {'G': G, 'dGdT': dGdT, 'dGdP': dGdP,
-                'd2GdT2': d2GdT2, 'd2GdP2': d2GdP2, 'd2GdPdT': d2GdPdT}
+def _debye_delta_excesses(pressure, temperature, params):
+    """
+    Applies an excess contribution based
+    on the thermal derivatives of a Debye model.
+    The excess entropy tends toward a
+    constant value at high temperature
+    and behaves like the heat capacity of a Debye model
+    at finite temperature.
+    """
+    f = params["S_inf"] / 3.0 / gas_constant
+    theta = params["Theta_0"]
+
+    G = -debye.thermal_energy(temperature, theta, f)
+    dGdT = -debye.molar_heat_capacity_v(temperature, theta, f)
+    dGdP = 0.0
+    d2GdT2 = -debye.dmolar_heat_capacity_v_dT(temperature, theta, f)
+    d2GdP2 = 0.0
+    d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
+
+    return (excesses, None)
+
+
+def _einstein_excesses(pressure, temperature, params):
+    """
+    Applies an excess contribution based
+    on an Einstein model. The excess heat capacity
+    tends toward a constant value at high temperature.
+    """
+    f = params["Cv_inf"] / 3.0 / gas_constant
+    theta = params["Theta_0"]
+
+    G = einstein.helmholtz_free_energy(temperature, theta, f)
+    dGdT = -einstein.entropy(temperature, theta, f)
+    dGdP = 0.0
+    if temperature > 1.0e-20:
+        d2GdT2 = -einstein.molar_heat_capacity_v(temperature, theta, f) / temperature
+    else:
+        d2GdT2 = 0.0
+    d2GdP2 = 0.0
+    d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
+
+    return (excesses, None)
+
+
+def _einstein_delta_excesses(pressure, temperature, params):
+    """
+    Applies an excess contribution based
+    on the thermal derivatives of an Einstein model.
+    The excess entropy tends toward a
+    constant value at high temperature
+    and behaves like the heat capacity of an Einstein model
+    at finite temperature.
+    """
+    f = params["S_inf"] / 3.0 / gas_constant
+    theta = params["Theta_0"]
+
+    G = -einstein.thermal_energy(temperature, theta, f)
+    dGdT = -einstein.molar_heat_capacity_v(temperature, theta, f)
+    dGdP = 0.0
+    d2GdT2 = -einstein.dmolar_heat_capacity_v_dT(temperature, theta, f)
+    d2GdP2 = 0.0
+    d2GdPdT = 0.0
+
+    excesses = {
+        "G": G,
+        "dGdT": dGdT,
+        "dGdP": dGdP,
+        "d2GdT2": d2GdT2,
+        "d2GdP2": d2GdP2,
+        "d2GdPdT": d2GdPdT,
+    }
 
     return (excesses, None)
 
 
 def calculate_property_modifications(mineral):
     """
     Sums the excesses from all the modifiers.
@@ -366,29 +673,50 @@
 
     H = gibbs + temperature*S
     helmholtz = gibbs - pressure*V
     C_v = C_p - V*temperature*alpha*alpha*K_T
     gr = alpha*K_T*V/C_v
     K_S = K_T*C_p/C_v
     """
-    excesses = {'G': 0., 'dGdT': 0., 'dGdP': 0.,
-                'd2GdT2': 0., 'd2GdP2': 0., 'd2GdPdT': 0.}
+    excesses = {
+        "G": 0.0,
+        "dGdT": 0.0,
+        "dGdP": 0.0,
+        "d2GdT2": 0.0,
+        "d2GdP2": 0.0,
+        "d2GdPdT": 0.0,
+    }
     mineral.property_modifier_properties = []
     for modifier in mineral.property_modifiers:
-        if modifier[0] == 'landau':
+        if modifier[0] == "landau":
             xs_function = _landau_excesses
-        if modifier[0] == 'landau_hp':
+        elif modifier[0] == "landau_slb_2022":
+            xs_function = _landau_slb_2022_excesses
+        elif modifier[0] == "landau_hp":
             xs_function = _landau_hp_excesses
-        if modifier[0] == 'linear':
+        elif modifier[0] == "linear":
             xs_function = _linear_excesses
-        if modifier[0] == 'bragg_williams':
+        elif modifier[0] == "bragg_williams":
             xs_function = _bragg_williams_excesses
-        if modifier[0] == 'magnetic_chs':
+        elif modifier[0] == "magnetic_chs":
             xs_function = _magnetic_excesses_chs
+        elif modifier[0] == "debye":
+            xs_function = _debye_excesses
+        elif modifier[0] == "debye_delta":
+            xs_function = _debye_delta_excesses
+        elif modifier[0] == "einstein":
+            xs_function = _einstein_excesses
+        elif modifier[0] == "einstein_delta":
+            xs_function = _einstein_delta_excesses
+        else:
+            raise Exception(
+                f"Property modifier label for {mineral.name} ({modifier[0]}) not recognised."
+            )
 
         xs_component, properties = xs_function(
-            mineral.pressure, mineral.temperature, modifier[1])
+            mineral.pressure, mineral.temperature, modifier[1]
+        )
         mineral.property_modifier_properties.append(properties)
         for key in xs_component:
             excesses[key] += xs_component[key]
 
     return excesses
```

### Comparing `burnman-1.1.0/burnman/eos/reciprocal_kprime.py` & `burnman-1.2.0/burnman/eos/reciprocal_kprime.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 from __future__ import absolute_import
+
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 
 import scipy.optimize as opt
 from scipy.special import gamma, gammainc
@@ -13,88 +14,117 @@
 
 # Try to import the jit from numba.  If it is
 # not available, just go with the standard
 # python interpreter
 try:
     from numba import jit
 except ImportError:
+
     def jit(fn):
         return fn
 
 
-@jit
+@jit(nopython=True)
 def _delta_PoverK_from_P(PoverK, pressure, K_0, Kprime_0, Kprime_inf):
-    return PoverK - (pressure/K_0)*np.power((1. - Kprime_inf*PoverK), Kprime_0/Kprime_inf) # eq. 58
+    return PoverK - (pressure / K_0) * np.power(
+        (1.0 - Kprime_inf * PoverK), Kprime_0 / Kprime_inf
+    )  # eq. 58
+
 
-@jit
+@jit(nopython=True)
 def _delta_PoverK_from_V(PoverK, V, V_0, K_0, Kprime_0, Kprime_inf):
     Kprime_ratio = Kprime_0 / Kprime_inf
-    return ( np.log( V_0 / V ) +
-             Kprime_ratio / Kprime_inf * np.log(1. - Kprime_inf * PoverK) +
-             (Kprime_ratio - 1.) * PoverK ) # eq. 61
+    return (
+        np.log(V_0 / V)
+        + Kprime_ratio / Kprime_inf * np.log(1.0 - Kprime_inf * PoverK)
+        + (Kprime_ratio - 1.0) * PoverK
+    )  # eq. 61
+
 
 def _upper_incomplete_gamma(z, a):
     """
     An implementation of the non-regularised upper incomplete gamma
     function. Computed using the relationship with the regularised
     lower incomplete gamma function (scipy.special.gammainc).
     Uses the recurrence relation wherever z<0.
     """
     n = int(-np.floor(z))
     if n > 0:
         z = z + n
-        u_gamma = (1. - gammainc(z, a))*gamma(z)
+        u_gamma = (1.0 - gammainc(z, a)) * gamma(z)
 
         for i in range(n):
-            z = z - 1.
-            u_gamma = (u_gamma - np.power(a, z)*np.exp(-a))/z
+            z = z - 1.0
+            u_gamma = (u_gamma - np.power(a, z) * np.exp(-a)) / z
         return u_gamma
     else:
-        return (1. - gammainc(z, a))*gamma(z)
+        return (1.0 - gammainc(z, a)) * gamma(z)
+
 
 def _PoverK_from_P(pressure, params):
     """
     Calculates the pressure:bulk modulus ratio
     from a given pressure using brentq optimization
     """
-    args = ((pressure - params['P_0']), params['K_0'],
-            params['Kprime_0'], params['Kprime_inf'])
-    return opt.brentq(_delta_PoverK_from_P,
-                      1./(params['Kprime_inf'] - params['Kprime_0']) + np.finfo(float).eps,
-                      1./params['Kprime_inf'] - np.finfo(float).eps,
-                      args=args)
+    args = (
+        (pressure - params["P_0"]),
+        params["K_0"],
+        params["Kprime_0"],
+        params["Kprime_inf"],
+    )
+    return opt.brentq(
+        _delta_PoverK_from_P,
+        1.0 / (params["Kprime_inf"] - params["Kprime_0"]) + np.finfo(float).eps,
+        1.0 / params["Kprime_inf"] - np.finfo(float).eps,
+        args=args,
+    )
+
 
 def _PoverK_from_V(volume, params):
     """
     Calculates the pressure:bulk modulus ratio
     from a given volume using brentq optimization
     """
-    args = (volume, params['V_0'], params['K_0'],
-            params['Kprime_0'], params['Kprime_inf'])
-    return opt.brentq(_delta_PoverK_from_V,
-                      1./(params['Kprime_inf'] - params['Kprime_0']) + np.finfo(float).eps,
-                      1./params['Kprime_inf'] - np.finfo(float).eps,
-                      args=args)
+    args = (
+        volume,
+        params["V_0"],
+        params["K_0"],
+        params["Kprime_0"],
+        params["Kprime_inf"],
+    )
+    return opt.brentq(
+        _delta_PoverK_from_V,
+        1.0 / (params["Kprime_inf"] - params["Kprime_0"]) + np.finfo(float).eps,
+        1.0 / params["Kprime_inf"] - np.finfo(float).eps,
+        args=args,
+    )
+
 
 def bulk_modulus(pressure, params):
     """
     Returns the bulk modulus at a given pressure
     """
     PoverK = _PoverK_from_P(pressure, params)
-    K = params['K_0']*np.power((1. - params['Kprime_inf']*PoverK), -
-                               params['Kprime_0']/params['Kprime_inf'])
+    K = params["K_0"] * np.power(
+        (1.0 - params["Kprime_inf"] * PoverK),
+        -params["Kprime_0"] / params["Kprime_inf"],
+    )
     return K
 
+
 def shear_modulus(pressure, params):
     """
     Returns the shear modulus at a given pressure
     """
-    G = ( params['G_0']/params['K_0'] * bulk_modulus(pressure, params) -
-          (params['G_0']/params['K_0']*params['Kprime_inf'] - params['Gprime_inf']) * pressure )
-    return G # eq. 78
+    G = (
+        params["G_0"] / params["K_0"] * bulk_modulus(pressure, params)
+        - (params["G_0"] / params["K_0"] * params["Kprime_inf"] - params["Gprime_inf"])
+        * pressure
+    )
+    return G  # eq. 78
 
 
 class RKprime(eos.EquationOfState):
 
     """
     Class for the isothermal reciprocal K-prime equation of state
     detailed in :cite:`StaceyDavis2004`.  This equation of state is
@@ -116,31 +146,39 @@
     This equation of state has no temperature dependence.
     """
 
     def volume(self, pressure, temperature, params):
         """
         Returns volume :math:`[m^3]` as a function of pressure :math:`[Pa]`.
         """
-        Kprime_ratio = params['Kprime_0']/params['Kprime_inf']
+        Kprime_ratio = params["Kprime_0"] / params["Kprime_inf"]
         PoverK = _PoverK_from_P(pressure, params)
 
-        V = params['V_0'] * np.exp( Kprime_ratio/params['Kprime_inf'] *
-                                    np.log(1. - params['Kprime_inf'] * PoverK) +
-                                    (Kprime_ratio - 1.) * PoverK ) # Eq. 61
+        V = params["V_0"] * np.exp(
+            Kprime_ratio
+            / params["Kprime_inf"]
+            * np.log(1.0 - params["Kprime_inf"] * PoverK)
+            + (Kprime_ratio - 1.0) * PoverK
+        )  # Eq. 61
 
         return V
 
     def pressure(self, temperature, volume, params):
         """
         Returns pressure :math:`[Pa]` as a function of volume :math:`[m^3]`.
         """
         PoverK = _PoverK_from_V(volume, params)
-        return params['P_0'] + ( params['K_0'] * PoverK *
-                                 np.power(1. - params['Kprime_inf'] * PoverK,
-                                          -params['Kprime_0']/params['Kprime_inf']) )
+        return params["P_0"] + (
+            params["K_0"]
+            * PoverK
+            * np.power(
+                1.0 - params["Kprime_inf"] * PoverK,
+                -params["Kprime_0"] / params["Kprime_inf"],
+            )
+        )
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`K_T` :math:`[Pa]` as a function of pressure :math:`[Pa]`,
         temperature :math:`[K]` and volume :math:`[m^3]`.
         """
         return bulk_modulus(pressure, params)
@@ -157,106 +195,126 @@
         """
         return shear_modulus(pressure, params)
 
     def entropy(self, pressure, temperature, volume, params):
         """
         Returns the molar entropy :math:`\mathcal{S}` of the mineral. :math:`[J/K/mol]`
         """
-        return 0.
+        return 0.0
 
     def _intVdP(self, xi, params):
-
-        a = params['Kprime_inf']
-        b = (params['Kprime_0']/params['Kprime_inf']/params['Kprime_inf'] -
-             params['Kprime_0']/params['Kprime_inf'] - 1.)
-        c = params['Kprime_0'] - params['Kprime_inf']
-        f = (params['Kprime_0']/params['Kprime_inf'] - 1.)
-
-        i1 = float( params['V_0'] * params['K_0'] *
-                    np.exp(f / a) * np.power(a, b - 1.) /
-                    np.power(f, b + 2.) *
-                    ( f * params['Kprime_0'] * _upper_incomplete_gamma( b + 1. ,
-                                                                        f * (1./a - xi) ) -
-                      a * c * _upper_incomplete_gamma( b + 2., f * (1./a - xi) ) ) )
+        a = params["Kprime_inf"]
+        b = (
+            params["Kprime_0"] / params["Kprime_inf"] / params["Kprime_inf"]
+            - params["Kprime_0"] / params["Kprime_inf"]
+            - 1.0
+        )
+        c = params["Kprime_0"] - params["Kprime_inf"]
+        f = params["Kprime_0"] / params["Kprime_inf"] - 1.0
+
+        i1 = float(
+            params["V_0"]
+            * params["K_0"]
+            * np.exp(f / a)
+            * np.power(a, b - 1.0)
+            / np.power(f, b + 2.0)
+            * (
+                f
+                * params["Kprime_0"]
+                * _upper_incomplete_gamma(b + 1.0, f * (1.0 / a - xi))
+                - a * c * _upper_incomplete_gamma(b + 2.0, f * (1.0 / a - xi))
+            )
+        )
 
         return i1
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
         Returns the Gibbs free energy :math:`\mathcal{G}` of the mineral. :math:`[J/mol]`
         """
         # G = E0 + int VdP (when S = 0)
         K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
-        return params['E_0'] + params['P_0']*params['V_0'] + self._intVdP((pressure - params['P_0'])/K, params) - self._intVdP(0., params)
+        return (
+            params["E_0"]
+            + params["P_0"] * params["V_0"]
+            + self._intVdP((pressure - params["P_0"]) / K, params)
+            - self._intVdP(0.0, params)
+        )
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
         Returns the internal energy :math:`\mathcal{E}` of the mineral. :math:`[J/mol]`
         """
         # E = G - PV (+ TS)
-        return ( self.gibbs_free_energy(pressure, temperature, volume, params) - pressure*volume)
+        return (
+            self.gibbs_free_energy(pressure, temperature, volume, params)
+            - pressure * volume
+        )
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return a very large number. :math:`[J/K/mol]`
         """
-        return 1.e99
+        return 1.0e99
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[1/K]`
         """
-        return 0.
+        return 0.0
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Since this equation of state does not contain temperature effects, simply return zero. :math:`[unitless]`
         """
-        return 0.
+        return 0.0
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters.
         The value for :math:`K'_{\infty}` is thermodynamically bounded
         between 5/3 and :math:`K'_0` :cite:`StaceyDavis2004`.
         """
 
-        if 'E_0' not in params:
-            params['E_0'] = 0.
-        if 'P_0' not in params:
-            params['P_0'] = 0.
+        if "E_0" not in params:
+            params["E_0"] = 0.0
+        if "P_0" not in params:
+            params["P_0"] = 0.0
 
         # If G and Gprime_inf are not included this is presumably deliberate,
         # as we can model density and bulk modulus just fine without them,
         # so just add them to the dictionary as nans
-        if 'G_0' not in params:
-            params['G_0'] = float('nan')
-        if 'Gprime_inf' not in params:
-            params['Gprime_inf'] = float('nan')
+        if "G_0" not in params:
+            params["G_0"] = float("nan")
+        if "Gprime_inf" not in params:
+            params["Gprime_inf"] = float("nan")
 
         # Check that all the required keys are in the dictionary
-        expected_keys = ['V_0', 'K_0', 'Kprime_0', 'Kprime_inf', 'G_0', 'Gprime_inf']
+        expected_keys = ["V_0", "K_0", "Kprime_0", "Kprime_inf", "G_0", "Gprime_inf"]
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['P_0'] < 0.:
-            warnings.warn('Unusual value for P_0', stacklevel=2)
-        if params['V_0'] < 1.e-7 or params['V_0'] > 1.e-3:
-            warnings.warn('Unusual value for V_0', stacklevel=2)
-        if params['K_0'] < 1.e9 or params['K_0'] > 1.e13:
-            warnings.warn('Unusual value for K_0', stacklevel=2)
-        if params['Kprime_0'] < 0. or params['Kprime_0'] > 10.:
-            warnings.warn('Unusual value for Kprime_0', stacklevel=2)
-        if params['Kprime_inf'] < 5./3. or params['Kprime_inf'] > params['Kprime_0']:
-            warnings.warn('Unusual value for Kprime_inf', stacklevel=2) # eq. 17
-        if params['G_0'] < 0.0 or params['G_0'] > 1.e13:
-            warnings.warn('Unusual value for G_0', stacklevel=2)
-        if params['Gprime_inf'] < -5. or params['Gprime_inf'] > 10.:
-            warnings.warn('Unusual value for Gprime_inf', stacklevel=2)
+        if params["P_0"] < 0.0:
+            warnings.warn("Unusual value for P_0", stacklevel=2)
+        if params["V_0"] < 1.0e-7 or params["V_0"] > 1.0e-3:
+            warnings.warn("Unusual value for V_0", stacklevel=2)
+        if params["K_0"] < 1.0e9 or params["K_0"] > 1.0e13:
+            warnings.warn("Unusual value for K_0", stacklevel=2)
+        if params["Kprime_0"] < 0.0 or params["Kprime_0"] > 10.0:
+            warnings.warn("Unusual value for Kprime_0", stacklevel=2)
+        if (
+            params["Kprime_inf"] < 5.0 / 3.0
+            or params["Kprime_inf"] > params["Kprime_0"]
+        ):
+            warnings.warn("Unusual value for Kprime_inf", stacklevel=2)  # eq. 17
+        if params["G_0"] < 0.0 or params["G_0"] > 1.0e13:
+            warnings.warn("Unusual value for G_0", stacklevel=2)
+        if params["Gprime_inf"] < -5.0 or params["Gprime_inf"] > 10.0:
+            warnings.warn("Unusual value for Gprime_inf", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/eos/slb.py` & `burnman-1.2.0/burnman/eos/aa.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,445 +1,473 @@
-# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit
-# for the Earth and Planetary Sciences
-# Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
-# GPL v2 or later.
+# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
+# Copyright (C) 2012 - 2015 by the BurnMan team, released under the GNU GPL v2 or later.
 
 from __future__ import absolute_import
 
 import numpy as np
-import scipy.optimize as opt
+from scipy.optimize import brentq
 import warnings
 
-# Try to import the jit from numba.  If it is
-# not available, just go with the standard
-# python interpreter
-try:
-    from numba import jit
-except ImportError:
-    def jit(fn):
-        return fn
+from . import equation_of_state as eos
+from ..constants import gas_constant
 
 
-from . import birch_murnaghan as bm
-from . import debye
-from . import equation_of_state as eos
-from ..utils.math import bracket
+class AA(eos.EquationOfState):
+    """
+    Class for the :math`E-V-S` liquid metal EOS detailed in :cite:`AA1994`.
+    Internal energy (:math:`E`) is first calculated
+    along a reference isentrope using a fourth order BM EoS
+    (:math:`V_0`, :math:`KS`, :math:`KS'`, :math:`KS''`),
+    which gives volume as a function of pressure,
+    coupled with the thermodynamic identity:
 
+    :math:`-\partial E/ \partial V |_S = P`.
 
-@jit
-def _grueneisen_parameter_fast(V_0, volume, gruen_0, q_0):
-    """global function with plain parameters so jit will work"""
-    x = V_0 / volume
-    f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-    a1_ii = 6. * gruen_0  # EQ 47
-    a2_iikk = -12. * gruen_0 + 36. * \
-        gruen_0 * gruen_0 - 18. * q_0 * gruen_0  # EQ 47
-    nu_o_nu0_sq = 1. + a1_ii * f + (1. / 2.) * a2_iikk * f * f  # EQ 41
-    return 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
-
-
-@jit
-def _delta_pressure(x, pressure, temperature, V_0, T_0, Debye_0, n, a1_ii,
-                    a2_iikk, b_iikk, b_iikkmm):
-
-    f = 0.5 * (pow(V_0 / x, 2. / 3.) - 1.)
-    nu_o_nu0_sq = 1. + a1_ii * f + 1. / 2. * a2_iikk * f * f
-    debye_temperature = Debye_0 * np.sqrt(nu_o_nu0_sq)
-    E_th = debye.thermal_energy(
-        temperature, debye_temperature, n)  # thermal energy at temperature T
-    E_th_ref = debye.thermal_energy(
-        T_0, debye_temperature, n)  # thermal energy at reference temperature
-    nu_o_nu0_sq = 1. + a1_ii * f + (1. / 2.) * a2_iikk * f * f  # EQ 41
-    gr = 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
-
-    return ((1. / 3.)
-            * (pow(1. + 2. * f, 5. / 2.)) * ((b_iikk * f)
-                                             + (0.5 * b_iikkmm * f * f))
-            + gr * (E_th - E_th_ref) / x - pressure)  # EQ 21
+    The temperature along the isentrope is calculated via
 
+    :math:`\partial (\ln T)/\partial (\ln \\rho) |_S = \gamma`
 
-class SLBBase(eos.EquationOfState):
+    which gives:
 
-    """
-    Base class for the finite strain-Mie-Grueneiesen-Debye equation of state
-    detailed in :cite:`Stixrude2005`.  For the most part the equations are
-    all third order in strain, but see further the :class:`burnman.slb.SLB2`
-    and :class:`burnman.slb.SLB3` classes.
+    :math:`T_S/T_0 = \exp(\int( \gamma/\\rho ) d \\rho)`
+
+    The thermal effect on internal energy is calculated at constant volume
+    using expressions for the kinetic, electronic and potential contributions
+    to the volumetric heat capacity, which can then be integrated with respect
+    to temperature:
+
+    :math:`\partial E/\partial T |_V = C_V`
+
+    :math:`\partial E/\partial S |_V = T`
+
+    We note that :cite:`AA1994` also include a detailed description
+    of the Gruneisen parameter as a function of volume and energy (Equation 15),
+    and use this to determine the temperature along the principal isentrope
+    (Equations B1-B10) and the thermal pressure away from that isentrope
+    (Equation 23). However, this expression is inconsistent with
+    the equation of state away from the principal isentrope. Here we choose
+    to calculate the thermal pressure and Grueneisen parameter thus:
+
+    1) As energy and entropy are defined by the equation of state at any
+    temperature and volume, pressure can be found by via the expression:
+
+    :math:`\partial E/\partial V |_S = P`
+
+    2) The Grueneisen parameter can now be determined as
+    :math:`\gamma = V \partial P/\partial E |_V`
+
+    To reiterate: away from the reference isentrope, the Grueneisen parameter
+    calculated using these expressions is *not* equal to the
+    (thermodynamically inconsistent) analytical expression given by :cite:`AA1994`.
+
+    A final note: the expression for :math:`\Lambda` (Equation 17).
+    does not reproduce Figure 5. We assume here that the figure matches the model
+    actually used by :cite:`AA1994`, which has the form:
+    :math:`F(-325.23 + 302.07 (\\rho/\\rho_0) + 30.45 (\\rho/\\rho_0)^{0.4})`.
     """
 
-    def _debye_temperature(self, x, params):
+    def _ABTheta(self, V, params):
         """
-        Finite strain approximation for Debye Temperature [K]
-        x = ref_vol/vol
+        Electronic heat capacity functions
         """
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = (-12. * params['grueneisen_0']
-                   + 36. * pow(params['grueneisen_0'], 2.)
-                   - 18. * params['q_0'] * params['grueneisen_0'])  # EQ 47
-        nu_o_nu0_sq = 1. + a1_ii * f + 1. / 2. * a2_iikk * f * f
-        if nu_o_nu0_sq > 0.:
-            return params['Debye_0'] * np.sqrt(nu_o_nu0_sq)
-        else:
-            raise Exception(f'This volume (V = {1./x:.2f}*V_0) exceeds the '
-                            'valid range of the thermal '
-                            'part of the slb equation of state.')
+        Vfrac = V / params["V_0"]
+
+        A = params["a"][0] + params["a"][1] * Vfrac  # A2
+        B = params["b"][0] + params["b"][1] * Vfrac * Vfrac  # A3
+        Theta = params["Theta"][0] * np.power(Vfrac, -params["Theta"][1])  # A4
+
+        return A, B, Theta
+
+    def _lambdaxi(self, V, params):
+        """
+        Potential heat capacity functions
+        """
+        rhofrac = params["V_0"] / V
+        xi = params["xi_0"] * np.power(rhofrac, -0.6)  # A16
+        F = 1.0 / (1.0 + np.exp((rhofrac - params["F"][0]) / params["F"][1]))  # A18
+        # lmda = (F*(params['lmda'][0] + params['lmda'][1]*rhofrac) + params['lmda'][2])*np.power(rhofrac, 0.4) # A17
+        lmda = F * (
+            params["lmda"][0]
+            + params["lmda"][1] * rhofrac
+            + params["lmda"][2] * np.power(rhofrac, 0.4)
+        )  # this incorrect expression for lmda seems to provide a very close fit to figure 5
+
+        return lmda, xi
+
+    def _rhofracxksis(self, V, params):
+        """
+        Functions for the fourth order Birch-Murnaghan equation of state
+        """
+        rhofrac = params["V_0"] / V  # rho/rho0 = V0/V
+        x = np.power(rhofrac, 1.0 / 3.0)  # equation 18
+        ksi1 = 0.75 * (4.0 - params["Kprime_S"])  # equation 19
+        ksi2 = (
+            0.375
+            * (
+                params["K_S"] * params["Kprime_prime_S"]
+                + params["Kprime_S"] * (params["Kprime_S"] - 7.0)
+            )
+            + 143.0 / 24.0
+        )  # equation 20
+        return rhofrac, x, ksi1, ksi2
+
+    def _isentropic_temperature(self, V, params):
+        """
+        Temperature along the reference isentrope
+        """
+
+        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)
+
+        # equation B6 -- B10
+        a1 = ksi2 / 8.0
+        a2 = (ksi1 + 3.0 * ksi2) / 6.0
+        a3 = (1.0 + 2.0 * ksi1 + 3.0 * ksi2) / 4.0
+        a4 = (1.0 + ksi1 + ksi2) / 2.0
+        a5 = (6.0 + 4.0 * ksi1 + 3.0 * ksi2) / 24.0
+
+        # equation B5
+        Ts = params["T_0"] * np.exp(
+            params["grueneisen_0"] * np.log(rhofrac)
+            + 13.5
+            * params["grueneisen_prime"]
+            * params["V_0"]
+            * params["K_S"]
+            * (
+                (a1 / (3 * params["grueneisen_n"] + 8.0))
+                * (np.power(x, (3 * params["grueneisen_n"] + 8.0)) - 1.0)
+                - (a2 / (3 * params["grueneisen_n"] + 6.0))
+                * (np.power(x, (3 * params["grueneisen_n"] + 6.0)) - 1.0)
+                + (a3 / (3 * params["grueneisen_n"] + 4.0))
+                * (np.power(x, (3 * params["grueneisen_n"] + 4.0)) - 1.0)
+                - (a4 / (3 * params["grueneisen_n"] + 2.0))
+                * (np.power(x, (3 * params["grueneisen_n"] + 2.0)) - 1.0)
+                + (a5 / (3 * params["grueneisen_n"] + 0.0))
+                * (np.power(x, (3 * params["grueneisen_n"] + 0.0)) - 1.0)
+            )
+        )
+
+        return Ts
+
+    def _isentropic_pressure(self, V, params):
+        """
+        Pressure along the reference isentrope
+        """
+        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)
+        x2 = x * x
+        x3 = x * x * x
+        x5 = x3 * x2
+        x7 = x5 * x2
+
+        Ps = (
+            1.5
+            * params["K_S"]
+            * (x7 - x5)
+            * (1.0 + ksi1 - ksi1 * x2 + ksi2 * (x2 - 1.0) * (x2 - 1.0))
+        )  # Eq. 17
+
+        return Ps
+
+    def _isentropic_energy_change(self, V, params):
+        """
+        Birch Murnaghan equation of state expression for the energy change along an isentrope
+        """
+        rhofrac, x, ksi1, ksi2 = self._rhofracxksis(V, params)
+        x2 = x * x
+        x4 = x2 * x2
+        x6 = x4 * x2
+        x8 = x4 * x4
+
+        E_S = (
+            4.5
+            * params["V_0"]
+            * params["K_S"]
+            * (
+                (ksi1 + 1.0) * (x4 / 4.0 - x2 / 2.0 + 1.0 / 4.0)
+                - ksi1 * (x6 / 6.0 - x4 / 4.0 + 1.0 / 12.0)
+                + ksi2 * (x8 / 8.0 - x6 / 2.0 + 3.0 * x4 / 4.0 - x2 / 2.0 + 1.0 / 8.0)
+            )
+        )  # Eq. 21
+        return E_S
+
+    def _isochoric_energy_change(self, Ts, T, V, params):
+        """
+        int Cv dT
+        """
+        A, B, Theta = self._ABTheta(V, params)
+        lmda, xi = self._lambdaxi(V, params)
+
+        E_kin = 1.5 * params["n"] * gas_constant * (T - Ts)
+        E_el = A * (
+            T - Ts - Theta * (np.arctan(T / Theta) - np.arctan(Ts / Theta))
+        ) + 5.0 / 8 * B * (
+            np.power(T, 1.6) - np.power(Ts, 1.6)
+        )  # A5
+        E_pot = lmda * (T - Ts) + params["theta"] * (xi - lmda) * np.log(
+            (params["theta"] + T) / (params["theta"] + Ts)
+        )  # A19
+
+        return E_kin + E_el + E_pot
 
     def volume_dependent_q(self, x, params):
         """
         Finite strain approximation for :math:`q`, the isotropic volume strain
         derivative of the grueneisen parameter.
         """
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = (-12. * params['grueneisen_0']
-                   + 36. * pow(params['grueneisen_0'], 2.)
-                   - 18. * params['q_0'] * params['grueneisen_0'])  # EQ 47
-        nu_o_nu0_sq = 1. + a1_ii * f + (1. / 2.) * a2_iikk * f * f  # EQ 41
-        gr = 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
-        # avoids divide by zero if grueneisen_0 = 0.
-        if np.abs(params['grueneisen_0']) < 1.e-10:
-            q = 1. / 9. * (18. * gr - 6.)
-        else:
-            q = 1. / 9. * \
-                (18. * gr - 6. - 1. / 2. / nu_o_nu0_sq *
-                 (2. * f + 1.) * (2. * f + 1.) * a2_iikk / gr)
-        return q
+        raise NotImplementedError("")
 
     def _isotropic_eta_s(self, x, params):
         """
         Finite strain approximation for :math:`eta_{s0}`, the isotropic shear
         strain derivative of the grueneisen parameter.
+        Zero for a liquid
         """
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        a2_s = -2. * params['grueneisen_0'] - 2. * params['eta_s_0']  # EQ 47
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = (-12. * params['grueneisen_0']
-                   + 36. * pow(params['grueneisen_0'], 2.)
-                   - 18. * params['q_0'] * params['grueneisen_0'])  # EQ 47
-        nu_o_nu0_sq = 1. + a1_ii * f + \
-            (1. / 2.) * a2_iikk * pow(f, 2.)  # EQ 41
-        gr = 1. / 6. / nu_o_nu0_sq * (2. * f + 1.) * (a1_ii + a2_iikk * f)
-        # EQ 46 NOTE the typo from Stixrude 2005:
-        eta_s = - gr - \
-            (1. / 2. * pow(nu_o_nu0_sq, -1.) * pow((2. * f) + 1., 2.) * a2_s)
-
-        return eta_s
-
-    # calculate isotropic thermal pressure, see
-    # Matas et. al. (2007) eq B4
-    def _thermal_pressure(self, T, V, params):
-        Debye_T = self._debye_temperature(params['V_0'] / V, params)
-        gr = self.grueneisen_parameter(0., T, V, params)  # P not important
-        P_th = gr * debye.thermal_energy(T, Debye_T, params['n']) / V
-        return P_th
+        return 0.0
 
     def volume(self, pressure, temperature, params):
         """
         Returns molar volume. :math:`[m^3]`
         """
-        T_0 = params['T_0']
-        Debye_0 = params['Debye_0']
-        V_0 = params['V_0']
-        dV = 1.e-2 * params['V_0']
-        n = params['n']
-
-        a1_ii = 6. * params['grueneisen_0']  # EQ 47
-        a2_iikk = (-12. * params['grueneisen_0']
-                   + 36. * pow(params['grueneisen_0'], 2.)
-                   - 18. * params['q_0'] * params['grueneisen_0'])  # EQ 47
-
-        b_iikk = 9. * params['K_0']  # EQ 28
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29z
-
-        # Finding the volume at a given pressure requires a
-        # root-finding scheme. Here we use brentq to find the root.
-
-        # Root-finding using brentq requires bounds to be specified.
-        # We do this using a bracketing function.
-        args = (pressure, temperature, V_0, T_0,
-                Debye_0, n, a1_ii, a2_iikk, b_iikk, b_iikkmm)
-
-        try:
-            # The first attempt to find a bracket for
-            # root finding uses V_0 as a starting point
-            sol = bracket(_delta_pressure, V_0, dV, args)
-        except Exception:
-            # At high temperature, the naive bracketing above may
-            # try a volume guess that exceeds the point at which the
-            # bulk modulus goes negative at that temperature.
-            # In this case, we try a more nuanced approach by
-            # first finding the volume at which the bulk modulus goes
-            # negative, and then either (a) raising an exception if the
-            # desired pressure is less than the pressure at that volume,
-            # or (b) using that pressure to create a better bracket for
-            # brentq.
-            def _K_T(V, T, params):
-                return self.isothermal_bulk_modulus(0., T, V, params)
-
-            sol_K_T = bracket(_K_T, V_0, dV,
-                              args=(temperature, params))
-            V_crit = opt.brentq(_K_T, sol_K_T[0], sol_K_T[1],
-                                args=(temperature, params))
-            P_min = self.pressure(temperature, V_crit, params)
-            if P_min > pressure:
-                raise Exception('The desired pressure is not achievable '
-                                'at this temperature. The minimum pressure '
-                                f'achievable is {P_min:.2e} Pa.')
-            else:
-                try:
-                    sol = bracket(_delta_pressure, V_crit - dV,
-                                  dV, args)
-                except Exception:
-                    raise Exception('Cannot find a volume, perhaps you are '
-                                    'outside of the range of validity for '
-                                    'the equation of state?')
 
-        return opt.brentq(_delta_pressure, sol[0], sol[1], args=args)
+        _volume = lambda V, P, T, params: (P - self.pressure(T, V, params))
+
+        return brentq(
+            _volume,
+            params["V_0"] * 0.1,
+            params["V_0"] * 2.0,
+            args=(pressure, temperature, params),
+        )
 
     def pressure(self, temperature, volume, params):
         """
-        Returns the pressure of the mineral at a given temperature and volume
-        [Pa]
+        Returns the pressure of the mineral at a given temperature and volume [Pa]
+        """
+
+        """
+        Ts = self._isentropic_temperature(volume, params)
+
+
+        dE = self._isochoric_energy_change(Ts, temperature, volume, params)
+        E1 = self._isentropic_energy_change(volume, params) - params['E_0']
+        E2 = E1 + dE
+
+        # Integrate at constant volume (V \int dP = \int gr dE)
+        dP = (params['grueneisen_0']*(E2 - E1) +
+              (0.5*params['grueneisen_prime'] *
+               np.power(params['V_0']/volume, params['grueneisen_n']) *
+               (E2*E2 - E1*E1))) / volume # eq. 23
+
+        P = self._isentropic_pressure(volume, params) + dP
         """
-        debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        gr = self.grueneisen_parameter(
-            0.0, temperature, volume, params)  # does not depend on pressure
-        # thermal energy at temperature T
-        E_th = debye.thermal_energy(temperature, debye_T, params['n'])
-        # thermal energy at reference temperature
-        E_th_ref = debye.thermal_energy(params['T_0'], debye_T, params['n'])
-
-        b_iikk = 9. * params['K_0']  # EQ 28
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29
-        f = 0.5 * (pow(params['V_0'] / volume, 2. / 3.) - 1.)  # EQ 24
-        P = (1. / 3.) * (pow(1. + 2. * f, 5. / 2.)) \
-            * ((b_iikk * f) + (0.5 * b_iikkmm * pow(f, 2.)))\
-            + gr * (E_th - E_th_ref) / volume  # EQ 21
+
+        dV = volume * 1.0e-4
+        S = self.entropy(0.0, temperature, volume, params)
+
+        delta_S = lambda T, S, V: S - self.entropy(0.0, T, V, params)
+
+        T0 = brentq(
+            delta_S, temperature * 0.97, temperature * 1.03, args=(S, volume - 0.5 * dV)
+        )
+        T1 = brentq(
+            delta_S, temperature * 0.97, temperature * 1.03, args=(S, volume + 0.5 * dV)
+        )
+
+        E0 = self.molar_internal_energy(0.0, T0, volume - 0.5 * dV, params)
+        E1 = self.molar_internal_energy(0.0, T1, volume + 0.5 * dV, params)
+
+        P = -(E1 - E0) / dV  # |S
 
         return P
 
     def grueneisen_parameter(self, pressure, temperature, volume, params):
         """
         Returns grueneisen parameter :math:`[unitless]`
         """
-        return _grueneisen_parameter_fast(params['V_0'], volume,
-                                          params['grueneisen_0'],
-                                          params['q_0'])
+        """
+        gr = (params['grueneisen_0'] +
+              params['grueneisen_prime'] *
+              (np.power(params['V_0']/volume, params['grueneisen_n']) *
+               (self.molar_internal_energy(pressure, temperature, volume, params) -
+                params['E_0'])))
+        """
+        dT = 1.0
+        dE = self.molar_internal_energy(
+            0.0, temperature + 0.5 * dT, volume, params
+        ) - self.molar_internal_energy(0.0, temperature - 0.5 * dT, volume, params)
+        dP = self.pressure(temperature + 0.5 * dT, volume, params) - self.pressure(
+            temperature - 0.5 * dT, volume, params
+        )
+        gr = volume * dP / dE
+
+        return gr
 
     def isothermal_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns isothermal bulk modulus :math:`[Pa]`
         """
-        T_0 = params['T_0']
-        debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        gr = self.grueneisen_parameter(pressure, temperature, volume, params)
-
-        # thermal energy at temperature T
-        E_th = debye.thermal_energy(temperature, debye_T, params['n'])
-        # thermal energy at reference temperature
-        E_th_ref = debye.thermal_energy(T_0, debye_T, params['n'])
-
-        # heat capacity at temperature T
-        C_v = debye.molar_heat_capacity_v(temperature, debye_T, params['n'])
-        # heat capacity at reference temperature
-        C_v_ref = debye.molar_heat_capacity_v(T_0, debye_T, params['n'])
-
-        q = self.volume_dependent_q(params['V_0'] / volume, params)
-
-        K = bm.bulk_modulus(volume, params) \
-            + (gr + 1. - q) * (gr / volume) * (E_th - E_th_ref) \
-            - (pow(gr, 2.) / volume) * (C_v * temperature - C_v_ref * T_0)
+        # K_T = -V * dP/dV
+        dV = volume * 1.0e-3
+        P0 = self.pressure(temperature, volume - 0.5 * dV, params)
+        P1 = self.pressure(temperature, volume + 0.5 * dV, params)
 
-        return K
+        K_T = -volume * (P1 - P0) / dV
+        return K_T
 
     def adiabatic_bulk_modulus(self, pressure, temperature, volume, params):
         """
         Returns adiabatic bulk modulus. :math:`[Pa]`
         """
-        K_T = self.isothermal_bulk_modulus(
-            pressure, temperature, volume, params)
+        K_T = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
-        K_S = K_T * (1. + gr * alpha * temperature)
+        K_S = K_T * (1.0 + gr * alpha * temperature)
         return K_S
 
     def shear_modulus(self, pressure, temperature, volume, params):
         """
         Returns shear modulus. :math:`[Pa]`
+        Zero for a liquid
         """
-        T_0 = params['T_0']
-        debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        eta_s = self._isotropic_eta_s(params['V_0'] / volume, params)
-
-        E_th = debye.thermal_energy(temperature, debye_T, params['n'])
-        E_th_ref = debye.thermal_energy(T_0, debye_T, params['n'])
-
-        if self.order == 2:
-            return (bm.shear_modulus_second_order(volume, params)
-                    - eta_s * (E_th - E_th_ref) / volume)
-        elif self.order == 3:
-            return (bm.shear_modulus_third_order(volume, params)
-                    - eta_s * (E_th - E_th_ref) / volume)
-        else:
-            raise NotImplementedError("")
+        return 0.0
 
     def molar_heat_capacity_v(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant volume. :math:`[J/K/mol]`
         """
-        debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        return debye.molar_heat_capacity_v(temperature, debye_T, params['n'])
+
+        A, B, Theta = self._ABTheta(volume, params)
+        lmda, xi = self._lambdaxi(volume, params)
+
+        C_kin = (
+            1.5 * params["n"] * gas_constant
+        )  # HT limit of kinetic contribution (just after equation 29.)
+        C_e = A * (
+            1.0 - (Theta * Theta) / (Theta * Theta + temperature * temperature)
+        ) + B * np.power(
+            temperature, 0.6
+        )  # Equation A1
+        C_pot = (lmda * temperature + xi * params["theta"]) / (
+            params["theta"] + temperature
+        )  # Equation A15
+
+        return C_kin + C_e + C_pot
 
     def molar_heat_capacity_p(self, pressure, temperature, volume, params):
         """
         Returns heat capacity at constant pressure. :math:`[J/K/mol]`
         """
+
         alpha = self.thermal_expansivity(pressure, temperature, volume, params)
         gr = self.grueneisen_parameter(pressure, temperature, volume, params)
         C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        C_p = C_v * (1. + gr * alpha * temperature)
+        C_p = C_v * (1.0 + gr * alpha * temperature)
+
         return C_p
 
     def thermal_expansivity(self, pressure, temperature, volume, params):
         """
         Returns thermal expansivity. :math:`[1/K]`
+        Currently found by numerical differentiation (1/V * dV/dT)
         """
-        C_v = self.molar_heat_capacity_v(pressure, temperature, volume, params)
-        gr = self.grueneisen_parameter(pressure, temperature, volume, params)
-        K = self.isothermal_bulk_modulus(pressure, temperature, volume, params)
-        alpha = gr * C_v / K / volume
-        return alpha
+
+        delta_T = 1.0
+        V0 = self.volume(pressure, temperature - 0.5 * delta_T, params)
+        V1 = self.volume(pressure, temperature + 0.5 * delta_T, params)
+
+        return (1.0 / volume) * (V1 - V0) / delta_T
 
     def gibbs_free_energy(self, pressure, temperature, volume, params):
         """
-        Returns the Gibbs free energy at the pressure and temperature
-        of the mineral [J/mol]
+        Returns the Gibbs free energy at the pressure and temperature of the mineral [J/mol]
+        E + PV
         """
-        G = self.helmholtz_free_energy(
-            pressure, temperature, volume, params) + pressure * volume
-        return G
+
+        return self.helmholtz_free_energy(
+            pressure, temperature, volume, params
+        ) + pressure * self.volume(pressure, temperature, params)
 
     def molar_internal_energy(self, pressure, temperature, volume, params):
         """
-        Returns the internal energy at the pressure and temperature
-        of the mineral [J/mol]
+        Returns the internal energy at the pressure and temperature of the mineral [J/mol]
         """
-        return (self.helmholtz_free_energy(pressure, temperature,
-                                           volume, params)
-                + temperature * self.entropy(pressure, temperature,
-                                             volume, params))
+        Ts = self._isentropic_temperature(volume, params)
+        E = (
+            params["E_0"]
+            + self._isentropic_energy_change(volume, params)
+            + self._isochoric_energy_change(Ts, temperature, volume, params)
+        )
+
+        return E
 
     def entropy(self, pressure, temperature, volume, params):
         """
-        Returns the entropy at the pressure and temperature
-        of the mineral [J/K/mol]
+        Returns the entropy at the pressure and temperature of the mineral [J/K/mol]
         """
-        Debye_T = self._debye_temperature(params['V_0'] / volume, params)
-        S = debye.entropy(temperature, Debye_T, params['n'])
+        T = temperature
+        Ts = self._isentropic_temperature(volume, params)
+
+        if np.abs(T - Ts) < 1.0e-10:
+            Delta_S = 0.0
+        else:
+            A, B, Theta = self._ABTheta(volume, params)
+            lmda, xi = self._lambdaxi(volume, params)
+            S_kin = 1.5 * params["n"] * gas_constant * (np.log(T) - np.log(Ts))
+            S_el = A * (
+                np.log(T / Ts)
+                - 0.5
+                * np.log(
+                    T
+                    * T
+                    * (Theta * Theta + Ts * Ts)
+                    / (Ts * Ts * (Theta * Theta + T * T))
+                )
+            ) + 5.0 / 3.0 * B * (
+                np.power(T, 0.6) - np.power(Ts, 0.6)
+            )  # A6
+            S_pot = lmda * np.log(
+                (params["theta"] + T) / (params["theta"] + Ts)
+            ) + xi * np.log(
+                (T * (params["theta"] + Ts)) / (Ts * (params["theta"] + T))
+            )  # A20
+            Delta_S = S_kin + S_el + S_pot
+
+        S = params["S_0"] + Delta_S
         return S
 
     def enthalpy(self, pressure, temperature, volume, params):
         """
-        Returns the enthalpy at the pressure and temperature
-        of the mineral [J/mol]
+        Returns the enthalpy at the pressure and temperature of the mineral [J/mol]
+        E + PV
         """
 
-        return (self.helmholtz_free_energy(pressure, temperature,
-                                           volume, params)
-                + temperature * self.entropy(pressure, temperature,
-                                             volume, params)
-                + pressure * volume)
+        return self.molar_internal_energy(
+            pressure, temperature, volume, params
+        ) + pressure * self.volume(pressure, temperature, params)
 
     def helmholtz_free_energy(self, pressure, temperature, volume, params):
         """
-        Returns the Helmholtz free energy at the pressure and temperature
-        of the mineral [J/mol]
+        Returns the Helmholtz free energy at the pressure and temperature of the mineral [J/mol]
+        E - TS
         """
-        x = params['V_0'] / volume
-        f = 1. / 2. * (pow(x, 2. / 3.) - 1.)
-        Debye_T = self._debye_temperature(params['V_0'] / volume, params)
-
-        F_quasiharmonic = (debye.helmholtz_free_energy(temperature,
-                                                       Debye_T,
-                                                       params['n'])
-                           - debye.helmholtz_free_energy(params['T_0'],
-                                                         Debye_T,
-                                                         params['n']))
-
-        b_iikk = 9. * params['K_0']  # EQ 28
-        b_iikkmm = 27. * params['K_0'] * (params['Kprime_0'] - 4.)  # EQ 29
-
-        F = (params['F_0'] + 0.5 * b_iikk * f * f * params['V_0']
-             + (1. / 6.) * params['V_0'] * b_iikkmm * f * f * f
-             + F_quasiharmonic)
-
-        return F
+        return self.molar_internal_energy(
+            pressure, temperature, volume, params
+        ) - temperature * self.entropy(pressure, temperature, volume, params)
 
     def validate_parameters(self, params):
         """
         Check for existence and validity of the parameters
         """
-        if 'T_0' not in params:
-            params['T_0'] = 300.
-
-        # If eta_s_0 is not included this is presumably deliberate,
-        # as we can model density and bulk modulus just fine without it,
-        # so just add it to the dictionary as nan
-        # The same goes for the standard state Helmholtz free energy
-        if 'eta_s_0' not in params:
-            params['eta_s_0'] = float('nan')
-        if 'F_0' not in params:
-            params['F_0'] = float('nan')
-
-        # First, let's check the EoS parameters for Tref
-        bm.BirchMurnaghanBase.validate_parameters(
-            bm.BirchMurnaghanBase(), params)
 
         # Now check all the required keys for the
         # thermal part of the EoS are in the dictionary
-        expected_keys = [
-            'molar_mass', 'n', 'Debye_0', 'grueneisen_0', 'q_0', 'eta_s_0']
+        expected_keys = ["P_0", "T_0", "S_0", "molar_mass", "grueneisen_0"]
+
         for k in expected_keys:
             if k not in params:
-                raise KeyError('params object missing parameter : ' + k)
+                raise KeyError("params object missing parameter : " + k)
 
         # Finally, check that the values are reasonable.
-        if params['T_0'] < 0.:
-            warnings.warn('Unusual value for T_0', stacklevel=2)
-        if params['molar_mass'] < 0.001 or params['molar_mass'] > 10.:
-            warnings.warn('Unusual value for molar_mass', stacklevel=2)
-        if params['n'] < 1. or params['n'] > 1000.:
-            warnings.warn('Unusual value for n', stacklevel=2)
-        if params['Debye_0'] < 1. or params['Debye_0'] > 10000.:
-            warnings.warn('Unusual value for Debye_0', stacklevel=2)
-        if params['grueneisen_0'] < -0.005 or params['grueneisen_0'] > 10.:
-            warnings.warn('Unusual value for grueneisen_0', stacklevel=2)
-        if params['q_0'] < -10. or params['q_0'] > 10.:
-            warnings.warn('Unusual value for q_0', stacklevel=2)
-        if params['eta_s_0'] < -10. or params['eta_s_0'] > 10.:
-            warnings.warn('Unusual value for eta_s_0', stacklevel=2)
-
-
-class SLB3(SLBBase):
-
-    """
-    SLB equation of state with third order finite strain expansion for the
-    shear modulus (this should be preferred, as it is more thermodynamically
-    consistent.)
-    """
-
-    def __init__(self):
-        self.order = 3
-
-
-class SLB2(SLBBase):
-
-    """
-    SLB equation of state with second order finite strain expansion for the
-    shear modulus.  In general, this should not be used, but sometimes
-    shear modulus data is fit to a second order equation of state.  In that
-    case, you should use this.  The moral is, be careful!
-    """
-
-    def __init__(self):
-        self.order = 2
+        if params["T_0"] < 0.0:
+            warnings.warn("Unusual value for T_0", stacklevel=2)
+        if params["molar_mass"] < 0.001 or params["molar_mass"] > 10.0:
+            warnings.warn("Unusual value for molar_mass", stacklevel=2)
+        if params["n"] < 1.0 or params["n"] > 1000.0:
+            warnings.warn("Unusual value for n", stacklevel=2)
```

### Comparing `burnman-1.1.0/burnman/minerals/HP_2011_ds62.py` & `burnman-1.2.0/burnman/minerals/HGP_2018_ds633.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,4219 +1,5655 @@
-# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit
-# for the Earth and Planetary Sciences
+# This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2021 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 
 """
-HP_2011_ds62
-^^^^^^^^^^^^
+HGP_2018_ds633
+^^^^^^^^^^^^^^
 
-Endmember minerals from Holland and Powell 2011 and references therein.
-Update to dataset version 6.2.
+Endmember minerals and melt solutions
+from Holland, Green and Powell (2018) and references therein.
+Dataset version 6.33.
 The values in this document are all in S.I. units,
-unlike those in the original tc-ds62.txt.
-File autogenerated using HPdata_to_burnman.py.
+unlike those in the original tc-ds633.txt.
+The endmember section of this file is autogenerated using
+HGP633data_to_burnman.py.
 """
 
-
 from ..classes.mineral import Mineral
+from ..classes.solution import Solution
+from ..classes.solutionmodel import AsymmetricRegularSolution
+from ..classes.combinedmineral import CombinedMineral
 
 """
 ENDMEMBERS
 """
 
 
-class fo (Mineral):
+class fo(Mineral):
     def __init__(self):
-        self.params = {'name': 'fo',
-                       'formula': {'Mg': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2172590.0,
-                       'S_0': 95.1,
-                       'V_0': 4.366e-05,
-                       'Cp': [233.3, 0.001494, -603800.0, -1869.7],
-                       'a_0': 2.85e-05,
-                       'K_0': 128500e6,
-                       'Kprime_0': 3.84,
-                       'Kdprime_0': -3e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1406931}
-        Mineral.__init__(self)
-
-
-class fa (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fa',
-                       'formula': {'Fe': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1477720.0,
-                       'S_0': 151.0,
-                       'V_0': 4.631e-05,
-                       'Cp': [201.1, 0.01733, -1960600.0, -900.9],
-                       'a_0': 2.82e-05,
-                       'K_0': 125600e6,
-                       'Kprime_0': 4.68,
-                       'Kdprime_0': -3.7e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.2037731}
-        Mineral.__init__(self)
-
-
-class teph (Mineral):
-    def __init__(self):
-        self.params = {'name': 'teph',
-                       'formula': {'Mn': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1733970.0,
-                       'S_0': 155.9,
-                       'V_0': 4.899e-05,
-                       'Cp': [219.6, 0.0, -1292700.0, -1308.3],
-                       'a_0': 2.86e-05,
-                       'K_0': 125600e6,
-                       'Kprime_0': 4.68,
-                       'Kdprime_0': -3.7e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.2019591}
-        Mineral.__init__(self)
-
-
-class lrn (Mineral):
-    def __init__(self):
-        self.params = {'name': 'lrn',
-                       'formula': {'Ca': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2306920.0,
-                       'S_0': 127.6,
-                       'V_0': 5.16e-05,
-                       'Cp': [247.5, -0.003206, 0.0, -2051.9],
-                       'a_0': 2.9e-05,
-                       'K_0': 98500e6,
-                       'Kprime_0': 4.07,
-                       'Kdprime_0': -4.1e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1722391}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 1710.0,
-                                                  'S_D': 10.03,
-                                                  'V_D': 5e-07}]]
-        Mineral.__init__(self)
-
-
-class mont (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mont',
-                       'formula': {'Ca': 1.0, 'Mg': 1.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2251260.0,
-                       'S_0': 109.5,
-                       'V_0': 5.148e-05,
-                       'Cp': [250.7, -0.010433, -797200.0, -1996.1],
-                       'a_0': 2.87e-05,
-                       'K_0': 113400e6,
-                       'Kprime_0': 3.87,
-                       'Kdprime_0': -3.4e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1564661}
-        Mineral.__init__(self)
-
-
-class chum (Mineral):
-    def __init__(self):
-        self.params = {'name': 'chum',
-                       'formula': {'H': 2.0, 'Mg': 9.0, 'O': 18.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9613540.0,
-                       'S_0': 440.5,
-                       'V_0': 0.00019801,
-                       'Cp': [1071.0, -0.016533, -7899600.0, -7373.9],
-                       'a_0': 3.2e-05,
-                       'K_0': 119900e6,
-                       'Kprime_0': 4.58,
-                       'Kdprime_0': -3.8e-11,
-                       'n': 33.0,
-                       'molar_mass': 0.62109208}
-        Mineral.__init__(self)
-
-
-class chdr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'chdr',
-                       'formula': {'H': 2.0, 'Mg': 5.0, 'O': 10.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5254890.0,
-                       'S_0': 260.0,
-                       'V_0': 0.00011084,
-                       'Cp': [625.0, -0.001088, -2259900.0, -4910.7],
-                       'a_0': 1.82e-05,
-                       'K_0': 116100e6,
-                       'Kprime_0': 4.8,
-                       'Kdprime_0': -4.1e-11,
-                       'n': 19.0,
-                       'molar_mass': 0.33970588}
-        Mineral.__init__(self)
-
-
-class mwd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mwd',
-                       'formula': {'Mg': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2138520.0,
-                       'S_0': 93.9,
-                       'V_0': 4.051e-05,
-                       'Cp': [208.7, 0.003942, -1709500.0, -1302.8],
-                       'a_0': 2.37e-05,
-                       'K_0': 172600e6,
-                       'Kprime_0': 3.84,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1406931}
-        Mineral.__init__(self)
-
-
-class fwd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fwd',
-                       'formula': {'Fe': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1467900.0,
-                       'S_0': 146.0,
-                       'V_0': 4.321e-05,
-                       'Cp': [201.1, 0.01733, -1960600.0, -900.9],
-                       'a_0': 2.73e-05,
-                       'K_0': 169000e6,
-                       'Kprime_0': 4.35,
-                       'Kdprime_0': -2.6e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.2037731}
-        Mineral.__init__(self)
-
-
-class mrw (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mrw',
-                       'formula': {'Mg': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2127680.0,
-                       'S_0': 90.0,
-                       'V_0': 3.949e-05,
-                       'Cp': [213.3, 0.00269, -1410400.0, -1495.9],
-                       'a_0': 2.01e-05,
-                       'K_0': 178100e6,
-                       'Kprime_0': 4.35,
-                       'Kdprime_0': -2.4e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1406931}
-        Mineral.__init__(self)
-
-
-class frw (Mineral):
-    def __init__(self):
-        self.params = {'name': 'frw',
-                       'formula': {'Fe': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1471760.0,
-                       'S_0': 140.0,
-                       'V_0': 4.203e-05,
-                       'Cp': [166.8, 0.04261, -1705400.0, -541.4],
-                       'a_0': 2.22e-05,
-                       'K_0': 197700e6,
-                       'Kprime_0': 4.92,
-                       'Kdprime_0': -2.5e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.2037731}
-        Mineral.__init__(self)
-
-
-class mpv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mpv',
-                       'formula': {'Mg': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1443030.0,
-                       'S_0': 62.6,
-                       'V_0': 2.445e-05,
-                       'Cp': [149.3, 0.002918, -2983000.0, -799.1],
-                       'a_0': 1.87e-05,
-                       'K_0': 251000e6,
-                       'Kprime_0': 4.14,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1003887}
-        Mineral.__init__(self)
-
-
-class fpv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fpv',
-                       'formula': {'Fe': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1084640.0,
-                       'S_0': 91.0,
-                       'V_0': 2.548e-05,
-                       'Cp': [133.2, 0.01083, -3661400.0, -314.7],
-                       'a_0': 1.87e-05,
-                       'K_0': 281000e6,
-                       'Kprime_0': 4.14,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1319287}
-        Mineral.__init__(self)
-
-
-class apv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'apv',
-                       'formula': {'Al': 2.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1646630.0,
-                       'S_0': 51.8,
-                       'V_0': 2.54e-05,
-                       'Cp': [139.5, 0.00589, -2460600.0, -589.2],
-                       'a_0': 1.8e-05,
-                       'K_0': 203000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -2e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1019612}
-        Mineral.__init__(self)
-
-
-class cpv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cpv',
-                       'formula': {'Ca': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1541730.0,
-                       'S_0': 73.5,
-                       'V_0': 2.745e-05,
-                       'Cp': [159.3, 0.0, -967300.0, -1075.4],
-                       'a_0': 1.87e-05,
-                       'K_0': 236000e6,
-                       'Kprime_0': 3.9,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1161617}
-        Mineral.__init__(self)
-
-
-class mak (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mak',
-                       'formula': {'Mg': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1490870.0,
-                       'S_0': 59.3,
-                       'V_0': 2.635e-05,
-                       'Cp': [147.8, 0.002015, -2395000.0, -801.8],
-                       'a_0': 2.12e-05,
-                       'K_0': 211000e6,
-                       'Kprime_0': 4.55,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1003887}
-        Mineral.__init__(self)
-
-
-class fak (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fak',
-                       'formula': {'Fe': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1142140.0,
-                       'S_0': 91.5,
-                       'V_0': 2.76e-05,
-                       'Cp': [100.3, 0.013328, -4364900.0, 419.8],
-                       'a_0': 2.12e-05,
-                       'K_0': 218000e6,
-                       'Kprime_0': 4.55,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1319287}
-        Mineral.__init__(self)
-
-
-class maj (Mineral):
-    def __init__(self):
-        self.params = {'name': 'maj',
-                       'formula': {'Mg': 4.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6050400.0,
-                       'S_0': 255.2,
-                       'V_0': 0.00011457,
-                       'Cp': [713.6, -0.000997, -1158200.0, -6622.3],
-                       'a_0': 1.83e-05,
-                       'K_0': 160000e6,
-                       'Kprime_0': 4.56,
-                       'Kdprime_0': -2.8e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.4015548}
-        Mineral.__init__(self)
-
-
-class py (Mineral):
-    def __init__(self):
-        self.params = {'name': 'py',
-                       'formula': {'Al': 2.0, 'Mg': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6281960.0,
-                       'S_0': 269.5,
-                       'V_0': 0.00011313,
-                       'Cp': [633.5, 0.0, -5196100.0, -4315.2],
-                       'a_0': 2.37e-05,
-                       'K_0': 174300e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.3e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.4031273}
-        Mineral.__init__(self)
-
-
-class alm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'alm',
-                       'formula': {'Al': 2.0, 'Fe': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5260700.0,
-                       'S_0': 342.0,
-                       'V_0': 0.00011525,
-                       'Cp': [677.3, 0.0, -3772700.0, -5044.0],
-                       'a_0': 2.12e-05,
-                       'K_0': 190000e6,
-                       'Kprime_0': 2.98,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.4977473}
-        Mineral.__init__(self)
-
-
-class spss (Mineral):
-    def __init__(self):
-        self.params = {'name': 'spss',
-                       'formula': {'Al': 2.0, 'Mn': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5693490.0,
-                       'S_0': 335.3,
-                       'V_0': 0.00011792,
-                       'Cp': [646.9, 0.0, -4525800.0, -4452.8],
-                       'a_0': 2.27e-05,
-                       'K_0': 174000e6,
-                       'Kprime_0': 6.68,
-                       'Kdprime_0': -3.8e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.4950263}
-        Mineral.__init__(self)
-
-
-class gr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'gr',
-                       'formula': {'Al': 2.0, 'Ca': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6643010.0,
-                       'S_0': 255.0,
-                       'V_0': 0.00012535,
-                       'Cp': [626.0, 0.0, -5779200.0, -4002.9],
-                       'a_0': 2.2e-05,
-                       'K_0': 172000e6,
-                       'Kprime_0': 5.53,
-                       'Kdprime_0': -3.2e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.4504463}
-        Mineral.__init__(self)
-
-
-class andr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'andr',
-                       'formula': {'Ca': 3.0, 'Fe': 2.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5769100.0,
-                       'S_0': 316.4,
-                       'V_0': 0.00013204,
-                       'Cp': [638.6, 0.0, -4955100.0, -3989.2],
-                       'a_0': 2.86e-05,
-                       'K_0': 158800e6,
-                       'Kprime_0': 5.68,
-                       'Kdprime_0': -3.6e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.5081733}
-        Mineral.__init__(self)
-
-
-class knor (Mineral):
-    def __init__(self):
-        self.params = {'name': 'knor',
-                       'formula': {'Cr': 2.0, 'Mg': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5687710.0,
-                       'S_0': 317.0,
-                       'V_0': 0.00011738,
-                       'Cp': [613.0, 0.003606, -4178000.0, -3729.4],
-                       'a_0': 2.37e-05,
-                       'K_0': 174300e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.3e-11,
-                       'n': 20.0,
-                       'molar_mass': 0.4531565}
-        Mineral.__init__(self)
-
-
-class osma (Mineral):
-    def __init__(self):
-        self.params = {'name': 'osma',
-                       'formula': {'Al': 5.0, 'K': 1.0, 'Mg': 2.0, 'O': 30.0, 'Si': 10.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -14896310.0,
-                       'S_0': 755.0,
-                       'V_0': 0.00037893,
-                       'Cp': [1540.7, -0.011359, -10339000.0, -11699.0],
-                       'a_0': 4.7e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 48.0,
-                       'molar_mass': 0.9834528}
-        Mineral.__init__(self)
-
-
-class osmm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'osmm',
-                       'formula': {'Al': 3.0, 'K': 1.0, 'Mg': 3.0, 'O': 30.0, 'Si': 11.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -14786740.0,
-                       'S_0': 740.0,
-                       'V_0': 0.0003844,
-                       'Cp': [1525.5, -0.010267, -10538000.0, -11337.0],
-                       'a_0': 4.7e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 48.0,
-                       'molar_mass': 0.9818803}
-        Mineral.__init__(self)
-
-
-class osfa (Mineral):
-    def __init__(self):
-        self.params = {'name': 'osfa',
-                       'formula': {'Al': 5.0, 'Fe': 2.0, 'K': 1.0, 'O': 30.0, 'Si': 10.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -14215490.0,
-                       'S_0': 780.0,
-                       'V_0': 0.0003845,
-                       'Cp': [1558.6, -0.011359, -9476500.0, -11845.0],
-                       'a_0': 4.9e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 48.0,
-                       'molar_mass': 1.0465328}
-        Mineral.__init__(self)
-
-
-class vsv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'vsv',
-                       'formula': {'Al': 11.0, 'Ca': 19.0, 'H': 9.0, 'Mg': 2.0, 'O': 78.0, 'Si': 18.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -42345820.0,
-                       'S_0': 1890.0,
-                       'V_0': 0.000852,
-                       'Cp': [4488.0, -0.057952, -22269300.0, -33478.0],
-                       'a_0': 2.75e-05,
-                       'K_0': 125500e6,
-                       'Kprime_0': 4.8,
-                       'Kdprime_0': -3.8e-11,
-                       'n': 137.0,
-                       'molar_mass': 2.86945216}
-        Mineral.__init__(self)
-
-
-class andalusite (Mineral):
-    def __init__(self):
-        self.params = {'name': 'and',
-                       'formula': {'Al': 2.0, 'O': 5.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2588670.0,
-                       'S_0': 92.7,
-                       'V_0': 5.153e-05,
-                       'Cp': [277.3, -0.006588, -1914100.0, -2265.6],
-                       'a_0': 1.81e-05,
-                       'K_0': 144200e6,
-                       'Kprime_0': 6.89,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 8.0,
-                       'molar_mass': 0.1620455}
-        Mineral.__init__(self)
-
-
-class ky (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ky',
-                       'formula': {'Al': 2.0, 'O': 5.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2592970.0,
-                       'S_0': 83.5,
-                       'V_0': 4.414e-05,
-                       'Cp': [279.4, -0.007124, -2055600.0, -2289.4],
-                       'a_0': 1.92e-05,
-                       'K_0': 160100e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.5e-11,
-                       'n': 8.0,
-                       'molar_mass': 0.1620455}
-        Mineral.__init__(self)
-
-
-class sill (Mineral):
-    def __init__(self):
-        self.params = {'name': 'sill',
-                       'formula': {'Al': 2.0, 'O': 5.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2585790.0,
-                       'S_0': 95.4,
-                       'V_0': 4.986e-05,
-                       'Cp': [280.2, -0.0069, -1375700.0, -2399.4],
-                       'a_0': 1.12e-05,
-                       'K_0': 164000e6,
-                       'Kprime_0': 5.06,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 8.0,
-                       'molar_mass': 0.1620455}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 4750.0,
-                                                       'deltaV': 1e-07,
-                                                       'Wh': 4750.0,
-                                                       'Wv': 1e-07,
-                                                       'n': 1.0,
-                                                       'factor': 0.25}]]
-        Mineral.__init__(self)
-
-
-class smul (Mineral):
-    def __init__(self):
-        self.params = {'name': 'smul',
-                       'formula': {'Al': 2.0, 'O': 5.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2569210.0,
-                       'S_0': 101.5,
-                       'V_0': 4.987e-05,
-                       'Cp': [280.2, -0.0069, -1375700.0, -2399.4],
-                       'a_0': 1.36e-05,
-                       'K_0': 174000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -2.3e-11,
-                       'n': 8.0,
-                       'molar_mass': 0.1620455}
-        Mineral.__init__(self)
-
-
-class amul (Mineral):
-    def __init__(self):
-        self.params = {'name': 'amul',
-                       'formula': {'Al': 2.5, 'O': 4.75, 'Si': 0.5},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2485530.0,
-                       'S_0': 113.0,
-                       'V_0': 5.083e-05,
-                       'Cp': [244.8, 0.000968, -2533300.0, -1641.6],
-                       'a_0': 1.36e-05,
-                       'K_0': 174000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -2.3e-11,
-                       'n': 7.75,
-                       'molar_mass': 0.15749365}
-        Mineral.__init__(self)
-
-
-class tpz (Mineral):
-    def __init__(self):
-        self.params = {'name': 'tpz',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'O': 6.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2900710.0,
-                       'S_0': 100.5,
-                       'V_0': 5.339e-05,
-                       'Cp': [387.7, -0.00712, -857200.0, -3744.2],
-                       'a_0': 1.57e-05,
-                       'K_0': 131500e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 11.0,
-                       'molar_mass': 0.18006078}
-        Mineral.__init__(self)
-
-
-class mst (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mst',
-                       'formula': {'Al': 18.0, 'H': 4.0, 'Mg': 4.0, 'O': 48.0, 'Si': 7.5},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -25123740.0,
-                       'S_0': 910.0,
-                       'V_0': 0.0004426,
-                       'Cp': [2820.5, -0.059366, -13774000.0, -24126.0],
-                       'a_0': 1.81e-05,
-                       'K_0': 168400e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.4e-11,
-                       'n': 81.5,
-                       'molar_mass': 1.56553121}
-        Mineral.__init__(self)
-
-
-class fst (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fst',
-                       'formula': {'Al': 18.0, 'Fe': 4.0, 'H': 4.0, 'O': 48.0, 'Si': 7.5},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -23754630.0,
-                       'S_0': 1010.0,
-                       'V_0': 0.0004488,
-                       'Cp': [2880.0, -0.056595, -10642000.0, -25373.0],
-                       'a_0': 1.83e-05,
-                       'K_0': 180000e6,
-                       'Kprime_0': 4.76,
-                       'Kdprime_0': -2.6e-11,
-                       'n': 81.5,
-                       'molar_mass': 1.69169121}
-        Mineral.__init__(self)
-
-
-class mnst (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mnst',
-                       'formula': {'Al': 18.0, 'H': 4.0, 'Mn': 4.0, 'O': 48.0, 'Si': 7.5},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -24245850.0,
-                       'S_0': 1034.0,
-                       'V_0': 0.0004546,
-                       'Cp': [2873.3, -0.089064, -12688000.0, -24749.0],
-                       'a_0': 2.09e-05,
-                       'K_0': 180000e6,
-                       'Kprime_0': 4.76,
-                       'Kdprime_0': -2.6e-11,
-                       'n': 81.5,
-                       'molar_mass': 1.68806321}
-        Mineral.__init__(self)
-
-
-class mctd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mctd',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'Mg': 1.0, 'O': 7.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3549250.0,
-                       'S_0': 146.0,
-                       'V_0': 6.875e-05,
-                       'Cp': [417.4, -0.003771, -2920600.0, -3417.8],
-                       'a_0': 2.63e-05,
-                       'K_0': 145600e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -2.8e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.22036518}
-        Mineral.__init__(self)
-
-
-class fctd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fctd',
-                       'formula': {'Al': 2.0, 'Fe': 1.0, 'H': 2.0, 'O': 7.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3208290.0,
-                       'S_0': 167.0,
-                       'V_0': 6.98e-05,
-                       'Cp': [416.1, -0.003477, -2835900.0, -3360.3],
-                       'a_0': 2.8e-05,
-                       'K_0': 145600e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -2.8e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.25190518}
-        Mineral.__init__(self)
-
-
-class mnctd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mnctd',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'Mn': 1.0, 'O': 7.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3336150.0,
-                       'S_0': 166.0,
-                       'V_0': 7.175e-05,
-                       'Cp': [464.4, -0.012654, -1147200.0, -4341.0],
-                       'a_0': 2.6e-05,
-                       'K_0': 145600e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -2.8e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.25099818}
-        Mineral.__init__(self)
-
-
-class merw (Mineral):
-    def __init__(self):
-        self.params = {'name': 'merw',
-                       'formula': {'Ca': 3.0, 'Mg': 1.0, 'O': 8.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4545700.0,
-                       'S_0': 253.1,
-                       'V_0': 9.847e-05,
-                       'Cp': [417.5, 0.008117, -2923000.0, -2320.3],
-                       'a_0': 3.19e-05,
-                       'K_0': 120000e6,
-                       'Kprime_0': 4.07,
-                       'Kdprime_0': -3.4e-11,
-                       'n': 14.0,
-                       'molar_mass': 0.3287052}
-        Mineral.__init__(self)
-
-
-class spu (Mineral):
-    def __init__(self):
-        self.params = {'name': 'spu',
-                       'formula': {'C': 1.0, 'Ca': 5.0, 'O': 11.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5846720.0,
-                       'S_0': 332.0,
-                       'V_0': 0.00014697,
-                       'Cp': [614.1, -0.003508, -2493100.0, -4168.0],
-                       'a_0': 3.4e-05,
-                       'K_0': 95000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.3e-11,
-                       'n': 19.0,
-                       'molar_mass': 0.4445651}
-        Mineral.__init__(self)
-
-
-class zo (Mineral):
-    def __init__(self):
-        self.params = {'name': 'zo',
-                       'formula': {'Al': 3.0, 'Ca': 2.0, 'H': 1.0, 'O': 13.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6896290.0,
-                       'S_0': 298.0,
-                       'V_0': 0.00013575,
-                       'Cp': [662.0, 0.010416, -6006400.0, -4260.7],
-                       'a_0': 3.12e-05,
-                       'K_0': 104400e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -3.8e-11,
-                       'n': 22.0,
-                       'molar_mass': 0.45435714}
-        Mineral.__init__(self)
-
-
-class cz (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cz',
-                       'formula': {'Al': 3.0, 'Ca': 2.0, 'H': 1.0, 'O': 13.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6895540.0,
-                       'S_0': 301.0,
-                       'V_0': 0.0001363,
-                       'Cp': [630.9, 0.013693, -6645800.0, -3731.1],
-                       'a_0': 2.33e-05,
-                       'K_0': 119700e6,
-                       'Kprime_0': 4.07,
-                       'Kdprime_0': -3.4e-11,
-                       'n': 22.0,
-                       'molar_mass': 0.45435714}
-        Mineral.__init__(self)
-
-
-class ep (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ep',
-                       'formula': {'Al': 2.0, 'Ca': 2.0, 'Fe': 1.0, 'H': 1.0, 'O': 13.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6473830.0,
-                       'S_0': 315.0,
-                       'V_0': 0.0001392,
-                       'Cp': [613.3, 0.02207, -7160000.0, -2987.7],
-                       'a_0': 2.34e-05,
-                       'K_0': 134000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -3e-11,
-                       'n': 22.0,
-                       'molar_mass': 0.48322064}
-        Mineral.__init__(self)
-
-
-class fep (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fep',
-                       'formula': {'Al': 1.0, 'Ca': 2.0, 'Fe': 2.0, 'H': 1.0, 'O': 13.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6028590.0,
-                       'S_0': 329.0,
-                       'V_0': 0.0001421,
-                       'Cp': [584.7, 0.030447, -7674200.0, -2244.3],
-                       'a_0': 2.31e-05,
-                       'K_0': 151300e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -2.6e-11,
-                       'n': 22.0,
-                       'molar_mass': 0.51208414}
-        Mineral.__init__(self)
-
-
-class pmt (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pmt',
-                       'formula': {'Al': 2.0, 'Ca': 2.0, 'H': 1.0, 'Mn': 1.0, 'O': 13.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6543030.0,
-                       'S_0': 340.0,
-                       'V_0': 0.0001382,
-                       'Cp': [569.8, 0.02779, -5442900.0, -2812.6],
-                       'a_0': 2.38e-05,
-                       'K_0': 119700e6,
-                       'Kprime_0': 4.07,
-                       'Kdprime_0': -3.4e-11,
-                       'n': 22.0,
-                       'molar_mass': 0.48231364}
-        Mineral.__init__(self)
-
-
-class law (Mineral):
-    def __init__(self):
-        self.params = {'name': 'law',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'H': 4.0, 'O': 10.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4868630.0,
-                       'S_0': 229.0,
-                       'V_0': 0.00010132,
-                       'Cp': [687.8, 0.001566, 375900.0, -7179.2],
-                       'a_0': 2.65e-05,
-                       'K_0': 122900e6,
-                       'Kprime_0': 5.45,
-                       'Kdprime_0': -4.4e-11,
-                       'n': 19.0,
-                       'molar_mass': 0.31423776}
-        Mineral.__init__(self)
-
-
-class mpm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mpm',
-                       'formula': {'Al': 5.0, 'Ca': 4.0, 'H': 7.0, 'Mg': 1.0, 'O': 28.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -14386910.0,
-                       'S_0': 629.0,
-                       'V_0': 0.0002955,
-                       'Cp': [1720.8, -0.024928, -5998700.0, -14620.3],
-                       'a_0': 2.48e-05,
-                       'K_0': 161500e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.5e-11,
-                       'n': 51.0,
-                       'molar_mass': 0.94307628}
-        Mineral.__init__(self)
-
-
-class fpm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fpm',
-                       'formula': {'Al': 5.0, 'Ca': 4.0, 'Fe': 1.0, 'H': 7.0, 'O': 28.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -14034040.0,
-                       'S_0': 657.0,
-                       'V_0': 0.0002968,
-                       'Cp': [1737.2, -0.024582, -5161100.0, -14963.0],
-                       'a_0': 2.49e-05,
-                       'K_0': 161500e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.5e-11,
-                       'n': 51.0,
-                       'molar_mass': 0.97461628}
-        Mineral.__init__(self)
-
-
-class jgd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'jgd',
-                       'formula': {'Ca': 4.0, 'Fe': 6.0, 'H': 7.0, 'O': 28.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -11808960.0,
-                       'S_0': 830.0,
-                       'V_0': 0.0003108,
-                       'Cp': [1795.4, -0.037986, -4455700.0, -14888.0],
-                       'a_0': 2.49e-05,
-                       'K_0': 161500e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.5e-11,
-                       'n': 51.0,
-                       'molar_mass': 1.11893378}
-        Mineral.__init__(self)
-
-
-class geh (Mineral):
-    def __init__(self):
-        self.params = {'name': 'geh',
-                       'formula': {'Al': 2.0, 'Ca': 2.0, 'O': 7.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3992240.0,
-                       'S_0': 198.5,
-                       'V_0': 9.024e-05,
-                       'Cp': [405.7, -0.007099, -1188300.0, -3174.4],
-                       'a_0': 2.23e-05,
-                       'K_0': 108000e6,
-                       'Kprime_0': 4.08,
-                       'Kdprime_0': -3.8e-11,
-                       'n': 12.0,
-                       'molar_mass': 0.2742003}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 7510.0,
-                                                       'deltaV': 9e-07,
-                                                       'Wh': 7500.0,
-                                                       'Wv': 9e-07,
-                                                       'n': 1.0,
-                                                       'factor': 0.8}]]
-        Mineral.__init__(self)
-
-
-class ak (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ak',
-                       'formula': {'Ca': 2.0, 'Mg': 1.0, 'O': 7.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3865620.0,
-                       'S_0': 212.5,
-                       'V_0': 9.254e-05,
-                       'Cp': [385.4, 0.003209, -247500.0, -2889.9],
-                       'a_0': 2.57e-05,
-                       'K_0': 142000e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -2.9e-11,
-                       'n': 12.0,
-                       'molar_mass': 0.2726278}
-        Mineral.__init__(self)
-
-
-class rnk (Mineral):
-    def __init__(self):
-        self.params = {'name': 'rnk',
-                       'formula': {'Ca': 3.0, 'O': 7.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3943820.0,
-                       'S_0': 210.0,
-                       'V_0': 9.651e-05,
-                       'Cp': [372.3, -0.002893, -2462400.0, -2181.3],
-                       'a_0': 3.28e-05,
-                       'K_0': 95000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.3e-11,
-                       'n': 12.0,
-                       'molar_mass': 0.2884008}
-        Mineral.__init__(self)
-
-
-class ty (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ty',
-                       'formula': {'C': 2.0, 'Ca': 5.0, 'O': 13.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6368040.0,
-                       'S_0': 390.0,
-                       'V_0': 0.00017039,
-                       'Cp': [741.7, -0.005345, -1434600.0, -5878.5],
-                       'a_0': 3.42e-05,
-                       'K_0': 95000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.3e-11,
-                       'n': 22.0,
-                       'molar_mass': 0.4885746}
-        Mineral.__init__(self)
-
-
-class crd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'crd',
-                       'formula': {'Al': 4.0, 'Mg': 2.0, 'O': 18.0, 'Si': 5.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9163430.0,
-                       'S_0': 404.1,
-                       'V_0': 0.00023322,
-                       'Cp': [906.1, 0.0, -7902000.0, -6293.4],
-                       'a_0': 6.8e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 29.0,
-                       'molar_mass': 0.5849527}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 36710.0,
-                                                       'deltaV': 1e-06,
-                                                       'Wh': 36700.0,
-                                                       'Wv': 1e-06,
-                                                       'n': 2.0,
-                                                       'factor': 1.5}]]
-        Mineral.__init__(self)
-
-
-class hcrd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hcrd',
-                       'formula': {'Al': 4.0, 'H': 2.0, 'Mg': 2.0, 'O': 19.0, 'Si': 5.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9448520.0,
-                       'S_0': 483.0,
-                       'V_0': 0.00023322,
-                       'Cp': [955.3, 0.0, -8352600.0, -6301.2],
-                       'a_0': 6.7e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 32.0,
-                       'molar_mass': 0.60296798}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 36710.0,
-                                                       'deltaV': 1e-06,
-                                                       'Wh': 36700.0,
-                                                       'Wv': 1e-06,
-                                                       'n': 2.0,
-                                                       'factor': 1.5}]]
-        Mineral.__init__(self)
-
-
-class fcrd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fcrd',
-                       'formula': {'Al': 4.0, 'Fe': 2.0, 'O': 18.0, 'Si': 5.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -8444070.0,
-                       'S_0': 461.0,
-                       'V_0': 0.0002371,
-                       'Cp': [924.0, 0.0, -7039400.0, -6439.6],
-                       'a_0': 6.7e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 29.0,
-                       'molar_mass': 0.6480327}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 36710.0,
-                                                       'deltaV': 1e-06,
-                                                       'Wh': 36700.0,
-                                                       'Wv': 1e-06,
-                                                       'n': 2.0,
-                                                       'factor': 1.5}]]
-        Mineral.__init__(self)
-
-
-class mncrd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mncrd',
-                       'formula': {'Al': 4.0, 'Mn': 2.0, 'O': 18.0, 'Si': 5.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -8693590.0,
-                       'S_0': 473.0,
-                       'V_0': 0.00024027,
-                       'Cp': [886.5, 0.0, -8840000.0, -5590.4],
-                       'a_0': 6.9e-06,
-                       'K_0': 129000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 29.0,
-                       'molar_mass': 0.6462187}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 36710.0,
-                                                       'deltaV': 1e-06,
-                                                       'Wh': 36700.0,
-                                                       'Wv': 1e-06,
-                                                       'n': 2.0,
-                                                       'factor': 1.5}]]
-        Mineral.__init__(self)
-
-
-class phA (Mineral):
-    def __init__(self):
-        self.params = {'name': 'phA',
-                       'formula': {'H': 6.0, 'Mg': 7.0, 'O': 14.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -7129620.0,
-                       'S_0': 350.5,
-                       'V_0': 0.00015422,
-                       'Cp': [962.0, -0.011521, -4517800.0, -7724.7],
-                       'a_0': 3.55e-05,
-                       'K_0': 145000e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -2.8e-11,
-                       'n': 29.0,
-                       'molar_mass': 0.45634524}
-        Mineral.__init__(self)
-
-
-class sph (Mineral):
-    def __init__(self):
-        self.params = {'name': 'sph',
-                       'formula': {'Ca': 1.0, 'O': 5.0, 'Si': 1.0, 'Ti': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2601660.0,
-                       'S_0': 124.0,
-                       'V_0': 5.565e-05,
-                       'Cp': [227.9, 0.002924, -3539500.0, -894.3],
-                       'a_0': 1.58e-05,
-                       'K_0': 101700e6,
-                       'Kprime_0': 9.85,
-                       'Kdprime_0': -9.7e-11,
-                       'n': 8.0,
-                       'molar_mass': 0.1960275}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 485.0,
-                                                  'S_D': 0.4,
-                                                  'V_D': 5e-08}]]
-        Mineral.__init__(self)
-
-
-class cstn (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cstn',
-                       'formula': {'Ca': 1.0, 'O': 5.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2496350.0,
-                       'S_0': 99.5,
-                       'V_0': 4.818e-05,
-                       'Cp': [205.6, 0.006034, -5517700.0, -352.6],
-                       'a_0': 1.58e-05,
-                       'K_0': 178200e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 8.0,
-                       'molar_mass': 0.176246}
-        Mineral.__init__(self)
-
-
-class zrc (Mineral):
-    def __init__(self):
-        self.params = {'name': 'zrc',
-                       'formula': {'O': 4.0, 'Si': 1.0, 'Zr': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2035070.0,
-                       'S_0': 83.03,
-                       'V_0': 3.926e-05,
-                       'Cp': [232.0, -0.014405, 0.0, -2238.2],
-                       'a_0': 1.25e-05,
-                       'K_0': 230100e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.8e-11,
-                       'n': 6.0,
-                       'molar_mass': 0.1833071}
-        Mineral.__init__(self)
-
-
-class en (Mineral):
-    def __init__(self):
-        self.params = {'name': 'en',
-                       'formula': {'Mg': 2.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3090220.0,
-                       'S_0': 132.5,
-                       'V_0': 6.262e-05,
-                       'Cp': [356.2, -0.00299, -596900.0, -3185.3],
-                       'a_0': 2.27e-05,
-                       'K_0': 105900e6,
-                       'Kprime_0': 8.65,
-                       'Kdprime_0': -8.2e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2007774}
-        Mineral.__init__(self)
-
-
-class pren (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pren',
-                       'formula': {'Mg': 2.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3084560.0,
-                       'S_0': 137.0,
-                       'V_0': 6.476e-05,
-                       'Cp': [356.2, -0.00299, -596900.0, -3185.3],
-                       'a_0': 2.3e-05,
-                       'K_0': 105900e6,
-                       'Kprime_0': 8.65,
-                       'Kdprime_0': -8.2e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2007774}
-        Mineral.__init__(self)
-
-
-class cen (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cen',
-                       'formula': {'Mg': 2.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3091110.0,
-                       'S_0': 132.0,
-                       'V_0': 6.264e-05,
-                       'Cp': [306.0, -0.003793, -3041700.0, -1852.1],
-                       'a_0': 2.11e-05,
-                       'K_0': 105900e6,
-                       'Kprime_0': 8.65,
-                       'Kdprime_0': -8.2e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2007774}
-        Mineral.__init__(self)
-
-
-class hen (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hen',
-                       'formula': {'Mg': 2.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3082730.0,
-                       'S_0': 131.7,
-                       'V_0': 6.099e-05,
-                       'Cp': [356.2, -0.00299, -596900.0, -3185.3],
-                       'a_0': 2.26e-05,
-                       'K_0': 150000e6,
-                       'Kprime_0': 5.5,
-                       'Kdprime_0': -3.6e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2007774}
-        Mineral.__init__(self)
-
-
-class fs (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fs',
-                       'formula': {'Fe': 2.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2388710.0,
-                       'S_0': 189.9,
-                       'V_0': 6.592e-05,
-                       'Cp': [398.7, -0.006579, 1290100.0, -4058.0],
-                       'a_0': 3.26e-05,
-                       'K_0': 101000e6,
-                       'Kprime_0': 4.08,
-                       'Kdprime_0': -4e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2638574}
-        Mineral.__init__(self)
-
-
-class mgts (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mgts',
-                       'formula': {'Al': 2.0, 'Mg': 1.0, 'O': 6.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3196670.0,
-                       'S_0': 131.0,
-                       'V_0': 6.05e-05,
-                       'Cp': [371.4, -0.004082, -398400.0, -3547.1],
-                       'a_0': 2.17e-05,
-                       'K_0': 102800e6,
-                       'Kprime_0': 8.55,
-                       'Kdprime_0': -8.3e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2023499}
-        Mineral.__init__(self)
-
-
-class di (Mineral):
-    def __init__(self):
-        self.params = {'name': 'di',
-                       'formula': {'Ca': 1.0, 'Mg': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3201850.0,
-                       'S_0': 142.9,
-                       'V_0': 6.619e-05,
-                       'Cp': [314.5, 4.1e-05, -2745900.0, -2020.1],
-                       'a_0': 2.73e-05,
-                       'K_0': 119200e6,
-                       'Kprime_0': 5.19,
-                       'Kdprime_0': -4.4e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2165504}
-        Mineral.__init__(self)
-
-
-class hed (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hed',
-                       'formula': {'Ca': 1.0, 'Fe': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2842060.0,
-                       'S_0': 175.0,
-                       'V_0': 6.795e-05,
-                       'Cp': [340.2, 0.000812, -1047800.0, -2646.7],
-                       'a_0': 2.38e-05,
-                       'K_0': 119200e6,
-                       'Kprime_0': 3.97,
-                       'Kdprime_0': -3.3e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2480904}
-        Mineral.__init__(self)
-
-
-class jd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'jd',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3025270.0,
-                       'S_0': 133.5,
-                       'V_0': 6.04e-05,
-                       'Cp': [319.4, 0.003616, -1173900.0, -2469.5],
-                       'a_0': 2.1e-05,
-                       'K_0': 128100e6,
-                       'Kprime_0': 3.81,
-                       'Kdprime_0': -3e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2021387}
-        Mineral.__init__(self)
-
-
-class acm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'acm',
-                       'formula': {'Fe': 1.0, 'Na': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2583430.0,
-                       'S_0': 170.6,
-                       'V_0': 6.459e-05,
-                       'Cp': [307.1, 0.016758, -1685500.0, -2125.8],
-                       'a_0': 2.11e-05,
-                       'K_0': 106000e6,
-                       'Kprime_0': 4.08,
-                       'Kdprime_0': -3.8e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2310022}
-        Mineral.__init__(self)
-
-
-class kos (Mineral):
-    def __init__(self):
-        self.params = {'name': 'kos',
-                       'formula': {'Cr': 1.0, 'Na': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2746840.0,
-                       'S_0': 149.65,
-                       'V_0': 6.309e-05,
-                       'Cp': [309.2, 0.005419, -664600.0, -2176.6],
-                       'a_0': 1.94e-05,
-                       'K_0': 130800e6,
-                       'Kprime_0': 3.0,
-                       'Kdprime_0': -2.3e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2271533}
-        Mineral.__init__(self)
-
-
-class cats (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cats',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'O': 6.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3310110.0,
-                       'S_0': 135.0,
-                       'V_0': 6.356e-05,
-                       'Cp': [347.6, -0.006974, -1781600.0, -2757.5],
-                       'a_0': 2.08e-05,
-                       'K_0': 119200e6,
-                       'Kprime_0': 5.19,
-                       'Kdprime_0': -4.4e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2181229}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 3800.0,
-                                                       'deltaV': 1e-07,
-                                                       'Wh': 3800.0,
-                                                       'Wv': 1e-07,
-                                                       'n': 1.0,
-                                                       'factor': 0.25}]]
-        Mineral.__init__(self)
-
-
-class caes (Mineral):
-    def __init__(self):
-        self.params = {'name': 'caes',
-                       'formula': {'Al': 1.0, 'Ca': 0.5, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3002020.0,
-                       'S_0': 127.0,
-                       'V_0': 6.05e-05,
-                       'Cp': [362.0, -0.016944, -175900.0, -3565.7],
-                       'a_0': 2.31e-05,
-                       'K_0': 119200e6,
-                       'Kprime_0': 5.19,
-                       'Kdprime_0': -4.4e-11,
-                       'n': 9.5,
-                       'molar_mass': 0.1991879}
-        Mineral.__init__(self)
-
-
-class rhod (Mineral):
-    def __init__(self):
-        self.params = {'name': 'rhod',
-                       'formula': {'Mn': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1322380.0,
-                       'S_0': 100.5,
-                       'V_0': 3.494e-05,
-                       'Cp': [138.4, 0.004088, -1936000.0, -538.9],
-                       'a_0': 2.81e-05,
-                       'K_0': 84000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1310217}
-        Mineral.__init__(self)
-
-
-class pxmn (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pxmn',
-                       'formula': {'Mn': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1323160.0,
-                       'S_0': 99.3,
-                       'V_0': 3.472e-05,
-                       'Cp': [138.4, 0.004088, -1936000.0, -538.9],
-                       'a_0': 2.8e-05,
-                       'K_0': 84000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1310217}
-        Mineral.__init__(self)
-
-
-class wo (Mineral):
-    def __init__(self):
-        self.params = {'name': 'wo',
-                       'formula': {'Ca': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1633770.0,
-                       'S_0': 82.5,
-                       'V_0': 3.993e-05,
-                       'Cp': [159.3, 0.0, -967300.0, -1075.4],
-                       'a_0': 2.54e-05,
-                       'K_0': 79500e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -5.2e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1161617}
-        Mineral.__init__(self)
-
-
-class pswo (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pswo',
-                       'formula': {'Ca': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1627960.0,
-                       'S_0': 87.8,
-                       'V_0': 4.008e-05,
-                       'Cp': [157.8, 0.0, -967300.0, -1075.4],
-                       'a_0': 2.85e-05,
-                       'K_0': 110000e6,
-                       'Kprime_0': 4.08,
-                       'Kdprime_0': -3.7e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1161617}
-        Mineral.__init__(self)
-
-
-class wal (Mineral):
-    def __init__(self):
-        self.params = {'name': 'wal',
-                       'formula': {'Ca': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1625900.0,
-                       'S_0': 83.5,
-                       'V_0': 3.7633e-05,
-                       'Cp': [159.3, 0.0, -967300.0, -1075.4],
-                       'a_0': 2.54e-05,
-                       'K_0': 79500e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -5.2e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1161617}
-        Mineral.__init__(self)
-
-
-class tr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'tr',
-                       'formula': {'Ca': 2.0, 'H': 2.0, 'Mg': 5.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12304870.0,
-                       'S_0': 553.0,
-                       'V_0': 0.0002727,
-                       'Cp': [1260.2, 0.00383, -11455000.0, -8237.6],
-                       'a_0': 2.61e-05,
-                       'K_0': 76200e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -5.4e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.81236648}
-        Mineral.__init__(self)
-
-
-class fact (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fact',
-                       'formula': {'Ca': 2.0, 'Fe': 5.0, 'H': 2.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -10504120.0,
-                       'S_0': 710.0,
-                       'V_0': 0.0002842,
-                       'Cp': [1290.0, 0.029992, -8447500.0, -8947.0],
-                       'a_0': 2.88e-05,
-                       'K_0': 76000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -5.4e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.97006648}
-        Mineral.__init__(self)
-
-
-class ts (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ts',
-                       'formula': {'Al': 4.0, 'Ca': 2.0, 'H': 2.0, 'Mg': 3.0, 'O': 24.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12555270.0,
-                       'S_0': 533.0,
-                       'V_0': 0.000268,
-                       'Cp': [1244.8, 0.024348, -11965000.0, -8112.1],
-                       'a_0': 2.66e-05,
-                       'K_0': 76000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -5.4e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.81551148}
-        Mineral.__init__(self)
-
-
-class parg (Mineral):
-    def __init__(self):
-        self.params = {'name': 'parg',
-                       'formula': {'Al': 3.0, 'Ca': 2.0, 'H': 2.0, 'Mg': 4.0, 'Na': 1.0, 'O': 24.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12664730.0,
-                       'S_0': 635.0,
-                       'V_0': 0.0002719,
-                       'Cp': [1280.2, 0.022997, -12359500.0, -8065.8],
-                       'a_0': 2.8e-05,
-                       'K_0': 91200e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.5e-11,
-                       'n': 42.0,
-                       'molar_mass': 0.83582478}
-        Mineral.__init__(self)
-
-
-class gl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'gl',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'Mg': 3.0, 'Na': 2.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -11960240.0,
-                       'S_0': 530.0,
-                       'V_0': 0.0002598,
-                       'Cp': [1717.5, -0.12107, 7075000.0, -19272.0],
-                       'a_0': 1.49e-05,
-                       'K_0': 88300e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.6e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.78354308}
-        Mineral.__init__(self)
-
-
-class fgl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fgl',
-                       'formula': {'Al': 2.0, 'Fe': 3.0, 'H': 2.0, 'Na': 2.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -10880210.0,
-                       'S_0': 624.0,
-                       'V_0': 0.0002659,
-                       'Cp': [1762.9, -0.118992, 9423700.0, -20207.1],
-                       'a_0': 1.83e-05,
-                       'K_0': 89000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.6e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.87816308}
-        Mineral.__init__(self)
-
-
-class rieb (Mineral):
-    def __init__(self):
-        self.params = {'name': 'rieb',
-                       'formula': {'Fe': 5.0, 'H': 2.0, 'Na': 2.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -10024780.0,
-                       'S_0': 695.0,
-                       'V_0': 0.0002749,
-                       'Cp': [1787.3, -0.124882, 9627100.0, -20275.5],
-                       'a_0': 1.81e-05,
-                       'K_0': 89000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.6e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.93589008}
-        Mineral.__init__(self)
-
-
-class anth (Mineral):
-    def __init__(self):
-        self.params = {'name': 'anth',
-                       'formula': {'H': 2.0, 'Mg': 7.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12066840.0,
-                       'S_0': 537.0,
-                       'V_0': 0.0002654,
-                       'Cp': [1277.3, 0.025825, -9704600.0, -9074.7],
-                       'a_0': 2.52e-05,
-                       'K_0': 70000e6,
-                       'Kprime_0': 4.11,
-                       'Kdprime_0': -5.9e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.78082048}
-        Mineral.__init__(self)
-
-
-class fanth (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fanth',
-                       'formula': {'Fe': 7.0, 'H': 2.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9624520.0,
-                       'S_0': 725.0,
-                       'V_0': 0.0002787,
-                       'Cp': [1383.1, 0.030669, -4224700.0, -11257.6],
-                       'a_0': 2.74e-05,
-                       'K_0': 70000e6,
-                       'Kprime_0': 4.11,
-                       'Kdprime_0': -5.9e-11,
-                       'n': 41.0,
-                       'molar_mass': 1.00160048}
-        Mineral.__init__(self)
-
-
-class cumm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cumm',
-                       'formula': {'H': 2.0, 'Mg': 7.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12064690.0,
-                       'S_0': 538.0,
-                       'V_0': 0.0002633,
-                       'Cp': [1277.3, 0.025825, -9704600.0, -9074.7],
-                       'a_0': 2.52e-05,
-                       'K_0': 70000e6,
-                       'Kprime_0': 4.11,
-                       'Kdprime_0': -5.9e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.78082048}
-        Mineral.__init__(self)
-
-
-class grun (Mineral):
-    def __init__(self):
-        self.params = {'name': 'grun',
-                       'formula': {'Fe': 7.0, 'H': 2.0, 'O': 24.0, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9607150.0,
-                       'S_0': 735.0,
-                       'V_0': 0.0002784,
-                       'Cp': [1383.1, 0.030669, -4224700.0, -11257.6],
-                       'a_0': 2.74e-05,
-                       'K_0': 64800e6,
-                       'Kprime_0': 4.12,
-                       'Kdprime_0': -6.4e-11,
-                       'n': 41.0,
-                       'molar_mass': 1.00160048}
-        Mineral.__init__(self)
-
-
-class ged (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ged',
-                       'formula': {'Al': 4.0, 'H': 2.0, 'Mg': 5.0, 'O': 24.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12329140.0,
-                       'S_0': 517.0,
-                       'V_0': 0.00025548,
-                       'Cp': [1307.7, 0.023642, -9307400.0, -9799.0],
-                       'a_0': 2.41e-05,
-                       'K_0': 77000e6,
-                       'Kprime_0': 4.1,
-                       'Kdprime_0': -5.3e-11,
-                       'n': 41.0,
-                       'molar_mass': 0.78396548}
-        Mineral.__init__(self)
-
-
-class spr4 (Mineral):
-    def __init__(self):
-        self.params = {'name': 'spr4',
-                       'formula': {'Al': 8.0, 'Mg': 4.0, 'O': 20.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -11022020.0,
-                       'S_0': 425.5,
-                       'V_0': 0.000199,
-                       'Cp': [1133.1, -0.007596, -8816600.0, -8180.6],
-                       'a_0': 2.05e-05,
-                       'K_0': 250000e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 34.0,
-                       'molar_mass': 0.689231}
-        Mineral.__init__(self)
-
-
-class spr5 (Mineral):
-    def __init__(self):
-        self.params = {'name': 'spr5',
-                       'formula': {'Al': 10.0, 'Mg': 3.0, 'O': 20.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -11135570.0,
-                       'S_0': 419.5,
-                       'V_0': 0.0001975,
-                       'Cp': [1103.4, 0.001015, -10957000.0, -7409.2],
-                       'a_0': 2.06e-05,
-                       'K_0': 250000e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 34.0,
-                       'molar_mass': 0.6908035}
-        Mineral.__init__(self)
-
-
-class fspr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fspr',
-                       'formula': {'Al': 8.0, 'Fe': 4.0, 'O': 20.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9659530.0,
-                       'S_0': 485.0,
-                       'V_0': 0.00019923,
-                       'Cp': [1132.9, -0.007348, -10420200.0, -7036.6],
-                       'a_0': 1.96e-05,
-                       'K_0': 250000e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.7e-11,
-                       'n': 34.0,
-                       'molar_mass': 0.815391}
-        Mineral.__init__(self)
-
-
-class mcar (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mcar',
-                       'formula': {'Al': 2.0, 'H': 4.0, 'Mg': 1.0, 'O': 10.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4771050.0,
-                       'S_0': 221.5,
-                       'V_0': 0.0001059,
-                       'Cp': [683.0, -0.014054, 291000.0, -6976.4],
-                       'a_0': 2.43e-05,
-                       'K_0': 52500e6,
-                       'Kprime_0': 4.14,
-                       'Kdprime_0': -7.9e-11,
-                       'n': 19.0,
-                       'molar_mass': 0.29846476}
-        Mineral.__init__(self)
-
-
-class fcar (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fcar',
-                       'formula': {'Al': 2.0, 'Fe': 1.0, 'H': 4.0, 'O': 10.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4411440.0,
-                       'S_0': 251.1,
-                       'V_0': 0.00010695,
-                       'Cp': [686.6, -0.012415, 186000.0, -6884.0],
-                       'a_0': 2.21e-05,
-                       'K_0': 52500e6,
-                       'Kprime_0': 4.14,
-                       'Kdprime_0': -7.9e-11,
-                       'n': 19.0,
-                       'molar_mass': 0.33000476}
-        Mineral.__init__(self)
-
-
-class deer (Mineral):
-    def __init__(self):
-        self.params = {'name': 'deer',
-                       'formula': {'Fe': 18.0, 'H': 10.0, 'O': 50.0, 'Si': 12.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -18341400.0,
-                       'S_0': 1650.0,
-                       'V_0': 0.0005574,
-                       'Cp': [3164.4, -0.027883, -5039100.0, -26721.0],
-                       'a_0': 2.75e-05,
-                       'K_0': 63000e6,
-                       'Kprime_0': 4.12,
-                       'Kdprime_0': -6.5e-11,
-                       'n': 90.0,
-                       'molar_mass': 2.1522854}
-        Mineral.__init__(self)
-
-
-class mu (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mu',
-                       'formula': {'Al': 3.0, 'H': 2.0, 'K': 1.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5976510.0,
-                       'S_0': 292.0,
-                       'V_0': 0.00014083,
-                       'Cp': [756.4, -0.01984, -2170000.0, -6979.2],
-                       'a_0': 3.07e-05,
-                       'K_0': 49000e6,
-                       'Kprime_0': 4.15,
-                       'Kdprime_0': -8.5e-11,
-                       'n': 21.0,
-                       'molar_mass': 0.39830798}
-        Mineral.__init__(self)
-
-
-class cel (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cel',
-                       'formula': {'Al': 1.0, 'H': 2.0, 'K': 1.0, 'Mg': 1.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5834840.0,
-                       'S_0': 290.0,
-                       'V_0': 0.00013957,
-                       'Cp': [741.2, -0.018748, -2368800.0, -6616.9],
-                       'a_0': 3.07e-05,
-                       'K_0': 70000e6,
-                       'Kprime_0': 4.11,
-                       'Kdprime_0': -5.9e-11,
-                       'n': 21.0,
-                       'molar_mass': 0.39673548}
-        Mineral.__init__(self)
-
-
-class fcel (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fcel',
-                       'formula': {'Al': 1.0, 'Fe': 1.0, 'H': 2.0, 'K': 1.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5468490.0,
-                       'S_0': 330.0,
-                       'V_0': 0.0001407,
-                       'Cp': [756.3, -0.019147, -1586100.0, -6928.7],
-                       'a_0': 3.18e-05,
-                       'K_0': 70000e6,
-                       'Kprime_0': 4.11,
-                       'Kdprime_0': -5.9e-11,
-                       'n': 21.0,
-                       'molar_mass': 0.42827548}
-        Mineral.__init__(self)
-
-
-class pa (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pa',
-                       'formula': {'Al': 3.0, 'H': 2.0, 'Na': 1.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5942840.0,
-                       'S_0': 277.0,
-                       'V_0': 0.00013211,
-                       'Cp': [803.0, -0.03158, 217000.0, -8151.0],
-                       'a_0': 3.7e-05,
-                       'K_0': 51500e6,
-                       'Kprime_0': 6.51,
-                       'Kdprime_0': -1.26e-10,
-                       'n': 21.0,
-                       'molar_mass': 0.38219948}
-        Mineral.__init__(self)
-
-
-class ma (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ma',
-                       'formula': {'Al': 4.0, 'Ca': 1.0, 'H': 2.0, 'O': 12.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6242070.0,
-                       'S_0': 265.0,
-                       'V_0': 0.00012964,
-                       'Cp': [744.4, -0.0168, -2074400.0, -6783.2],
-                       'a_0': 2.33e-05,
-                       'K_0': 100000e6,
-                       'Kprime_0': 4.08,
-                       'Kdprime_0': -4.1e-11,
-                       'n': 21.0,
-                       'molar_mass': 0.39818368}
-        Mineral.__init__(self)
-
-
-class phl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'phl',
-                       'formula': {'Al': 1.0, 'H': 2.0, 'K': 1.0, 'Mg': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6214880.0,
-                       'S_0': 326.0,
-                       'V_0': 0.00014964,
-                       'Cp': [770.3, -0.036939, -2328900.0, -6531.6],
-                       'a_0': 3.8e-05,
-                       'K_0': 51300e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 22.0,
-                       'molar_mass': 0.41725998}
-        Mineral.__init__(self)
-
-
-class ann (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ann',
-                       'formula': {'Al': 1.0, 'Fe': 3.0, 'H': 2.0, 'K': 1.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5143720.0,
-                       'S_0': 420.0,
-                       'V_0': 0.00015432,
-                       'Cp': [815.7, -0.034861, 19800.0, -7466.7],
-                       'a_0': 3.8e-05,
-                       'K_0': 51300e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 22.0,
-                       'molar_mass': 0.51187998}
-        Mineral.__init__(self)
-
-
-class mnbi (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mnbi',
-                       'formula': {'Al': 1.0, 'H': 2.0, 'K': 1.0, 'Mn': 3.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5477520.0,
-                       'S_0': 433.0,
-                       'V_0': 0.00015264,
-                       'Cp': [809.9, -0.059213, -1514400.0, -6998.7],
-                       'a_0': 3.8e-05,
-                       'K_0': 53000e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 22.0,
-                       'molar_mass': 0.50915898}
-        Mineral.__init__(self)
-
-
-class east (Mineral):
-    def __init__(self):
-        self.params = {'name': 'east',
-                       'formula': {'Al': 3.0, 'H': 2.0, 'K': 1.0, 'Mg': 2.0, 'O': 12.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6330380.0,
-                       'S_0': 318.0,
-                       'V_0': 0.00014738,
-                       'Cp': [785.5, -0.038031, -2130300.0, -6893.7],
-                       'a_0': 3.8e-05,
-                       'K_0': 53000e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 22.0,
-                       'molar_mass': 0.41883248}
-        Mineral.__init__(self)
-
-
-class naph (Mineral):
-    def __init__(self):
-        self.params = {'name': 'naph',
-                       'formula': {'Al': 1.0, 'H': 2.0, 'Mg': 3.0, 'Na': 1.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6172010.0,
-                       'S_0': 318.0,
-                       'V_0': 0.0001445,
-                       'Cp': [773.5, -0.040229, -2597900.0, -6512.6],
-                       'a_0': 3.28e-05,
-                       'K_0': 51300e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 22.0,
-                       'molar_mass': 0.40115148}
-        Mineral.__init__(self)
-
-
-class clin (Mineral):
-    def __init__(self):
-        self.params = {'name': 'clin',
-                       'formula': {'Al': 2.0, 'H': 8.0, 'Mg': 5.0, 'O': 18.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -8909160.0,
-                       'S_0': 437.0,
-                       'V_0': 0.0002114,
-                       'Cp': [1170.8, -0.001508, -3825800.0, -10315.0],
-                       'a_0': 2.04e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 36.0,
-                       'molar_mass': 0.55579722}
-        Mineral.__init__(self)
-
-
-class ames (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ames',
-                       'formula': {'Al': 4.0, 'H': 8.0, 'Mg': 4.0, 'O': 18.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -9040460.0,
-                       'S_0': 412.0,
-                       'V_0': 0.0002071,
-                       'Cp': [1186.0, -0.002599, -3627200.0, -10677.0],
-                       'a_0': 2e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 36.0,
-                       'molar_mass': 0.55736972}
-        Mineral.__init__(self)
-
-
-class afchl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'afchl',
-                       'formula': {'H': 8.0, 'Mg': 6.0, 'O': 18.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -8727860.0,
-                       'S_0': 439.0,
-                       'V_0': 0.0002157,
-                       'Cp': [1155.0, -0.000417, -4024400.0, -9952.9],
-                       'a_0': 2.04e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 36.0,
-                       'molar_mass': 0.55422472}
-        Mineral.__init__(self)
-
-
-class daph (Mineral):
-    def __init__(self):
-        self.params = {'name': 'daph',
-                       'formula': {'Al': 2.0, 'Fe': 5.0, 'H': 8.0, 'O': 18.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -7116910.0,
-                       'S_0': 584.0,
-                       'V_0': 0.0002162,
-                       'Cp': [1192.0, -0.00594, -4826400.0, -9768.3],
-                       'a_0': 2.27e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 36.0,
-                       'molar_mass': 0.71349722}
-        Mineral.__init__(self)
-
-
-class mnchl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mnchl',
-                       'formula': {'Al': 2.0, 'H': 8.0, 'Mn': 5.0, 'O': 18.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -7702320.0,
-                       'S_0': 595.0,
-                       'V_0': 0.0002259,
-                       'Cp': [1136.5, -0.005243, -5548100.0, -8911.5],
-                       'a_0': 2.23e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 36.0,
-                       'molar_mass': 0.70896222}
-        Mineral.__init__(self)
-
-
-class sud (Mineral):
-    def __init__(self):
-        self.params = {'name': 'sud',
-                       'formula': {'Al': 4.0, 'H': 8.0, 'Mg': 2.0, 'O': 18.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -8626540.0,
-                       'S_0': 395.0,
-                       'V_0': 0.000203,
-                       'Cp': [1436.1, -0.048749, -2748500.0, -13764.0],
-                       'a_0': 1.99e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 35.0,
-                       'molar_mass': 0.53684522}
-        Mineral.__init__(self)
-
-
-class fsud (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fsud',
-                       'formula': {'Al': 4.0, 'Fe': 2.0, 'H': 8.0, 'O': 18.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -7899850.0,
-                       'S_0': 456.0,
-                       'V_0': 0.000204,
-                       'Cp': [1466.3, -0.047365, -1182800.0, -14388.0],
-                       'a_0': 2.08e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 35.0,
-                       'molar_mass': 0.59992522}
-        Mineral.__init__(self)
-
-
-class prl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'prl',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5640610.0,
-                       'S_0': 239.0,
-                       'V_0': 0.00012804,
-                       'Cp': [784.5, -0.042948, 1251000.0, -8495.9],
-                       'a_0': 4.5e-05,
-                       'K_0': 37000e6,
-                       'Kprime_0': 10.0,
-                       'Kdprime_0': -2.71e-10,
-                       'n': 20.0,
-                       'molar_mass': 0.36031368}
-        Mineral.__init__(self)
-
-
-class ta (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ta',
-                       'formula': {'H': 2.0, 'Mg': 3.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5897170.0,
-                       'S_0': 259.0,
-                       'V_0': 0.00013665,
-                       'Cp': [622.2, 0.0, -6385500.0, -3916.3],
-                       'a_0': 1.8e-05,
-                       'K_0': 43000e6,
-                       'Kprime_0': 6.17,
-                       'Kdprime_0': -1.44e-10,
-                       'n': 21.0,
-                       'molar_mass': 0.37926568}
-        Mineral.__init__(self)
-
-
-class fta (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fta',
-                       'formula': {'Fe': 3.0, 'H': 2.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4798540.0,
-                       'S_0': 352.0,
-                       'V_0': 0.00014225,
-                       'Cp': [579.7, 0.039494, -6459300.0, -3088.1],
-                       'a_0': 1.8e-05,
-                       'K_0': 43000e6,
-                       'Kprime_0': 6.17,
-                       'Kdprime_0': -1.44e-10,
-                       'n': 21.0,
-                       'molar_mass': 0.47388568}
-        Mineral.__init__(self)
-
-
-class tats (Mineral):
-    def __init__(self):
-        self.params = {'name': 'tats',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'Mg': 2.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6001290.0,
-                       'S_0': 259.0,
-                       'V_0': 0.0001351,
-                       'Cp': [549.5, 0.036324, -8606600.0, -2515.3],
-                       'a_0': 1.8e-05,
-                       'K_0': 43000e6,
-                       'Kprime_0': 6.17,
-                       'Kdprime_0': -1.44e-10,
-                       'n': 21.0,
-                       'molar_mass': 0.38083818}
-        Mineral.__init__(self)
-
-
-class tap (Mineral):
-    def __init__(self):
-        self.params = {'name': 'tap',
-                       'formula': {'Al': 2.0, 'H': 2.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5649780.0,
-                       'S_0': 235.0,
-                       'V_0': 0.0001345,
-                       'Cp': [784.5, -0.042948, 1251000.0, -8495.9],
-                       'a_0': 4.5e-05,
-                       'K_0': 37000e6,
-                       'Kprime_0': 10.0,
-                       'Kdprime_0': -2.71e-10,
-                       'n': 20.0,
-                       'molar_mass': 0.36031368}
-        Mineral.__init__(self)
-
-
-class minn (Mineral):
-    def __init__(self):
-        self.params = {'name': 'minn',
-                       'formula': {'Fe': 3.0, 'H': 2.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4819310.0,
-                       'S_0': 355.0,
-                       'V_0': 0.00014851,
-                       'Cp': [579.7, 0.039494, -6459300.0, -3088.1],
-                       'a_0': 1.8e-05,
-                       'K_0': 43000e6,
-                       'Kprime_0': 6.17,
-                       'Kdprime_0': -1.44e-10,
-                       'n': 21.0,
-                       'molar_mass': 0.47388568}
-        Mineral.__init__(self)
-
-
-class minm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'minm',
-                       'formula': {'H': 2.0, 'Mg': 3.0, 'O': 12.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5866000.0,
-                       'S_0': 263.9,
-                       'V_0': 0.00014291,
-                       'Cp': [622.2, 0.0, -6385500.0, -3916.3],
-                       'a_0': 1.8e-05,
-                       'K_0': 43000e6,
-                       'Kprime_0': 6.17,
-                       'Kdprime_0': -1.44e-10,
-                       'n': 21.0,
-                       'molar_mass': 0.37926568}
-        Mineral.__init__(self)
-
-
-class kao (Mineral):
-    def __init__(self):
-        self.params = {'name': 'kao',
-                       'formula': {'Al': 2.0, 'H': 4.0, 'O': 9.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4122000.0,
-                       'S_0': 203.7,
-                       'V_0': 9.934e-05,
-                       'Cp': [436.7, -0.034295, -4055900.0, -2699.1],
-                       'a_0': 2.51e-05,
-                       'K_0': 64500e6,
-                       'Kprime_0': 4.12,
-                       'Kdprime_0': -6.4e-11,
-                       'n': 17.0,
-                       'molar_mass': 0.25816036}
-        Mineral.__init__(self)
-
-
-class pre (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pre',
-                       'formula': {'Al': 2.0, 'Ca': 2.0, 'H': 2.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6202170.0,
-                       'S_0': 292.8,
-                       'V_0': 0.00014026,
-                       'Cp': [724.9, -0.013865, -2059000.0, -6323.9],
-                       'a_0': 1.58e-05,
-                       'K_0': 109300e6,
-                       'Kprime_0': 4.01,
-                       'Kdprime_0': -3.7e-11,
-                       'n': 21.0,
-                       'molar_mass': 0.41238418}
-        Mineral.__init__(self)
-
-
-class fpre (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fpre',
-                       'formula': {'Al': 1.0, 'Ca': 2.0, 'Fe': 1.0, 'H': 2.0, 'O': 12.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -5766640.0,
-                       'S_0': 320.0,
-                       'V_0': 0.000148,
-                       'Cp': [737.1, -0.01681, -1957300.0, -6358.1],
-                       'a_0': 1.58e-05,
-                       'K_0': 109300e6,
-                       'Kprime_0': 4.01,
-                       'Kdprime_0': -3.7e-11,
-                       'n': 21.0,
-                       'molar_mass': 0.44124768}
-        Mineral.__init__(self)
-
-
-class chr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'chr',
-                       'formula': {'H': 4.0, 'Mg': 3.0, 'O': 9.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4361000.0,
-                       'S_0': 221.3,
-                       'V_0': 0.00010746,
-                       'Cp': [624.7, -0.02077, -1721800.0, -5619.4],
-                       'a_0': 2.2e-05,
-                       'K_0': 62800e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -6.4e-11,
-                       'n': 18.0,
-                       'molar_mass': 0.27711236}
-        Mineral.__init__(self)
-
-
-class liz (Mineral):
-    def __init__(self):
-        self.params = {'name': 'liz',
-                       'formula': {'H': 4.0, 'Mg': 3.0, 'O': 9.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4369190.0,
-                       'S_0': 212.0,
-                       'V_0': 0.00010645,
-                       'Cp': [614.7, -0.02077, -1721800.0, -5619.4],
-                       'a_0': 2.2e-05,
-                       'K_0': 71000e6,
-                       'Kprime_0': 3.2,
-                       'Kdprime_0': -4.5e-11,
-                       'n': 18.0,
-                       'molar_mass': 0.27711236}
-        Mineral.__init__(self)
-
-
-class glt (Mineral):
-    def __init__(self):
-        self.params = {'name': 'glt',
-                       'formula': {'Fe': 3.0, 'H': 4.0, 'O': 9.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3297620.0,
-                       'S_0': 310.0,
-                       'V_0': 0.0001198,
-                       'Cp': [576.4, 0.002984, -3757000.0, -4166.2],
-                       'a_0': 2.28e-05,
-                       'K_0': 63000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -6.3e-11,
-                       'n': 18.0,
-                       'molar_mass': 0.37173236}
-        Mineral.__init__(self)
-
-
-class fstp (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fstp',
-                       'formula': {'Al': 2.0, 'Fe': 5.0, 'H': 12.5, 'K': 0.5, 'O': 30.5, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -12551070.0,
-                       'S_0': 930.2,
-                       'V_0': 0.00037239,
-                       'Cp': [1944.3, -0.012289, -4840200.0, -16635.0],
-                       'a_0': 3.68e-05,
-                       'K_0': 51300e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 58.5,
-                       'molar_mass': 1.0780021}
-        Mineral.__init__(self)
-
-
-class mstp (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mstp',
-                       'formula': {'Al': 2.0, 'H': 12.5, 'K': 0.5, 'Mg': 5.0, 'O': 30.5, 'Si': 8.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -14288380.0,
-                       'S_0': 847.4,
-                       'V_0': 0.00036577,
-                       'Cp': [1862.2, -0.014018, -8983100.0, -14923.0],
-                       'a_0': 3.71e-05,
-                       'K_0': 51300e6,
-                       'Kprime_0': 7.33,
-                       'Kdprime_0': -1.43e-10,
-                       'n': 58.5,
-                       'molar_mass': 0.9203021}
-        Mineral.__init__(self)
-
-
-class atg (Mineral):
-    def __init__(self):
-        self.params = {'name': 'atg',
-                       'formula': {'H': 62.0, 'Mg': 48.0, 'O': 147.0, 'Si': 34.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -71404690.0,
-                       'S_0': 3620.0,
-                       'V_0': 0.0017548,
-                       'Cp': [9621.0, -0.091183, -35941600.0, -83034.2],
-                       'a_0': 2.8e-05,
-                       'K_0': 63100e6,
-                       'Kprime_0': 5.92,
-                       'Kdprime_0': -9.4e-11,
-                       'n': 291.0,
-                       'molar_mass': 4.53595108}
-        Mineral.__init__(self)
-
-
-class ab (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ab',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3935480.0,
-                       'S_0': 207.4,
-                       'V_0': 0.00010067,
-                       'Cp': [452.0, -0.013364, -1275900.0, -3953.6],
-                       'a_0': 2.36e-05,
-                       'K_0': 54100e6,
-                       'Kprime_0': 5.91,
-                       'Kdprime_0': -1.09e-10,
-                       'n': 13.0,
-                       'molar_mass': 0.262223}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 14000.0,
-                                                       'deltaV': 4.2e-07,
-                                                       'Wh': 13000.0,
-                                                       'Wv': 4.2e-07,
-                                                       'n': 3.0,
-                                                       'factor': 0.9}]]
-        Mineral.__init__(self)
-
-
-class abh (Mineral):
-    def __init__(self):
-        self.params = {'name': 'abh',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3921480.0,
-                       'S_0': 224.3,
-                       'V_0': 0.00010105,
-                       'Cp': [452.0, -0.013364, -1275900.0, -3953.6],
-                       'a_0': 2.41e-05,
-                       'K_0': 54100e6,
-                       'Kprime_0': 5.91,
-                       'Kdprime_0': -1.09e-10,
-                       'n': 13.0,
-                       'molar_mass': 0.262223}
-        Mineral.__init__(self)
-
-
-class mic (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mic',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3975350.0,
-                       'S_0': 214.3,
-                       'V_0': 0.00010871,
-                       'Cp': [448.8, -0.010075, -1007300.0, -3973.1],
-                       'a_0': 1.66e-05,
-                       'K_0': 58300e6,
-                       'Kprime_0': 4.02,
-                       'Kdprime_0': -6.9e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.2783315}
-        Mineral.__init__(self)
-
-
-class san (Mineral):
-    def __init__(self):
-        self.params = {'name': 'san',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3966700.0,
-                       'S_0': 214.3,
-                       'V_0': 0.00010871,
-                       'Cp': [448.8, -0.010075, -1007300.0, -3973.1],
-                       'a_0': 1.66e-05,
-                       'K_0': 58300e6,
-                       'Kprime_0': 4.02,
-                       'Kdprime_0': -6.9e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.2783315}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 8650.0,
-                                                       'deltaV': 2.4e-07,
-                                                       'Wh': 8500.0,
-                                                       'Wv': 2.4e-07,
-                                                       'n': 3.0,
-                                                       'factor': 0.8}]]
-        Mineral.__init__(self)
-
-
-class an (Mineral):
-    def __init__(self):
-        self.params = {'name': 'an',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'O': 8.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4232690.0,
-                       'S_0': 200.5,
-                       'V_0': 0.00010079,
-                       'Cp': [370.5, 0.01001, -4339100.0, -1960.6],
-                       'a_0': 1.41e-05,
-                       'K_0': 86000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.2782072}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 42010.0,
-                                                       'deltaV': 1e-06,
-                                                       'Wh': 42000.0,
-                                                       'Wv': 1e-06,
-                                                       'n': 1.0,
-                                                       'factor': 2.0}]]
-        Mineral.__init__(self)
-
-
-class kcm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'kcm',
-                       'formula': {'Al': 1.0, 'H': 2.0, 'K': 1.0, 'O': 9.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4232640.0,
-                       'S_0': 281.5,
-                       'V_0': 0.00011438,
-                       'Cp': [536.5, -0.01009, -980400.0, -4735.0],
-                       'a_0': 3.21e-05,
-                       'K_0': 42500e6,
-                       'Kprime_0': 2.0,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 16.0,
-                       'molar_mass': 0.29634678}
-        Mineral.__init__(self)
-
-
-class wa (Mineral):
-    def __init__(self):
-        self.params = {'name': 'wa',
-                       'formula': {'K': 2.0, 'O': 9.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -4271890.0,
-                       'S_0': 254.0,
-                       'V_0': 0.00010844,
-                       'Cp': [499.1, 0.0, 0.0, -4350.1],
-                       'a_0': 2.66e-05,
-                       'K_0': 90000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -4.4e-11,
-                       'n': 15.0,
-                       'molar_mass': 0.3345332}
-        Mineral.__init__(self)
-
-
-class hol (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hol',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3791960.0,
-                       'S_0': 166.2,
-                       'V_0': 7.128e-05,
-                       'Cp': [417.6, -0.003617, -4748100.0, -2819.9],
-                       'a_0': 2.8e-05,
-                       'K_0': 180000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 13.0,
-                       'molar_mass': 0.2783315}
-        Mineral.__init__(self)
-
-
-class q (Mineral):
-    def __init__(self):
-        self.params = {'name': 'q',
-                       'formula': {'O': 2.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -910720.0,
-                       'S_0': 41.43,
-                       'V_0': 2.269e-05,
-                       'Cp': [92.9, -0.000642, -714900.0, -716.1],
-                       'a_0': 0.0,
-                       'K_0': 73000e6,
-                       'Kprime_0': 6.0,
-                       'Kdprime_0': -8.2e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.0600843}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 847.0,
-                                                  'S_D': 4.95,
-                                                  'V_D': 1.188e-06}]]
-        Mineral.__init__(self)
-
-
-class trd (Mineral):
-    def __init__(self):
-        self.params = {'name': 'trd',
-                       'formula': {'O': 2.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -907110.0,
-                       'S_0': 44.1,
-                       'V_0': 2.8e-05,
-                       'Cp': [74.9, 0.0031, -1174000.0, -236.7],
-                       'a_0': 0.0,
-                       'K_0': 15000e6,
-                       'Kprime_0': 4.36,
-                       'Kdprime_0': -2.91e-10,
-                       'n': 3.0,
-                       'molar_mass': 0.0600843}
-        Mineral.__init__(self)
-
-
-class crst (Mineral):
-    def __init__(self):
-        self.params = {'name': 'crst',
-                       'formula': {'O': 2.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -904270.0,
-                       'S_0': 50.86,
-                       'V_0': 2.745e-05,
-                       'Cp': [72.7, 0.001304, -4129000.0, 0.0],
-                       'a_0': 0.0,
-                       'K_0': 16000e6,
-                       'Kprime_0': 4.35,
-                       'Kdprime_0': -2.72e-10,
-                       'n': 3.0,
-                       'molar_mass': 0.0600843}
-        Mineral.__init__(self)
-
-
-class coe (Mineral):
-    def __init__(self):
-        self.params = {'name': 'coe',
-                       'formula': {'O': 2.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -907000.0,
-                       'S_0': 39.6,
-                       'V_0': 2.064e-05,
-                       'Cp': [107.8, -0.003279, -190300.0, -1041.6],
-                       'a_0': 1.23e-05,
-                       'K_0': 97900e6,
-                       'Kprime_0': 4.19,
-                       'Kdprime_0': -4.3e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.0600843}
-        Mineral.__init__(self)
-
-
-class stv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'stv',
-                       'formula': {'O': 2.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -876390.0,
-                       'S_0': 24.0,
-                       'V_0': 1.401e-05,
-                       'Cp': [68.1, 0.00601, -1978200.0, -82.1],
-                       'a_0': 1.58e-05,
-                       'K_0': 309000e6,
-                       'Kprime_0': 4.6,
-                       'Kdprime_0': -1.5e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.0600843}
-        Mineral.__init__(self)
-
-
-class ne (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ne',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2094560.0,
-                       'S_0': 124.4,
-                       'V_0': 5.419e-05,
-                       'Cp': [272.7, -0.012398, 0.0, -2763.1],
-                       'a_0': 4.63e-05,
-                       'K_0': 46500e6,
-                       'Kprime_0': 4.16,
-                       'Kdprime_0': -8.9e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1420544}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 467.0,
-                                                  'S_D': 10.0,
-                                                  'V_D': 8e-07}]]
-        Mineral.__init__(self)
-
-
-class cg (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cg',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2091719.9999999998,
-                       'S_0': 118.7,
-                       'V_0': 5.603e-05,
-                       'Cp': [116.1, 0.086021, -1992700.0, 0.0],
-                       'a_0': 4.5e-05,
-                       'K_0': 46500e6,
-                       'Kprime_0': 4.16,
-                       'Kdprime_0': -8.9e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1420544}
-        Mineral.__init__(self)
-
-
-class cgh (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cgh',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2078010.0000000002,
-                       'S_0': 135.0,
-                       'V_0': 5.67e-05,
-                       'Cp': [229.2, 0.011876, 0.0, -1970.7],
-                       'a_0': 4.67e-05,
-                       'K_0': 46500e6,
-                       'Kprime_0': 4.16,
-                       'Kdprime_0': -8.9e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1420544}
-        Mineral.__init__(self)
-
-
-class sdl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'sdl',
-                       'formula': {'Al': 6.0, 'Cl': 2.0, 'Na': 8.0, 'O': 24.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -13405530.0,
-                       'S_0': 910.0,
-                       'V_0': 0.0004213,
-                       'Cp': [1532.7, 0.047747, -2972800.0, -12427.0],
-                       'a_0': 4.63e-05,
-                       'K_0': 46500e6,
-                       'Kprime_0': 4.16,
-                       'Kdprime_0': -8.9e-11,
-                       'n': 46.0,
-                       'molar_mass': 0.969212}
-        Mineral.__init__(self)
-
-
-class kls (Mineral):
-    def __init__(self):
-        self.params = {'name': 'kls',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2122960.0,
-                       'S_0': 136.0,
-                       'V_0': 6.052e-05,
-                       'Cp': [242.0, -0.004482, -895800.0, -1935.8],
-                       'a_0': 3.16e-05,
-                       'K_0': 51400e6,
-                       'Kprime_0': 2.0,
-                       'Kdprime_0': -3.9e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1581629}
-        Mineral.__init__(self)
-
-
-class lc (Mineral):
-    def __init__(self):
-        self.params = {'name': 'lc',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3029270.0,
-                       'S_0': 198.5,
-                       'V_0': 8.826e-05,
-                       'Cp': [369.8, -0.016332, 684700.0, -3683.1],
-                       'a_0': 1.85e-05,
-                       'K_0': 45000e6,
-                       'Kprime_0': 5.7,
-                       'Kdprime_0': -1.27e-10,
-                       'n': 10.0,
-                       'molar_mass': 0.2182472}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 11610.0,
-                                                       'deltaV': 4e-06,
-                                                       'Wh': 11600.0,
-                                                       'Wv': 4e-06,
-                                                       'n': 2.0,
-                                                       'factor': 0.7}]]
-        Mineral.__init__(self)
-
-
-class me (Mineral):
-    def __init__(self):
-        self.params = {'name': 'me',
-                       'formula': {'Al': 6.0, 'C': 1.0, 'Ca': 4.0, 'O': 27.0, 'Si': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -13841820.0,
-                       'S_0': 752.0,
-                       'V_0': 0.00033985,
-                       'Cp': [1359.0, 0.036442, -8594700.0, -9598.2],
-                       'a_0': 1.81e-05,
-                       'K_0': 87000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.7e-11,
-                       'n': 44.0,
-                       'molar_mass': 0.9347085}
-        Mineral.__init__(self)
-
-
-class wrk (Mineral):
-    def __init__(self):
-        self.params = {'name': 'wrk',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'H': 4.0, 'O': 14.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -6662450.0,
-                       'S_0': 380.0,
-                       'V_0': 0.0001904,
-                       'Cp': [838.3, -0.02146, -2272000.0, -7292.3],
-                       'a_0': 1.49e-05,
-                       'K_0': 86000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 25.0,
-                       'molar_mass': 0.43440636}
-        Mineral.__init__(self)
-
-
-class lmt (Mineral):
-    def __init__(self):
-        self.params = {'name': 'lmt',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'H': 8.0, 'O': 16.0, 'Si': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -7262700.0,
-                       'S_0': 465.0,
-                       'V_0': 0.0002037,
-                       'Cp': [1013.4, -0.021413, -2235800.0, -8806.7],
-                       'a_0': 1.37e-05,
-                       'K_0': 86000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 31.0,
-                       'molar_mass': 0.47043692}
-        Mineral.__init__(self)
-
-
-class heu (Mineral):
-    def __init__(self):
-        self.params = {'name': 'heu',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'H': 12.0, 'O': 24.0, 'Si': 7.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -10545220.0,
-                       'S_0': 783.0,
-                       'V_0': 0.000317,
-                       'Cp': [1504.8, -0.033224, -2959300.0, -13297.2],
-                       'a_0': 1.57e-05,
-                       'K_0': 27400e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -1.46e-10,
-                       'n': 46.0,
-                       'molar_mass': 0.68672038}
-        Mineral.__init__(self)
-
-
-class stlb (Mineral):
-    def __init__(self):
-        self.params = {'name': 'stlb',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'H': 14.0, 'O': 25.0, 'Si': 7.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -10896760.0,
-                       'S_0': 710.0,
-                       'V_0': 0.0003287,
-                       'Cp': [1588.4, -0.032043, -3071600.0, -13966.9],
-                       'a_0': 1.51e-05,
-                       'K_0': 86000e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -4.8e-11,
-                       'n': 49.0,
-                       'molar_mass': 0.70473566}
-        Mineral.__init__(self)
-
-
-class anl (Mineral):
-    def __init__(self):
-        self.params = {'name': 'anl',
-                       'formula': {'Al': 1.0, 'H': 2.0, 'Na': 1.0, 'O': 7.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -3307220.0,
-                       'S_0': 232.0,
-                       'V_0': 9.74e-05,
-                       'Cp': [643.5, -0.016067, 9302300.0, -9179.6],
-                       'a_0': 2.76e-05,
-                       'K_0': 40000e6,
-                       'Kprime_0': 4.18,
-                       'Kdprime_0': -1.04e-10,
-                       'n': 13.0,
-                       'molar_mass': 0.22015398}
-        Mineral.__init__(self)
-
-
-class lime (Mineral):
-    def __init__(self):
-        self.params = {'name': 'lime',
-                       'formula': {'Ca': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -634530.0,
-                       'S_0': 38.1,
-                       'V_0': 1.676e-05,
-                       'Cp': [52.4, 0.003673, -750700.0, -51.0],
-                       'a_0': 3.41e-05,
-                       'K_0': 113000e6,
-                       'Kprime_0': 3.87,
-                       'Kdprime_0': -3.4e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.0560774}
-        Mineral.__init__(self)
-
-
-class ru (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ru',
-                       'formula': {'O': 2.0, 'Ti': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -944360.0,
-                       'S_0': 50.5,
-                       'V_0': 1.882e-05,
-                       'Cp': [90.4, 0.0029, 0.0, -623.8],
-                       'a_0': 2.24e-05,
-                       'K_0': 222000e6,
-                       'Kprime_0': 4.24,
-                       'Kdprime_0': -1.9e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.0798658}
-        Mineral.__init__(self)
-
-
-class per (Mineral):
-    def __init__(self):
-        self.params = {'name': 'per',
-                       'formula': {'Mg': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -601530.0,
-                       'S_0': 26.5,
-                       'V_0': 1.125e-05,
-                       'Cp': [60.5, 0.000362, -535800.0, -299.2],
-                       'a_0': 3.11e-05,
-                       'K_0': 161600e6,
-                       'Kprime_0': 3.95,
-                       'Kdprime_0': -2.4e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.0403044}
-        Mineral.__init__(self)
-
-
-class fper (Mineral):
-    def __init__(self):
-        self.params = {'name': 'fper',
-                       'formula': {'Fe': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -259870.0,
-                       'S_0': 58.6,
-                       'V_0': 1.206e-05,
-                       'Cp': [44.4, 0.00828, -1214200.0, 185.2],
-                       'a_0': 3.22e-05,
-                       'K_0': 152000e6,
-                       'Kprime_0': 4.9,
-                       'Kdprime_0': -3.2e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.0718444}
-        Mineral.__init__(self)
-
-
-class mang (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mang',
-                       'formula': {'Mn': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -385550.0,
-                       'S_0': 59.7,
-                       'V_0': 1.322e-05,
-                       'Cp': [59.8, 0.0036, -31400.0, -282.6],
-                       'a_0': 3.69e-05,
-                       'K_0': 164500e6,
-                       'Kprime_0': 4.46,
-                       'Kdprime_0': -2.7e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.0709374}
-        Mineral.__init__(self)
-
-
-class cor (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cor',
-                       'formula': {'Al': 2.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1675270.0,
-                       'S_0': 50.9,
-                       'V_0': 2.558e-05,
-                       'Cp': [139.5, 0.00589, -2460600.0, -589.2],
-                       'a_0': 1.8e-05,
-                       'K_0': 254000e6,
-                       'Kprime_0': 4.34,
-                       'Kdprime_0': -1.7e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1019612}
-        Mineral.__init__(self)
-
-
-class mcor (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mcor',
-                       'formula': {'Mg': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1474440.0,
-                       'S_0': 59.3,
-                       'V_0': 2.635e-05,
-                       'Cp': [147.8, 0.002015, -2395000.0, -801.8],
-                       'a_0': 2.12e-05,
-                       'K_0': 211000e6,
-                       'Kprime_0': 4.55,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1003887}
-        Mineral.__init__(self)
-
-
-class hem (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hem',
-                       'formula': {'Fe': 2.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -825610.0,
-                       'S_0': 87.4,
-                       'V_0': 3.027e-05,
-                       'Cp': [163.9, 0.0, -2257200.0, -657.6],
-                       'a_0': 2.79e-05,
-                       'K_0': 223000e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.8e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1596882}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 955.0,
-                                                  'S_D': 15.6,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class esk (Mineral):
-    def __init__(self):
-        self.params = {'name': 'esk',
-                       'formula': {'Cr': 2.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1137320.0,
-                       'S_0': 83.0,
-                       'V_0': 2.909e-05,
-                       'Cp': [119.0, 0.009496, -1442000.0, -3.4],
-                       'a_0': 1.59e-05,
-                       'K_0': 238000e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -1.7e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1519904}
-        Mineral.__init__(self)
-
-
-class bix (Mineral):
-    def __init__(self):
-        self.params = {'name': 'bix',
-                       'formula': {'Mn': 2.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -959000.0,
-                       'S_0': 113.7,
-                       'V_0': 3.137e-05,
-                       'Cp': [145.1, 0.023534, 721600.0, -1008.4],
-                       'a_0': 2.91e-05,
-                       'K_0': 223000e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.8e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1578742}
-        Mineral.__init__(self)
-
-
-class NiO (Mineral):
-    def __init__(self):
-        self.params = {'name': 'NiO',
-                       'formula': {'Ni': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -239470.0,
-                       'S_0': 38.0,
-                       'V_0': 1.097e-05,
-                       'Cp': [47.7, 0.007824, -392500.0, 0.0],
-                       'a_0': 3.3e-05,
-                       'K_0': 200000e6,
-                       'Kprime_0': 3.94,
-                       'Kdprime_0': -2e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.0746928}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 520.0,
-                                                  'S_D': 5.7,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class pnt (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pnt',
-                       'formula': {'Mn': 1.0, 'O': 3.0, 'Ti': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1361950.0,
-                       'S_0': 105.5,
-                       'V_0': 3.288e-05,
-                       'Cp': [143.5, 0.003373, -1940700.0, -407.6],
-                       'a_0': 2.4e-05,
-                       'K_0': 170000e6,
-                       'Kprime_0': 8.3,
-                       'Kdprime_0': -4.9e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1508032}
-        Mineral.__init__(self)
-
-
-class geik (Mineral):
-    def __init__(self):
-        self.params = {'name': 'geik',
-                       'formula': {'Mg': 1.0, 'O': 3.0, 'Ti': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1568960.0,
-                       'S_0': 73.6,
-                       'V_0': 3.086e-05,
-                       'Cp': [151.0, 0.0, -1890400.0, -652.2],
-                       'a_0': 2.15e-05,
-                       'K_0': 170000e6,
-                       'Kprime_0': 8.3,
-                       'Kdprime_0': -4.9e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1201702}
-        Mineral.__init__(self)
-
-
-class ilm (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ilm',
-                       'formula': {'Fe': 1.0, 'O': 3.0, 'Ti': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1230450.0,
-                       'S_0': 109.5,
-                       'V_0': 3.169e-05,
-                       'Cp': [138.9, 0.005081, -1288800.0, -463.7],
-                       'a_0': 2.4e-05,
-                       'K_0': 170000e6,
-                       'Kprime_0': 8.3,
-                       'Kdprime_0': -4.9e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1517102}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 1900.0,
-                                                  'S_D': 12.0,
-                                                  'V_D': 2e-07}]]
-        Mineral.__init__(self)
-
-
-class bdy (Mineral):
-    def __init__(self):
-        self.params = {'name': 'bdy',
-                       'formula': {'O': 2.0, 'Zr': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1100340.0,
-                       'S_0': 50.4,
-                       'V_0': 2.115e-05,
-                       'Cp': [103.5, -0.004547, -416200.0, -713.6],
-                       'a_0': 2e-05,
-                       'K_0': 95300e6,
-                       'Kprime_0': 3.88,
-                       'Kdprime_0': -4.1e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.1232228}
-        Mineral.__init__(self)
-
-
-class ten (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ten',
-                       'formula': {'Cu': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -156100.0,
-                       'S_0': 42.6,
-                       'V_0': 1.222e-05,
-                       'Cp': [31.0, 0.01374, -1258000.0, 369.3],
-                       'a_0': 3.57e-05,
-                       'K_0': 200000e6,
-                       'Kprime_0': 3.94,
-                       'Kdprime_0': -2e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.0795454}
-        Mineral.__init__(self)
-
-
-class cup (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cup',
-                       'formula': {'Cu': 2.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -170600.0,
-                       'S_0': 92.4,
-                       'V_0': 2.344e-05,
-                       'Cp': [110.3, 0.0, 0.0, -674.8],
-                       'a_0': 3.33e-05,
-                       'K_0': 131000e6,
-                       'Kprime_0': 5.7,
-                       'Kdprime_0': -4.3e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.1430914}
-        Mineral.__init__(self)
-
-
-class sp (Mineral):
-    def __init__(self):
-        self.params = {'name': 'sp',
-                       'formula': {'Al': 2.0, 'Mg': 1.0, 'O': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2301190.0,
-                       'S_0': 82.0,
-                       'V_0': 3.978e-05,
-                       'Cp': [222.9, 0.006127, -1686000.0, -1551.0],
-                       'a_0': 1.93e-05,
-                       'K_0': 192200e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -2.1e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1422656}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 8000.0,
-                                                       'deltaV': 0.0,
-                                                       'Wh': 1200.0,
-                                                       'Wv': 0.0,
-                                                       'n': 2.0,
-                                                       'factor': 0.5}]]
-        Mineral.__init__(self)
-
-
-class herc (Mineral):
-    def __init__(self):
-        self.params = {'name': 'herc',
-                       'formula': {'Al': 2.0, 'Fe': 1.0, 'O': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1953030.0,
-                       'S_0': 113.9,
-                       'V_0': 4.075e-05,
-                       'Cp': [216.7, 0.005868, -2430200.0, -1178.3],
-                       'a_0': 2.06e-05,
-                       'K_0': 192200e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -2.1e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1738056}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 18300.0,
-                                                       'deltaV': 0.0,
-                                                       'Wh': 13600.0,
-                                                       'Wv': 0.0,
-                                                       'n': 2.0,
-                                                       'factor': 1.0}]]
-        Mineral.__init__(self)
-
-
-class mt (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mt',
-                       'formula': {'Fe': 3.0, 'O': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1114500.0,
-                       'S_0': 146.9,
-                       'V_0': 4.452e-05,
-                       'Cp': [262.5, -0.007205, -1926200.0, -1655.7],
-                       'a_0': 3.71e-05,
-                       'K_0': 185700e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.2315326}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 848.0,
-                                                  'S_D': 35.0,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class mft (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mft',
-                       'formula': {'Fe': 2.0, 'Mg': 1.0, 'O': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1442290.0,
-                       'S_0': 121.0,
-                       'V_0': 4.457e-05,
-                       'Cp': [270.5, -0.007505, -999200.0, -2022.4],
-                       'a_0': 3.63e-05,
-                       'K_0': 185700e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1999926}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 665.0,
-                                                  'S_D': 17.0,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class usp (Mineral):
-    def __init__(self):
-        self.params = {'name': 'usp',
-                       'formula': {'Fe': 2.0, 'O': 4.0, 'Ti': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1491120.0,
-                       'S_0': 180.0,
-                       'V_0': 4.682e-05,
-                       'Cp': [-102.6, 0.14252, -9144500.0, 5270.7],
-                       'a_0': 3.86e-05,
-                       'K_0': 185700e6,
-                       'Kprime_0': 4.05,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.2235546}
-        Mineral.__init__(self)
-
-
-class picr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'picr',
-                       'formula': {'Cr': 2.0, 'Mg': 1.0, 'O': 4.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1762600.0,
-                       'S_0': 118.3,
-                       'V_0': 4.356e-05,
-                       'Cp': [196.1, 0.005398, -3126000.0, -616.9],
-                       'a_0': 1.8e-05,
-                       'K_0': 192200e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -2.1e-11,
-                       'n': 7.0,
-                       'molar_mass': 0.1922948}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 8000.0,
-                                                       'deltaV': 0.0,
-                                                       'Wh': 1200.0,
-                                                       'Wv': 0.0,
-                                                       'n': 2.0,
-                                                       'factor': 0.5}]]
-        Mineral.__init__(self)
-
-
-class br (Mineral):
-    def __init__(self):
-        self.params = {'name': 'br',
-                       'formula': {'H': 2.0, 'Mg': 1.0, 'O': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -925560.0,
-                       'S_0': 63.2,
-                       'V_0': 2.463e-05,
-                       'Cp': [158.4, -0.004076, -1052300.0, -1171.3],
-                       'a_0': 6.2e-05,
-                       'K_0': 41500e6,
-                       'Kprime_0': 6.45,
-                       'Kdprime_0': -1.55e-10,
-                       'n': 5.0,
-                       'molar_mass': 0.05831968}
-        Mineral.__init__(self)
-
-
-class dsp (Mineral):
-    def __init__(self):
-        self.params = {'name': 'dsp',
-                       'formula': {'Al': 1.0, 'H': 1.0, 'O': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -999840.0,
-                       'S_0': 34.5,
-                       'V_0': 1.786e-05,
-                       'Cp': [145.1, 0.008709, 584400.0, -1741.1],
-                       'a_0': 3.57e-05,
-                       'K_0': 228000e6,
-                       'Kprime_0': 4.04,
-                       'Kdprime_0': -1.8e-11,
-                       'n': 4.0,
-                       'molar_mass': 0.05998824}
-        Mineral.__init__(self)
-
-
-class gth (Mineral):
-    def __init__(self):
-        self.params = {'name': 'gth',
-                       'formula': {'Fe': 1.0, 'H': 1.0, 'O': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -561770.0,
-                       'S_0': 60.3,
-                       'V_0': 2.082e-05,
-                       'Cp': [139.3, 0.000147, -212700.0, -1077.8],
-                       'a_0': 4.35e-05,
-                       'K_0': 250000e6,
-                       'Kprime_0': 4.03,
-                       'Kdprime_0': -1.6e-11,
-                       'n': 4.0,
-                       'molar_mass': 0.08885174}
-        Mineral.__init__(self)
-
-
-class cc (Mineral):
-    def __init__(self):
-        self.params = {'name': 'cc',
-                       'formula': {'C': 1.0, 'Ca': 1.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1207760.0,
-                       'S_0': 92.5,
-                       'V_0': 3.689e-05,
-                       'Cp': [140.9, 0.005029, -950700.0, -858.4],
-                       'a_0': 2.52e-05,
-                       'K_0': 73300e6,
-                       'Kprime_0': 4.06,
-                       'Kdprime_0': -5.5e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1000869}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 1240.0,
-                                                  'S_D': 10.0,
-                                                  'V_D': 4e-07}]]
-        Mineral.__init__(self)
-
-
-class arag (Mineral):
-    def __init__(self):
-        self.params = {'name': 'arag',
-                       'formula': {'C': 1.0, 'Ca': 1.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1207650.0,
-                       'S_0': 89.8,
-                       'V_0': 3.415e-05,
-                       'Cp': [167.1, 0.010695, 162000.0, -1564.9],
-                       'a_0': 6.14e-05,
-                       'K_0': 61400e6,
-                       'Kprime_0': 5.87,
-                       'Kdprime_0': -9.6e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1000869}
-        Mineral.__init__(self)
-
-
-class mag (Mineral):
-    def __init__(self):
-        self.params = {'name': 'mag',
-                       'formula': {'C': 1.0, 'Mg': 1.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1110920.0,
-                       'S_0': 65.5,
-                       'V_0': 2.803e-05,
-                       'Cp': [186.4, -0.003772, 0.0, -1886.2],
-                       'a_0': 3.38e-05,
-                       'K_0': 102800e6,
-                       'Kprime_0': 5.41,
-                       'Kdprime_0': -5.3e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.0843139}
-        Mineral.__init__(self)
-
-
-class sid (Mineral):
-    def __init__(self):
-        self.params = {'name': 'sid',
-                       'formula': {'C': 1.0, 'Fe': 1.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -762220.0,
-                       'S_0': 93.3,
-                       'V_0': 2.943e-05,
-                       'Cp': [168.4, 0.0, 0.0, -1483.6],
-                       'a_0': 4.39e-05,
-                       'K_0': 120000e6,
-                       'Kprime_0': 4.07,
-                       'Kdprime_0': -3.4e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1158539}
-        Mineral.__init__(self)
-
-
-class rhc (Mineral):
-    def __init__(self):
-        self.params = {'name': 'rhc',
-                       'formula': {'C': 1.0, 'Mn': 1.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -892280.0,
-                       'S_0': 98.0,
-                       'V_0': 3.107e-05,
-                       'Cp': [169.5, 0.0, 0.0, -1534.3],
-                       'a_0': 2.44e-05,
-                       'K_0': 95300e6,
-                       'Kprime_0': 3.88,
-                       'Kdprime_0': -4.1e-11,
-                       'n': 5.0,
-                       'molar_mass': 0.1149469}
-        Mineral.__init__(self)
-
-
-class dol (Mineral):
-    def __init__(self):
-        self.params = {'name': 'dol',
-                       'formula': {'C': 2.0, 'Ca': 1.0, 'Mg': 1.0, 'O': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -2326220.0,
-                       'S_0': 156.1,
-                       'V_0': 6.429e-05,
-                       'Cp': [358.9, -0.004905, 0.0, -3456.2],
-                       'a_0': 3.28e-05,
-                       'K_0': 94300e6,
-                       'Kprime_0': 3.74,
-                       'Kdprime_0': -4e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.1844008}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 11910.0,
-                                                       'deltaV': 1.6e-07,
-                                                       'Wh': 11900.0,
-                                                       'Wv': 1.6e-07,
-                                                       'n': 1.0,
-                                                       'factor': 1.0}]]
-        Mineral.__init__(self)
-
-
-class ank (Mineral):
-    def __init__(self):
-        self.params = {'name': 'ank',
-                       'formula': {'C': 2.0, 'Ca': 1.0, 'Fe': 1.0, 'O': 6.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1971410.0,
-                       'S_0': 188.46,
-                       'V_0': 6.606e-05,
-                       'Cp': [341.0, -0.001161, 0.0, -3054.8],
-                       'a_0': 3.46e-05,
-                       'K_0': 91400e6,
-                       'Kprime_0': 3.88,
-                       'Kdprime_0': -4.3e-11,
-                       'n': 10.0,
-                       'molar_mass': 0.2159408}
-        self.property_modifiers = [['bragg_williams', {'deltaH': 11910.0,
-                                                       'deltaV': 1.6e-07,
-                                                       'Wh': 11900.0,
-                                                       'Wv': 1.6e-07,
-                                                       'n': 1.0,
-                                                       'factor': 1.0}]]
-        Mineral.__init__(self)
-
-
-class syv (Mineral):
-    def __init__(self):
-        self.params = {'name': 'syv',
-                       'formula': {'Cl': 1.0, 'K': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -436500.0,
-                       'S_0': 82.6,
-                       'V_0': 3.752e-05,
-                       'Cp': [46.2, 0.01797, 0.0, 0.0],
-                       'a_0': 0.0001109,
-                       'K_0': 17000e6,
-                       'Kprime_0': 5.0,
-                       'Kdprime_0': -2.94e-10,
-                       'n': 2.0,
-                       'molar_mass': 0.0745513}
-        Mineral.__init__(self)
-
-
-class hlt (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hlt',
-                       'formula': {'Cl': 1.0, 'Na': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -411300.0,
-                       'S_0': 72.1,
-                       'V_0': 2.702e-05,
-                       'Cp': [45.2, 0.01797, 0.0, 0.0],
-                       'a_0': 0.0001147,
-                       'K_0': 23800e6,
-                       'Kprime_0': 5.0,
-                       'Kdprime_0': -2.1e-10,
-                       'n': 2.0,
-                       'molar_mass': 0.0584428}
-        Mineral.__init__(self)
-
-
-class pyr (Mineral):
-    def __init__(self):
-        self.params = {'name': 'pyr',
-                       'formula': {'Fe': 1.0, 'S': 2.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -171640.0,
-                       'S_0': 52.9,
-                       'V_0': 2.394e-05,
-                       'Cp': [37.3, 0.026715, -1817000.0, 649.3],
-                       'a_0': 3.1e-05,
-                       'K_0': 139500e6,
-                       'Kprime_0': 4.09,
-                       'Kdprime_0': -2.9e-11,
-                       'n': 3.0,
-                       'molar_mass': 0.119975}
-        Mineral.__init__(self)
-
-
-class trot (Mineral):
-    def __init__(self):
-        self.params = {'name': 'trot',
-                       'formula': {'Fe': 1.0, 'S': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -99030.0,
-                       'S_0': 65.5,
-                       'V_0': 1.819e-05,
-                       'Cp': [50.2, 0.011052, -940000.0, 0.0],
-                       'a_0': 5.68e-05,
-                       'K_0': 65800e6,
-                       'Kprime_0': 4.17,
-                       'Kdprime_0': -6.3e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.08791}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 598.0,
-                                                  'S_D': 12.0,
-                                                  'V_D': 4.1e-07}]]
-        Mineral.__init__(self)
-
-
-class tro (Mineral):
-    def __init__(self):
-        self.params = {'name': 'tro',
-                       'formula': {'Fe': 1.0, 'S': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -97760.0,
-                       'S_0': 70.8,
-                       'V_0': 1.819e-05,
-                       'Cp': [50.2, 0.011052, -940000.0, 0.0],
-                       'a_0': 5.73e-05,
-                       'K_0': 65800e6,
-                       'Kprime_0': 4.17,
-                       'Kdprime_0': -6.3e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.08791}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 598.0,
-                                                  'S_D': 12.0,
-                                                  'V_D': 4.1e-07}]]
-        Mineral.__init__(self)
-
-
-class lot (Mineral):
-    def __init__(self):
-        self.params = {'name': 'lot',
-                       'formula': {'Fe': 1.0, 'S': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -102160.0,
-                       'S_0': 60.0,
-                       'V_0': 1.818e-05,
-                       'Cp': [50.2, 0.011052, -940000.0, 0.0],
-                       'a_0': 4.93e-05,
-                       'K_0': 65800e6,
-                       'Kprime_0': 4.17,
-                       'Kdprime_0': -6.3e-11,
-                       'n': 2.0,
-                       'molar_mass': 0.08791}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 420.0,
-                                                  'S_D': 10.0,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class trov (Mineral):
-    def __init__(self):
-        self.params = {'name': 'trov',
-                       'formula': {'Fe': 0.875, 'S': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -96020.0,
-                       'S_0': 57.5,
-                       'V_0': 1.738e-05,
-                       'Cp': [51.1, 0.008307, -669700.0, 0.0],
-                       'a_0': 5.94e-05,
-                       'K_0': 65800e6,
-                       'Kprime_0': 4.17,
-                       'Kdprime_0': -6.3e-11,
-                       'n': 1.875,
-                       'molar_mass': 0.080929375}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 595.0,
-                                                  'S_D': 10.0,
-                                                  'V_D': 1.6e-07}]]
-        Mineral.__init__(self)
-
-
-class any (Mineral):
-    def __init__(self):
-        self.params = {'name': 'any',
-                       'formula': {'Ca': 1.0, 'O': 4.0, 'S': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -1434400.0,
-                       'S_0': 106.9,
-                       'V_0': 4.594e-05,
-                       'Cp': [128.7, 0.048545, -1223000.0, -560.5],
-                       'a_0': 4.18e-05,
-                       'K_0': 54379999999.99999,
-                       'Kprime_0': 4.19,
-                       'Kdprime_0': -7.7e-11,
-                       'n': 6.0,
-                       'molar_mass': 0.1361406}
-        Mineral.__init__(self)
-
-
-class iron (Mineral):
-    def __init__(self):
-        self.params = {'name': 'iron',
-                       'formula': {'Fe': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -0.0,
-                       'S_0': 27.09,
-                       'V_0': 7.09e-06,
-                       'Cp': [46.2, 0.005159, 723100.0, -556.2],
-                       'a_0': 3.56e-05,
-                       'K_0': 164000e6,
-                       'Kprime_0': 5.16,
-                       'Kdprime_0': -3.1e-11,
-                       'n': 1.0,
-                       'molar_mass': 0.055845}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 1042.0,
-                                                  'S_D': 8.3,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class Ni (Mineral):
-    def __init__(self):
-        self.params = {'name': 'Ni',
-                       'formula': {'Ni': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': 0.0,
-                       'S_0': 29.87,
-                       'V_0': 6.59e-06,
-                       'Cp': [49.8, 0.0, 585900.0, -533.9],
-                       'a_0': 4.28e-05,
-                       'K_0': 190500e6,
-                       'Kprime_0': 4.25,
-                       'Kdprime_0': -2.2e-11,
-                       'n': 1.0,
-                       'molar_mass': 0.0586934}
-        self.property_modifiers = [['landau_hp', {'P_0': 100000.0,
-                                                  'T_0': 298.15,
-                                                  'Tc_0': 631.0,
-                                                  'S_D': 3.0,
-                                                  'V_D': 0.0}]]
-        Mineral.__init__(self)
-
-
-class Cu (Mineral):
-    def __init__(self):
-        self.params = {'name': 'Cu',
-                       'formula': {'Cu': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': -0.0,
-                       'S_0': 33.14,
-                       'V_0': 7.11e-06,
-                       'Cp': [12.4, 0.00922, -379900.0, 233.5],
-                       'a_0': 3.58e-05,
-                       'K_0': 162500e6,
-                       'Kprime_0': 4.24,
-                       'Kdprime_0': -2.6e-11,
-                       'n': 1.0,
-                       'molar_mass': 0.063546}
-        Mineral.__init__(self)
-
-
-class gph (Mineral):
-    def __init__(self):
-        self.params = {'name': 'gph',
-                       'formula': {'C': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': 0.0,
-                       'S_0': 5.76,
-                       'V_0': 5.3e-06,
-                       'Cp': [34.3, 0.0, -240700.0, -403.8],
-                       'a_0': 1.65e-05,
-                       'K_0': 31200e6,
-                       'Kprime_0': 3.9,
-                       'Kdprime_0': -1.25e-10,
-                       'n': 1.0,
-                       'molar_mass': 0.0120107}
-        Mineral.__init__(self)
-
-
-class diam (Mineral):
-    def __init__(self):
-        self.params = {'name': 'diam',
-                       'formula': {'C': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': 1890.0,
-                       'S_0': 2.36,
-                       'V_0': 3.42e-06,
-                       'Cp': [40.0, 0.0, -28500.0, -580.5],
-                       'a_0': 4e-06,
-                       'K_0': 446500e6,
-                       'Kprime_0': 1.61,
-                       'Kdprime_0': -3.6e-12,
-                       'n': 1.0,
-                       'molar_mass': 0.0120107}
-        Mineral.__init__(self)
-
-
-class S (Mineral):
-    def __init__(self):
-        self.params = {'name': 'S',
-                       'formula': {'S': 1.0},
-                       'equation_of_state': 'hp_tmt',
-                       'H_0': 0.0,
-                       'S_0': 32.05,
-                       'V_0': 1.551e-05,
-                       'Cp': [56.6, -0.004557, 638000.0, -681.8],
-                       'a_0': 6.4e-05,
-                       'K_0': 14500e6,
-                       'Kprime_0': 7.0,
-                       'Kdprime_0': -4.8e-10,
-                       'n': 1.0,
-                       'molar_mass': 0.032065}
-        Mineral.__init__(self)
-
-
-class syvL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'syvL',
-                       'formula': {'Cl': 1.0, 'K': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -417410.0,
-                       'S_0': 94.5,
-                       'V_0': 3.822e-05,
-                       'Cp': [66.9, 0.0, 0.0, 0.0],
-                       'a_0': 0.000301,
-                       'K_0': 5600e6,
-                       'Kprime_0': 4.65,
-                       'Kdprime_0': -8.3e-10,
-                       'dKdT_0': -2e6,
-                       'n': 2.0,
-                       'molar_mass': 0.0745513}
-        Mineral.__init__(self)
-
-
-class hltL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'hltL',
-                       'formula': {'Cl': 1.0, 'Na': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -392990.0,
-                       'S_0': 80.1,
-                       'V_0': 2.938e-05,
-                       'Cp': [72.0, -0.003223, 0.0, 0.0],
-                       'a_0': 0.000295,
-                       'K_0': 6400e6,
-                       'Kprime_0': 4.61,
-                       'Kdprime_0': -7.2e-10,
-                       'dKdT_0': -1500000.0,
-                       'n': 2.0,
-                       'molar_mass': 0.0584428}
-        Mineral.__init__(self)
-
-
-class perL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'perL',
-                       'formula': {'Mg': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -654120.0,
-                       'S_0': -64.3,
-                       'V_0': 8.39e-06,
-                       'Cp': [99.0, 0.0, 0.0, 0.0],
-                       'a_0': 0.000226,
-                       'K_0': 36200e6,
-                       'Kprime_0': 10.06,
-                       'Kdprime_0': -2.78e-10,
-                       'dKdT_0': -4100000.0,
-                       'n': 2.0,
-                       'molar_mass': 0.0403044}
-        Mineral.__init__(self)
-
-
-class limL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'limL',
-                       'formula': {'Ca': 1.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -692280.0,
-                       'S_0': -47.5,
-                       'V_0': 1.303e-05,
-                       'Cp': [99.0, 0.0, 0.0, 0.0],
-                       'a_0': 0.000175,
-                       'K_0': 36200e6,
-                       'Kprime_0': 10.06,
-                       'Kdprime_0': -2.78e-10,
-                       'dKdT_0': -4100000.0,
-                       'n': 2.0,
-                       'molar_mass': 0.0560774}
-        Mineral.__init__(self)
-
-
-class corL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'corL',
-                       'formula': {'Al': 2.0, 'O': 3.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -1632160.0,
-                       'S_0': 14.9,
-                       'V_0': 3.369e-05,
-                       'Cp': [157.6, 0.0, 0.0, 0.0],
-                       'a_0': 7.03e-05,
-                       'K_0': 15000e6,
-                       'Kprime_0': 6.0,
-                       'Kdprime_0': 4e-10,
-                       'dKdT_0': -3500000.0000000005,
-                       'n': 5.0,
-                       'molar_mass': 0.1019612}
-        Mineral.__init__(self)
-
-
-class qL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'qL',
-                       'formula': {'O': 2.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -921070.0,
-                       'S_0': 16.3,
-                       'V_0': 2.73e-05,
-                       'Cp': [82.5, 0.0, 0.0, 0.0],
-                       'a_0': 0.0,
-                       'K_0': 22000e6,
-                       'Kprime_0': 9.46,
-                       'Kdprime_0': -4.3e-10,
-                       'dKdT_0': -3500000.0000000005,
-                       'n': 3.0,
-                       'molar_mass': 0.0600843}
-        Mineral.__init__(self)
-
-
-class h2oL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'h2oL',
-                       'formula': {'H': 2.0, 'O': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -295010.0,
-                       'S_0': 45.5,
-                       'V_0': 1.39e-05,
-                       'Cp': [80.0, 0.0, 0.0, 0.0],
-                       'a_0': 0.000521,
-                       'K_0': 5060e6,
-                       'Kprime_0': 4.0,
-                       'Kdprime_0': -7.9e-10,
-                       'dKdT_0': -370000.0,
-                       'n': 3.0,
-                       'molar_mass': 0.01801528}
-        Mineral.__init__(self)
-
-
-class foL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'foL',
-                       'formula': {'Mg': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -2237350.0,
-                       'S_0': -62.0,
-                       'V_0': 4.312e-05,
-                       'Cp': [269.4, 0.0, 0.0, 0.0],
-                       'a_0': 9.2e-05,
-                       'K_0': 36200e6,
-                       'Kprime_0': 10.06,
-                       'Kdprime_0': -2.78e-10,
-                       'dKdT_0': -4400000.0,
-                       'n': 7.0,
-                       'molar_mass': 0.1406931}
-        Mineral.__init__(self)
-
-
-class faL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'faL',
-                       'formula': {'Fe': 2.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -1463020.0,
-                       'S_0': 96.0,
-                       'V_0': 4.677e-05,
-                       'Cp': [243.7, 0.0, 0.0, 0.0],
-                       'a_0': 0.0001071,
-                       'K_0': 29000e6,
-                       'Kprime_0': 10.42,
-                       'Kdprime_0': -3.59e-10,
-                       'dKdT_0': -5500000.0,
-                       'n': 7.0,
-                       'molar_mass': 0.2037731}
-        Mineral.__init__(self)
-
-
-class woL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'woL',
-                       'formula': {'Ca': 1.0, 'O': 3.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -1642220.0,
-                       'S_0': 22.5,
-                       'V_0': 3.965e-05,
-                       'Cp': [167.4, 0.0, 0.0, 0.0],
-                       'a_0': 6.69e-05,
-                       'K_0': 30500e6,
-                       'Kprime_0': 9.38,
-                       'Kdprime_0': -3.08e-10,
-                       'dKdT_0': -2e6,
-                       'n': 5.0,
-                       'molar_mass': 0.1161617}
-        Mineral.__init__(self)
-
-
-class enL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'enL',
-                       'formula': {'Mg': 2.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -3096570.0,
-                       'S_0': -4.0,
-                       'V_0': 6.984e-05,
-                       'Cp': [353.6, 0.0, 0.0, 0.0],
-                       'a_0': 6.81e-05,
-                       'K_0': 21800e6,
-                       'Kprime_0': 7.2,
-                       'Kdprime_0': -3.3e-10,
-                       'dKdT_0': -2400000.0,
-                       'n': 10.0,
-                       'molar_mass': 0.2007774}
-        Mineral.__init__(self)
-
-
-class diL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'diL',
-                       'formula': {'Ca': 1.0, 'Mg': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -3193870.0,
-                       'S_0': 42.1,
-                       'V_0': 7.288e-05,
-                       'Cp': [334.0, 0.0, 0.0, 0.0],
-                       'a_0': 8.51e-05,
-                       'K_0': 24900e6,
-                       'Kprime_0': 8.04,
-                       'Kdprime_0': -3.23e-10,
-                       'dKdT_0': -3730000.0,
-                       'n': 10.0,
-                       'molar_mass': 0.2165504}
-        Mineral.__init__(self)
-
-
-class silL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'silL',
-                       'formula': {'Al': 2.0, 'O': 5.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -2593430.0,
-                       'S_0': 10.0,
-                       'V_0': 6.051e-05,
-                       'Cp': [253.0, 0.0, 0.0, 0.0],
-                       'a_0': 4.08e-05,
-                       'K_0': 22000e6,
-                       'Kprime_0': 6.36,
-                       'Kdprime_0': -2.89e-10,
-                       'dKdT_0': -2900000.0,
-                       'n': 8.0,
-                       'molar_mass': 0.1620455}
-        Mineral.__init__(self)
-
-
-class anL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'anL',
-                       'formula': {'Al': 2.0, 'Ca': 1.0, 'O': 8.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -4277970.0,
-                       'S_0': 29.0,
-                       'V_0': 0.00010014,
-                       'Cp': [430.0, 0.0, 0.0, 0.0],
-                       'a_0': 5.14e-05,
-                       'K_0': 21000e6,
-                       'Kprime_0': 6.38,
-                       'Kdprime_0': -3.04e-10,
-                       'dKdT_0': -5500000.0,
-                       'n': 13.0,
-                       'molar_mass': 0.2782072}
-        Mineral.__init__(self)
-
-
-class kspL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'kspL',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -3985190.0,
-                       'S_0': 129.2,
-                       'V_0': 0.00011431,
-                       'Cp': [368.0, 0.0, 0.0, 0.0],
-                       'a_0': 4.93e-05,
-                       'K_0': 17300e6,
-                       'Kprime_0': 6.84,
-                       'Kdprime_0': -3.93e-10,
-                       'dKdT_0': -899999.9999999999,
-                       'n': 13.0,
-                       'molar_mass': 0.2783315}
-        Mineral.__init__(self)
-
-
-class abL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'abL',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 8.0, 'Si': 3.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -3926520.0,
-                       'S_0': 149.9,
-                       'V_0': 0.00010858,
-                       'Cp': [358.0, 0.0, 0.0, 0.0],
-                       'a_0': 3.37e-05,
-                       'K_0': 17600e6,
-                       'Kprime_0': 14.35,
-                       'Kdprime_0': -8.15e-10,
-                       'dKdT_0': -2600000.0,
-                       'n': 13.0,
-                       'molar_mass': 0.262223}
-        Mineral.__init__(self)
-
-
-class neL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'neL',
-                       'formula': {'Al': 1.0, 'Na': 1.0, 'O': 4.0, 'Si': 1.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -2116730.0,
-                       'S_0': 52.9,
-                       'V_0': 5.2e-05,
-                       'Cp': [216.5, 0.0, 0.0, 0.0],
-                       'a_0': 0.000137,
-                       'K_0': 25000e6,
-                       'Kprime_0': 7.37,
-                       'Kdprime_0': -2.95e-10,
-                       'dKdT_0': -800000.0,
-                       'n': 7.0,
-                       'molar_mass': 0.1420544}
-        Mineral.__init__(self)
-
-
-class lcL (Mineral):
-    def __init__(self):
-        self.params = {'name': 'lcL',
-                       'formula': {'Al': 1.0, 'K': 1.0, 'O': 6.0, 'Si': 2.0},
-                       'equation_of_state': 'hp_tmtL',
-                       'H_0': -3068410.0,
-                       'S_0': 102.0,
-                       'V_0': 8.59e-05,
-                       'Cp': [287.0, 0.0, 0.0, 0.0],
-                       'a_0': 6.7e-05,
-                       'K_0': 17500e6,
-                       'Kprime_0': 7.0,
-                       'Kdprime_0': -3.94e-10,
-                       'dKdT_0': -0.0,
-                       'n': 10.0,
-                       'molar_mass': 0.2182472}
+        self.params = {
+            "name": "fo",
+            "formula": {"Mg": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2172500.0,
+            "S_0": 95.1,
+            "V_0": 4.366e-05,
+            "Cp": [233.3, 0.001494, -603800.0, -1869.7],
+            "a_0": 2.85e-05,
+            "K_0": 128500e6,
+            "Kprime_0": 3.84,
+            "Kdprime_0": -3e-11,
+            "n": 7.0,
+            "molar_mass": 0.1406931,
+        }
+        Mineral.__init__(self)
+
+
+class fa(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fa",
+            "formula": {"Fe": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1477510.0,
+            "S_0": 151.0,
+            "V_0": 4.631e-05,
+            "Cp": [201.1, 0.01733, -1960600.0, -900.9],
+            "a_0": 2.82e-05,
+            "K_0": 125600e6,
+            "Kprime_0": 4.68,
+            "Kdprime_0": -3.7e-11,
+            "n": 7.0,
+            "molar_mass": 0.2037731,
+        }
+        Mineral.__init__(self)
+
+
+class teph(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "teph",
+            "formula": {"Mn": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1733910.0,
+            "S_0": 155.9,
+            "V_0": 4.899e-05,
+            "Cp": [219.6, 0.0, -1292700.0, -1308.3],
+            "a_0": 2.86e-05,
+            "K_0": 125600e6,
+            "Kprime_0": 4.68,
+            "Kdprime_0": -3.7e-11,
+            "n": 7.0,
+            "molar_mass": 0.2019591,
+        }
+        Mineral.__init__(self)
+
+
+class lrn(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "lrn",
+            "formula": {"Ca": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2306940.0,
+            "S_0": 127.6,
+            "V_0": 5.16e-05,
+            "Cp": [247.5, -0.003206, 0.0, -2051.9],
+            "a_0": 2.9e-05,
+            "K_0": 98500e6,
+            "Kprime_0": 4.07,
+            "Kdprime_0": -4.1e-11,
+            "n": 7.0,
+            "molar_mass": 0.1722391,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 1710.0,
+                    "S_D": 10.03,
+                    "V_D": 5e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class mont(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mont",
+            "formula": {"Ca": 1.0, "Mg": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2251230.0,
+            "S_0": 109.5,
+            "V_0": 5.148e-05,
+            "Cp": [250.7, -0.010433, -797200.0, -1996.1],
+            "a_0": 2.87e-05,
+            "K_0": 113400e6,
+            "Kprime_0": 3.87,
+            "Kdprime_0": -3.4e-11,
+            "n": 7.0,
+            "molar_mass": 0.1564661,
+        }
+        Mineral.__init__(self)
+
+
+class chum(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "chum",
+            "formula": {"H": 2.0, "Mg": 9.0, "O": 18.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9613220.0,
+            "S_0": 440.5,
+            "V_0": 0.00019801,
+            "Cp": [1071.0, -0.016533, -7899600.0, -7373.9],
+            "a_0": 3.2e-05,
+            "K_0": 119900e6,
+            "Kprime_0": 4.58,
+            "Kdprime_0": -3.8e-11,
+            "n": 33.0,
+            "molar_mass": 0.62109208,
+        }
+        Mineral.__init__(self)
+
+
+class chdr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "chdr",
+            "formula": {"H": 2.0, "Mg": 5.0, "O": 10.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5254760.0,
+            "S_0": 260.0,
+            "V_0": 0.00011084,
+            "Cp": [625.0, -0.001088, -2259900.0, -4910.7],
+            "a_0": 1.82e-05,
+            "K_0": 116100e6,
+            "Kprime_0": 4.8,
+            "Kdprime_0": -4.1e-11,
+            "n": 19.0,
+            "molar_mass": 0.33970588,
+        }
+        Mineral.__init__(self)
+
+
+class mwd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mwd",
+            "formula": {"Mg": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2138060.0,
+            "S_0": 93.9,
+            "V_0": 4.051e-05,
+            "Cp": [208.7, 0.003942, -1709500.0, -1302.8],
+            "a_0": 2.37e-05,
+            "K_0": 172600e6,
+            "Kprime_0": 3.84,
+            "Kdprime_0": -2.2e-11,
+            "n": 7.0,
+            "molar_mass": 0.1406931,
+        }
+        Mineral.__init__(self)
+
+
+class fwd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fwd",
+            "formula": {"Fe": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1467690.0,
+            "S_0": 146.0,
+            "V_0": 4.321e-05,
+            "Cp": [201.1, 0.01733, -1960600.0, -900.9],
+            "a_0": 2.73e-05,
+            "K_0": 169000e6,
+            "Kprime_0": 4.35,
+            "Kdprime_0": -2.6e-11,
+            "n": 7.0,
+            "molar_mass": 0.2037731,
+        }
+        Mineral.__init__(self)
+
+
+class mrw(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mrw",
+            "formula": {"Mg": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2126800.0,
+            "S_0": 90.0,
+            "V_0": 3.949e-05,
+            "Cp": [213.3, 0.00269, -1410400.0, -1495.9],
+            "a_0": 2.01e-05,
+            "K_0": 178100e6,
+            "Kprime_0": 4.35,
+            "Kdprime_0": -2.4e-11,
+            "n": 7.0,
+            "molar_mass": 0.1406931,
+        }
+        Mineral.__init__(self)
+
+
+class frw(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "frw",
+            "formula": {"Fe": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1471510.0,
+            "S_0": 140.0,
+            "V_0": 4.203e-05,
+            "Cp": [166.8, 0.04261, -1705400.0, -541.4],
+            "a_0": 2.22e-05,
+            "K_0": 197700e6,
+            "Kprime_0": 4.92,
+            "Kdprime_0": -2.5e-11,
+            "n": 7.0,
+            "molar_mass": 0.2037731,
+        }
+        Mineral.__init__(self)
+
+
+class mpv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mpv",
+            "formula": {"Mg": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1442170.0,
+            "S_0": 62.6,
+            "V_0": 2.445e-05,
+            "Cp": [149.3, 0.002918, -2983000.0, -799.1],
+            "a_0": 1.87e-05,
+            "K_0": 251000e6,
+            "Kprime_0": 4.14,
+            "Kdprime_0": -1.6e-11,
+            "n": 5.0,
+            "molar_mass": 0.1003887,
+        }
+        Mineral.__init__(self)
+
+
+class fpv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fpv",
+            "formula": {"Fe": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1082690.0,
+            "S_0": 95.0,
+            "V_0": 2.534e-05,
+            "Cp": [133.2, 0.01083, -3661400.0, -314.7],
+            "a_0": 1.87e-05,
+            "K_0": 281000e6,
+            "Kprime_0": 4.14,
+            "Kdprime_0": -1.6e-11,
+            "n": 5.0,
+            "molar_mass": 0.1319287,
+        }
+        Mineral.__init__(self)
+
+
+class apv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "apv",
+            "formula": {"Al": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1619680.0,
+            "S_0": 51.8,
+            "V_0": 2.54e-05,
+            "Cp": [139.5, 0.00589, -2460600.0, -589.2],
+            "a_0": 1.8e-05,
+            "K_0": 203000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2e-11,
+            "n": 5.0,
+            "molar_mass": 0.1019612,
+        }
+        Mineral.__init__(self)
+
+
+class npv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "npv",
+            "formula": {"Al": 0.5, "Na": 0.5, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1365000.0,
+            "S_0": 63.0,
+            "V_0": 2.334e-05,
+            "Cp": [135.0, 0.00846, -1850300.0, -600.8],
+            "a_0": 1.8e-05,
+            "K_0": 203000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2e-11,
+            "n": 5.0,
+            "molar_mass": 0.10106935,
+        }
+        Mineral.__init__(self)
+
+
+class ppv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ppv",
+            "formula": {"Mg": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1418480.0,
+            "S_0": 60.4,
+            "V_0": 2.442e-05,
+            "Cp": [149.3, 0.002918, -2983000.0, -799.1],
+            "a_0": 1.87e-05,
+            "K_0": 231200e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -1.6e-11,
+            "n": 5.0,
+            "molar_mass": 0.1003887,
+        }
+        Mineral.__init__(self)
+
+
+class cpv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cpv",
+            "formula": {"Ca": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1533570.0,
+            "S_0": 74.5,
+            "V_0": 2.745e-05,
+            "Cp": [159.3, 0.0, -967300.0, -1075.4],
+            "a_0": 2e-05,
+            "K_0": 236000e6,
+            "Kprime_0": 3.9,
+            "Kdprime_0": -1.6e-11,
+            "n": 5.0,
+            "molar_mass": 0.1161617,
+        }
+        Mineral.__init__(self)
+
+
+class mak(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mak",
+            "formula": {"Mg": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1489550.0,
+            "S_0": 59.3,
+            "V_0": 2.635e-05,
+            "Cp": [147.8, 0.002015, -2395000.0, -801.8],
+            "a_0": 2.12e-05,
+            "K_0": 211000e6,
+            "Kprime_0": 4.55,
+            "Kdprime_0": -2.2e-11,
+            "n": 5.0,
+            "molar_mass": 0.1003887,
+        }
+        Mineral.__init__(self)
+
+
+class fak(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fak",
+            "formula": {"Fe": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1142110.0,
+            "S_0": 91.5,
+            "V_0": 2.76e-05,
+            "Cp": [100.3, 0.013328, -4364900.0, 419.8],
+            "a_0": 2.12e-05,
+            "K_0": 218000e6,
+            "Kprime_0": 4.55,
+            "Kdprime_0": -2.2e-11,
+            "n": 5.0,
+            "molar_mass": 0.1319287,
+        }
+        Mineral.__init__(self)
+
+
+class maj(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "maj",
+            "formula": {"Mg": 4.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6041720.0,
+            "S_0": 260.2,
+            "V_0": 0.00011457,
+            "Cp": [713.6, -0.000997, -1158200.0, -6622.3],
+            "a_0": 1.83e-05,
+            "K_0": 160000e6,
+            "Kprime_0": 4.56,
+            "Kdprime_0": -2.8e-11,
+            "n": 20.0,
+            "molar_mass": 0.4015548,
+        }
+        Mineral.__init__(self)
+
+
+class nagt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "nagt",
+            "formula": {"Al": 1.0, "Mg": 2.0, "Na": 1.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5985000.0,
+            "S_0": 260.6,
+            "V_0": 0.0001109,
+            "Cp": [620.8, 0.0112, -3755900.0, -4421.3],
+            "a_0": 2.1e-05,
+            "K_0": 170000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.3e-11,
+            "n": 20.0,
+            "molar_mass": 0.4029161,
+        }
+        Mineral.__init__(self)
+
+
+class py(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "py",
+            "formula": {"Al": 2.0, "Mg": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6284740.0,
+            "S_0": 267.0,
+            "V_0": 0.00011313,
+            "Cp": [633.5, 0.0, -5196100.0, -4315.2],
+            "a_0": 2.37e-05,
+            "K_0": 174300e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.3e-11,
+            "n": 20.0,
+            "molar_mass": 0.4031273,
+        }
+        Mineral.__init__(self)
+
+
+class alm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "alm",
+            "formula": {"Al": 2.0, "Fe": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5267060.0,
+            "S_0": 337.0,
+            "V_0": 0.00011525,
+            "Cp": [716.2, -0.01241, -3160800.0, -5863.5],
+            "a_0": 2.12e-05,
+            "K_0": 190000e6,
+            "Kprime_0": 2.98,
+            "Kdprime_0": -1.6e-11,
+            "n": 20.0,
+            "molar_mass": 0.4977473,
+        }
+        Mineral.__init__(self)
+
+
+class spss(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "spss",
+            "formula": {"Al": 2.0, "Mn": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5692410.0,
+            "S_0": 335.3,
+            "V_0": 0.00011792,
+            "Cp": [646.9, 0.0, -4525800.0, -4452.8],
+            "a_0": 2.27e-05,
+            "K_0": 174000e6,
+            "Kprime_0": 6.68,
+            "Kdprime_0": -3.8e-11,
+            "n": 20.0,
+            "molar_mass": 0.4950263,
+        }
+        Mineral.__init__(self)
+
+
+class gr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "gr",
+            "formula": {"Al": 2.0, "Ca": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6642910.0,
+            "S_0": 255.0,
+            "V_0": 0.00012535,
+            "Cp": [626.0, 0.0, -5779200.0, -4002.9],
+            "a_0": 2.2e-05,
+            "K_0": 172000e6,
+            "Kprime_0": 5.53,
+            "Kdprime_0": -3.2e-11,
+            "n": 20.0,
+            "molar_mass": 0.4504463,
+        }
+        Mineral.__init__(self)
+
+
+class andr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "andr",
+            "formula": {"Ca": 3.0, "Fe": 2.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5768870.0,
+            "S_0": 316.4,
+            "V_0": 0.00013204,
+            "Cp": [638.6, 0.0, -4955100.0, -3989.2],
+            "a_0": 2.86e-05,
+            "K_0": 158800e6,
+            "Kprime_0": 5.68,
+            "Kdprime_0": -3.6e-11,
+            "n": 20.0,
+            "molar_mass": 0.5081733,
+        }
+        Mineral.__init__(self)
+
+
+class ski(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ski",
+            "formula": {"Fe": 5.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4330840.0,
+            "S_0": 403.4,
+            "V_0": 0.00012144,
+            "Cp": [689.9, 0.0, -2948600.0, -5030.3],
+            "a_0": 2.85e-05,
+            "K_0": 157400e6,
+            "Kprime_0": 6.7,
+            "Kdprime_0": -4.3e-11,
+            "n": 20.0,
+            "molar_mass": 0.5554743,
+        }
+        Mineral.__init__(self)
+
+
+class knor(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "knor",
+            "formula": {"Cr": 2.0, "Mg": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5701180.0,
+            "S_0": 302.0,
+            "V_0": 0.00011738,
+            "Cp": [613.0, 0.003606, -4178000.0, -3729.4],
+            "a_0": 2.37e-05,
+            "K_0": 153400e6,
+            "Kprime_0": 4.34,
+            "Kdprime_0": -2.8e-11,
+            "n": 20.0,
+            "molar_mass": 0.4531565,
+        }
+        Mineral.__init__(self)
+
+
+class uv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "uv",
+            "formula": {"Ca": 3.0, "Cr": 2.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6057590.0,
+            "S_0": 320.9,
+            "V_0": 0.00013077,
+            "Cp": [605.1, 0.003606, -4760600.0, -3417.1],
+            "a_0": 2.2e-05,
+            "K_0": 162000e6,
+            "Kprime_0": 4.7,
+            "Kdprime_0": -2.9e-11,
+            "n": 20.0,
+            "molar_mass": 0.5004755,
+        }
+        Mineral.__init__(self)
+
+
+class osma(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "osma",
+            "formula": {"Al": 5.0, "K": 1.0, "Mg": 2.0, "O": 30.0, "Si": 10.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -14896020.0,
+            "S_0": 755.0,
+            "V_0": 0.00037893,
+            "Cp": [1540.7, -0.011359, -10339000.0, -11699.0],
+            "a_0": 4.7e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 48.0,
+            "molar_mass": 0.9834528,
+        }
+        Mineral.__init__(self)
+
+
+class osmm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "osmm",
+            "formula": {"Al": 3.0, "K": 1.0, "Mg": 3.0, "O": 30.0, "Si": 11.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -14786240.0,
+            "S_0": 740.0,
+            "V_0": 0.0003844,
+            "Cp": [1525.5, -0.010267, -10538000.0, -11337.0],
+            "a_0": 4.7e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 48.0,
+            "molar_mass": 0.9818803,
+        }
+        Mineral.__init__(self)
+
+
+class osfa(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "osfa",
+            "formula": {"Al": 5.0, "Fe": 2.0, "K": 1.0, "O": 30.0, "Si": 10.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -14215310.0,
+            "S_0": 780.0,
+            "V_0": 0.0003845,
+            "Cp": [1558.6, -0.011359, -9476500.0, -11845.0],
+            "a_0": 4.9e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 48.0,
+            "molar_mass": 1.0465328,
+        }
+        Mineral.__init__(self)
+
+
+class vsv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "vsv",
+            "formula": {
+                "Al": 11.0,
+                "Ca": 19.0,
+                "H": 9.0,
+                "Mg": 2.0,
+                "O": 78.0,
+                "Si": 18.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -42345130.0,
+            "S_0": 1890.0,
+            "V_0": 0.000852,
+            "Cp": [4488.0, -0.057952, -22269300.0, -33478.0],
+            "a_0": 2.75e-05,
+            "K_0": 125500e6,
+            "Kprime_0": 4.8,
+            "Kdprime_0": -3.8e-11,
+            "n": 137.0,
+            "molar_mass": 2.86945216,
+        }
+        Mineral.__init__(self)
+
+
+class andalusite(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "and",
+            "formula": {"Al": 2.0, "O": 5.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2588600.0,
+            "S_0": 92.7,
+            "V_0": 5.153e-05,
+            "Cp": [277.3, -0.006588, -1914100.0, -2265.6],
+            "a_0": 1.81e-05,
+            "K_0": 144200e6,
+            "Kprime_0": 6.89,
+            "Kdprime_0": -4.8e-11,
+            "n": 8.0,
+            "molar_mass": 0.1620455,
+        }
+        Mineral.__init__(self)
+
+
+class ky(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ky",
+            "formula": {"Al": 2.0, "O": 5.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2592900.0,
+            "S_0": 83.5,
+            "V_0": 4.414e-05,
+            "Cp": [279.4, -0.007124, -2055600.0, -2289.4],
+            "a_0": 1.92e-05,
+            "K_0": 160100e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.5e-11,
+            "n": 8.0,
+            "molar_mass": 0.1620455,
+        }
+        Mineral.__init__(self)
+
+
+class sill(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "sill",
+            "formula": {"Al": 2.0, "O": 5.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2585690.0,
+            "S_0": 95.4,
+            "V_0": 4.986e-05,
+            "Cp": [280.2, -0.0069, -1375700.0, -2399.4],
+            "a_0": 1.12e-05,
+            "K_0": 164000e6,
+            "Kprime_0": 5.06,
+            "Kdprime_0": -3.1e-11,
+            "n": 8.0,
+            "molar_mass": 0.1620455,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 4750.0,
+                    "deltaV": 1e-07,
+                    "Wh": 4750.0,
+                    "Wv": 1e-07,
+                    "n": 1.0,
+                    "factor": 0.25,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class smul(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "smul",
+            "formula": {"Al": 2.0, "O": 5.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2569210.0,
+            "S_0": 101.5,
+            "V_0": 4.987e-05,
+            "Cp": [280.2, -0.0069, -1375700.0, -2399.4],
+            "a_0": 1.36e-05,
+            "K_0": 174000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.3e-11,
+            "n": 8.0,
+            "molar_mass": 0.1620455,
+        }
+        Mineral.__init__(self)
+
+
+class amul(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "amul",
+            "formula": {"Al": 2.5, "O": 4.75, "Si": 0.5},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2485660.0,
+            "S_0": 113.0,
+            "V_0": 5.083e-05,
+            "Cp": [244.8, 0.000968, -2533300.0, -1641.6],
+            "a_0": 1.36e-05,
+            "K_0": 174000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.3e-11,
+            "n": 7.75,
+            "molar_mass": 0.15749365,
+        }
+        Mineral.__init__(self)
+
+
+class tpz(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tpz",
+            "formula": {"Al": 2.0, "H": 2.0, "O": 6.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2900640.0,
+            "S_0": 100.5,
+            "V_0": 5.339e-05,
+            "Cp": [387.7, -0.00712, -857200.0, -3744.2],
+            "a_0": 1.57e-05,
+            "K_0": 131500e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -3.1e-11,
+            "n": 11.0,
+            "molar_mass": 0.18006078,
+        }
+        Mineral.__init__(self)
+
+
+class mst(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mst",
+            "formula": {"Al": 18.0, "H": 4.0, "Mg": 4.0, "O": 48.0, "Si": 7.5},
+            "equation_of_state": "hp_tmt",
+            "H_0": -25122970.0,
+            "S_0": 910.0,
+            "V_0": 0.0004426,
+            "Cp": [2820.5, -0.059366, -13774000.0, -24126.0],
+            "a_0": 1.81e-05,
+            "K_0": 168400e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.4e-11,
+            "n": 81.5,
+            "molar_mass": 1.56553121,
+        }
+        Mineral.__init__(self)
+
+
+class fst(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fst",
+            "formula": {"Al": 18.0, "Fe": 4.0, "H": 4.0, "O": 48.0, "Si": 7.5},
+            "equation_of_state": "hp_tmt",
+            "H_0": -23755130.0,
+            "S_0": 1010.0,
+            "V_0": 0.0004488,
+            "Cp": [2880.0, -0.056595, -10642000.0, -25373.0],
+            "a_0": 1.83e-05,
+            "K_0": 180000e6,
+            "Kprime_0": 4.76,
+            "Kdprime_0": -2.6e-11,
+            "n": 81.5,
+            "molar_mass": 1.69169121,
+        }
+        Mineral.__init__(self)
+
+
+class mnst(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mnst",
+            "formula": {"Al": 18.0, "H": 4.0, "Mn": 4.0, "O": 48.0, "Si": 7.5},
+            "equation_of_state": "hp_tmt",
+            "H_0": -24242690.0,
+            "S_0": 1034.0,
+            "V_0": 0.0004546,
+            "Cp": [2873.3, -0.089064, -12688000.0, -24749.0],
+            "a_0": 2.09e-05,
+            "K_0": 180000e6,
+            "Kprime_0": 4.76,
+            "Kdprime_0": -2.6e-11,
+            "n": 81.5,
+            "molar_mass": 1.68806321,
+        }
+        Mineral.__init__(self)
+
+
+class mctd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mctd",
+            "formula": {"Al": 2.0, "H": 2.0, "Mg": 1.0, "O": 7.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3549210.0,
+            "S_0": 146.0,
+            "V_0": 6.875e-05,
+            "Cp": [417.4, -0.003771, -2920600.0, -3417.8],
+            "a_0": 2.63e-05,
+            "K_0": 145600e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -2.8e-11,
+            "n": 13.0,
+            "molar_mass": 0.22036518,
+        }
+        Mineral.__init__(self)
+
+
+class fctd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fctd",
+            "formula": {"Al": 2.0, "Fe": 1.0, "H": 2.0, "O": 7.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3208500.0,
+            "S_0": 167.0,
+            "V_0": 6.98e-05,
+            "Cp": [416.1, -0.003477, -2835900.0, -3360.3],
+            "a_0": 2.8e-05,
+            "K_0": 145600e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -2.8e-11,
+            "n": 13.0,
+            "molar_mass": 0.25190518,
+        }
+        Mineral.__init__(self)
+
+
+class mnctd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mnctd",
+            "formula": {"Al": 2.0, "H": 2.0, "Mn": 1.0, "O": 7.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3335510.0,
+            "S_0": 166.0,
+            "V_0": 7.175e-05,
+            "Cp": [464.4, -0.012654, -1147200.0, -4341.0],
+            "a_0": 2.6e-05,
+            "K_0": 145600e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -2.8e-11,
+            "n": 13.0,
+            "molar_mass": 0.25099818,
+        }
+        Mineral.__init__(self)
+
+
+class merw(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "merw",
+            "formula": {"Ca": 3.0, "Mg": 1.0, "O": 8.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4545690.0,
+            "S_0": 253.1,
+            "V_0": 9.847e-05,
+            "Cp": [417.5, 0.008117, -2923000.0, -2320.3],
+            "a_0": 3.19e-05,
+            "K_0": 120000e6,
+            "Kprime_0": 4.07,
+            "Kdprime_0": -3.4e-11,
+            "n": 14.0,
+            "molar_mass": 0.3287052,
+        }
+        Mineral.__init__(self)
+
+
+class spu(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "spu",
+            "formula": {"C": 1.0, "Ca": 5.0, "O": 11.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5846800.0,
+            "S_0": 332.0,
+            "V_0": 0.00014697,
+            "Cp": [614.1, -0.003508, -2493100.0, -4168.0],
+            "a_0": 3.4e-05,
+            "K_0": 95000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.3e-11,
+            "n": 19.0,
+            "molar_mass": 0.4445651,
+        }
+        Mineral.__init__(self)
+
+
+class zo(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "zo",
+            "formula": {"Al": 3.0, "Ca": 2.0, "H": 1.0, "O": 13.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6896150.0,
+            "S_0": 298.0,
+            "V_0": 0.00013575,
+            "Cp": [662.0, 0.010416, -6006400.0, -4260.7],
+            "a_0": 3.12e-05,
+            "K_0": 104400e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -3.8e-11,
+            "n": 22.0,
+            "molar_mass": 0.45435714,
+        }
+        Mineral.__init__(self)
+
+
+class cz(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cz",
+            "formula": {"Al": 3.0, "Ca": 2.0, "H": 1.0, "O": 13.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6895400.0,
+            "S_0": 301.0,
+            "V_0": 0.0001363,
+            "Cp": [630.9, 0.013693, -6645800.0, -3731.1],
+            "a_0": 2.33e-05,
+            "K_0": 119700e6,
+            "Kprime_0": 4.07,
+            "Kdprime_0": -3.4e-11,
+            "n": 22.0,
+            "molar_mass": 0.45435714,
+        }
+        Mineral.__init__(self)
+
+
+class ep(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ep",
+            "formula": {
+                "Al": 2.0,
+                "Ca": 2.0,
+                "Fe": 1.0,
+                "H": 1.0,
+                "O": 13.0,
+                "Si": 3.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -6473650.0,
+            "S_0": 315.0,
+            "V_0": 0.0001392,
+            "Cp": [613.3, 0.02207, -7160000.0, -2987.7],
+            "a_0": 2.34e-05,
+            "K_0": 134000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -3e-11,
+            "n": 22.0,
+            "molar_mass": 0.48322064,
+        }
+        Mineral.__init__(self)
+
+
+class fep(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fep",
+            "formula": {
+                "Al": 1.0,
+                "Ca": 2.0,
+                "Fe": 2.0,
+                "H": 1.0,
+                "O": 13.0,
+                "Si": 3.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -6028290.0,
+            "S_0": 329.0,
+            "V_0": 0.0001421,
+            "Cp": [584.7, 0.030447, -7674200.0, -2244.3],
+            "a_0": 2.31e-05,
+            "K_0": 151300e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.6e-11,
+            "n": 22.0,
+            "molar_mass": 0.51208414,
+        }
+        Mineral.__init__(self)
+
+
+class pmt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pmt",
+            "formula": {
+                "Al": 2.0,
+                "Ca": 2.0,
+                "H": 1.0,
+                "Mn": 1.0,
+                "O": 13.0,
+                "Si": 3.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -6542600.0,
+            "S_0": 340.0,
+            "V_0": 0.0001382,
+            "Cp": [569.8, 0.02779, -5442900.0, -2812.6],
+            "a_0": 2.38e-05,
+            "K_0": 119700e6,
+            "Kprime_0": 4.07,
+            "Kdprime_0": -3.4e-11,
+            "n": 22.0,
+            "molar_mass": 0.48231364,
+        }
+        Mineral.__init__(self)
+
+
+class law(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "law",
+            "formula": {"Al": 2.0, "Ca": 1.0, "H": 4.0, "O": 10.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4868550.0,
+            "S_0": 229.0,
+            "V_0": 0.00010132,
+            "Cp": [687.8, 0.001566, 375900.0, -7179.2],
+            "a_0": 2.65e-05,
+            "K_0": 122900e6,
+            "Kprime_0": 5.45,
+            "Kdprime_0": -4.4e-11,
+            "n": 19.0,
+            "molar_mass": 0.31423776,
+        }
+        Mineral.__init__(self)
+
+
+class mpm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mpm",
+            "formula": {
+                "Al": 5.0,
+                "Ca": 4.0,
+                "H": 7.0,
+                "Mg": 1.0,
+                "O": 28.0,
+                "Si": 6.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -14386650.0,
+            "S_0": 629.0,
+            "V_0": 0.0002955,
+            "Cp": [1720.8, -0.024928, -5998700.0, -14620.3],
+            "a_0": 2.48e-05,
+            "K_0": 161500e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.5e-11,
+            "n": 51.0,
+            "molar_mass": 0.94307628,
+        }
+        Mineral.__init__(self)
+
+
+class fpm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fpm",
+            "formula": {
+                "Al": 5.0,
+                "Ca": 4.0,
+                "Fe": 1.0,
+                "H": 7.0,
+                "O": 28.0,
+                "Si": 6.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -14034030.0,
+            "S_0": 657.0,
+            "V_0": 0.0002968,
+            "Cp": [1737.2, -0.024582, -5161100.0, -14963.0],
+            "a_0": 2.49e-05,
+            "K_0": 161500e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.5e-11,
+            "n": 51.0,
+            "molar_mass": 0.97461628,
+        }
+        Mineral.__init__(self)
+
+
+class jgd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "jgd",
+            "formula": {"Ca": 4.0, "Fe": 6.0, "H": 7.0, "O": 28.0, "Si": 6.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -11808710.0,
+            "S_0": 830.0,
+            "V_0": 0.0003108,
+            "Cp": [1795.4, -0.037986, -4455700.0, -14888.0],
+            "a_0": 2.49e-05,
+            "K_0": 161500e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.5e-11,
+            "n": 51.0,
+            "molar_mass": 1.11893378,
+        }
+        Mineral.__init__(self)
+
+
+class geh(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "geh",
+            "formula": {"Al": 2.0, "Ca": 2.0, "O": 7.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3992180.0,
+            "S_0": 198.5,
+            "V_0": 9.024e-05,
+            "Cp": [405.7, -0.007099, -1188300.0, -3174.4],
+            "a_0": 2.23e-05,
+            "K_0": 108000e6,
+            "Kprime_0": 4.08,
+            "Kdprime_0": -3.8e-11,
+            "n": 12.0,
+            "molar_mass": 0.2742003,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 7510.0,
+                    "deltaV": 9e-07,
+                    "Wh": 7500.0,
+                    "Wv": 9e-07,
+                    "n": 1.0,
+                    "factor": 0.8,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class ak(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ak",
+            "formula": {"Ca": 2.0, "Mg": 1.0, "O": 7.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3865580.0,
+            "S_0": 212.5,
+            "V_0": 9.254e-05,
+            "Cp": [385.4, 0.003209, -247500.0, -2889.9],
+            "a_0": 2.57e-05,
+            "K_0": 142000e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -2.9e-11,
+            "n": 12.0,
+            "molar_mass": 0.2726278,
+        }
+        Mineral.__init__(self)
+
+
+class rnk(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "rnk",
+            "formula": {"Ca": 3.0, "O": 7.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3943840.0,
+            "S_0": 210.0,
+            "V_0": 9.651e-05,
+            "Cp": [372.3, -0.002893, -2462400.0, -2181.3],
+            "a_0": 3.28e-05,
+            "K_0": 95000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.3e-11,
+            "n": 12.0,
+            "molar_mass": 0.2884008,
+        }
+        Mineral.__init__(self)
+
+
+class ty(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ty",
+            "formula": {"C": 2.0, "Ca": 5.0, "O": 13.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6368130.0,
+            "S_0": 390.0,
+            "V_0": 0.00017039,
+            "Cp": [741.7, -0.005345, -1434600.0, -5878.5],
+            "a_0": 3.42e-05,
+            "K_0": 95000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.3e-11,
+            "n": 22.0,
+            "molar_mass": 0.4885746,
+        }
+        Mineral.__init__(self)
+
+
+class crd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "crd",
+            "formula": {"Al": 4.0, "Mg": 2.0, "O": 18.0, "Si": 5.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9163180.0,
+            "S_0": 404.1,
+            "V_0": 0.00023322,
+            "Cp": [906.1, 0.0, -7902000.0, -6293.4],
+            "a_0": 6.8e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 29.0,
+            "molar_mass": 0.5849527,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 36710.0,
+                    "deltaV": 1e-06,
+                    "Wh": 36700.0,
+                    "Wv": 1e-06,
+                    "n": 2.0,
+                    "factor": 1.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class hcrd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hcrd",
+            "formula": {"Al": 4.0, "H": 2.0, "Mg": 2.0, "O": 19.0, "Si": 5.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9448270.0,
+            "S_0": 483.0,
+            "V_0": 0.00023322,
+            "Cp": [955.3, 0.0, -8352600.0, -6301.2],
+            "a_0": 6.7e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 32.0,
+            "molar_mass": 0.60296798,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 36710.0,
+                    "deltaV": 1e-06,
+                    "Wh": 36700.0,
+                    "Wv": 1e-06,
+                    "n": 2.0,
+                    "factor": 1.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class fcrd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fcrd",
+            "formula": {"Al": 4.0, "Fe": 2.0, "O": 18.0, "Si": 5.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -8444070.0,
+            "S_0": 461.0,
+            "V_0": 0.0002371,
+            "Cp": [924.0, 0.0, -7039400.0, -6439.6],
+            "a_0": 6.7e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 29.0,
+            "molar_mass": 0.6480327,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 36710.0,
+                    "deltaV": 1e-06,
+                    "Wh": 36700.0,
+                    "Wv": 1e-06,
+                    "n": 2.0,
+                    "factor": 1.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class mncrd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mncrd",
+            "formula": {"Al": 4.0, "Mn": 2.0, "O": 18.0, "Si": 5.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -8692150.0,
+            "S_0": 473.0,
+            "V_0": 0.00024027,
+            "Cp": [886.5, 0.0, -8840000.0, -5590.4],
+            "a_0": 6.9e-06,
+            "K_0": 129000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -3.1e-11,
+            "n": 29.0,
+            "molar_mass": 0.6462187,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 36710.0,
+                    "deltaV": 1e-06,
+                    "Wh": 36700.0,
+                    "Wv": 1e-06,
+                    "n": 2.0,
+                    "factor": 1.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class phA(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "phA",
+            "formula": {"H": 6.0, "Mg": 7.0, "O": 14.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -7129610.0,
+            "S_0": 350.5,
+            "V_0": 0.00015422,
+            "Cp": [962.0, -0.011521, -4517800.0, -7724.7],
+            "a_0": 3.55e-05,
+            "K_0": 145000e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -2.8e-11,
+            "n": 29.0,
+            "molar_mass": 0.45634524,
+        }
+        Mineral.__init__(self)
+
+
+class phD(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "phD",
+            "formula": {"H": 2.0, "Mg": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2670160.0,
+            "S_0": 111.2,
+            "V_0": 5.103e-05,
+            "Cp": [294.6, 0.007944, -5008700.0, -1335.5],
+            "a_0": 3.79e-05,
+            "K_0": 165000e6,
+            "Kprime_0": 5.0,
+            "Kdprime_0": -3e-11,
+            "n": 11.0,
+            "molar_mass": 0.17848828,
+        }
+        Mineral.__init__(self)
+
+
+class phE(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "phE",
+            "formula": {"H": 2.4, "Mg": 2.4, "O": 6.0, "Si": 1.2},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2931150.0,
+            "S_0": 169.0,
+            "V_0": 6.435e-05,
+            "Cp": [397.4, -0.003533, -1344400.0, -3290.2],
+            "a_0": 3.79e-05,
+            "K_0": 93000e6,
+            "Kprime_0": 5.0,
+            "Kdprime_0": -5.4e-11,
+            "n": 12.0,
+            "molar_mass": 0.190450056,
+        }
+        Mineral.__init__(self)
+
+
+class shB(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "shB",
+            "formula": {"H": 4.0, "Mg": 10.0, "O": 18.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9477320.0,
+            "S_0": 396.0,
+            "V_0": 0.00018615,
+            "Cp": [1077.7, 0.000642, -7407400.0, -7428.7],
+            "a_0": 3.56e-05,
+            "K_0": 132000e6,
+            "Kprime_0": 5.3,
+            "Kdprime_0": -3.91e-11,
+            "n": 35.0,
+            "molar_mass": 0.61932746,
+        }
+        Mineral.__init__(self)
+
+
+class sph(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "sph",
+            "formula": {"Ca": 1.0, "O": 5.0, "Si": 1.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2601450.0,
+            "S_0": 124.0,
+            "V_0": 5.565e-05,
+            "Cp": [227.9, 0.002924, -3539500.0, -894.3],
+            "a_0": 1.58e-05,
+            "K_0": 101700e6,
+            "Kprime_0": 9.85,
+            "Kdprime_0": -9.7e-11,
+            "n": 8.0,
+            "molar_mass": 0.1960275,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 485.0,
+                    "S_D": 0.4,
+                    "V_D": 5e-08,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class cstn(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cstn",
+            "formula": {"Ca": 1.0, "O": 5.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2482910.0,
+            "S_0": 99.5,
+            "V_0": 4.818e-05,
+            "Cp": [205.6, 0.006034, -5517700.0, -352.6],
+            "a_0": 1.58e-05,
+            "K_0": 178200e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 8.0,
+            "molar_mass": 0.176246,
+        }
+        Mineral.__init__(self)
+
+
+class zrc(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "zrc",
+            "formula": {"O": 4.0, "Si": 1.0, "Zr": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2035140.0,
+            "S_0": 83.03,
+            "V_0": 3.926e-05,
+            "Cp": [232.0, -0.014405, 0.0, -2238.2],
+            "a_0": 1.25e-05,
+            "K_0": 230100e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.8e-11,
+            "n": 6.0,
+            "molar_mass": 0.1833071,
+        }
+        Mineral.__init__(self)
+
+
+class zrt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "zrt",
+            "formula": {"O": 4.0, "Ti": 1.0, "Zr": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1998020.0,
+            "S_0": 98.0,
+            "V_0": 4.42e-05,
+            "Cp": [214.6, -0.008226, 190300.0, -1820.4],
+            "a_0": 1.25e-05,
+            "K_0": 230100e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.8e-11,
+            "n": 6.0,
+            "molar_mass": 0.2030886,
+        }
+        Mineral.__init__(self)
+
+
+class tcn(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tcn",
+            "formula": {"O": 4.0, "Si": 1.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1766360.0,
+            "S_0": 77.0,
+            "V_0": 3.493e-05,
+            "Cp": [208.6, -0.003669, 113000.0, -1906.9],
+            "a_0": 1.25e-05,
+            "K_0": 230100e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.8e-11,
+            "n": 6.0,
+            "molar_mass": 0.1399501,
+        }
+        Mineral.__init__(self)
+
+
+class en(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "en",
+            "formula": {"Mg": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3089960.0,
+            "S_0": 132.5,
+            "V_0": 6.262e-05,
+            "Cp": [356.2, -0.00299, -596900.0, -3185.3],
+            "a_0": 2.27e-05,
+            "K_0": 105900e6,
+            "Kprime_0": 8.65,
+            "Kdprime_0": -8.2e-11,
+            "n": 10.0,
+            "molar_mass": 0.2007774,
+        }
+        Mineral.__init__(self)
+
+
+class pren(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pren",
+            "formula": {"Mg": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3084300.0,
+            "S_0": 137.0,
+            "V_0": 6.476e-05,
+            "Cp": [356.2, -0.00299, -596900.0, -3185.3],
+            "a_0": 2.3e-05,
+            "K_0": 105900e6,
+            "Kprime_0": 8.65,
+            "Kdprime_0": -8.2e-11,
+            "n": 10.0,
+            "molar_mass": 0.2007774,
+        }
+        Mineral.__init__(self)
+
+
+class cen(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cen",
+            "formula": {"Mg": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3090850.0,
+            "S_0": 132.0,
+            "V_0": 6.264e-05,
+            "Cp": [306.0, -0.003793, -3041700.0, -1852.1],
+            "a_0": 2.11e-05,
+            "K_0": 105900e6,
+            "Kprime_0": 8.65,
+            "Kdprime_0": -8.2e-11,
+            "n": 10.0,
+            "molar_mass": 0.2007774,
+        }
+        Mineral.__init__(self)
+
+
+class hen(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hen",
+            "formula": {"Mg": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3082460.0,
+            "S_0": 131.7,
+            "V_0": 6.099e-05,
+            "Cp": [356.2, -0.00299, -596900.0, -3185.3],
+            "a_0": 2.26e-05,
+            "K_0": 150000e6,
+            "Kprime_0": 5.5,
+            "Kdprime_0": -3.6e-11,
+            "n": 10.0,
+            "molar_mass": 0.2007774,
+        }
+        Mineral.__init__(self)
+
+
+class hfs(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hfs",
+            "formula": {"Fe": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2380550.0,
+            "S_0": 189.0,
+            "V_0": 6.405e-05,
+            "Cp": [398.7, -0.006579, 1290100.0, -4058.0],
+            "a_0": 2.37e-05,
+            "K_0": 150000e6,
+            "Kprime_0": 5.5,
+            "Kdprime_0": -3.6e-11,
+            "n": 10.0,
+            "molar_mass": 0.2638574,
+        }
+        Mineral.__init__(self)
+
+
+class fs(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fs",
+            "formula": {"Fe": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2388500.0,
+            "S_0": 189.9,
+            "V_0": 6.592e-05,
+            "Cp": [398.7, -0.006579, 1290100.0, -4058.0],
+            "a_0": 3.26e-05,
+            "K_0": 101000e6,
+            "Kprime_0": 4.08,
+            "Kdprime_0": -4e-11,
+            "n": 10.0,
+            "molar_mass": 0.2638574,
+        }
+        Mineral.__init__(self)
+
+
+class mgts(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mgts",
+            "formula": {"Al": 2.0, "Mg": 1.0, "O": 6.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3200660.0,
+            "S_0": 128.5,
+            "V_0": 6.05e-05,
+            "Cp": [371.4, -0.004082, -398400.0, -3547.1],
+            "a_0": 2.17e-05,
+            "K_0": 102800e6,
+            "Kprime_0": 8.55,
+            "Kdprime_0": -8.3e-11,
+            "n": 10.0,
+            "molar_mass": 0.2023499,
+        }
+        Mineral.__init__(self)
+
+
+class di(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "di",
+            "formula": {"Ca": 1.0, "Mg": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3201780.0,
+            "S_0": 142.9,
+            "V_0": 6.619e-05,
+            "Cp": [314.5, 4.1e-05, -2745900.0, -2020.1],
+            "a_0": 2.73e-05,
+            "K_0": 119200e6,
+            "Kprime_0": 5.19,
+            "Kdprime_0": -4.4e-11,
+            "n": 10.0,
+            "molar_mass": 0.2165504,
+        }
+        Mineral.__init__(self)
+
+
+class hed(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hed",
+            "formula": {"Ca": 1.0, "Fe": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2841970.0,
+            "S_0": 175.0,
+            "V_0": 6.795e-05,
+            "Cp": [340.2, 0.000812, -1047800.0, -2646.7],
+            "a_0": 2.38e-05,
+            "K_0": 119200e6,
+            "Kprime_0": 3.97,
+            "Kdprime_0": -3.3e-11,
+            "n": 10.0,
+            "molar_mass": 0.2480904,
+        }
+        Mineral.__init__(self)
+
+
+class jd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "jd",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3025370.0,
+            "S_0": 133.5,
+            "V_0": 6.04e-05,
+            "Cp": [319.4, 0.003616, -1173900.0, -2469.5],
+            "a_0": 2.1e-05,
+            "K_0": 128100e6,
+            "Kprime_0": 3.81,
+            "Kdprime_0": -3e-11,
+            "n": 10.0,
+            "molar_mass": 0.2021387,
+        }
+        Mineral.__init__(self)
+
+
+class kjd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "kjd",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2932700.0,
+            "S_0": 141.24,
+            "V_0": 6.479e-05,
+            "Cp": [316.2, 0.006905, -905300.0, -2489.0],
+            "a_0": 2.73e-05,
+            "K_0": 145000e6,
+            "Kprime_0": 5.0,
+            "Kdprime_0": -3.4e-11,
+            "n": 10.0,
+            "molar_mass": 0.2182472,
+        }
+        Mineral.__init__(self)
+
+
+class acm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "acm",
+            "formula": {"Fe": 1.0, "Na": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2583270.0,
+            "S_0": 170.6,
+            "V_0": 6.459e-05,
+            "Cp": [307.1, 0.016758, -1685500.0, -2125.8],
+            "a_0": 2.11e-05,
+            "K_0": 106000e6,
+            "Kprime_0": 4.08,
+            "Kdprime_0": -3.8e-11,
+            "n": 10.0,
+            "molar_mass": 0.2310022,
+        }
+        Mineral.__init__(self)
+
+
+class kos(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "kos",
+            "formula": {"Cr": 1.0, "Na": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2744890.0,
+            "S_0": 149.65,
+            "V_0": 6.309e-05,
+            "Cp": [309.2, 0.005419, -664600.0, -2176.6],
+            "a_0": 1.94e-05,
+            "K_0": 130800e6,
+            "Kprime_0": 3.0,
+            "Kdprime_0": -2.3e-11,
+            "n": 10.0,
+            "molar_mass": 0.2271533,
+        }
+        Mineral.__init__(self)
+
+
+class cats(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cats",
+            "formula": {"Al": 2.0, "Ca": 1.0, "O": 6.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3310050.0,
+            "S_0": 135.0,
+            "V_0": 6.356e-05,
+            "Cp": [347.6, -0.006974, -1781600.0, -2757.5],
+            "a_0": 2.08e-05,
+            "K_0": 119200e6,
+            "Kprime_0": 5.19,
+            "Kdprime_0": -4.4e-11,
+            "n": 10.0,
+            "molar_mass": 0.2181229,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 3800.0,
+                    "deltaV": 1e-07,
+                    "Wh": 3800.0,
+                    "Wv": 1e-07,
+                    "n": 1.0,
+                    "factor": 0.25,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class caes(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "caes",
+            "formula": {"Al": 1.0, "Ca": 0.5, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3001960.0,
+            "S_0": 127.0,
+            "V_0": 6.05e-05,
+            "Cp": [362.0, -0.016944, -175900.0, -3565.7],
+            "a_0": 2.31e-05,
+            "K_0": 119200e6,
+            "Kprime_0": 5.19,
+            "Kdprime_0": -4.4e-11,
+            "n": 9.5,
+            "molar_mass": 0.1991879,
+        }
+        Mineral.__init__(self)
+
+
+class rhod(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "rhod",
+            "formula": {"Mn": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1322350.0,
+            "S_0": 100.5,
+            "V_0": 3.494e-05,
+            "Cp": [138.4, 0.004088, -1936000.0, -538.9],
+            "a_0": 2.81e-05,
+            "K_0": 84000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -4.8e-11,
+            "n": 5.0,
+            "molar_mass": 0.1310217,
+        }
+        Mineral.__init__(self)
+
+
+class pxmn(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pxmn",
+            "formula": {"Mn": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1323130.0,
+            "S_0": 99.3,
+            "V_0": 3.472e-05,
+            "Cp": [138.4, 0.004088, -1936000.0, -538.9],
+            "a_0": 2.8e-05,
+            "K_0": 84000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -4.8e-11,
+            "n": 5.0,
+            "molar_mass": 0.1310217,
+        }
+        Mineral.__init__(self)
+
+
+class wo(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "wo",
+            "formula": {"Ca": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1633760.0,
+            "S_0": 82.5,
+            "V_0": 3.993e-05,
+            "Cp": [159.3, 0.0, -967300.0, -1075.4],
+            "a_0": 2.54e-05,
+            "K_0": 79500e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -5.2e-11,
+            "n": 5.0,
+            "molar_mass": 0.1161617,
+        }
+        Mineral.__init__(self)
+
+
+class pswo(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pswo",
+            "formula": {"Ca": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1627960.0,
+            "S_0": 87.8,
+            "V_0": 4.008e-05,
+            "Cp": [157.8, 0.0, -967300.0, -1075.4],
+            "a_0": 2.85e-05,
+            "K_0": 110000e6,
+            "Kprime_0": 4.08,
+            "Kdprime_0": -3.7e-11,
+            "n": 5.0,
+            "molar_mass": 0.1161617,
+        }
+        Mineral.__init__(self)
+
+
+class wal(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "wal",
+            "formula": {"Ca": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1625600.0,
+            "S_0": 84.5,
+            "V_0": 3.7633e-05,
+            "Cp": [159.3, 0.0, -967300.0, -1075.4],
+            "a_0": 3.2e-05,
+            "K_0": 86000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -4.7e-11,
+            "n": 5.0,
+            "molar_mass": 0.1161617,
+        }
+        Mineral.__init__(self)
+
+
+class tr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tr",
+            "formula": {"Ca": 2.0, "H": 2.0, "Mg": 5.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -12304300.0,
+            "S_0": 553.0,
+            "V_0": 0.0002727,
+            "Cp": [1260.2, 0.00383, -11455000.0, -8237.6],
+            "a_0": 2.61e-05,
+            "K_0": 76200e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -5.4e-11,
+            "n": 41.0,
+            "molar_mass": 0.81236648,
+        }
+        Mineral.__init__(self)
+
+
+class fact(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fact",
+            "formula": {"Ca": 2.0, "Fe": 5.0, "H": 2.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -10503600.0,
+            "S_0": 710.0,
+            "V_0": 0.0002842,
+            "Cp": [1290.0, 0.029992, -8447500.0, -8947.0],
+            "a_0": 2.88e-05,
+            "K_0": 76000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -5.4e-11,
+            "n": 41.0,
+            "molar_mass": 0.97006648,
+        }
+        Mineral.__init__(self)
+
+
+class ts(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ts",
+            "formula": {
+                "Al": 4.0,
+                "Ca": 2.0,
+                "H": 2.0,
+                "Mg": 3.0,
+                "O": 24.0,
+                "Si": 6.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -12554640.0,
+            "S_0": 533.0,
+            "V_0": 0.000268,
+            "Cp": [1244.8, 0.024348, -11965000.0, -8112.1],
+            "a_0": 2.66e-05,
+            "K_0": 76000e6,
+            "Kprime_0": 4.1,
+            "Kdprime_0": -5.4e-11,
+            "n": 41.0,
+            "molar_mass": 0.81551148,
+        }
+        Mineral.__init__(self)
+
+
+class parg(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "parg",
+            "formula": {
+                "Al": 3.0,
+                "Ca": 2.0,
+                "H": 2.0,
+                "Mg": 4.0,
+                "Na": 1.0,
+                "O": 24.0,
+                "Si": 6.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -12664760.0,
+            "S_0": 635.0,
+            "V_0": 0.0002719,
+            "Cp": [1280.2, 0.022997, -12359500.0, -8065.8],
+            "a_0": 2.8e-05,
+            "K_0": 91200e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.5e-11,
+            "n": 42.0,
+            "molar_mass": 0.83582478,
+        }
+        Mineral.__init__(self)
+
+
+class gl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "gl",
+            "formula": {
+                "Al": 2.0,
+                "H": 2.0,
+                "Mg": 3.0,
+                "Na": 2.0,
+                "O": 24.0,
+                "Si": 8.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -11955920.0,
+            "S_0": 530.0,
+            "V_0": 0.0002598,
+            "Cp": [1717.5, -0.12107, 7075000.0, -19272.0],
+            "a_0": 1.58e-05,
+            "K_0": 88300e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.6e-11,
+            "n": 41.0,
+            "molar_mass": 0.78354308,
+        }
+        Mineral.__init__(self)
+
+
+class fgl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fgl",
+            "formula": {
+                "Al": 2.0,
+                "Fe": 3.0,
+                "H": 2.0,
+                "Na": 2.0,
+                "O": 24.0,
+                "Si": 8.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -10879520.0,
+            "S_0": 624.0,
+            "V_0": 0.0002659,
+            "Cp": [1762.9, -0.118992, 9423700.0, -20207.1],
+            "a_0": 1.83e-05,
+            "K_0": 89000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.6e-11,
+            "n": 41.0,
+            "molar_mass": 0.87816308,
+        }
+        Mineral.__init__(self)
+
+
+class nyb(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "nyb",
+            "formula": {
+                "Al": 3.0,
+                "H": 2.0,
+                "Mg": 3.0,
+                "Na": 3.0,
+                "O": 24.0,
+                "Si": 7.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -12165450.0,
+            "S_0": 622.0,
+            "V_0": 0.00026314,
+            "Cp": [1745.2, -0.112162, 6425500.0, -19163.0],
+            "a_0": 2.2e-05,
+            "K_0": 91000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.5e-11,
+            "n": 42.0,
+            "molar_mass": 0.80542888,
+        }
+        Mineral.__init__(self)
+
+
+class rieb(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "rieb",
+            "formula": {"Fe": 5.0, "H": 2.0, "Na": 2.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -10024100.0,
+            "S_0": 695.0,
+            "V_0": 0.0002749,
+            "Cp": [1787.3, -0.124882, 9627100.0, -20275.5],
+            "a_0": 1.81e-05,
+            "K_0": 89000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.6e-11,
+            "n": 41.0,
+            "molar_mass": 0.93589008,
+        }
+        Mineral.__init__(self)
+
+
+class anth(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "anth",
+            "formula": {"H": 2.0, "Mg": 7.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -12065900.0,
+            "S_0": 537.0,
+            "V_0": 0.0002654,
+            "Cp": [1277.3, 0.025825, -9704600.0, -9074.7],
+            "a_0": 2.52e-05,
+            "K_0": 70000e6,
+            "Kprime_0": 4.11,
+            "Kdprime_0": -5.9e-11,
+            "n": 41.0,
+            "molar_mass": 0.78082048,
+        }
+        Mineral.__init__(self)
+
+
+class fanth(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fanth",
+            "formula": {"Fe": 7.0, "H": 2.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9623750.0,
+            "S_0": 725.0,
+            "V_0": 0.0002787,
+            "Cp": [1383.1, 0.030669, -4224700.0, -11257.6],
+            "a_0": 2.74e-05,
+            "K_0": 70000e6,
+            "Kprime_0": 4.11,
+            "Kdprime_0": -5.9e-11,
+            "n": 41.0,
+            "molar_mass": 1.00160048,
+        }
+        Mineral.__init__(self)
+
+
+class cumm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cumm",
+            "formula": {"H": 2.0, "Mg": 7.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -12063750.0,
+            "S_0": 538.0,
+            "V_0": 0.0002633,
+            "Cp": [1277.3, 0.025825, -9704600.0, -9074.7],
+            "a_0": 2.52e-05,
+            "K_0": 70000e6,
+            "Kprime_0": 4.11,
+            "Kdprime_0": -5.9e-11,
+            "n": 41.0,
+            "molar_mass": 0.78082048,
+        }
+        Mineral.__init__(self)
+
+
+class grun(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "grun",
+            "formula": {"Fe": 7.0, "H": 2.0, "O": 24.0, "Si": 8.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9606390.0,
+            "S_0": 735.0,
+            "V_0": 0.0002784,
+            "Cp": [1383.1, 0.030669, -4224700.0, -11257.6],
+            "a_0": 2.74e-05,
+            "K_0": 64800e6,
+            "Kprime_0": 4.12,
+            "Kdprime_0": -6.4e-11,
+            "n": 41.0,
+            "molar_mass": 1.00160048,
+        }
+        Mineral.__init__(self)
+
+
+class ged(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ged",
+            "formula": {"Al": 4.0, "H": 2.0, "Mg": 5.0, "O": 24.0, "Si": 6.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -12306610.0,
+            "S_0": 535.0,
+            "V_0": 0.00025956,
+            "Cp": [1307.7, 0.023642, -9307400.0, -9799.0],
+            "a_0": 2.41e-05,
+            "K_0": 70000e6,
+            "Kprime_0": 4.11,
+            "Kdprime_0": -5.9e-11,
+            "n": 41.0,
+            "molar_mass": 0.78396548,
+        }
+        Mineral.__init__(self)
+
+
+class spr4(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "spr4",
+            "formula": {"Al": 8.0, "Mg": 4.0, "O": 20.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -11020350.0,
+            "S_0": 425.5,
+            "V_0": 0.000199,
+            "Cp": [1133.1, -0.007596, -8816600.0, -8180.6],
+            "a_0": 2.05e-05,
+            "K_0": 250000e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.6e-11,
+            "n": 34.0,
+            "molar_mass": 0.689231,
+        }
+        Mineral.__init__(self)
+
+
+class spr5(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "spr5",
+            "formula": {"Al": 10.0, "Mg": 3.0, "O": 20.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -11135050.0,
+            "S_0": 419.5,
+            "V_0": 0.0001975,
+            "Cp": [1103.4, 0.001015, -10957000.0, -7409.2],
+            "a_0": 2.06e-05,
+            "K_0": 250000e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.6e-11,
+            "n": 34.0,
+            "molar_mass": 0.6908035,
+        }
+        Mineral.__init__(self)
+
+
+class fspr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fspr",
+            "formula": {"Al": 8.0, "Fe": 4.0, "O": 20.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9658040.0,
+            "S_0": 485.0,
+            "V_0": 0.00019923,
+            "Cp": [1132.9, -0.007348, -10420200.0, -7036.6],
+            "a_0": 1.96e-05,
+            "K_0": 250000e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.7e-11,
+            "n": 34.0,
+            "molar_mass": 0.815391,
+        }
+        Mineral.__init__(self)
+
+
+class mcar(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mcar",
+            "formula": {"Al": 2.0, "H": 4.0, "Mg": 1.0, "O": 10.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4770850.0,
+            "S_0": 221.5,
+            "V_0": 0.0001059,
+            "Cp": [683.0, -0.014054, 291000.0, -6976.4],
+            "a_0": 2.43e-05,
+            "K_0": 52500e6,
+            "Kprime_0": 4.14,
+            "Kdprime_0": -7.9e-11,
+            "n": 19.0,
+            "molar_mass": 0.29846476,
+        }
+        Mineral.__init__(self)
+
+
+class fcar(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fcar",
+            "formula": {"Al": 2.0, "Fe": 1.0, "H": 4.0, "O": 10.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4411490.0,
+            "S_0": 251.1,
+            "V_0": 0.00010695,
+            "Cp": [686.6, -0.012415, 186000.0, -6884.0],
+            "a_0": 2.21e-05,
+            "K_0": 52500e6,
+            "Kprime_0": 4.14,
+            "Kdprime_0": -7.9e-11,
+            "n": 19.0,
+            "molar_mass": 0.33000476,
+        }
+        Mineral.__init__(self)
+
+
+class deer(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "deer",
+            "formula": {"Fe": 18.0, "H": 10.0, "O": 50.0, "Si": 12.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -18339500.0,
+            "S_0": 1650.0,
+            "V_0": 0.0005574,
+            "Cp": [3164.4, -0.027883, -5039100.0, -26721.0],
+            "a_0": 2.75e-05,
+            "K_0": 63000e6,
+            "Kprime_0": 4.12,
+            "Kdprime_0": -6.5e-11,
+            "n": 90.0,
+            "molar_mass": 2.1522854,
+        }
+        Mineral.__init__(self)
+
+
+class mu(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mu",
+            "formula": {"Al": 3.0, "H": 2.0, "K": 1.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5976510.0,
+            "S_0": 292.0,
+            "V_0": 0.00014083,
+            "Cp": [756.4, -0.01984, -2170000.0, -6979.2],
+            "a_0": 3.07e-05,
+            "K_0": 49000e6,
+            "Kprime_0": 4.15,
+            "Kdprime_0": -8.5e-11,
+            "n": 21.0,
+            "molar_mass": 0.39830798,
+        }
+        Mineral.__init__(self)
+
+
+class cel(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cel",
+            "formula": {"Al": 1.0, "H": 2.0, "K": 1.0, "Mg": 1.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5834860.0,
+            "S_0": 290.0,
+            "V_0": 0.00013957,
+            "Cp": [741.2, -0.018748, -2368800.0, -6616.9],
+            "a_0": 3.07e-05,
+            "K_0": 70000e6,
+            "Kprime_0": 4.11,
+            "Kdprime_0": -5.9e-11,
+            "n": 21.0,
+            "molar_mass": 0.39673548,
+        }
+        Mineral.__init__(self)
+
+
+class fcel(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fcel",
+            "formula": {"Al": 1.0, "Fe": 1.0, "H": 2.0, "K": 1.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5468630.0,
+            "S_0": 330.0,
+            "V_0": 0.0001407,
+            "Cp": [756.3, -0.019147, -1586100.0, -6928.7],
+            "a_0": 3.18e-05,
+            "K_0": 70000e6,
+            "Kprime_0": 4.11,
+            "Kdprime_0": -5.9e-11,
+            "n": 21.0,
+            "molar_mass": 0.42827548,
+        }
+        Mineral.__init__(self)
+
+
+class pa(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pa",
+            "formula": {"Al": 3.0, "H": 2.0, "Na": 1.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5942660.0,
+            "S_0": 277.0,
+            "V_0": 0.00013211,
+            "Cp": [803.0, -0.03158, 217000.0, -8151.0],
+            "a_0": 3.7e-05,
+            "K_0": 51500e6,
+            "Kprime_0": 6.51,
+            "Kdprime_0": -1.26e-10,
+            "n": 21.0,
+            "molar_mass": 0.38219948,
+        }
+        Mineral.__init__(self)
+
+
+class ma(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ma",
+            "formula": {"Al": 4.0, "Ca": 1.0, "H": 2.0, "O": 12.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6241920.0,
+            "S_0": 265.0,
+            "V_0": 0.00012964,
+            "Cp": [744.4, -0.0168, -2074400.0, -6783.2],
+            "a_0": 2.33e-05,
+            "K_0": 100000e6,
+            "Kprime_0": 4.08,
+            "Kdprime_0": -4.1e-11,
+            "n": 21.0,
+            "molar_mass": 0.39818368,
+        }
+        Mineral.__init__(self)
+
+
+class phl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "phl",
+            "formula": {"Al": 1.0, "H": 2.0, "K": 1.0, "Mg": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6214610.0,
+            "S_0": 326.0,
+            "V_0": 0.00014964,
+            "Cp": [770.3, -0.036939, -2328900.0, -6531.6],
+            "a_0": 3.8e-05,
+            "K_0": 51300e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 22.0,
+            "molar_mass": 0.41725998,
+        }
+        Mineral.__init__(self)
+
+
+class ann(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ann",
+            "formula": {"Al": 1.0, "Fe": 3.0, "H": 2.0, "K": 1.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5143590.0,
+            "S_0": 420.0,
+            "V_0": 0.00015432,
+            "Cp": [815.7, -0.034861, 19800.0, -7466.7],
+            "a_0": 3.8e-05,
+            "K_0": 51300e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 22.0,
+            "molar_mass": 0.51187998,
+        }
+        Mineral.__init__(self)
+
+
+class mnbi(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mnbi",
+            "formula": {"Al": 1.0, "H": 2.0, "K": 1.0, "Mn": 3.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5475460.0,
+            "S_0": 433.0,
+            "V_0": 0.00015264,
+            "Cp": [809.9, -0.059213, -1514400.0, -6998.7],
+            "a_0": 3.8e-05,
+            "K_0": 53000e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 22.0,
+            "molar_mass": 0.50915898,
+        }
+        Mineral.__init__(self)
+
+
+class east(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "east",
+            "formula": {"Al": 3.0, "H": 2.0, "K": 1.0, "Mg": 2.0, "O": 12.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6330120.0,
+            "S_0": 318.0,
+            "V_0": 0.00014738,
+            "Cp": [785.5, -0.038031, -2130300.0, -6893.7],
+            "a_0": 3.8e-05,
+            "K_0": 53000e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 22.0,
+            "molar_mass": 0.41883248,
+        }
+        Mineral.__init__(self)
+
+
+class naph(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "naph",
+            "formula": {
+                "Al": 1.0,
+                "H": 2.0,
+                "Mg": 3.0,
+                "Na": 1.0,
+                "O": 12.0,
+                "Si": 3.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -6164670.0,
+            "S_0": 318.0,
+            "V_0": 0.0001445,
+            "Cp": [773.5, -0.040229, -2597900.0, -6512.6],
+            "a_0": 3.28e-05,
+            "K_0": 51300e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 22.0,
+            "molar_mass": 0.40115148,
+        }
+        Mineral.__init__(self)
+
+
+class tan(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tan",
+            "formula": {"H": 2.0, "Mg": 3.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5899790.0,
+            "S_0": 259.0,
+            "V_0": 0.00013665,
+            "Cp": [622.2, 0.0, -6385500.0, -3916.3],
+            "a_0": 1.8e-05,
+            "K_0": 43000e6,
+            "Kprime_0": 6.17,
+            "Kdprime_0": -1.44e-10,
+            "n": 21.0,
+            "molar_mass": 0.37926568,
+        }
+        Mineral.__init__(self)
+
+
+class clin(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "clin",
+            "formula": {"Al": 2.0, "H": 8.0, "Mg": 5.0, "O": 18.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -8908950.0,
+            "S_0": 437.0,
+            "V_0": 0.0002114,
+            "Cp": [1170.8, -0.001508, -3825800.0, -10315.0],
+            "a_0": 2.04e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 36.0,
+            "molar_mass": 0.55579722,
+        }
+        Mineral.__init__(self)
+
+
+class ames(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ames",
+            "formula": {"Al": 4.0, "H": 8.0, "Mg": 4.0, "O": 18.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -9040330.0,
+            "S_0": 412.0,
+            "V_0": 0.0002071,
+            "Cp": [1186.0, -0.002599, -3627200.0, -10677.0],
+            "a_0": 2e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 36.0,
+            "molar_mass": 0.55736972,
+        }
+        Mineral.__init__(self)
+
+
+class afchl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "afchl",
+            "formula": {"H": 8.0, "Mg": 6.0, "O": 18.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -8727580.0,
+            "S_0": 439.0,
+            "V_0": 0.0002157,
+            "Cp": [1155.0, -0.000417, -4024400.0, -9952.9],
+            "a_0": 2.04e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 36.0,
+            "molar_mass": 0.55422472,
+        }
+        Mineral.__init__(self)
+
+
+class daph(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "daph",
+            "formula": {"Al": 2.0, "Fe": 5.0, "H": 8.0, "O": 18.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -7117950.0,
+            "S_0": 584.0,
+            "V_0": 0.0002162,
+            "Cp": [1192.0, -0.00594, -4826400.0, -9768.3],
+            "a_0": 2.27e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 36.0,
+            "molar_mass": 0.71349722,
+        }
+        Mineral.__init__(self)
+
+
+class mnchl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mnchl",
+            "formula": {"Al": 2.0, "H": 8.0, "Mn": 5.0, "O": 18.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -7699120.0,
+            "S_0": 595.0,
+            "V_0": 0.0002259,
+            "Cp": [1136.5, -0.005243, -5548100.0, -8911.5],
+            "a_0": 2.23e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 36.0,
+            "molar_mass": 0.70896222,
+        }
+        Mineral.__init__(self)
+
+
+class sud(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "sud",
+            "formula": {"Al": 4.0, "H": 8.0, "Mg": 2.0, "O": 18.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -8626150.0,
+            "S_0": 395.0,
+            "V_0": 0.000203,
+            "Cp": [1436.1, -0.048749, -2748500.0, -13764.0],
+            "a_0": 1.99e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 35.0,
+            "molar_mass": 0.53684522,
+        }
+        Mineral.__init__(self)
+
+
+class fsud(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fsud",
+            "formula": {"Al": 4.0, "Fe": 2.0, "H": 8.0, "O": 18.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -7899960.0,
+            "S_0": 456.0,
+            "V_0": 0.000204,
+            "Cp": [1466.3, -0.047365, -1182800.0, -14388.0],
+            "a_0": 2.08e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 35.0,
+            "molar_mass": 0.59992522,
+        }
+        Mineral.__init__(self)
+
+
+class prl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "prl",
+            "formula": {"Al": 2.0, "H": 2.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5640520.0,
+            "S_0": 239.0,
+            "V_0": 0.00012804,
+            "Cp": [784.5, -0.042948, 1251000.0, -8495.9],
+            "a_0": 4.5e-05,
+            "K_0": 37000e6,
+            "Kprime_0": 10.0,
+            "Kdprime_0": -2.71e-10,
+            "n": 20.0,
+            "molar_mass": 0.36031368,
+        }
+        Mineral.__init__(self)
+
+
+class ta(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ta",
+            "formula": {"H": 2.0, "Mg": 3.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5896740.0,
+            "S_0": 259.0,
+            "V_0": 0.00013665,
+            "Cp": [622.2, 0.0, -6385500.0, -3916.3],
+            "a_0": 1.8e-05,
+            "K_0": 43000e6,
+            "Kprime_0": 6.17,
+            "Kdprime_0": -1.44e-10,
+            "n": 21.0,
+            "molar_mass": 0.37926568,
+        }
+        Mineral.__init__(self)
+
+
+class fta(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fta",
+            "formula": {"Fe": 3.0, "H": 2.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4798850.0,
+            "S_0": 352.0,
+            "V_0": 0.00014225,
+            "Cp": [579.7, 0.039494, -6459300.0, -3088.1],
+            "a_0": 1.8e-05,
+            "K_0": 43000e6,
+            "Kprime_0": 6.17,
+            "Kdprime_0": -1.44e-10,
+            "n": 21.0,
+            "molar_mass": 0.47388568,
+        }
+        Mineral.__init__(self)
+
+
+class tats(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tats",
+            "formula": {"Al": 2.0, "H": 2.0, "Mg": 2.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6000930.0,
+            "S_0": 259.0,
+            "V_0": 0.0001351,
+            "Cp": [549.5, 0.036324, -8606600.0, -2515.3],
+            "a_0": 1.8e-05,
+            "K_0": 43000e6,
+            "Kprime_0": 6.17,
+            "Kdprime_0": -1.44e-10,
+            "n": 21.0,
+            "molar_mass": 0.38083818,
+        }
+        Mineral.__init__(self)
+
+
+class tap(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tap",
+            "formula": {"Al": 2.0, "H": 2.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5649650.0,
+            "S_0": 235.0,
+            "V_0": 0.0001345,
+            "Cp": [784.5, -0.042948, 1251000.0, -8495.9],
+            "a_0": 4.5e-05,
+            "K_0": 37000e6,
+            "Kprime_0": 10.0,
+            "Kdprime_0": -2.71e-10,
+            "n": 20.0,
+            "molar_mass": 0.36031368,
+        }
+        Mineral.__init__(self)
+
+
+class nta(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "nta",
+            "formula": {
+                "Al": 1.0,
+                "H": 2.0,
+                "Mg": 3.0,
+                "Na": 1.0,
+                "O": 12.0,
+                "Si": 3.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -6163460.0,
+            "S_0": 318.0,
+            "V_0": 0.0001445,
+            "Cp": [773.5, -0.040229, -2597900.0, -6512.6],
+            "a_0": 3.28e-05,
+            "K_0": 51300e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 22.0,
+            "molar_mass": 0.40115148,
+        }
+        Mineral.__init__(self)
+
+
+class minn(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "minn",
+            "formula": {"Fe": 3.0, "H": 2.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4818980.0,
+            "S_0": 355.0,
+            "V_0": 0.00014851,
+            "Cp": [579.7, 0.039494, -6459300.0, -3088.1],
+            "a_0": 1.8e-05,
+            "K_0": 43000e6,
+            "Kprime_0": 6.17,
+            "Kdprime_0": -1.44e-10,
+            "n": 21.0,
+            "molar_mass": 0.47388568,
+        }
+        Mineral.__init__(self)
+
+
+class minm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "minm",
+            "formula": {"H": 2.0, "Mg": 3.0, "O": 12.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -5865930.0,
+            "S_0": 263.9,
+            "V_0": 0.00014291,
+            "Cp": [622.2, 0.0, -6385500.0, -3916.3],
+            "a_0": 1.8e-05,
+            "K_0": 43000e6,
+            "Kprime_0": 6.17,
+            "Kdprime_0": -1.44e-10,
+            "n": 21.0,
+            "molar_mass": 0.37926568,
+        }
+        Mineral.__init__(self)
+
+
+class kao(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "kao",
+            "formula": {"Al": 2.0, "H": 4.0, "O": 9.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4121930.0000000005,
+            "S_0": 203.7,
+            "V_0": 9.934e-05,
+            "Cp": [436.7, -0.034295, -4055900.0, -2699.1],
+            "a_0": 2.51e-05,
+            "K_0": 64500e6,
+            "Kprime_0": 4.12,
+            "Kdprime_0": -6.4e-11,
+            "n": 17.0,
+            "molar_mass": 0.25816036,
+        }
+        Mineral.__init__(self)
+
+
+class pre(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pre",
+            "formula": {"Al": 2.0, "Ca": 2.0, "H": 2.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6202070.0,
+            "S_0": 292.8,
+            "V_0": 0.00014026,
+            "Cp": [724.9, -0.013865, -2059000.0, -6323.9],
+            "a_0": 1.58e-05,
+            "K_0": 109300e6,
+            "Kprime_0": 4.01,
+            "Kdprime_0": -3.7e-11,
+            "n": 21.0,
+            "molar_mass": 0.41238418,
+        }
+        Mineral.__init__(self)
+
+
+class fpre(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fpre",
+            "formula": {
+                "Al": 1.0,
+                "Ca": 2.0,
+                "Fe": 1.0,
+                "H": 2.0,
+                "O": 12.0,
+                "Si": 3.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -5766490.0,
+            "S_0": 320.0,
+            "V_0": 0.000148,
+            "Cp": [737.1, -0.01681, -1957300.0, -6358.1],
+            "a_0": 1.58e-05,
+            "K_0": 109300e6,
+            "Kprime_0": 4.01,
+            "Kdprime_0": -3.7e-11,
+            "n": 21.0,
+            "molar_mass": 0.44124768,
+        }
+        Mineral.__init__(self)
+
+
+class chr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "chr",
+            "formula": {"H": 4.0, "Mg": 3.0, "O": 9.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4360800.0,
+            "S_0": 221.3,
+            "V_0": 0.00010746,
+            "Cp": [624.7, -0.02077, -1721800.0, -5619.4],
+            "a_0": 2.2e-05,
+            "K_0": 62800e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -6.4e-11,
+            "n": 18.0,
+            "molar_mass": 0.27711236,
+        }
+        Mineral.__init__(self)
+
+
+class liz(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "liz",
+            "formula": {"H": 4.0, "Mg": 3.0, "O": 9.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4368980.0,
+            "S_0": 212.0,
+            "V_0": 0.00010645,
+            "Cp": [614.7, -0.02077, -1721800.0, -5619.4],
+            "a_0": 2.2e-05,
+            "K_0": 71000e6,
+            "Kprime_0": 3.2,
+            "Kdprime_0": -4.5e-11,
+            "n": 18.0,
+            "molar_mass": 0.27711236,
+        }
+        Mineral.__init__(self)
+
+
+class glt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "glt",
+            "formula": {"Fe": 3.0, "H": 4.0, "O": 9.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3297310.0,
+            "S_0": 310.0,
+            "V_0": 0.0001198,
+            "Cp": [576.4, 0.002984, -3757000.0, -4166.2],
+            "a_0": 2.28e-05,
+            "K_0": 63000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -6.3e-11,
+            "n": 18.0,
+            "molar_mass": 0.37173236,
+        }
+        Mineral.__init__(self)
+
+
+class fstp(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fstp",
+            "formula": {
+                "Al": 2.0,
+                "Fe": 5.0,
+                "H": 12.5,
+                "K": 0.5,
+                "O": 30.5,
+                "Si": 8.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -12552150.0,
+            "S_0": 930.2,
+            "V_0": 0.00037239,
+            "Cp": [1944.3, -0.012289, -4840200.0, -16635.0],
+            "a_0": 3.68e-05,
+            "K_0": 51300e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 58.5,
+            "molar_mass": 1.0780021,
+        }
+        Mineral.__init__(self)
+
+
+class mstp(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mstp",
+            "formula": {
+                "Al": 2.0,
+                "H": 12.5,
+                "K": 0.5,
+                "Mg": 5.0,
+                "O": 30.5,
+                "Si": 8.0,
+            },
+            "equation_of_state": "hp_tmt",
+            "H_0": -14288210.0,
+            "S_0": 847.4,
+            "V_0": 0.00036577,
+            "Cp": [1862.2, -0.014018, -8983100.0, -14923.0],
+            "a_0": 3.71e-05,
+            "K_0": 51300e6,
+            "Kprime_0": 7.33,
+            "Kdprime_0": -1.43e-10,
+            "n": 58.5,
+            "molar_mass": 0.9203021,
+        }
+        Mineral.__init__(self)
+
+
+class atg(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "atg",
+            "formula": {"H": 62.0, "Mg": 48.0, "O": 147.0, "Si": 34.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -71400990.0,
+            "S_0": 3620.0,
+            "V_0": 0.0017548,
+            "Cp": [9621.0, -0.091183, -35941600.0, -83034.2],
+            "a_0": 2.8e-05,
+            "K_0": 63100e6,
+            "Kprime_0": 5.92,
+            "Kdprime_0": -9.4e-11,
+            "n": 291.0,
+            "molar_mass": 4.53595108,
+        }
+        Mineral.__init__(self)
+
+
+class ab(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ab",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3935290.0,
+            "S_0": 207.4,
+            "V_0": 0.00010067,
+            "Cp": [452.0, -0.013364, -1275900.0, -3953.6],
+            "a_0": 2.36e-05,
+            "K_0": 54100e6,
+            "Kprime_0": 5.91,
+            "Kdprime_0": -1.09e-10,
+            "n": 13.0,
+            "molar_mass": 0.262223,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 14000.0,
+                    "deltaV": 4.2e-07,
+                    "Wh": 13000.0,
+                    "Wv": 4.2e-07,
+                    "n": 3.0,
+                    "factor": 0.9,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class abh(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "abh",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3921290.0,
+            "S_0": 224.3,
+            "V_0": 0.00010105,
+            "Cp": [452.0, -0.013364, -1275900.0, -3953.6],
+            "a_0": 2.41e-05,
+            "K_0": 54100e6,
+            "Kprime_0": 5.91,
+            "Kdprime_0": -1.09e-10,
+            "n": 13.0,
+            "molar_mass": 0.262223,
+        }
+        Mineral.__init__(self)
+
+
+class mic(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mic",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3975410.0,
+            "S_0": 214.3,
+            "V_0": 0.00010871,
+            "Cp": [448.8, -0.010075, -1007300.0, -3973.1],
+            "a_0": 1.66e-05,
+            "K_0": 58300e6,
+            "Kprime_0": 4.02,
+            "Kdprime_0": -6.9e-11,
+            "n": 13.0,
+            "molar_mass": 0.2783315,
+        }
+        Mineral.__init__(self)
+
+
+class san(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "san",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3966760.0,
+            "S_0": 214.3,
+            "V_0": 0.00010871,
+            "Cp": [448.8, -0.010075, -1007300.0, -3973.1],
+            "a_0": 1.66e-05,
+            "K_0": 58300e6,
+            "Kprime_0": 4.02,
+            "Kdprime_0": -6.9e-11,
+            "n": 13.0,
+            "molar_mass": 0.2783315,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 8650.0,
+                    "deltaV": 2.4e-07,
+                    "Wh": 8500.0,
+                    "Wv": 2.4e-07,
+                    "n": 3.0,
+                    "factor": 0.8,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class an(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "an",
+            "formula": {"Al": 2.0, "Ca": 1.0, "O": 8.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4232600.0,
+            "S_0": 200.5,
+            "V_0": 0.00010079,
+            "Cp": [370.5, 0.01001, -4339100.0, -1960.6],
+            "a_0": 1.41e-05,
+            "K_0": 86000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.8e-11,
+            "n": 13.0,
+            "molar_mass": 0.2782072,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 42010.0,
+                    "deltaV": 1e-06,
+                    "Wh": 42000.0,
+                    "Wv": 1e-06,
+                    "n": 1.0,
+                    "factor": 2.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class kcm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "kcm",
+            "formula": {"Al": 1.0, "H": 2.0, "K": 1.0, "O": 9.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4232700.0,
+            "S_0": 281.5,
+            "V_0": 0.00011438,
+            "Cp": [536.5, -0.01009, -980400.0, -4735.0],
+            "a_0": 3.21e-05,
+            "K_0": 42500e6,
+            "Kprime_0": 2.0,
+            "Kdprime_0": -4.7e-11,
+            "n": 16.0,
+            "molar_mass": 0.29634678,
+        }
+        Mineral.__init__(self)
+
+
+class wa(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "wa",
+            "formula": {"K": 2.0, "O": 9.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4272090.0,
+            "S_0": 254.0,
+            "V_0": 0.00010844,
+            "Cp": [499.1, 0.0, 0.0, -4350.1],
+            "a_0": 2.66e-05,
+            "K_0": 90000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -4.4e-11,
+            "n": 15.0,
+            "molar_mass": 0.3345332,
+        }
+        Mineral.__init__(self)
+
+
+class hol(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hol",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3792020.0,
+            "S_0": 166.2,
+            "V_0": 7.128e-05,
+            "Cp": [417.6, -0.003617, -4748100.0, -2819.9],
+            "a_0": 2.8e-05,
+            "K_0": 180000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 13.0,
+            "molar_mass": 0.2783315,
+        }
+        Mineral.__init__(self)
+
+
+class q(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "q",
+            "formula": {"O": 2.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -910710.0,
+            "S_0": 41.43,
+            "V_0": 2.269e-05,
+            "Cp": [92.9, -0.000642, -714900.0, -716.1],
+            "a_0": 0.0,
+            "K_0": 73000e6,
+            "Kprime_0": 6.0,
+            "Kdprime_0": -8.2e-11,
+            "n": 3.0,
+            "molar_mass": 0.0600843,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 847.0,
+                    "S_D": 4.95,
+                    "V_D": 1.188e-06,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class trd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "trd",
+            "formula": {"O": 2.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -907100.0,
+            "S_0": 44.1,
+            "V_0": 2.8e-05,
+            "Cp": [74.9, 0.0031, -1174000.0, -236.7],
+            "a_0": 0.0,
+            "K_0": 15000e6,
+            "Kprime_0": 4.36,
+            "Kdprime_0": -2.91e-10,
+            "n": 3.0,
+            "molar_mass": 0.0600843,
+        }
+        Mineral.__init__(self)
+
+
+class crst(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "crst",
+            "formula": {"O": 2.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -904260.0,
+            "S_0": 50.86,
+            "V_0": 2.745e-05,
+            "Cp": [72.7, 0.001304, -4129000.0, 0.0],
+            "a_0": 0.0,
+            "K_0": 16000e6,
+            "Kprime_0": 4.35,
+            "Kdprime_0": -2.72e-10,
+            "n": 3.0,
+            "molar_mass": 0.0600843,
+        }
+        Mineral.__init__(self)
+
+
+class coe(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "coe",
+            "formula": {"O": 2.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -906990.0,
+            "S_0": 39.6,
+            "V_0": 2.064e-05,
+            "Cp": [107.8, -0.003279, -190300.0, -1041.6],
+            "a_0": 1.23e-05,
+            "K_0": 97900e6,
+            "Kprime_0": 4.19,
+            "Kdprime_0": -4.3e-11,
+            "n": 3.0,
+            "molar_mass": 0.0600843,
+        }
+        Mineral.__init__(self)
+
+
+class stv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "stv",
+            "formula": {"O": 2.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -876720.0,
+            "S_0": 24.0,
+            "V_0": 1.401e-05,
+            "Cp": [68.1, 0.00601, -1978200.0, -82.1],
+            "a_0": 1.58e-05,
+            "K_0": 309000e6,
+            "Kprime_0": 4.6,
+            "Kdprime_0": -1.5e-11,
+            "n": 3.0,
+            "molar_mass": 0.0600843,
+        }
+        Mineral.__init__(self)
+
+
+class ne(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ne",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2094860.0000000002,
+            "S_0": 124.4,
+            "V_0": 5.419e-05,
+            "Cp": [272.7, -0.012398, 0.0, -2763.1],
+            "a_0": 4.63e-05,
+            "K_0": 46500e6,
+            "Kprime_0": 4.16,
+            "Kdprime_0": -8.9e-11,
+            "n": 7.0,
+            "molar_mass": 0.1420544,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 467.0,
+                    "S_D": 10.0,
+                    "V_D": 8e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class cg(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cg",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2092030.0000000002,
+            "S_0": 118.7,
+            "V_0": 5.603e-05,
+            "Cp": [116.1, 0.086021, -1992700.0, 0.0],
+            "a_0": 4.5e-05,
+            "K_0": 46500e6,
+            "Kprime_0": 4.16,
+            "Kdprime_0": -8.9e-11,
+            "n": 7.0,
+            "molar_mass": 0.1420544,
+        }
+        Mineral.__init__(self)
+
+
+class cgh(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cgh",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2078310.0,
+            "S_0": 135.0,
+            "V_0": 5.67e-05,
+            "Cp": [229.2, 0.011876, 0.0, -1970.7],
+            "a_0": 4.67e-05,
+            "K_0": 46500e6,
+            "Kprime_0": 4.16,
+            "Kdprime_0": -8.9e-11,
+            "n": 7.0,
+            "molar_mass": 0.1420544,
+        }
+        Mineral.__init__(self)
+
+
+class macf(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "macf",
+            "formula": {"Al": 2.0, "Mg": 1.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2246370.0,
+            "S_0": 80.0,
+            "V_0": 3.614e-05,
+            "Cp": [200.0, 0.006252, -2996400.0, -888.4],
+            "a_0": 1.93e-05,
+            "K_0": 212000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -1.7e-11,
+            "n": 7.0,
+            "molar_mass": 0.1422656,
+        }
+        Mineral.__init__(self)
+
+
+class mscf(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mscf",
+            "formula": {"Mg": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2061420.0,
+            "S_0": 87.5,
+            "V_0": 3.649e-05,
+            "Cp": [213.3, 0.00269, -1410400.0, -1495.9],
+            "a_0": 2.01e-05,
+            "K_0": 185000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -1.7e-11,
+            "n": 7.0,
+            "molar_mass": 0.1406931,
+        }
+        Mineral.__init__(self)
+
+
+class fscf(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fscf",
+            "formula": {"Fe": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1402500.0,
+            "S_0": 143.4,
+            "V_0": 3.914e-05,
+            "Cp": [181.1, 0.018526, -2767200.0, -527.1],
+            "a_0": 2.01e-05,
+            "K_0": 185000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -1.7e-11,
+            "n": 7.0,
+            "molar_mass": 0.2037731,
+        }
+        Mineral.__init__(self)
+
+
+class nacf(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "nacf",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1965650.0,
+            "S_0": 110.0,
+            "V_0": 3.631e-05,
+            "Cp": [272.7, -0.012398, 0.0, -2763.1],
+            "a_0": 2.1e-05,
+            "K_0": 185000e6,
+            "Kprime_0": 4.6,
+            "Kdprime_0": -2.5e-11,
+            "n": 7.0,
+            "molar_mass": 0.1420544,
+        }
+        Mineral.__init__(self)
+
+
+class cacf(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cacf",
+            "formula": {"Al": 2.0, "Ca": 1.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2325600.0,
+            "S_0": 87.6,
+            "V_0": 3.976e-05,
+            "Cp": [191.9, 0.009563, -3211300.0, -640.2],
+            "a_0": 1.93e-05,
+            "K_0": 190000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.1e-11,
+            "n": 7.0,
+            "molar_mass": 0.1580386,
+        }
+        Mineral.__init__(self)
+
+
+class manal(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "manal",
+            "formula": {"Al": 6.0, "Mg": 3.0, "O": 12.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6796630.0,
+            "S_0": 250.0,
+            "V_0": 0.00011166,
+            "Cp": [600.0, 0.018756, -8989200.0, -2665.2],
+            "a_0": 1.93e-05,
+            "K_0": 184000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 21.0,
+            "molar_mass": 0.4267968,
+        }
+        Mineral.__init__(self)
+
+
+class nanal(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "nanal",
+            "formula": {"Al": 5.0, "Mg": 2.0, "Na": 1.0, "O": 12.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6610270.0,
+            "S_0": 280.0,
+            "V_0": 0.00011322,
+            "Cp": [672.7, 0.000106, -5992800.0, -4539.9],
+            "a_0": 2.01e-05,
+            "K_0": 184000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 21.0,
+            "molar_mass": 0.4265856,
+        }
+        Mineral.__init__(self)
+
+
+class msnal(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "msnal",
+            "formula": {"Mg": 6.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6172380.0,
+            "S_0": 272.5,
+            "V_0": 0.00011061,
+            "Cp": [639.9, 0.00807, -4231200.0, -4487.7],
+            "a_0": 2.1e-05,
+            "K_0": 185000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 21.0,
+            "molar_mass": 0.4220793,
+        }
+        Mineral.__init__(self)
+
+
+class fsnal(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fsnal",
+            "formula": {"Fe": 6.0, "O": 12.0, "Si": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -4146000.0,
+            "S_0": 440.2,
+            "V_0": 0.00011856,
+            "Cp": [543.3, 0.055578, -8301600.0, -1581.3],
+            "a_0": 2.1e-05,
+            "K_0": 185000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 21.0,
+            "molar_mass": 0.6113193,
+        }
+        Mineral.__init__(self)
+
+
+class canal(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "canal",
+            "formula": {"Al": 6.0, "Ca": 1.0, "Mg": 2.0, "O": 12.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6840000.0,
+            "S_0": 257.6,
+            "V_0": 0.00011159,
+            "Cp": [591.9, 0.022067, -9204100.0, -2417.0],
+            "a_0": 1.93e-05,
+            "K_0": 177000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.2e-11,
+            "n": 21.0,
+            "molar_mass": 0.4425698,
+        }
+        Mineral.__init__(self)
+
+
+class sdl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "sdl",
+            "formula": {"Al": 6.0, "Cl": 2.0, "Na": 8.0, "O": 24.0, "Si": 6.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -13407370.0,
+            "S_0": 910.0,
+            "V_0": 0.0004213,
+            "Cp": [1532.7, 0.047747, -2972800.0, -12427.0],
+            "a_0": 4.63e-05,
+            "K_0": 46500e6,
+            "Kprime_0": 4.16,
+            "Kdprime_0": -8.9e-11,
+            "n": 46.0,
+            "molar_mass": 0.969212,
+        }
+        Mineral.__init__(self)
+
+
+class kls(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "kls",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2123210.0,
+            "S_0": 136.0,
+            "V_0": 6.052e-05,
+            "Cp": [242.0, -0.004482, -895800.0, -1935.8],
+            "a_0": 3.16e-05,
+            "K_0": 51400e6,
+            "Kprime_0": 2.0,
+            "Kdprime_0": -3.9e-11,
+            "n": 7.0,
+            "molar_mass": 0.1581629,
+        }
+        Mineral.__init__(self)
+
+
+class lc(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "lc",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3029430.0,
+            "S_0": 198.5,
+            "V_0": 8.826e-05,
+            "Cp": [369.8, -0.016332, 684700.0, -3683.1],
+            "a_0": 1.85e-05,
+            "K_0": 45000e6,
+            "Kprime_0": 5.7,
+            "Kdprime_0": -1.27e-10,
+            "n": 10.0,
+            "molar_mass": 0.2182472,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 11610.0,
+                    "deltaV": 4e-06,
+                    "Wh": 11600.0,
+                    "Wv": 4e-06,
+                    "n": 2.0,
+                    "factor": 0.7,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class me(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "me",
+            "formula": {"Al": 6.0, "C": 1.0, "Ca": 4.0, "O": 27.0, "Si": 6.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -13841600.0,
+            "S_0": 752.0,
+            "V_0": 0.00033985,
+            "Cp": [1359.0, 0.036442, -8594700.0, -9598.2],
+            "a_0": 1.81e-05,
+            "K_0": 87000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.7e-11,
+            "n": 44.0,
+            "molar_mass": 0.9347085,
+        }
+        Mineral.__init__(self)
+
+
+class wrk(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "wrk",
+            "formula": {"Al": 2.0, "Ca": 1.0, "H": 4.0, "O": 14.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -6662350.0,
+            "S_0": 380.0,
+            "V_0": 0.0001904,
+            "Cp": [838.3, -0.02146, -2272000.0, -7292.3],
+            "a_0": 1.49e-05,
+            "K_0": 86000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.8e-11,
+            "n": 25.0,
+            "molar_mass": 0.43440636,
+        }
+        Mineral.__init__(self)
+
+
+class lmt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "lmt",
+            "formula": {"Al": 2.0, "Ca": 1.0, "H": 8.0, "O": 16.0, "Si": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -7262590.0,
+            "S_0": 465.0,
+            "V_0": 0.0002037,
+            "Cp": [1013.4, -0.021413, -2235800.0, -8806.7],
+            "a_0": 1.37e-05,
+            "K_0": 86000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.8e-11,
+            "n": 31.0,
+            "molar_mass": 0.47043692,
+        }
+        Mineral.__init__(self)
+
+
+class heu(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "heu",
+            "formula": {"Al": 2.0, "Ca": 1.0, "H": 12.0, "O": 24.0, "Si": 7.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -10545090.0,
+            "S_0": 783.0,
+            "V_0": 0.000317,
+            "Cp": [1504.8, -0.033224, -2959300.0, -13297.2],
+            "a_0": 1.57e-05,
+            "K_0": 27400e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -1.46e-10,
+            "n": 46.0,
+            "molar_mass": 0.68672038,
+        }
+        Mineral.__init__(self)
+
+
+class stlb(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "stlb",
+            "formula": {"Al": 2.0, "Ca": 1.0, "H": 14.0, "O": 25.0, "Si": 7.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -10896630.0,
+            "S_0": 710.0,
+            "V_0": 0.0003287,
+            "Cp": [1588.4, -0.032043, -3071600.0, -13966.9],
+            "a_0": 1.51e-05,
+            "K_0": 86000e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -4.8e-11,
+            "n": 49.0,
+            "molar_mass": 0.70473566,
+        }
+        Mineral.__init__(self)
+
+
+class anl(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "anl",
+            "formula": {"Al": 1.0, "H": 2.0, "Na": 1.0, "O": 7.0, "Si": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -3307050.0,
+            "S_0": 232.0,
+            "V_0": 9.74e-05,
+            "Cp": [643.5, -0.016067, 9302300.0, -9179.6],
+            "a_0": 2.76e-05,
+            "K_0": 40000e6,
+            "Kprime_0": 4.18,
+            "Kdprime_0": -1.04e-10,
+            "n": 13.0,
+            "molar_mass": 0.22015398,
+        }
+        Mineral.__init__(self)
+
+
+class lime(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "lime",
+            "formula": {"Ca": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -634580.0,
+            "S_0": 38.1,
+            "V_0": 1.676e-05,
+            "Cp": [52.4, 0.003673, -750700.0, -51.0],
+            "a_0": 3.41e-05,
+            "K_0": 113000e6,
+            "Kprime_0": 3.87,
+            "Kdprime_0": -3.4e-11,
+            "n": 2.0,
+            "molar_mass": 0.0560774,
+        }
+        Mineral.__init__(self)
+
+
+class ru(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ru",
+            "formula": {"O": 2.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -944160.0,
+            "S_0": 50.5,
+            "V_0": 1.882e-05,
+            "Cp": [90.4, 0.0029, 0.0, -623.8],
+            "a_0": 2.24e-05,
+            "K_0": 222000e6,
+            "Kprime_0": 4.24,
+            "Kdprime_0": -1.9e-11,
+            "n": 3.0,
+            "molar_mass": 0.0798658,
+        }
+        Mineral.__init__(self)
+
+
+class per(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "per",
+            "formula": {"Mg": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -601600.0,
+            "S_0": 26.5,
+            "V_0": 1.125e-05,
+            "Cp": [60.5, 0.000362, -535800.0, -299.2],
+            "a_0": 3.11e-05,
+            "K_0": 161600e6,
+            "Kprime_0": 3.95,
+            "Kdprime_0": -2.4e-11,
+            "n": 2.0,
+            "molar_mass": 0.0403044,
+        }
+        Mineral.__init__(self)
+
+
+class fper(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "fper",
+            "formula": {"Fe": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -262160.0,
+            "S_0": 58.6,
+            "V_0": 1.206e-05,
+            "Cp": [44.4, 0.00828, -1214200.0, 185.2],
+            "a_0": 3.22e-05,
+            "K_0": 152000e6,
+            "Kprime_0": 4.9,
+            "Kdprime_0": -3.2e-11,
+            "n": 2.0,
+            "molar_mass": 0.0718444,
+        }
+        Mineral.__init__(self)
+
+
+class wu(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "wu",
+            "formula": {"Fe": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -262430.0,
+            "S_0": 63.0,
+            "V_0": 1.206e-05,
+            "Cp": [67.4, 0.003758, 315700.0, -381.7],
+            "a_0": 3.22e-05,
+            "K_0": 152000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -3.2e-11,
+            "n": 2.0,
+            "molar_mass": 0.0718444,
+        }
+        Mineral.__init__(self)
+
+
+class mang(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mang",
+            "formula": {"Mn": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -385570.0,
+            "S_0": 59.7,
+            "V_0": 1.322e-05,
+            "Cp": [59.8, 0.0036, -31400.0, -282.6],
+            "a_0": 3.69e-05,
+            "K_0": 164500e6,
+            "Kprime_0": 4.46,
+            "Kdprime_0": -2.7e-11,
+            "n": 2.0,
+            "molar_mass": 0.0709374,
+        }
+        Mineral.__init__(self)
+
+
+class cor(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cor",
+            "formula": {"Al": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1675220.0,
+            "S_0": 50.9,
+            "V_0": 2.558e-05,
+            "Cp": [139.5, 0.00589, -2460600.0, -589.2],
+            "a_0": 1.8e-05,
+            "K_0": 254000e6,
+            "Kprime_0": 4.34,
+            "Kdprime_0": -1.7e-11,
+            "n": 5.0,
+            "molar_mass": 0.1019612,
+        }
+        Mineral.__init__(self)
+
+
+class mcor(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mcor",
+            "formula": {"Mg": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1468360.0,
+            "S_0": 59.3,
+            "V_0": 2.635e-05,
+            "Cp": [147.8, 0.002015, -2395000.0, -801.8],
+            "a_0": 2.12e-05,
+            "K_0": 211000e6,
+            "Kprime_0": 4.55,
+            "Kdprime_0": -2.2e-11,
+            "n": 5.0,
+            "molar_mass": 0.1003887,
+        }
+        Mineral.__init__(self)
+
+
+class hem(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hem",
+            "formula": {"Fe": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -825420.0,
+            "S_0": 87.4,
+            "V_0": 3.027e-05,
+            "Cp": [163.9, 0.0, -2257200.0, -657.6],
+            "a_0": 2.79e-05,
+            "K_0": 223000e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.8e-11,
+            "n": 5.0,
+            "molar_mass": 0.1596882,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 955.0,
+                    "S_D": 15.6,
+                    "V_D": 0.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class esk(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "esk",
+            "formula": {"Cr": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1128170.0,
+            "S_0": 83.0,
+            "V_0": 2.898e-05,
+            "Cp": [119.0, 0.009496, -1442000.0, -3.4],
+            "a_0": 1.59e-05,
+            "K_0": 245000e6,
+            "Kprime_0": 3.6,
+            "Kdprime_0": -1.5e-11,
+            "n": 5.0,
+            "molar_mass": 0.1519904,
+        }
+        Mineral.__init__(self)
+
+
+class bix(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "bix",
+            "formula": {"Mn": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -959000.0,
+            "S_0": 113.7,
+            "V_0": 3.137e-05,
+            "Cp": [145.1, 0.023534, 721600.0, -1008.4],
+            "a_0": 2.91e-05,
+            "K_0": 223000e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.8e-11,
+            "n": 5.0,
+            "molar_mass": 0.1578742,
+        }
+        Mineral.__init__(self)
+
+
+class NiO(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "NiO",
+            "formula": {"Ni": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -239470.0,
+            "S_0": 38.0,
+            "V_0": 1.097e-05,
+            "Cp": [47.7, 0.007824, -392500.0, 0.0],
+            "a_0": 3.3e-05,
+            "K_0": 200000e6,
+            "Kprime_0": 3.94,
+            "Kdprime_0": -2e-11,
+            "n": 2.0,
+            "molar_mass": 0.0746928,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {"P_0": 100000.0, "T_0": 298.15, "Tc_0": 520.0, "S_D": 5.7, "V_D": 0.0},
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class pnt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pnt",
+            "formula": {"Mn": 1.0, "O": 3.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1361500.0,
+            "S_0": 105.5,
+            "V_0": 3.288e-05,
+            "Cp": [143.5, 0.003373, -1940700.0, -407.6],
+            "a_0": 2.4e-05,
+            "K_0": 170000e6,
+            "Kprime_0": 8.3,
+            "Kdprime_0": -4.9e-11,
+            "n": 5.0,
+            "molar_mass": 0.1508032,
+        }
+        Mineral.__init__(self)
+
+
+class geik(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "geik",
+            "formula": {"Mg": 1.0, "O": 3.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1568390.0,
+            "S_0": 73.6,
+            "V_0": 3.086e-05,
+            "Cp": [115.5, 0.014938, -2637700.0, 45.5],
+            "a_0": 2.15e-05,
+            "K_0": 170000e6,
+            "Kprime_0": 8.3,
+            "Kdprime_0": -4.9e-11,
+            "n": 5.0,
+            "molar_mass": 0.1201702,
+        }
+        Mineral.__init__(self)
+
+
+class ilm(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ilm",
+            "formula": {"Fe": 1.0, "O": 3.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1232320.0,
+            "S_0": 107.5,
+            "V_0": 3.169e-05,
+            "Cp": [138.9, 0.005081, -1288800.0, -463.7],
+            "a_0": 2.4e-05,
+            "K_0": 170000e6,
+            "Kprime_0": 8.3,
+            "Kdprime_0": -4.9e-11,
+            "n": 5.0,
+            "molar_mass": 0.1517102,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 1900.0,
+                    "S_D": 12.0,
+                    "V_D": 2e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class bdy(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "bdy",
+            "formula": {"O": 2.0, "Zr": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1100320.0,
+            "S_0": 50.4,
+            "V_0": 2.115e-05,
+            "Cp": [89.6, 0.000354, -853100.0, -413.7],
+            "a_0": 2e-05,
+            "K_0": 95300e6,
+            "Kprime_0": 3.88,
+            "Kdprime_0": -4.1e-11,
+            "n": 3.0,
+            "molar_mass": 0.1232228,
+        }
+        Mineral.__init__(self)
+
+
+class bdyT(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "bdyT",
+            "formula": {"O": 2.0, "Zr": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1096010.0,
+            "S_0": 53.4,
+            "V_0": 2.115e-05,
+            "Cp": [89.6, 0.000354, -853100.0, -413.7],
+            "a_0": 2e-05,
+            "K_0": 95300e6,
+            "Kprime_0": 3.88,
+            "Kdprime_0": -4.1e-11,
+            "n": 3.0,
+            "molar_mass": 0.1232228,
+        }
+        Mineral.__init__(self)
+
+
+class bdyC(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "bdyC",
+            "formula": {"O": 2.0, "Zr": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1085960.0,
+            "S_0": 57.2,
+            "V_0": 2.495e-05,
+            "Cp": [89.6, 0.000354, -853100.0, -413.7],
+            "a_0": 2e-05,
+            "K_0": 95300e6,
+            "Kprime_0": 3.88,
+            "Kdprime_0": -4.1e-11,
+            "n": 3.0,
+            "molar_mass": 0.1232228,
+        }
+        Mineral.__init__(self)
+
+
+class ten(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ten",
+            "formula": {"Cu": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -156100.0,
+            "S_0": 42.6,
+            "V_0": 1.222e-05,
+            "Cp": [31.0, 0.01374, -1258000.0, 369.3],
+            "a_0": 3.57e-05,
+            "K_0": 200000e6,
+            "Kprime_0": 3.94,
+            "Kdprime_0": -2e-11,
+            "n": 2.0,
+            "molar_mass": 0.0795454,
+        }
+        Mineral.__init__(self)
+
+
+class cup(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cup",
+            "formula": {"Cu": 2.0, "O": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -170600.0,
+            "S_0": 92.4,
+            "V_0": 2.344e-05,
+            "Cp": [110.3, 0.0, 0.0, -674.8],
+            "a_0": 3.33e-05,
+            "K_0": 131000e6,
+            "Kprime_0": 5.7,
+            "Kdprime_0": -4.3e-11,
+            "n": 3.0,
+            "molar_mass": 0.1430914,
+        }
+        Mineral.__init__(self)
+
+
+class sp(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "sp",
+            "formula": {"Al": 2.0, "Mg": 1.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2300180.0,
+            "S_0": 80.63,
+            "V_0": 3.978e-05,
+            "Cp": [200.5, 0.006252, -2996400.0, -888.4],
+            "a_0": 1.93e-05,
+            "K_0": 192200e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -2.1e-11,
+            "n": 7.0,
+            "molar_mass": 0.1422656,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 13930.0,
+                    "deltaV": 0.0,
+                    "Wh": -3600.0,
+                    "Wv": 0.0,
+                    "n": 2.0,
+                    "factor": -0.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class herc(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "herc",
+            "formula": {"Al": 2.0, "Fe": 1.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1949470.0,
+            "S_0": 113.9,
+            "V_0": 4.075e-05,
+            "Cp": [184.9, 0.01417, -3674800.0, -404.0],
+            "a_0": 2.06e-05,
+            "K_0": 192200e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -2.1e-11,
+            "n": 7.0,
+            "molar_mass": 0.1738056,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 13930.0,
+                    "deltaV": 0.0,
+                    "Wh": -3600.0,
+                    "Wv": 0.0,
+                    "n": 2.0,
+                    "factor": -0.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class mt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mt",
+            "formula": {"Fe": 3.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1114200.0,
+            "S_0": 146.9,
+            "V_0": 4.452e-05,
+            "Cp": [262.5, -0.007205, -1926200.0, -1655.7],
+            "a_0": 3.71e-05,
+            "K_0": 185700e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.2e-11,
+            "n": 7.0,
+            "molar_mass": 0.2315326,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 848.0,
+                    "S_D": 35.0,
+                    "V_D": 0.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class mft(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mft",
+            "formula": {"Fe": 2.0, "Mg": 1.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1442210.0,
+            "S_0": 121.0,
+            "V_0": 4.457e-05,
+            "Cp": [270.5, -0.007505, -999200.0, -2022.4],
+            "a_0": 3.63e-05,
+            "K_0": 185700e6,
+            "Kprime_0": 4.05,
+            "Kdprime_0": -2.2e-11,
+            "n": 7.0,
+            "molar_mass": 0.1999926,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 665.0,
+                    "S_D": 17.0,
+                    "V_D": 0.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class qnd(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "qnd",
+            "formula": {"Mg": 2.0, "O": 4.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2157150.0,
+            "S_0": 111.0,
+            "V_0": 4.529e-05,
+            "Cp": [161.7, 0.03286, -2382200.0, -278.6],
+            "a_0": 2.63e-05,
+            "K_0": 147000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.72e-11,
+            "n": 7.0,
+            "molar_mass": 0.1604746,
+        }
+        Mineral.__init__(self)
+
+
+class usp(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "usp",
+            "formula": {"Fe": 2.0, "O": 4.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1494180.0,
+            "S_0": 171.0,
+            "V_0": 4.682e-05,
+            "Cp": [129.5, 0.048696, -3739000.0, 690.2],
+            "a_0": 3.86e-05,
+            "K_0": 147000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -2.72e-11,
+            "n": 7.0,
+            "molar_mass": 0.2235546,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 1000.0,
+                    "deltaV": 0.0,
+                    "Wh": 900.0,
+                    "Wv": 0.0,
+                    "n": 1.0,
+                    "factor": 0.5,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class picr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "picr",
+            "formula": {"Cr": 2.0, "Mg": 1.0, "O": 4.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1764240.0,
+            "S_0": 118.3,
+            "V_0": 4.356e-05,
+            "Cp": [196.1, 0.005398, -3126000.0, -616.9],
+            "a_0": 2.6e-05,
+            "K_0": 192200e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -2.1e-11,
+            "n": 7.0,
+            "molar_mass": 0.1922948,
+        }
+        Mineral.__init__(self)
+
+
+class br(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "br",
+            "formula": {"H": 2.0, "Mg": 1.0, "O": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -925620.0,
+            "S_0": 63.2,
+            "V_0": 2.463e-05,
+            "Cp": [158.4, -0.004076, -1052300.0, -1171.3],
+            "a_0": 6.2e-05,
+            "K_0": 41500e6,
+            "Kprime_0": 6.45,
+            "Kdprime_0": -1.55e-10,
+            "n": 5.0,
+            "molar_mass": 0.05831968,
+        }
+        Mineral.__init__(self)
+
+
+class dsp(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "dsp",
+            "formula": {"Al": 1.0, "H": 1.0, "O": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -999810.0,
+            "S_0": 34.5,
+            "V_0": 1.786e-05,
+            "Cp": [145.1, 0.008709, 584400.0, -1741.1],
+            "a_0": 3.57e-05,
+            "K_0": 228000e6,
+            "Kprime_0": 4.04,
+            "Kdprime_0": -1.8e-11,
+            "n": 4.0,
+            "molar_mass": 0.05998824,
+        }
+        Mineral.__init__(self)
+
+
+class gth(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "gth",
+            "formula": {"Fe": 1.0, "H": 1.0, "O": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -561670.0,
+            "S_0": 60.3,
+            "V_0": 2.082e-05,
+            "Cp": [139.3, 0.000147, -212700.0, -1077.8],
+            "a_0": 4.35e-05,
+            "K_0": 250000e6,
+            "Kprime_0": 4.03,
+            "Kdprime_0": -1.6e-11,
+            "n": 4.0,
+            "molar_mass": 0.08885174,
+        }
+        Mineral.__init__(self)
+
+
+class cc(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "cc",
+            "formula": {"C": 1.0, "Ca": 1.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1207790.0,
+            "S_0": 92.5,
+            "V_0": 3.689e-05,
+            "Cp": [140.9, 0.005029, -950700.0, -858.4],
+            "a_0": 2.52e-05,
+            "K_0": 73300e6,
+            "Kprime_0": 4.06,
+            "Kdprime_0": -5.5e-11,
+            "n": 5.0,
+            "molar_mass": 0.1000869,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 1240.0,
+                    "S_D": 10.0,
+                    "V_D": 4e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class arag(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "arag",
+            "formula": {"C": 1.0, "Ca": 1.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1207690.0,
+            "S_0": 89.8,
+            "V_0": 3.415e-05,
+            "Cp": [167.1, 0.010695, 162000.0, -1564.9],
+            "a_0": 6.14e-05,
+            "K_0": 61400e6,
+            "Kprime_0": 5.87,
+            "Kdprime_0": -9.6e-11,
+            "n": 5.0,
+            "molar_mass": 0.1000869,
+        }
+        Mineral.__init__(self)
+
+
+class mag(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "mag",
+            "formula": {"C": 1.0, "Mg": 1.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1110910.0,
+            "S_0": 65.5,
+            "V_0": 2.803e-05,
+            "Cp": [186.4, -0.003772, 0.0, -1886.2],
+            "a_0": 3.38e-05,
+            "K_0": 102800e6,
+            "Kprime_0": 5.41,
+            "Kdprime_0": -5.3e-11,
+            "n": 5.0,
+            "molar_mass": 0.0843139,
+        }
+        Mineral.__init__(self)
+
+
+class sid(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "sid",
+            "formula": {"C": 1.0, "Fe": 1.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -762120.0,
+            "S_0": 93.3,
+            "V_0": 2.943e-05,
+            "Cp": [168.4, 0.0, 0.0, -1483.6],
+            "a_0": 4.39e-05,
+            "K_0": 120000e6,
+            "Kprime_0": 4.07,
+            "Kdprime_0": -3.4e-11,
+            "n": 5.0,
+            "molar_mass": 0.1158539,
+        }
+        Mineral.__init__(self)
+
+
+class rhc(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "rhc",
+            "formula": {"C": 1.0, "Mn": 1.0, "O": 3.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -892280.0,
+            "S_0": 98.0,
+            "V_0": 3.107e-05,
+            "Cp": [169.5, 0.0, 0.0, -1534.3],
+            "a_0": 2.44e-05,
+            "K_0": 95300e6,
+            "Kprime_0": 3.88,
+            "Kdprime_0": -4.1e-11,
+            "n": 5.0,
+            "molar_mass": 0.1149469,
+        }
+        Mineral.__init__(self)
+
+
+class dol(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "dol",
+            "formula": {"C": 2.0, "Ca": 1.0, "Mg": 1.0, "O": 6.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -2326270.0,
+            "S_0": 156.1,
+            "V_0": 6.429e-05,
+            "Cp": [358.9, -0.004905, 0.0, -3456.2],
+            "a_0": 3.28e-05,
+            "K_0": 94300e6,
+            "Kprime_0": 3.74,
+            "Kdprime_0": -4e-11,
+            "n": 10.0,
+            "molar_mass": 0.1844008,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 11910.0,
+                    "deltaV": 1.6e-07,
+                    "Wh": 11900.0,
+                    "Wv": 1.6e-07,
+                    "n": 1.0,
+                    "factor": 1.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class ank(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ank",
+            "formula": {"C": 2.0, "Ca": 1.0, "Fe": 1.0, "O": 6.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1971340.0,
+            "S_0": 188.46,
+            "V_0": 6.606e-05,
+            "Cp": [341.0, -0.001161, 0.0, -3054.8],
+            "a_0": 3.46e-05,
+            "K_0": 91400e6,
+            "Kprime_0": 3.88,
+            "Kdprime_0": -4.3e-11,
+            "n": 10.0,
+            "molar_mass": 0.2159408,
+        }
+        self.property_modifiers = [
+            [
+                "bragg_williams",
+                {
+                    "deltaH": 11910.0,
+                    "deltaV": 1.6e-07,
+                    "Wh": 11900.0,
+                    "Wv": 1.6e-07,
+                    "n": 1.0,
+                    "factor": 1.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class syv(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "syv",
+            "formula": {"Cl": 1.0, "K": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -436500.0,
+            "S_0": 82.6,
+            "V_0": 3.752e-05,
+            "Cp": [46.2, 0.01797, 0.0, 0.0],
+            "a_0": 0.0001109,
+            "K_0": 17000e6,
+            "Kprime_0": 5.0,
+            "Kdprime_0": -2.94e-10,
+            "n": 2.0,
+            "molar_mass": 0.0745513,
+        }
+        Mineral.__init__(self)
+
+
+class hlt(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hlt",
+            "formula": {"Cl": 1.0, "Na": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -411300.0,
+            "S_0": 72.1,
+            "V_0": 2.702e-05,
+            "Cp": [45.2, 0.01797, 0.0, 0.0],
+            "a_0": 0.0001147,
+            "K_0": 23800e6,
+            "Kprime_0": 5.0,
+            "Kdprime_0": -2.1e-10,
+            "n": 2.0,
+            "molar_mass": 0.0584428,
+        }
+        Mineral.__init__(self)
+
+
+class pyr(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "pyr",
+            "formula": {"Fe": 1.0, "S": 2.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -171640.0,
+            "S_0": 52.9,
+            "V_0": 2.394e-05,
+            "Cp": [37.3, 0.026715, -1817000.0, 649.3],
+            "a_0": 3.1e-05,
+            "K_0": 139500e6,
+            "Kprime_0": 4.09,
+            "Kdprime_0": -2.9e-11,
+            "n": 3.0,
+            "molar_mass": 0.119975,
+        }
+        Mineral.__init__(self)
+
+
+class trot(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "trot",
+            "formula": {"Fe": 1.0, "S": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -99030.0,
+            "S_0": 65.5,
+            "V_0": 1.819e-05,
+            "Cp": [50.2, 0.011052, -940000.0, 0.0],
+            "a_0": 5.68e-05,
+            "K_0": 65800e6,
+            "Kprime_0": 4.17,
+            "Kdprime_0": -6.3e-11,
+            "n": 2.0,
+            "molar_mass": 0.08791,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 598.0,
+                    "S_D": 12.0,
+                    "V_D": 4.1e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class tro(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "tro",
+            "formula": {"Fe": 1.0, "S": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -97770.0,
+            "S_0": 70.8,
+            "V_0": 1.819e-05,
+            "Cp": [50.2, 0.011052, -940000.0, 0.0],
+            "a_0": 5.73e-05,
+            "K_0": 65800e6,
+            "Kprime_0": 4.17,
+            "Kdprime_0": -6.3e-11,
+            "n": 2.0,
+            "molar_mass": 0.08791,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 598.0,
+                    "S_D": 12.0,
+                    "V_D": 4.1e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class lot(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "lot",
+            "formula": {"Fe": 1.0, "S": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -102170.0,
+            "S_0": 60.0,
+            "V_0": 1.818e-05,
+            "Cp": [50.2, 0.011052, -940000.0, 0.0],
+            "a_0": 4.93e-05,
+            "K_0": 65800e6,
+            "Kprime_0": 4.17,
+            "Kdprime_0": -6.3e-11,
+            "n": 2.0,
+            "molar_mass": 0.08791,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 420.0,
+                    "S_D": 10.0,
+                    "V_D": 0.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class trov(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "trov",
+            "formula": {"Fe": 0.875, "S": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -96020.0,
+            "S_0": 57.5,
+            "V_0": 1.738e-05,
+            "Cp": [51.1, 0.008307, -669700.0, 0.0],
+            "a_0": 5.94e-05,
+            "K_0": 65800e6,
+            "Kprime_0": 4.17,
+            "Kdprime_0": -6.3e-11,
+            "n": 1.875,
+            "molar_mass": 0.080929375,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 595.0,
+                    "S_D": 10.0,
+                    "V_D": 1.6e-07,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class any(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "any",
+            "formula": {"Ca": 1.0, "O": 4.0, "S": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -1434400.0,
+            "S_0": 106.9,
+            "V_0": 4.594e-05,
+            "Cp": [128.7, 0.048545, -1223000.0, -560.5],
+            "a_0": 4.18e-05,
+            "K_0": 54379999999.99999,
+            "Kprime_0": 4.19,
+            "Kdprime_0": -7.7e-11,
+            "n": 6.0,
+            "molar_mass": 0.1361406,
+        }
+        Mineral.__init__(self)
+
+
+class iron(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "iron",
+            "formula": {"Fe": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -0.0,
+            "S_0": 27.09,
+            "V_0": 7.09e-06,
+            "Cp": [46.2, 0.005159, 723100.0, -556.2],
+            "a_0": 3.56e-05,
+            "K_0": 164000e6,
+            "Kprime_0": 5.16,
+            "Kdprime_0": -3.1e-11,
+            "n": 1.0,
+            "molar_mass": 0.055845,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {
+                    "P_0": 100000.0,
+                    "T_0": 298.15,
+                    "Tc_0": 1042.0,
+                    "S_D": 8.3,
+                    "V_D": 0.0,
+                },
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class Ni(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "Ni",
+            "formula": {"Ni": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": 0.0,
+            "S_0": 29.87,
+            "V_0": 6.59e-06,
+            "Cp": [49.8, 0.0, 585900.0, -533.9],
+            "a_0": 4.28e-05,
+            "K_0": 190500e6,
+            "Kprime_0": 4.25,
+            "Kdprime_0": -2.2e-11,
+            "n": 1.0,
+            "molar_mass": 0.0586934,
+        }
+        self.property_modifiers = [
+            [
+                "landau_hp",
+                {"P_0": 100000.0, "T_0": 298.15, "Tc_0": 631.0, "S_D": 3.0, "V_D": 0.0},
+            ]
+        ]
+        Mineral.__init__(self)
+
+
+class Cu(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "Cu",
+            "formula": {"Cu": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": -0.0,
+            "S_0": 33.14,
+            "V_0": 7.11e-06,
+            "Cp": [12.4, 0.00922, -379900.0, 233.5],
+            "a_0": 3.58e-05,
+            "K_0": 162500e6,
+            "Kprime_0": 4.24,
+            "Kdprime_0": -2.6e-11,
+            "n": 1.0,
+            "molar_mass": 0.063546,
+        }
+        Mineral.__init__(self)
+
+
+class gph(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "gph",
+            "formula": {"C": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": 0.0,
+            "S_0": 5.76,
+            "V_0": 5.3e-06,
+            "Cp": [34.3, 0.0, -240700.0, -403.8],
+            "a_0": 1.65e-05,
+            "K_0": 31200e6,
+            "Kprime_0": 3.9,
+            "Kdprime_0": -1.25e-10,
+            "n": 1.0,
+            "molar_mass": 0.0120107,
+        }
+        Mineral.__init__(self)
+
+
+class diam(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "diam",
+            "formula": {"C": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": 1890.0,
+            "S_0": 2.36,
+            "V_0": 3.42e-06,
+            "Cp": [40.0, 0.0, -28500.0, -580.5],
+            "a_0": 4e-06,
+            "K_0": 446500e6,
+            "Kprime_0": 1.61,
+            "Kdprime_0": -3.6e-12,
+            "n": 1.0,
+            "molar_mass": 0.0120107,
+        }
+        Mineral.__init__(self)
+
+
+class S(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "S",
+            "formula": {"S": 1.0},
+            "equation_of_state": "hp_tmt",
+            "H_0": 0.0,
+            "S_0": 32.05,
+            "V_0": 1.551e-05,
+            "Cp": [56.6, -0.004557, 638000.0, -681.8],
+            "a_0": 6.4e-05,
+            "K_0": 14500e6,
+            "Kprime_0": 7.0,
+            "Kdprime_0": -4.8e-10,
+            "n": 1.0,
+            "molar_mass": 0.032065,
+        }
+        Mineral.__init__(self)
+
+
+class syvL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "syvL",
+            "formula": {"Cl": 1.0, "K": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -417410.0,
+            "S_0": 94.5,
+            "V_0": 3.822e-05,
+            "Cp": [66.9, 0.0, 0.0, 0.0],
+            "a_0": 0.000301,
+            "K_0": 5600e6,
+            "Kprime_0": 4.65,
+            "Kdprime_0": -8.3e-10,
+            "dKdT_0": -2e6,
+            "n": 2.0,
+            "molar_mass": 0.0745513,
+        }
+        Mineral.__init__(self)
+
+
+class hltL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hltL",
+            "formula": {"Cl": 1.0, "Na": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -392990.0,
+            "S_0": 80.1,
+            "V_0": 2.938e-05,
+            "Cp": [72.0, -0.003223, 0.0, 0.0],
+            "a_0": 0.000295,
+            "K_0": 6400e6,
+            "Kprime_0": 4.61,
+            "Kdprime_0": -7.2e-10,
+            "dKdT_0": -1500000.0,
+            "n": 2.0,
+            "molar_mass": 0.0584428,
+        }
+        Mineral.__init__(self)
+
+
+class perL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "perL",
+            "formula": {"Mg": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -654190.0,
+            "S_0": -64.3,
+            "V_0": 8.39e-06,
+            "Cp": [99.0, 0.0, 0.0, 0.0],
+            "a_0": 0.000226,
+            "K_0": 36200e6,
+            "Kprime_0": 10.06,
+            "Kdprime_0": -2.78e-10,
+            "dKdT_0": -4100000.0,
+            "n": 2.0,
+            "molar_mass": 0.0403044,
+        }
+        Mineral.__init__(self)
+
+
+class limL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "limL",
+            "formula": {"Ca": 1.0, "O": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -692330.0,
+            "S_0": -47.5,
+            "V_0": 1.303e-05,
+            "Cp": [99.0, 0.0, 0.0, 0.0],
+            "a_0": 0.000175,
+            "K_0": 36200e6,
+            "Kprime_0": 10.06,
+            "Kdprime_0": -2.78e-10,
+            "dKdT_0": -4100000.0,
+            "n": 2.0,
+            "molar_mass": 0.0560774,
+        }
+        Mineral.__init__(self)
+
+
+class corL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "corL",
+            "formula": {"Al": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -1632150.0,
+            "S_0": 14.9,
+            "V_0": 3.369e-05,
+            "Cp": [157.6, 0.0, 0.0, 0.0],
+            "a_0": 7.03e-05,
+            "K_0": 15000e6,
+            "Kprime_0": 6.0,
+            "Kdprime_0": 4e-10,
+            "dKdT_0": -3500000.0000000005,
+            "n": 5.0,
+            "molar_mass": 0.1019612,
+        }
+        Mineral.__init__(self)
+
+
+class eskL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "eskL",
+            "formula": {"Cr": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -1062180.0,
+            "S_0": 63.3,
+            "V_0": 3.709e-05,
+            "Cp": [157.6, 0.0, 0.0, 0.0],
+            "a_0": 7.03e-05,
+            "K_0": 15000e6,
+            "Kprime_0": 6.0,
+            "Kdprime_0": 4e-10,
+            "dKdT_0": -3500000.0000000005,
+            "n": 5.0,
+            "molar_mass": 0.1519904,
+        }
+        Mineral.__init__(self)
+
+
+class hemL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "hemL",
+            "formula": {"Fe": 2.0, "O": 3.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -875130.0,
+            "S_0": -33.2,
+            "V_0": 3.2208e-05,
+            "Cp": [229.0, 0.0, 0.0, 0.0],
+            "a_0": 0.0001953,
+            "K_0": 23000e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -1.74e-10,
+            "dKdT_0": -4600000.0,
+            "n": 5.0,
+            "molar_mass": 0.1596882,
+        }
+        Mineral.__init__(self)
+
+
+class qL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "qL",
+            "formula": {"O": 2.0, "Si": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -921080.0,
+            "S_0": 16.3,
+            "V_0": 2.73e-05,
+            "Cp": [82.5, 0.0, 0.0, 0.0],
+            "a_0": 0.0,
+            "K_0": 22000e6,
+            "Kprime_0": 9.46,
+            "Kdprime_0": -4.3e-10,
+            "dKdT_0": -3500000.0000000005,
+            "n": 3.0,
+            "molar_mass": 0.0600843,
+        }
+        Mineral.__init__(self)
+
+
+class h2oL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "h2oL",
+            "formula": {"H": 2.0, "O": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -281650.0,
+            "S_0": 66.6,
+            "V_0": 1.3355e-05,
+            "Cp": [65.0, 0.0, 0.0, 0.0],
+            "a_0": 0.000626,
+            "K_0": 4228e6,
+            "Kprime_0": 4.0,
+            "Kdprime_0": -9.46e-10,
+            "dKdT_0": -1060000.0,
+            "n": 3.0,
+            "molar_mass": 0.01801528,
+        }
+        Mineral.__init__(self)
+
+
+class foL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "foL",
+            "formula": {"Mg": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -2237250.0,
+            "S_0": -62.0,
+            "V_0": 4.312e-05,
+            "Cp": [269.4, 0.0, 0.0, 0.0],
+            "a_0": 9.2e-05,
+            "K_0": 36200e6,
+            "Kprime_0": 10.06,
+            "Kdprime_0": -2.78e-10,
+            "dKdT_0": -4400000.0,
+            "n": 7.0,
+            "molar_mass": 0.1406931,
+        }
+        Mineral.__init__(self)
+
+
+class faL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "faL",
+            "formula": {"Fe": 2.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -1462820.0,
+            "S_0": 96.0,
+            "V_0": 4.677e-05,
+            "Cp": [243.7, 0.0, 0.0, 0.0],
+            "a_0": 0.0001071,
+            "K_0": 29000e6,
+            "Kprime_0": 10.42,
+            "Kdprime_0": -3.59e-10,
+            "dKdT_0": -5500000.0,
+            "n": 7.0,
+            "molar_mass": 0.2037731,
+        }
+        Mineral.__init__(self)
+
+
+class woL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "woL",
+            "formula": {"Ca": 1.0, "O": 3.0, "Si": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -1642570.0,
+            "S_0": 22.5,
+            "V_0": 3.985e-05,
+            "Cp": [167.4, 0.0, 0.0, 0.0],
+            "a_0": 6.69e-05,
+            "K_0": 32500e6,
+            "Kprime_0": 9.38,
+            "Kdprime_0": -3.08e-10,
+            "dKdT_0": -2e6,
+            "n": 5.0,
+            "molar_mass": 0.1161617,
+        }
+        Mineral.__init__(self)
+
+
+class enL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "enL",
+            "formula": {"Mg": 2.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -3096310.0,
+            "S_0": -4.0,
+            "V_0": 6.984e-05,
+            "Cp": [353.6, 0.0, 0.0, 0.0],
+            "a_0": 6.81e-05,
+            "K_0": 21800e6,
+            "Kprime_0": 7.2,
+            "Kdprime_0": -3.3e-10,
+            "dKdT_0": -2400000.0,
+            "n": 10.0,
+            "molar_mass": 0.2007774,
+        }
+        Mineral.__init__(self)
+
+
+class diL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "diL",
+            "formula": {"Ca": 1.0, "Mg": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -3193790.0,
+            "S_0": 42.1,
+            "V_0": 7.288e-05,
+            "Cp": [334.0, 0.0, 0.0, 0.0],
+            "a_0": 8.51e-05,
+            "K_0": 24900e6,
+            "Kprime_0": 8.04,
+            "Kdprime_0": -3.23e-10,
+            "dKdT_0": -3730000.0,
+            "n": 10.0,
+            "molar_mass": 0.2165504,
+        }
+        Mineral.__init__(self)
+
+
+class silL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "silL",
+            "formula": {"Al": 2.0, "O": 5.0, "Si": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -2593510.0,
+            "S_0": 10.0,
+            "V_0": 6.051e-05,
+            "Cp": [253.0, 0.0, 0.0, 0.0],
+            "a_0": 4.08e-05,
+            "K_0": 22000e6,
+            "Kprime_0": 6.36,
+            "Kdprime_0": -2.89e-10,
+            "dKdT_0": -2900000.0,
+            "n": 8.0,
+            "molar_mass": 0.1620455,
+        }
+        Mineral.__init__(self)
+
+
+class anL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "anL",
+            "formula": {"Al": 2.0, "Ca": 1.0, "O": 8.0, "Si": 2.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -4277920.0,
+            "S_0": 29.0,
+            "V_0": 0.00010014,
+            "Cp": [430.0, 0.0, 0.0, 0.0],
+            "a_0": 5.14e-05,
+            "K_0": 21000e6,
+            "Kprime_0": 6.38,
+            "Kdprime_0": -3.04e-10,
+            "dKdT_0": -5500000.0,
+            "n": 13.0,
+            "molar_mass": 0.2782072,
+        }
+        Mineral.__init__(self)
+
+
+class kspL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "kspL",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -3985340.0,
+            "S_0": 129.2,
+            "V_0": 0.00011431,
+            "Cp": [368.0, 0.0, 0.0, 0.0],
+            "a_0": 4.93e-05,
+            "K_0": 17300e6,
+            "Kprime_0": 6.84,
+            "Kdprime_0": -3.93e-10,
+            "dKdT_0": -899999.9999999999,
+            "n": 13.0,
+            "molar_mass": 0.2783315,
+        }
+        Mineral.__init__(self)
+
+
+class abL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "abL",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 8.0, "Si": 3.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -3925410.0,
+            "S_0": 149.9,
+            "V_0": 0.00010858,
+            "Cp": [358.0, 0.0, 0.0, 0.0],
+            "a_0": 3.37e-05,
+            "K_0": 17600e6,
+            "Kprime_0": 14.35,
+            "Kdprime_0": -8.15e-10,
+            "dKdT_0": -2600000.0,
+            "n": 13.0,
+            "molar_mass": 0.262223,
+        }
+        Mineral.__init__(self)
+
+
+class neL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "neL",
+            "formula": {"Al": 1.0, "Na": 1.0, "O": 4.0, "Si": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -2117040.0,
+            "S_0": 52.9,
+            "V_0": 5.2e-05,
+            "Cp": [216.5, 0.0, 0.0, 0.0],
+            "a_0": 0.000137,
+            "K_0": 25000e6,
+            "Kprime_0": 7.37,
+            "Kdprime_0": -2.95e-10,
+            "dKdT_0": -800000.0,
+            "n": 7.0,
+            "molar_mass": 0.1420544,
+        }
+        Mineral.__init__(self)
+
+
+class lcL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "lcL",
+            "formula": {"Al": 1.0, "K": 1.0, "O": 6.0, "Si": 2.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -3068560.0,
+            "S_0": 102.0,
+            "V_0": 8.59e-05,
+            "Cp": [287.0, 0.0, 0.0, 0.0],
+            "a_0": 6.7e-05,
+            "K_0": 17500e6,
+            "Kprime_0": 7.0,
+            "Kdprime_0": -3.94e-10,
+            "dKdT_0": -0.0,
+            "n": 10.0,
+            "molar_mass": 0.2182472,
+        }
+        Mineral.__init__(self)
+
+
+class ruL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "ruL",
+            "formula": {"O": 2.0, "Ti": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -944300.0,
+            "S_0": 1.0,
+            "V_0": 1.7032e-05,
+            "Cp": [111.8, 0.0, 0.0, 0.0],
+            "a_0": 0.0002901,
+            "K_0": 14900e6,
+            "Kprime_0": 8.0,
+            "Kdprime_0": -3.4e-10,
+            "dKdT_0": -3500000.0000000005,
+            "n": 3.0,
+            "molar_mass": 0.0798658,
+        }
+        Mineral.__init__(self)
+
+
+class bdyL(Mineral):
+    def __init__(self):
+        self.params = {
+            "name": "bdyL",
+            "formula": {"O": 2.0, "Zr": 1.0},
+            "equation_of_state": "hp_tmtL",
+            "H_0": -1031880.0000000001,
+            "S_0": 48.9,
+            "V_0": 1.83e-05,
+            "Cp": [90.0, 0.0, 0.0, 0.0],
+            "a_0": 0.0002,
+            "K_0": 14900e6,
+            "Kprime_0": 8.0,
+            "Kdprime_0": -3.4e-10,
+            "dKdT_0": -3e6,
+            "n": 3.0,
+            "molar_mass": 0.1232228,
+        }
         Mineral.__init__(self)
 
 
 def cov():
     """
     A function which loads and returns the variance-covariance matrix of the
     zero-point energies of all the endmembers in the dataset.
@@ -4223,9 +5659,258 @@
     cov : dictionary
         Dictionary keys are:
         - endmember_names: a list of endmember names, and
         - covariance_matrix: a 2D variance-covariance array for the
           endmember zero-point energies of formation
     """
 
-    from .HP_2011_ds62_cov import cov
+    from .HGP_2018_ds633_cov import cov
+
     return cov
+
+
+"""
+MELT SOLUTIONS
+"""
+
+# q4L      1  3    xv  2   sumT -1    pq  1
+# make  1  qL 4
+# delG(mod)    0.22   0   -0.059
+q4L = CombinedMineral([qL()], [4.0], [0.22e3, 0, -0.059e-5], name="q4L")
+
+# sl1L     1  5    xv  2  sumT -1     psl 1  AlM  1 sumM -1
+# make  1  silL 1
+# delG(mod)   6.20  0  -0.318
+sl1L = CombinedMineral([silL()], [1.0], [6.2e3, 0, -0.318e-5], name="sl1L")
+
+# wo1L     1  5    xv  2  sumT -1     pwo 1  CaM  1  sumM -1
+# make  1  woL 1
+# delG(mod)  -0.45  0   -0.114
+wo1L = CombinedMineral([woL()], [1.0], [-0.45e3, 0, -0.114e-5], name="wo1L")
+
+# fo2L     1  5    xv  2  sumT -1     pol 1  mgM  4  sumM -4
+# make  1  foL 2
+# delG(mod)  8.67  0  -0.131
+fo2L = CombinedMineral([foL()], [2.0], [8.67e3, 0, -0.131e-5], name="fo2L")
+
+# fa2L     1  5    xv  2  sumT -1     pol 1  feM  4  sumM -4
+# make  1  faL 2
+# delG(mod)  13.70  0  -0.055
+fa2L = CombinedMineral([faL()], [2.0], [13.7e3, 0, -0.055e-5], name="fa2L")
+
+# jdL     1  3    xv  2  sumT -1      pjd 1
+# make  2  abL  1  qL -1
+# delG(make)  12.19  0  -0.089
+jdL = CombinedMineral([abL(), qL()], [1.0, -1.0], [12.19e3, 0, -0.089e-5], name="jdL")
+
+# hmL     1  3    xv  2  sumT -1      phm  1
+# make  1 hemL 1/2
+# delG(mod)  3.30  0  -0.032
+hmL = CombinedMineral([hemL()], [0.5], [3.3e3, 0, -0.032e-5], name="hmL")
+
+# ekL     1  3    xv  2  sumT -1      pek  1
+# make  1 eskL 1/2
+# delG(mod)  24.85 .245
+ekL = CombinedMineral([eskL()], [0.5], [24.85e3, 0, 0.245e-5], name="ekL")
+
+# tiL     1  3    xv  2  sumT -1      pti  1
+# make  1  ruL 1
+# delG(mod)  5.58  0    -0.489
+tiL = CombinedMineral([ruL()], [1.0], [5.58e3, 0, -0.489e-5], name="tiL")
+
+# kjL     1  3    xv  2  sumT -1      pkj 1
+# make  2  kspL  1  qL -1
+# delG(make)  11.98  0  -0.210
+kjL = CombinedMineral([kspL(), qL()], [1.0, -1.0], [11.98e3, 0, -0.210e-5], name="kjL")
+
+# ctL     1  3    xv  2  sumT -1      pct 1
+# make  3  woL  1  silL  1  qL -1
+# delG(make)  -108.3  0.055  0.053
+ctL = CombinedMineral(
+    [woL(), silL(), qL()], [1.0, 1.0, -1.0], [-108.3e3, -0.055e3, 0.053e-5], name="ctL"
+)
+
+# h2o1L    1  1    xh 2
+# make   1  h2oL 1
+# delG(mod)    3.20  -0.0039  0.00087
+h2o1L = CombinedMineral([h2oL()], [1.0], [3.2e3, -0.0039e3, 0.00087e-5], name="h2o1L")
+
+W = {}
+W["q4L"] = {}
+W["q4L"]["sl1L"] = [9.5, 0, -0.10]
+W["q4L"]["wo1L"] = [-10.3, 0, 0]
+W["q4L"]["fo2L"] = [-26.5, 0, -3.12]
+W["q4L"]["fa2L"] = [-12.0, 0, -0.55]
+W["q4L"]["jdL"] = [-15.1, 0, -0.13]
+W["q4L"]["hmL"] = [20, 0, 0]
+W["q4L"]["ekL"] = [0, 0, 0]
+W["q4L"]["tiL"] = [24.6, 0, 0]
+W["q4L"]["kjL"] = [-17.8, 0, -0.05]
+W["q4L"]["ctL"] = [-14.6, 0, 0]
+W["q4L"]["h2o1L"] = [17.8, 0, -0.61]
+
+W["sl1L"] = {}
+W["sl1L"]["wo1L"] = [-26.5, 0, 0.85]
+W["sl1L"]["fo2L"] = [2.2, 0, 0]
+W["sl1L"]["fa2L"] = [2.5, 0, 0]
+W["sl1L"]["jdL"] = [16.8, 0, 0]
+W["sl1L"]["hmL"] = [-5, 0, 0]
+W["sl1L"]["ekL"] = [0, 0, 0]
+W["sl1L"]["tiL"] = [15.2, 0, -0.04]
+W["sl1L"]["kjL"] = [7.0, 0, 0]
+W["sl1L"]["ctL"] = [4.0, 0, 0]
+W["sl1L"]["h2o1L"] = [23.7, 0, -0.94]
+
+W["wo1L"] = {}
+W["wo1L"]["fo2L"] = [25.5, 0, 0.11]
+W["wo1L"]["fa2L"] = [14.0, 0, 0]
+W["wo1L"]["jdL"] = [-1.2, 0, 0]
+W["wo1L"]["hmL"] = [0, 0, 0]
+W["wo1L"]["ekL"] = [0, 0, 0]
+W["wo1L"]["tiL"] = [18.0, 0, 0]
+W["wo1L"]["kjL"] = [-1.1, 0, 0]
+W["wo1L"]["ctL"] = [9.5, 0, 0]
+W["wo1L"]["h2o1L"] = [40.3, 0, -0.86]
+
+W["fo2L"] = {}
+W["fo2L"]["fa2L"] = [18.0, 0, 0]
+W["fo2L"]["jdL"] = [1.5, 0, 0]
+W["fo2L"]["hmL"] = [0, 0, 0]
+W["fo2L"]["ekL"] = [0, 0, 0]
+W["fo2L"]["tiL"] = [7.5, 0, 0]
+W["fo2L"]["kjL"] = [3.0, 0, 0]
+W["fo2L"]["ctL"] = [-5.6, 0, 0]
+W["fo2L"]["h2o1L"] = [9.4, 0, -1.58]
+
+W["fa2L"] = {}
+W["fa2L"]["jdL"] = [7.5, 0, -0.05]
+W["fa2L"]["hmL"] = [-30, 0, 0]
+W["fa2L"]["ekL"] = [0, 0, 0]
+W["fa2L"]["tiL"] = [6.7, 0, 0]
+W["fa2L"]["kjL"] = [10.0, 0, 0]
+W["fa2L"]["ctL"] = [-6.5, 0, 0]
+W["fa2L"]["h2o1L"] = [9.2, 0, -1.58]
+
+W["jdL"] = {}
+W["jdL"]["hmL"] = [10, 0, 0]
+W["jdL"]["ekL"] = [0, 0, 0]
+W["jdL"]["tiL"] = [16.5, 0, 0.14]
+W["jdL"]["kjL"] = [-5.9, 0, 0]
+W["jdL"]["ctL"] = [7.6, 0, 0]
+W["jdL"]["h2o1L"] = [-8.3, 0, -0.06]
+
+W["hmL"] = {}
+W["hmL"]["ekL"] = [0, 0, 0]
+W["hmL"]["tiL"] = [0, 0, 0]
+W["hmL"]["kjL"] = [10, 0, 0]
+W["hmL"]["ctL"] = [0, 0, 0]
+W["hmL"]["h2o1L"] = [60.0, 0, -0.66]
+
+W["ekL"] = {}
+W["ekL"]["tiL"] = [0, 0, 0]
+W["ekL"]["kjL"] = [0, 0, 0]
+W["ekL"]["ctL"] = [0, 0, 0]
+W["ekL"]["h2o1L"] = [30.0, 0, -0.66]
+
+W["tiL"] = {}
+W["tiL"]["kjL"] = [9.0, 0, 0]
+W["tiL"]["ctL"] = [0, 0, 0]
+W["tiL"]["h2o1L"] = [30.0, 0, -0.60]
+
+W["kjL"] = {}
+W["kjL"]["ctL"] = [-5.6, 0, 0]
+W["kjL"]["h2o1L"] = [-0.1, 0, 0.22]
+
+W["ctL"] = {}
+W["ctL"]["h2o1L"] = [17.3, 0, 0.05]
+
+a = {
+    "q4L": 100,
+    "sl1L": 120,
+    "wo1L": 140,
+    "fo2L": 240,
+    "fa2L": 100,
+    "jdL": 120,
+    "hmL": 100,
+    "ekL": 100,
+    "tiL": 100,
+    "kjL": 100,
+    "ctL": 100,
+    "h2o1L": 100,
+}
+
+site_formulae = {
+    "q4L": "[]0[Sinet][]0[Vac]2",
+    "sl1L": "[Al][Alsi][]0[Vac]2",
+    "wo1L": "[Ca][Sichain][]0[Vac]2",
+    "fo2L": "[Mg]4[Sitet][]0[Vac]2",
+    "fa2L": "[Fe]4[Sitet][]0[Vac]2",
+    "jdL": "[]0[Alsi2][Na][Vac]2",
+    "hmL": "[]0[Fef][]0[Vac]2",
+    "ekL": "[]0[Cr][]0[Vac]2",
+    "tiL": "[]0[Ti][]0[Vac]2",
+    "kjL": "[]0[Alsi2][K][Vac]2",
+    "ctL": "[]0[Caaltwosi][]0[Vac]2",
+    "h2o1L": "[]0[]0[]0[H]2",
+}
+
+
+def make_melt_class(selected_endmembers):
+    """
+    A function that generates a melt class that is a subclass of the
+    Holland et al. (2018) silicate melt model.
+
+    Parameters
+    ----------
+    selected_endmembers: list of Minerals
+        Endmembers to include in the model.
+        Valid endmembers are given in the following list,
+        and should be specified in the same order
+        as they appear in the list:
+        ['q4L', 'sl1L', 'wo1L', 'fo2L', 'fa2L', 'jdL',
+        'hmL', 'ekL', 'tiL', 'kjL', 'ctL', 'h2o1L'].
+
+    Returns
+    -------
+    melt_class: Solution class
+        Melt class spanning the specified endmembers.
+    """
+    endmembers = [[mbr, site_formulae[mbr.name]] for mbr in selected_endmembers]
+    alphas = [a[mbr.name] for mbr in selected_endmembers]
+    We = [
+        [
+            W[selected_endmembers[i].name][selected_endmembers[j].name][0] * 1.0e3
+            for j in range(i + 1, len(selected_endmembers))
+        ]
+        for i in range(len(selected_endmembers))
+    ]
+
+    Wv = [
+        [
+            W[selected_endmembers[i].name][selected_endmembers[j].name][2] * 1.0e-5
+            for j in range(i + 1, len(selected_endmembers))
+        ]
+        for i in range(len(selected_endmembers))
+    ]
+
+    class silicate_melt(Solution):
+        def __init__(self, molar_fractions=None):
+            self.name = "Holland et al. (2018) melt model"
+            self.solution_model = AsymmetricRegularSolution(
+                endmembers=endmembers,
+                energy_interaction=We,
+                volume_interaction=Wv,
+                alphas=alphas,
+            )
+
+            Solution.__init__(self, molar_fractions=molar_fractions)
+
+    return silicate_melt
+
+
+silicate_melt = make_melt_class(
+    [q4L, sl1L, wo1L, fo2L, fa2L, jdL, hmL, ekL, tiL, kjL, ctL, h2o1L]
+)
+
+CMS_melt = make_melt_class([q4L, wo1L, fo2L])
+
+MS_melt = make_melt_class([q4L, fo2L])
```

### Comparing `burnman-1.1.0/burnman/minerals/HP_2011_fluids.py` & `burnman-1.2.0/burnman/minerals/HP_2011_fluids.py`

 * *Files 19% similar despite different names*

```diff
@@ -40,125 +40,155 @@
 
 from __future__ import absolute_import
 
 from ..classes.mineral import Mineral
 from ..utils.chemistry import dictionarize_formula, formula_mass
 
 
-class CO2 (Mineral):
-
-    def __init__(self):
-        formula = 'CO2'
-        formula = dictionarize_formula(formula)
-        self.params = {
-            'name': 'carbon dioxide',
-            'formula': formula,
-            'equation_of_state': 'cork',
-            'cork_params': [[5.45963e1, -8.63920e0], [9.18301e-1], [-3.30558e-2, 2.30524e-3], [6.93054e-4, -8.38293e-5]],
-            'cork_T': 304.2,
-            'cork_P': 0.0738e8,
-            'H_0': -393.51e3,
-            'S_0': 213.7,
-            'Cp': [87.8, -2.644e-3, 706.4e3, -998.9],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
-        Mineral.__init__(self)
-
-
-class CH4 (Mineral):
-
-    def __init__(self):
-        formula = 'CH4'
-        formula = dictionarize_formula(formula)
-        self.params = {
-            'name': 'methane',
-            'formula': formula,
-            'equation_of_state': 'cork',
-            'cork_params': [[5.45963e1, -8.63920e0], [9.18301e-1], [-3.30558e-2, 2.30524e-3], [6.93054e-4, -8.38293e-5]],
-            'cork_T': 190.6,
-            'cork_P': 0.0460e8,
-            'H_0': -74.81e3,
-            'S_0': 186.26,
-            'Cp': [150.1, 0.002063, 3427700., -2650.4],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
-        Mineral.__init__(self)
-
-
-class O2 (Mineral):
-
-    def __init__(self):
-        formula = 'O2'
-        formula = dictionarize_formula(formula)
-        self.params = {
-            'name': 'oxygen',
-            'formula': formula,
-            'equation_of_state': 'cork',
-            'cork_params': [[5.45963e1, -8.63920e0], [9.18301e-1], [-3.30558e-2, 2.30524e-3], [6.93054e-4, -8.38293e-5]],
-            'cork_T': 0.,
-            'cork_P': 1.0e5,
-            'H_0': 0.,
-            'S_0': 205.2,
-            'Cp': [48.3, -0.000691, 499200., -420.7],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
-        Mineral.__init__(self)
-
-
-class H2 (Mineral):
-
-    def __init__(self):
-        formula = 'H2'
-        formula = dictionarize_formula(formula)
-        self.params = {
-            'name': 'hydrogen',
-            'formula': formula,
-            'equation_of_state': 'cork',
-            'cork_params': [[5.45963e1, -8.63920e0], [9.18301e-1], [-3.30558e-2, 2.30524e-3], [6.93054e-4, -8.38293e-5]],
-            'cork_T': 41.2,
-            'cork_P': 0.0211e8,
-            'H_0': 0.,
-            'S_0': 130.7,
-            'Cp': [23.3, 0.004627, 0.0, 76.3],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
-        Mineral.__init__(self)
-
-
-class S2 (Mineral):
-
-    def __init__(self):
-        formula = 'S2'
-        formula = dictionarize_formula(formula)
-        self.params = {
-            'name': 'sulfur',
-            'formula': formula,
-            'equation_of_state': 'cork',
-            'cork_params': [[5.45963e1, -8.63920e0], [9.18301e-1], [-3.30558e-2, 2.30524e-3], [6.93054e-4, -8.38293e-5]],
-            'cork_T': 1314.00,
-            'cork_P': 0.21000e8,
-            'H_0': 128.54e3,
-            'S_0': 231.0,
-            'Cp': [37.1, 0.002398, -161000.0, -65.0],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
-        Mineral.__init__(self)
-
-
-class H2S (Mineral):
-
+class CO2(Mineral):
     def __init__(self):
-        formula = 'H2S'
+        formula = "CO2"
         formula = dictionarize_formula(formula)
         self.params = {
-            'name': 'hydrogen sulfide',
-            'formula': formula,
-            'equation_of_state': 'cork',
-            'cork_params': [[5.45963e1, -8.63920e0], [9.18301e-1], [-3.30558e-2, 2.30524e-3], [6.93054e-4, -8.38293e-5]],
-            'cork_T': 373.15,
-            'cork_P': 0.08937e8,
-            'H_0': 128.54e3,
-            'S_0': 231.0,
-            'Cp': [47.4, 0.010240, 615900., -397.8],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
+            "name": "carbon dioxide",
+            "formula": formula,
+            "equation_of_state": "cork",
+            "cork_params": [
+                [5.45963e1, -8.63920e0],
+                [9.18301e-1],
+                [-3.30558e-2, 2.30524e-3],
+                [6.93054e-4, -8.38293e-5],
+            ],
+            "cork_T": 304.2,
+            "cork_P": 0.0738e8,
+            "H_0": -393.51e3,
+            "S_0": 213.7,
+            "Cp": [87.8, -2.644e-3, 706.4e3, -998.9],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
+        Mineral.__init__(self)
+
+
+class CH4(Mineral):
+    def __init__(self):
+        formula = "CH4"
+        formula = dictionarize_formula(formula)
+        self.params = {
+            "name": "methane",
+            "formula": formula,
+            "equation_of_state": "cork",
+            "cork_params": [
+                [5.45963e1, -8.63920e0],
+                [9.18301e-1],
+                [-3.30558e-2, 2.30524e-3],
+                [6.93054e-4, -8.38293e-5],
+            ],
+            "cork_T": 190.6,
+            "cork_P": 0.0460e8,
+            "H_0": -74.81e3,
+            "S_0": 186.26,
+            "Cp": [150.1, 0.002063, 3427700.0, -2650.4],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
+        Mineral.__init__(self)
+
+
+class O2(Mineral):
+    def __init__(self):
+        formula = "O2"
+        formula = dictionarize_formula(formula)
+        self.params = {
+            "name": "oxygen",
+            "formula": formula,
+            "equation_of_state": "cork",
+            "cork_params": [
+                [5.45963e1, -8.63920e0],
+                [9.18301e-1],
+                [-3.30558e-2, 2.30524e-3],
+                [6.93054e-4, -8.38293e-5],
+            ],
+            "cork_T": 0.0,
+            "cork_P": 1.0e5,
+            "H_0": 0.0,
+            "S_0": 205.2,
+            "Cp": [48.3, -0.000691, 499200.0, -420.7],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
+        Mineral.__init__(self)
+
+
+class H2(Mineral):
+    def __init__(self):
+        formula = "H2"
+        formula = dictionarize_formula(formula)
+        self.params = {
+            "name": "hydrogen",
+            "formula": formula,
+            "equation_of_state": "cork",
+            "cork_params": [
+                [5.45963e1, -8.63920e0],
+                [9.18301e-1],
+                [-3.30558e-2, 2.30524e-3],
+                [6.93054e-4, -8.38293e-5],
+            ],
+            "cork_T": 41.2,
+            "cork_P": 0.0211e8,
+            "H_0": 0.0,
+            "S_0": 130.7,
+            "Cp": [23.3, 0.004627, 0.0, 76.3],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
+        Mineral.__init__(self)
+
+
+class S2(Mineral):
+    def __init__(self):
+        formula = "S2"
+        formula = dictionarize_formula(formula)
+        self.params = {
+            "name": "sulfur",
+            "formula": formula,
+            "equation_of_state": "cork",
+            "cork_params": [
+                [5.45963e1, -8.63920e0],
+                [9.18301e-1],
+                [-3.30558e-2, 2.30524e-3],
+                [6.93054e-4, -8.38293e-5],
+            ],
+            "cork_T": 1314.00,
+            "cork_P": 0.21000e8,
+            "H_0": 128.54e3,
+            "S_0": 231.0,
+            "Cp": [37.1, 0.002398, -161000.0, -65.0],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
+        Mineral.__init__(self)
+
+
+class H2S(Mineral):
+    def __init__(self):
+        formula = "H2S"
+        formula = dictionarize_formula(formula)
+        self.params = {
+            "name": "hydrogen sulfide",
+            "formula": formula,
+            "equation_of_state": "cork",
+            "cork_params": [
+                [5.45963e1, -8.63920e0],
+                [9.18301e-1],
+                [-3.30558e-2, 2.30524e-3],
+                [6.93054e-4, -8.38293e-5],
+            ],
+            "cork_T": 373.15,
+            "cork_P": 0.08937e8,
+            "H_0": 128.54e3,
+            "S_0": 231.0,
+            "Cp": [47.4, 0.010240, 615900.0, -397.8],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
         Mineral.__init__(self)
```

### Comparing `burnman-1.1.0/burnman/minerals/ICL_2018.py` & `burnman-1.2.0/burnman/minerals/ICL_2018.py`

 * *Files 22% similar despite different names*

```diff
@@ -15,28 +15,29 @@
 """
 from __future__ import absolute_import
 
 from ..classes import mineral_helpers as helpers
 from ..classes.mineral import Mineral
 
 
-class EPOC_vinet (Mineral):
-
+class EPOC_vinet(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'vinet',
-            'V_0': 8.18e-6,
-            'K_0': 67.5e9,
-            'Kprime_0': 6.12,
-            'molar_mass': .05,}
+            "equation_of_state": "vinet",
+            "V_0": 8.18e-6,
+            "K_0": 67.5e9,
+            "Kprime_0": 6.12,
+            "molar_mass": 0.05,
+        }
         Mineral.__init__(self)
 
-class EPOC_bm (Mineral):
 
+class EPOC_bm(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'bm3',
-            'V_0': 7.63e-6,
-            'K_0': 120e9,
-            'Kprime_0': 4.6,
-            'molar_mass': .05,}
+            "equation_of_state": "bm3",
+            "V_0": 7.63e-6,
+            "K_0": 120e9,
+            "Kprime_0": 4.6,
+            "molar_mass": 0.05,
+        }
         Mineral.__init__(self)
```

### Comparing `burnman-1.1.0/burnman/minerals/JH_2015.py` & `burnman-1.2.0/burnman/minerals/JH_2015.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,14 +12,15 @@
 (10.1093/petrology/egv020).
 The values in this document are all in S.I. units,
 unlike those in the original tc file.
 """
 import inspect
 import numpy as np
 from ..classes.solution import Solution
+from ..classes.solutionmodel import SymmetricRegularSolution, AsymmetricRegularSolution
 from ..classes.combinedmineral import CombinedMineral
 from copy import copy
 
 """
 ENDMEMBERS
 
 Direct import from HP_2011_ds62
@@ -28,17 +29,21 @@
 from . import HP_2011_ds62
 
 # The next few lines import the classes from HP_2011_ds62,
 # so that they can be read as attributes of JH_2015.
 # This avoids copying the covariance matrix into the JH_2015,
 # as would happen with import HP_2011_ds62
 import sys
+
 this_module = sys.modules[__name__]
-for m in [m for m in inspect.getmembers(HP_2011_ds62, inspect.isclass)
-          if m[1].__module__ == 'burnman.minerals.HP_2011_ds62']:
+for m in [
+    m
+    for m in inspect.getmembers(HP_2011_ds62, inspect.isclass)
+    if m[1].__module__ == "burnman.minerals.HP_2011_ds62"
+]:
     setattr(this_module, m[0], m[1])
 
 
 """
 SOLID SOLUTIONS
 
 The parameters in Jennings and Holland (2015) are given in the following units:
@@ -50,235 +55,276 @@
 (W=W_H-T*W_S+P*W_V), rather than a thermal correction to the
 interaction parameter (W=W_0+T*W_T+P*W_P).
 """
 
 
 class ferropericlase(Solution):
     def __init__(self, molar_fractions=None):
-        self.name = 'ferropericlase (FM)'
-        self.endmembers = [[HP_2011_ds62.per(), '[Mg]O'],
-                           [HP_2011_ds62.fper(), '[Fe]O']]
-        self.solution_type = 'symmetric'
-        self.energy_interaction = [[18.e3]]
+        self.name = "ferropericlase (FM)"
+        self.solution_model = SymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.per(), "[Mg]O"],
+                [HP_2011_ds62.fper(), "[Fe]O"],
+            ],
+            energy_interaction=[[18.0e3]],
+        )
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class plagioclase(Solution):
     def __init__(self, molar_fractions=None):
-        self.name = 'plagioclase (NCAS)'
-        self.endmembers = [[HP_2011_ds62.an(), '[Ca][Al]2Si2O8'],
-                           [HP_2011_ds62.abh(), '[Na][Al1/2Si1/2]2Si2O8']]  # Al-avoidance model
-        self.solution_type = 'asymmetric'
-        self.alphas = [0.39, 1.]
-        self.energy_interaction = [[22.4e3]]
+        self.name = "plagioclase (NCAS)"
+        self.solution_model = AsymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.an(), "[Ca][Al]2Si2O8"],
+                [HP_2011_ds62.abh(), "[Na][Al1/2Si1/2]2Si2O8"],
+            ],  # Al-avoidance model
+            alphas=[0.39, 1.0],
+            energy_interaction=[[22.4e3]],
+        )
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class clinopyroxene(Solution):
     def __init__(self, molar_fractions=None):
-        self.name = 'clinopyroxene (NCFMASCrO)'
-        self.endmembers = [[HP_2011_ds62.di(),   '[Mg][Ca][Si]1/2O6'],
-                           [cfs(),  '[Fe][Fe][Si]1/2O6'],
-                           [HP_2011_ds62.cats(), '[Al][Ca][Si1/2Al1/2]1/2O6'],
-                           [crdi(), '[Cr][Ca][Si1/2Al1/2]1/2O6'],
-                           [cess(), '[Fef][Ca][Si1/2Al1/2]1/2O6'],
-                           [HP_2011_ds62.jd(),   '[Al][Na][Si]1/2O6'],
-                           [cen(),  '[Mg][Mg][Si]1/2O6'],
-                           [cfm(),  '[Mg][Fe][Si]1/2O6']]  # note cfm ordered endmember
-        self.solution_type = 'asymmetric'
-        self.alphas = [1.2, 1.0, 1.9, 1.9, 1.9, 1.2, 1.0, 1.0]
-        self.energy_interaction = [[20.e3, 12.3e3, 8.e3, 8.e3, 26.e3, 29.8e3, 18.e3],
-                                   [25.e3, 34.e3, 34.e3, 24.e3, 7.e3, 4.e3],
-                                   [2.e3, 2.e3, 6.e3, 45.7e3, 27.e3],
-                                   [2.e3, 3.e3, 48.e3, 36.e3],
-                                   [3.e3, 58.e3, 36.e3],
-                                   [40.e3, 40.e3],
-                                   [4.e3]]
-        self.volume_interaction = [[0., -0.1e-5, 0., 0., 0., -0.03e-5, 0.],
-                                   [-0.1e-5, 0., 0., 0., 0., 0.],
-                                   [0., 0., 0., -0.29e-5, -0.1e-5],
-                                   [0., 0., 0., 0.],
-                                   [0., 0., 0.],
-                                   [0., 0.],
-                                   [0.]]
+        self.name = "clinopyroxene (NCFMASCrO)"
+
+        self.solution_model = AsymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.di(), "[Mg][Ca][Si]1/2O6"],
+                [cfs(), "[Fe][Fe][Si]1/2O6"],
+                [HP_2011_ds62.cats(), "[Al][Ca][Si1/2Al1/2]1/2O6"],
+                [crdi(), "[Cr][Ca][Si1/2Al1/2]1/2O6"],
+                [cess(), "[Fef][Ca][Si1/2Al1/2]1/2O6"],
+                [HP_2011_ds62.jd(), "[Al][Na][Si]1/2O6"],
+                [cen(), "[Mg][Mg][Si]1/2O6"],
+                [cfm(), "[Mg][Fe][Si]1/2O6"],
+            ],  # note cfm ordered endmember
+            alphas=[1.2, 1.0, 1.9, 1.9, 1.9, 1.2, 1.0, 1.0],
+            energy_interaction=[
+                [20.0e3, 12.3e3, 8.0e3, 8.0e3, 26.0e3, 29.8e3, 18.0e3],
+                [25.0e3, 34.0e3, 34.0e3, 24.0e3, 7.0e3, 4.0e3],
+                [2.0e3, 2.0e3, 6.0e3, 45.7e3, 27.0e3],
+                [2.0e3, 3.0e3, 48.0e3, 36.0e3],
+                [3.0e3, 58.0e3, 36.0e3],
+                [40.0e3, 40.0e3],
+                [4.0e3],
+            ],
+            volume_interaction=[
+                [0.0, -0.1e-5, 0.0, 0.0, 0.0, -0.03e-5, 0.0],
+                [-0.1e-5, 0.0, 0.0, 0.0, 0.0, 0.0],
+                [0.0, 0.0, 0.0, -0.29e-5, -0.1e-5],
+                [0.0, 0.0, 0.0, 0.0],
+                [0.0, 0.0, 0.0],
+                [0.0, 0.0],
+                [0.0],
+            ],
+        )
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class cfs(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='clinoferrosilite',
-                                 mineral_list=[HP_2011_ds62.fs()],
-                                 molar_amounts=[1.],
-                                 free_energy_adjustment=[3.8e3, 3., 0.03e-5])
+        CombinedMineral.__init__(
+            self,
+            name="clinoferrosilite",
+            mineral_list=[HP_2011_ds62.fs()],
+            molar_amounts=[1.0],
+            free_energy_adjustment=[3.8e3, 3.0, 0.03e-5],
+        )
 
 
 class crdi(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='chromium diopside',
-                                 mineral_list=[HP_2011_ds62.cats(),
-                                               HP_2011_ds62.kos(),
-                                               HP_2011_ds62.jd()],
-                                 molar_amounts=[1., 1., -1.],
-                                 free_energy_adjustment=[-3.e3, 0., 0.])
+        CombinedMineral.__init__(
+            self,
+            name="chromium diopside",
+            mineral_list=[HP_2011_ds62.cats(), HP_2011_ds62.kos(), HP_2011_ds62.jd()],
+            molar_amounts=[1.0, 1.0, -1.0],
+            free_energy_adjustment=[-3.0e3, 0.0, 0.0],
+        )
 
 
 class cess(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='ferric diopside',
-                                 mineral_list=[HP_2011_ds62.cats(),
-                                               HP_2011_ds62.acm(),
-                                               HP_2011_ds62.jd()],
-                                 molar_amounts=[1., 1., -1.],
-                                 free_energy_adjustment=[-6.e3, 0., 0.])
+        CombinedMineral.__init__(
+            self,
+            name="ferric diopside",
+            mineral_list=[HP_2011_ds62.cats(), HP_2011_ds62.acm(), HP_2011_ds62.jd()],
+            molar_amounts=[1.0, 1.0, -1.0],
+            free_energy_adjustment=[-6.0e3, 0.0, 0.0],
+        )
 
 
 class cen(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='clinoenstatite',
-                                 mineral_list=[HP_2011_ds62.en()],
-                                 molar_amounts=[1.],
-                                 free_energy_adjustment=[3.5e3, 2., 0.048e-5])
+        CombinedMineral.__init__(
+            self,
+            name="clinoenstatite",
+            mineral_list=[HP_2011_ds62.en()],
+            molar_amounts=[1.0],
+            free_energy_adjustment=[3.5e3, 2.0, 0.048e-5],
+        )
 
 
 class cfm(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='ordered clinoferroenstatite',
-                                 mineral_list=[HP_2011_ds62.en(),
-                                               HP_2011_ds62.fs()],
-                                 molar_amounts=[0.5, 0.5],
-                                 free_energy_adjustment=[-3.e3, 0., 0.])
+        CombinedMineral.__init__(
+            self,
+            name="ordered clinoferroenstatite",
+            mineral_list=[HP_2011_ds62.en(), HP_2011_ds62.fs()],
+            molar_amounts=[0.5, 0.5],
+            free_energy_adjustment=[-3.0e3, 0.0, 0.0],
+        )
 
 
 class olivine(Solution):
-
     def __init__(self, molar_fractions=None):
-        self.name = 'olivine (FMS)'
-        self.endmembers = [[HP_2011_ds62.fo(), '[Mg]2SiO4'],
-                           [HP_2011_ds62.fa(), '[Fe]2SiO4']]
-        self.solution_type = 'symmetric'
-        self.energy_interaction = [[9.e3]]
+        self.name = "olivine (FMS)"
+        self.solution_model = SymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.fo(), "[Mg]2SiO4"],
+                [HP_2011_ds62.fa(), "[Fe]2SiO4"],
+            ],
+            energy_interaction=[[9.0e3]],
+        )
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class spinel(Solution):
-
     def __init__(self, molar_fractions=None):
-        self.name = 'disordered spinel (CFMASO)'
-        self.endmembers = [[HP_2011_ds62.sp(),   '[Al2/3Mg1/3]3O4'],
-                           [HP_2011_ds62.herc(), '[Al2/3Fe1/3]3O4'],
-                           [HP_2011_ds62.mt(),   '[Fef2/3Fe1/3]3O4'],
-                           [HP_2011_ds62.picr(), '[Cr2/3Mg1/3]3O4']]
-        self.solution_type = 'symmetric'
-        self.energy_interaction = [[4.e3, 56.e3, 39.e3],
-                                   [32.e3, 27.e3],
-                                   [36.e3]]
+        self.name = "disordered spinel (CFMASO)"
+        self.solution_model = SymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.sp(), "[Al2/3Mg1/3]3O4"],
+                [HP_2011_ds62.herc(), "[Al2/3Fe1/3]3O4"],
+                [HP_2011_ds62.mt(), "[Fef2/3Fe1/3]3O4"],
+                [HP_2011_ds62.picr(), "[Cr2/3Mg1/3]3O4"],
+            ],
+            energy_interaction=[[4.0e3, 56.0e3, 39.0e3], [32.0e3, 27.0e3], [36.0e3]],
+        )
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class garnet(Solution):
-
     def __init__(self, molar_fractions=None):
-        self.name = 'garnet (CFMASCrO, low pressure)'
-        self.endmembers = [[HP_2011_ds62.py(),   '[Mg]3[Al]2Si3O12'],
-                           [HP_2011_ds62.alm(),  '[Fe]3[Al]2Si3O12'],
-                           [HP_2011_ds62.gr(),   '[Ca]3[Al]2Si3O12'],
-                           [HP_2011_ds62.andr(), '[Ca]3[Fef]2Si3O12'],
-                           [HP_2011_ds62.knor(), '[Mg]3[Cr]2Si3O12']]
-        self.solution_type = 'symmetric'
-        self.energy_interaction = [[4.e3, 35.e3, 91.e3, 2.e3],
-                                   [4.e3, 60.e3, 6.e3],
-                                   [2.e3, 47.e3],
-                                   [101.e3]]
-        self.entropy_interaction = [[0., 0., -1.7, 0.],
-                                    [0., -1.7, 0.],
-                                    [0., 33.8],
-                                    [32.1]] # note huge entropy additions! (and sign change from a + bT + cP format)
-        self.volume_interaction = [[0.1e-5, 0.1e-5, 0.032e-5, 0.],
-                                   [0.1e-5, 0.032e-5, 0.01e-5],
-                                   [0., 0.221e-5],
-                                   [0.153e-5]]
+        self.name = "garnet (CFMASCrO, low pressure)"
+
+        self.solution_model = SymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.py(), "[Mg]3[Al]2Si3O12"],
+                [HP_2011_ds62.alm(), "[Fe]3[Al]2Si3O12"],
+                [HP_2011_ds62.gr(), "[Ca]3[Al]2Si3O12"],
+                [HP_2011_ds62.andr(), "[Ca]3[Fef]2Si3O12"],
+                [HP_2011_ds62.knor(), "[Mg]3[Cr]2Si3O12"],
+            ],
+            energy_interaction=[
+                [4.0e3, 35.0e3, 91.0e3, 2.0e3],
+                [4.0e3, 60.0e3, 6.0e3],
+                [2.0e3, 47.0e3],
+                [101.0e3],
+            ],
+            entropy_interaction=[
+                [0.0, 0.0, -1.7, 0.0],
+                [0.0, -1.7, 0.0],
+                [0.0, 33.8],
+                [32.1],
+            ],  # note huge entropy additions! (and sign change from a + bT + cP format)
+            volume_interaction=[
+                [0.1e-5, 0.1e-5, 0.032e-5, 0.0],
+                [0.1e-5, 0.032e-5, 0.01e-5],
+                [0.0, 0.221e-5],
+                [0.153e-5],
+            ],
+        )
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class orthopyroxene(Solution):
     def __init__(self, molar_fractions=None):
-        self.name = 'orthopyroxene (CFMASCrO)'
-        self.endmembers = [[HP_2011_ds62.en(),   '[Mg][Mg][Si]0.5Si1.5O6'],
-                           [HP_2011_ds62.fs(),   '[Fe][Fe][Si]0.5Si1.5O6'],
-                           [fm(),   '[Fe][Mg][Si]0.5Si1.5O6'],
-                           [odi(),  '[Mg][Ca][Si]0.5Si1.5O6'],
-                           [HP_2011_ds62.mgts(), '[Al][Mg][Si1/2Al1/2]0.5Si1.5O6'],
-                           [cren(), '[Cr][Mg][Si1/2Al1/2]0.5Si1.5O6'],
-                           [mess(), '[Fef][Mg][Si1/2Al1/2]0.5Si1.5O6']]  # fm ordered phase, fake T-site multiplicity
-        self.solution_type = 'asymmetric'
-        self.alphas = [1., 1., 1., 1.2, 1., 1., 1.]
-        self.energy_interaction = [[5.2e3, 4.e3, 32.2e3, 13.e3, 8.e3, 8.e3],
-                                   [4.e3, 24.e3, 7.e3, 10.e3, 10.e3],
-                                   [18.e3, 2.e3, 12.e3, 12.e3],
-                                   [75.4e3, 30.e3, 30.e3],
-                                   [2.e3, 2.e3],
-                                   [2.e3]]
-        self.volume_interaction = [[0., 0., 0.12e-5, -0.15e-5, 0., 0.],
-                                   [0., 0., -0.15e-5, 0., 0.],
-                                   [0., -0.15e-5, 0., 0.],
-                                   [-0.94e-5, 0., 0.],
-                                   [0., 0.],
-                                   [0.]]
+        self.name = "orthopyroxene (CFMASCrO)"
+        self.solution_model = AsymmetricRegularSolution(
+            endmembers=[
+                [HP_2011_ds62.en(), "[Mg][Mg][Si]0.5Si1.5O6"],
+                [HP_2011_ds62.fs(), "[Fe][Fe][Si]0.5Si1.5O6"],
+                [fm(), "[Fe][Mg][Si]0.5Si1.5O6"],
+                [odi(), "[Mg][Ca][Si]0.5Si1.5O6"],
+                [HP_2011_ds62.mgts(), "[Al][Mg][Si1/2Al1/2]0.5Si1.5O6"],
+                [cren(), "[Cr][Mg][Si1/2Al1/2]0.5Si1.5O6"],
+                [mess(), "[Fef][Mg][Si1/2Al1/2]0.5Si1.5O6"],
+            ],  # fm ordered phase, fake T-site multiplicity
+            alphas=[1.0, 1.0, 1.0, 1.2, 1.0, 1.0, 1.0],
+            energy_interaction=[
+                [5.2e3, 4.0e3, 32.2e3, 13.0e3, 8.0e3, 8.0e3],
+                [4.0e3, 24.0e3, 7.0e3, 10.0e3, 10.0e3],
+                [18.0e3, 2.0e3, 12.0e3, 12.0e3],
+                [75.4e3, 30.0e3, 30.0e3],
+                [2.0e3, 2.0e3],
+                [2.0e3],
+            ],
+            volume_interaction=[
+                [0.0, 0.0, 0.12e-5, -0.15e-5, 0.0, 0.0],
+                [0.0, 0.0, -0.15e-5, 0.0, 0.0],
+                [0.0, -0.15e-5, 0.0, 0.0],
+                [-0.94e-5, 0.0, 0.0],
+                [0.0, 0.0],
+                [0.0],
+            ],
+        )
 
         Solution.__init__(self, molar_fractions=molar_fractions)
 
 
 class fm(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='ordered ferroenstatite',
-                                 mineral_list=[HP_2011_ds62.en(),
-                                               HP_2011_ds62.fs()],
-                                 molar_amounts=[0.5, 0.5],
-                                 free_energy_adjustment=[-6.e3, 0., 0.])
+        CombinedMineral.__init__(
+            self,
+            name="ordered ferroenstatite",
+            mineral_list=[HP_2011_ds62.en(), HP_2011_ds62.fs()],
+            molar_amounts=[0.5, 0.5],
+            free_energy_adjustment=[-6.0e3, 0.0, 0.0],
+        )
 
 
 class odi(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='orthodiopside',
-                                 mineral_list=[HP_2011_ds62.di()],
-                                 molar_amounts=[1.],
-                                 free_energy_adjustment=[-0.1e3, -0.211, 0.005e-5]) # note sign of *entropy* change.
+        CombinedMineral.__init__(
+            self,
+            name="orthodiopside",
+            mineral_list=[HP_2011_ds62.di()],
+            molar_amounts=[1.0],
+            free_energy_adjustment=[-0.1e3, -0.211, 0.005e-5],
+        )  # note sign of *entropy* change.
 
 
 class cren(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='chromium enstatite',
-                                 mineral_list=[HP_2011_ds62.mgts(),
-                                               HP_2011_ds62.kos(),
-                                               HP_2011_ds62.jd()],
-                                 molar_amounts=[1., 1., -1.],
-                                 free_energy_adjustment=[3.e3, 0., 0.])
+        CombinedMineral.__init__(
+            self,
+            name="chromium enstatite",
+            mineral_list=[HP_2011_ds62.mgts(), HP_2011_ds62.kos(), HP_2011_ds62.jd()],
+            molar_amounts=[1.0, 1.0, -1.0],
+            free_energy_adjustment=[3.0e3, 0.0, 0.0],
+        )
 
 
 class mess(CombinedMineral):
     def __init__(self):
-        CombinedMineral.__init__(self,
-                                 name='ferrienstatite',
-                                 mineral_list=[HP_2011_ds62.mgts(),
-                                               HP_2011_ds62.acm(),
-                                               HP_2011_ds62.jd()],
-                                 molar_amounts=[1., 1., -1.],
-                                 free_energy_adjustment=[-15.e3, 0., 0.15e-5])
+        CombinedMineral.__init__(
+            self,
+            name="ferrienstatite",
+            mineral_list=[HP_2011_ds62.mgts(), HP_2011_ds62.acm(), HP_2011_ds62.jd()],
+            molar_amounts=[1.0, 1.0, -1.0],
+            free_energy_adjustment=[-15.0e3, 0.0, 0.15e-5],
+        )
 
 
-def construct_combined_covariance(original_covariance_dictionary,
-                                  combined_mineral_list):
+def construct_combined_covariance(
+    original_covariance_dictionary, combined_mineral_list
+):
     """
     This function takes a dictionary containing a list of endmember_names
     and a covariance_matrix, and a list of CombinedMineral instances,
     and creates an updated covariance dictionary containing those
     CombinedMinerals
 
     Parameters
@@ -295,30 +341,34 @@
     cov : dictionary
         Updated covariance dictionary, with the same keys as the original
 
     """
     cov_orig = original_covariance_dictionary
 
     # Update names
-    cov = {'endmember_names': copy(cov_orig['endmember_names'])}
+    cov = {"endmember_names": copy(cov_orig["endmember_names"])}
     for c in combined_mineral_list:
-        cov['endmember_names'].append(c.name)
+        cov["endmember_names"].append(c.name)
 
     # Update covariance matrix
-    A = np.identity(len(cov_orig['endmember_names']))
-    for i, indices in enumerate([[cov_orig['endmember_names'].index(name)
-                                  for name in [mbr[0].params['name']
-                                               for mbr
-                                               in c.mixture.endmembers]]
-                                 for c in combined_mineral_list]):
-        B = np.zeros(len(cov_orig['endmember_names']))
+    A = np.identity(len(cov_orig["endmember_names"]))
+    for i, indices in enumerate(
+        [
+            [
+                cov_orig["endmember_names"].index(name)
+                for name in [mbr[0].params["name"] for mbr in c.mixture.endmembers]
+            ]
+            for c in combined_mineral_list
+        ]
+    ):
+        B = np.zeros(len(cov_orig["endmember_names"]))
         B[indices] = combined_mineral_list[i].mixture.molar_fractions
         A = np.vstack((A, B))
 
-    cov['covariance_matrix'] = A.dot(cov_orig['covariance_matrix']).dot(A.T)
+    cov["covariance_matrix"] = A.dot(cov_orig["covariance_matrix"]).dot(A.T)
 
     return cov
 
 
 def cov():
     """
     A function which returns the variance-covariance matrix of the
@@ -329,17 +379,21 @@
     Returns
     -------
     cov : dictionary
         Dictionary keys are:
         - endmember_names: a list of endmember names, and
         - covariance_matrix: a 2D variance-covariance array for the endmember enthalpies of formation
     """
-    return construct_combined_covariance(original_covariance_dictionary=HP_2011_ds62.cov(),
-                                         combined_mineral_list=[cfs(),
-                                                                crdi(),
-                                                                cess(),
-                                                                cen(),
-                                                                cfm(),
-                                                                fm(),
-                                                                odi(),
-                                                                cren(),
-                                                                mess()])
+    return construct_combined_covariance(
+        original_covariance_dictionary=HP_2011_ds62.cov(),
+        combined_mineral_list=[
+            cfs(),
+            crdi(),
+            cess(),
+            cen(),
+            cfm(),
+            fm(),
+            odi(),
+            cren(),
+            mess(),
+        ],
+    )
```

### Comparing `burnman-1.1.0/burnman/minerals/Matas_etal_2007.py` & `burnman-1.2.0/burnman/minerals/SLB_2005.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,133 +1,123 @@
 # This file is part of BurnMan - a thermoelastic and thermodynamic toolkit for the Earth and Planetary Sciences
 # Copyright (C) 2012 - 2017 by the BurnMan team, released under the GNU
 # GPL v2 or later.
 
 
 """
-Matas_etal_2007
-^^^^^^^^^^^^^^^
+SLB_2005
+^^^^^^^^
+
+Minerals from Stixrude & Lithgow-Bertelloni 2005 and references therein
 
-Minerals from Matas et al. 2007 and references therein. See Table 1 and 2.
 """
 from __future__ import absolute_import
-
+from ..classes import mineral_helpers as helpers
 from ..classes.mineral import Mineral
 
 
-class mg_perovskite(Mineral):
-
+class stishovite(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'mgd2',
-            'V_0': 24.43e-6,
-            'K_0': 250.0e9,
-            'Kprime_0': 4.0,
-            'G_0': 175.0e9,
-            'Gprime_0': 1.8,
-            'molar_mass': .1020,
-            'n': 5,
-            'Debye_0': 1070.,
-            'grueneisen_0': 1.48,
-            'q_0': 1.4}
+            "formula": {"Si": 1.0, "O": 2.0},
+            "equation_of_state": "slb3",
+            "V_0": 14.02e-6,
+            "K_0": 314.0e9,
+            "Kprime_0": 4.4,
+            "G_0": 220.0e9,
+            "Gprime_0": 1.6,
+            "molar_mass": 0.0601,
+            "n": 3,
+            "Debye_0": 1044.0,
+            "grueneisen_0": 1.34,
+            "q_0": 2.4,
+            "eta_s_0": 5.0,
+        }
 
         Mineral.__init__(self)
 
 
-class fe_perovskite(Mineral):
-
-    def __init__(self):
-        self.params = {
-            'equation_of_state': 'mgd2',
-            'V_0': 25.34e-6,
-            'K_0': 250.0e9,
-            'Kprime_0': 4.0,
-            'G_0': 135.0e9,
-            'Gprime_0': 1.3,
-            'molar_mass': .1319,
-            'n': 5,
-            'Debye_0': 841.,
-            'grueneisen_0': 1.48,
-            'q_0': 1.4}
-
+class periclase(Mineral):
+    def __init__(self):
+        self.params = {
+            "formula": {"Mg": 1.0, "O": 1.0},
+            "equation_of_state": "slb3",
+            "V_0": 11.24e-6,
+            "K_0": 161.0e9,
+            "Kprime_0": 3.8,
+            "G_0": 131.0e9,
+            "Gprime_0": 2.1,
+            "molar_mass": 0.0403,
+            "n": 2,
+            "Debye_0": 773.0,
+            "grueneisen_0": 1.5,
+            "q_0": 1.5,
+            "eta_s_0": 2.8,
+        }
         Mineral.__init__(self)
 
 
-class al_perovskite(Mineral):
-
-    def __init__(self):
-        self.params = {
-            'equation_of_state': 'mgd2',
-            'V_0': 24.58e-6,
-            'K_0': 249.0e9,
-            'Kprime_0': 4.0,
-            'G_0': 165.0e9,
-            'Gprime_0': 1.8,
-            'molar_mass': .1005,
-            'n': 5,
-            'Debye_0': 1021.,
-            'grueneisen_0': 1.48,
-            'q_0': 1.4}
+class wuestite(Mineral):
+    def __init__(self):
+        self.params = {
+            "equation_of_state": "slb3",
+            "formula": {"Fe": 1.0, "O": 1.0},
+            "V_0": 12.06e-6,
+            "K_0": 152.0e9,
+            "Kprime_0": 4.9,
+            "G_0": 47.0e9,
+            "Gprime_0": 0.7,
+            "molar_mass": 0.0718,
+            "n": 2,
+            "Debye_0": 455.0,
+            "grueneisen_0": 1.28,
+            "q_0": 1.5,
+            "eta_s_0": 0.8,
+        }
 
         Mineral.__init__(self)
 
 
-class ca_perovskite(Mineral):
-
+class mg_perovskite(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'mgd2',
-            'V_0': 27.45e-6,
-            'K_0': 236.0e9,
-            'Kprime_0': 3.9,
-            'G_0': 165.0e9,
-            'Gprime_0': 2.46,
-            'molar_mass': .11616,
-            'n': 5,
-            'Debye_0': 984.,
-            'grueneisen_0': 1.53,
-            'q_0': 1.6}
+            "formula": {"Mg": 1.0, "Si": 1.0, "O": 3.0},
+            "equation_of_state": "slb3",
+            "V_0": 24.45e-6,
+            "K_0": 251.0e9,
+            "Kprime_0": 4.1,
+            "G_0": 175.0e9,
+            "Gprime_0": 1.7,
+            "molar_mass": 0.1000,
+            "n": 5,
+            "Debye_0": 1070.0,
+            "grueneisen_0": 1.48,
+            "q_0": 1.4,
+            "eta_s_0": 2.6,
+        }
 
         Mineral.__init__(self)
 
 
-class periclase (Mineral):
-
+class fe_perovskite(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'mgd2',
-            'V_0': 11.25e-6,
-            'K_0': 160.1e9,
-            'Kprime_0': 3.83,
-            'G_0': 130.0e9,
-            'Gprime_0': 2.2,
-            'molar_mass': .0403,
-            'n': 2,
-            'Debye_0': 673.,
-            'grueneisen_0': 1.41,
-            'q_0': 1.3}
+            "formula": {"Fe": 1.0, "Si": 1.0, "O": 3.0},
+            "equation_of_state": "slb3",
+            "V_0": 25.48e-6,
+            "K_0": 281.0e9,
+            "Kprime_0": 4.1,
+            "G_0": 138.0e9,
+            "Gprime_0": 1.7,
+            "molar_mass": 0.1319,
+            "n": 5,
+            "Debye_0": 841.0,
+            "grueneisen_0": 1.48,
+            "q_0": 1.4,
+            "eta_s_0": 2.1,
+        }
 
         Mineral.__init__(self)
 
 
-class wuestite (Mineral):
-
-    def __init__(self):
-        self.params = {
-            'equation_of_state': 'mgd2',
-            'V_0': 12.26e-6,
-            'K_0': 160.1e9,
-            'Kprime_0': 3.83,
-            'G_0': 46.0e9,
-            'Gprime_0':  0.6,
-            'molar_mass': .0718,
-            'n': 2,
-            'Debye_0': 673.,
-            'grueneisen_0': 1.41,
-            'q_0': 1.3}
-
-        Mineral.__init__(self)
-
-ca_bridgmanite = ca_perovskite
 mg_bridgmanite = mg_perovskite
 fe_bridgmanite = fe_perovskite
-al_bridgmanite = al_perovskite
```

### Comparing `burnman-1.1.0/burnman/minerals/Murakami_etal_2012.py` & `burnman-1.2.0/burnman/minerals/Murakami_etal_2012.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,183 +14,187 @@
 """
 from __future__ import absolute_import
 from ..classes import mineral_helpers as helpers
 from ..classes.mineral import Mineral
 
 
 class mg_perovskite(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb2',
-            'V_0': 24.45e-6,  # S & L-B 2005
-            'K_0': 281e9,
-            'Kprime_0': 4.1,
-            'G_0': 173e9,
-            'Gprime_0': 1.56,
-            'molar_mass': .100,
-            'n': 5,
-            'Debye_0': 1070.,
-            'grueneisen_0': 1.48,
-            'q_0': 1.4,
-            'eta_s_0': 2.4}
+            "equation_of_state": "slb2",
+            "V_0": 24.45e-6,  # S & L-B 2005
+            "K_0": 281e9,
+            "Kprime_0": 4.1,
+            "G_0": 173e9,
+            "Gprime_0": 1.56,
+            "molar_mass": 0.100,
+            "n": 5,
+            "Debye_0": 1070.0,
+            "grueneisen_0": 1.48,
+            "q_0": 1.4,
+            "eta_s_0": 2.4,
+        }
 
         Mineral.__init__(self)
 
 
 class mg_perovskite_3rdorder(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 24.45e-6,  # S & L-B 2005
-            'K_0': 281e9,
-            'Kprime_0': 4.1,
-            'G_0': 171.42e9,
-            'Gprime_0': 1.83,
-            'molar_mass': .100,
-            'n': 5,
-            'Debye_0': 1070.,
-            'grueneisen_0': 1.48,
-            'q_0': 1.4,
-            'eta_s_0': 2.4}
+            "equation_of_state": "slb3",
+            "V_0": 24.45e-6,  # S & L-B 2005
+            "K_0": 281e9,
+            "Kprime_0": 4.1,
+            "G_0": 171.42e9,
+            "Gprime_0": 1.83,
+            "molar_mass": 0.100,
+            "n": 5,
+            "Debye_0": 1070.0,
+            "grueneisen_0": 1.48,
+            "q_0": 1.4,
+            "eta_s_0": 2.4,
+        }
 
         Mineral.__init__(self)
 
 
 class fe_perovskite(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb2',
-            'V_0': 24.607e-6,
-            'K_0': 251.9e9,
-            'Kprime_0': 4.01,
-            'G_0': 164.7e9,
-            'Gprime_0': 1.58,
-            'molar_mass': .102,
-            'n': 5,
-            'Debye_0': 1054.,
-            'grueneisen_0': 1.48,
-            'q_0': 1.4,
-            'eta_s_0': 2.4}
+            "equation_of_state": "slb2",
+            "V_0": 24.607e-6,
+            "K_0": 251.9e9,
+            "Kprime_0": 4.01,
+            "G_0": 164.7e9,
+            "Gprime_0": 1.58,
+            "molar_mass": 0.102,
+            "n": 5,
+            "Debye_0": 1054.0,
+            "grueneisen_0": 1.48,
+            "q_0": 1.4,
+            "eta_s_0": 2.4,
+        }
 
         Mineral.__init__(self)
 
 
 class mg_periclase(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb2',
-            'V_0': 11.24e-6,  # S & L-B 2005
-            'K_0': 161e9,
-            'Kprime_0': 3.9,
-            'G_0': 131e9,
-            'Gprime_0': 1.92,
-            'molar_mass': .0403,
-            'n': 2,
-            'Debye_0': 773.,  # S& L-B 2005
-            'grueneisen_0': 1.5,
-            'q_0': 1.5,  # S&L-B 2005
-            'eta_s_0': 3.0}
+            "equation_of_state": "slb2",
+            "V_0": 11.24e-6,  # S & L-B 2005
+            "K_0": 161e9,
+            "Kprime_0": 3.9,
+            "G_0": 131e9,
+            "Gprime_0": 1.92,
+            "molar_mass": 0.0403,
+            "n": 2,
+            "Debye_0": 773.0,  # S& L-B 2005
+            "grueneisen_0": 1.5,
+            "q_0": 1.5,  # S&L-B 2005
+            "eta_s_0": 3.0,
+        }
 
         Mineral.__init__(self)
 
 
 class fe_periclase(helpers.HelperSpinTransition):
-
     def __init__(self):
         helpers.HelperSpinTransition.__init__(
-            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS())
+            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS()
+        )
 
 
 class fe_periclase_3rd(helpers.HelperSpinTransition):
-
     def __init__(self):
         helpers.HelperSpinTransition.__init__(
-            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS())
-
+            self, 63.0e9, fe_periclase_LS(), fe_periclase_HS()
+        )
 
-class fe_periclase_HS(Mineral):  # From Murakami's emails, see Cayman for details, represents Mg# = .79
 
-    def __init__(self):
-        self.params = {
-            'equation_of_state': 'slb2',
-            'V_0': 11.412e-6,
-            'K_0': 159.1e9,
-            'Kprime_0': 4.11,
-            'G_0': 105.43e9,
-            'Gprime_0': 1.773,
-            'molar_mass': .047,
-            'n': 2,
-            'Debye_0': 706.,
-            'grueneisen_0': 1.45,
-            'q_0': 1.5,
-            'eta_s_0': 2.54}
+class fe_periclase_HS(
+    Mineral
+):  # From Murakami's emails, see Cayman for details, represents Mg# = .79
+    def __init__(self):
+        self.params = {
+            "equation_of_state": "slb2",
+            "V_0": 11.412e-6,
+            "K_0": 159.1e9,
+            "Kprime_0": 4.11,
+            "G_0": 105.43e9,
+            "Gprime_0": 1.773,
+            "molar_mass": 0.047,
+            "n": 2,
+            "Debye_0": 706.0,
+            "grueneisen_0": 1.45,
+            "q_0": 1.5,
+            "eta_s_0": 2.54,
+        }
 
         Mineral.__init__(self)
 
 
-class fe_periclase_LS(Mineral):  # From Murakami's emails, see Cayman for details, represents Mg# = .79
-
-    def __init__(self):
-        self.params = {
-            'equation_of_state': 'slb2',
-            'V_0': 11.171e-6,
-            'K_0': 170.0e9,
-            'Kprime_0': 4.00,
-            'G_0': 116.34e9,
-            'Gprime_0': 1.668,
-            'molar_mass': .047,
-            'n': 2,
-            'Debye_0': 706.,
-            'grueneisen_0': 1.45,
-            'q_0': 1.5,
-            'eta_s_0': 2.54}
+class fe_periclase_LS(
+    Mineral
+):  # From Murakami's emails, see Cayman for details, represents Mg# = .79
+    def __init__(self):
+        self.params = {
+            "equation_of_state": "slb2",
+            "V_0": 11.171e-6,
+            "K_0": 170.0e9,
+            "Kprime_0": 4.00,
+            "G_0": 116.34e9,
+            "Gprime_0": 1.668,
+            "molar_mass": 0.047,
+            "n": 2,
+            "Debye_0": 706.0,
+            "grueneisen_0": 1.45,
+            "q_0": 1.5,
+            "eta_s_0": 2.54,
+        }
 
         Mineral.__init__(self)
 
 
 class fe_periclase_HS_3rd(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 11.412e-6,
-            'K_0': 159.1e9,
-            'Kprime_0': 4.11,
-            'G_0': 129.35e9,
-            'Gprime_0': 1.993,
-            'molar_mass': .0469,
-            'n': 2,
-            'Debye_0': 706.,
-            'grueneisen_0': 1.45,
-            'q_0': 1.5,
-            'eta_s_0': 2.54}
+            "equation_of_state": "slb3",
+            "V_0": 11.412e-6,
+            "K_0": 159.1e9,
+            "Kprime_0": 4.11,
+            "G_0": 129.35e9,
+            "Gprime_0": 1.993,
+            "molar_mass": 0.0469,
+            "n": 2,
+            "Debye_0": 706.0,
+            "grueneisen_0": 1.45,
+            "q_0": 1.5,
+            "eta_s_0": 2.54,
+        }
 
         Mineral.__init__(self)
 
 
 class fe_periclase_LS_3rd(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 11.171e-6,
-            'K_0': 170.0e9,
-            'Kprime_0': 4.0,
-            'G_0': 151.67e9,
-            'Gprime_0': 1.754,
-            'molar_mass': .0469,
-            'n': 2,
-            'Debye_0': 706.,
-            'grueneisen_0': 1.45,
-            'q_0': 1.5,
-            'eta_s_0': 2.54}
+            "equation_of_state": "slb3",
+            "V_0": 11.171e-6,
+            "K_0": 170.0e9,
+            "Kprime_0": 4.0,
+            "G_0": 151.67e9,
+            "Gprime_0": 1.754,
+            "molar_mass": 0.0469,
+            "n": 2,
+            "Debye_0": 706.0,
+            "grueneisen_0": 1.45,
+            "q_0": 1.5,
+            "eta_s_0": 2.54,
+        }
 
         Mineral.__init__(self)
 
 
 mg_bridgmanite = mg_perovskite
 fe_bridgmanite = fe_perovskite
 mg_bridgmanite_3rdorder = mg_perovskite_3rdorder
```

### Comparing `burnman-1.1.0/burnman/minerals/RS_2014_liquids.py` & `burnman-1.2.0/burnman/minerals/RS_2014_liquids.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,34 +12,40 @@
 with the help of David Munoz Ramo.
 """
 
 import numpy as np
 from ..classes.mineral import Mineral
 from ..utils.chemistry import dictionarize_formula, formula_mass
 
+
 class Fe2SiO4_liquid(Mineral):
     def __init__(self):
-        formula = 'Fe2SiO4'
+        formula = "Fe2SiO4"
         formula = dictionarize_formula(formula)
         self.params = {
-            'name': 'Fe2SiO4_liquid',
-            'formula': formula,
-            'equation_of_state': 'dks_l',
-            'V_0':  59.7717e-6,  # modified for T_0
-            'T_0':  1900.,  # corrected
-            'O_theta': 1,
-            'O_f': 4,
-            'm': 0.6,
-            'a': np.array([[-4252948.0, 997810.188],
-                           [-599315.125, 12032.8936],
-                           [12572739., 7299239.5],
-                           [53442800.0, -26791676.0],
-                           [52981912.0, 0.]]),  # corrected order
-            'zeta_0': 0.0161350928,  # 0.0166734, # the comment is a refit to David's dataset
-            'xi': 0.34431043,  # 0.34431053, # the comment is a refit to David's dataset
-            'Tel_0': 1919.3553,  # 1921.6813, # the comment is a refit to David's dataset
-            'eta': 0.0127067110,  # 0.0127067, # the comment is a refit to David's dataset
-            'spin_a': [-0.00011134, 0.00010863],
-            'spin_b': [3.53793, -3.81421, 2.83703, -0.676241],
-            'n': sum(formula.values()),
-            'molar_mass': formula_mass(formula)}
+            "name": "Fe2SiO4_liquid",
+            "formula": formula,
+            "equation_of_state": "dks_l",
+            "V_0": 59.7717e-6,  # modified for T_0
+            "T_0": 1900.0,  # corrected
+            "O_theta": 1,
+            "O_f": 4,
+            "m": 0.6,
+            "a": np.array(
+                [
+                    [-4252948.0, 997810.188],
+                    [-599315.125, 12032.8936],
+                    [12572739.0, 7299239.5],
+                    [53442800.0, -26791676.0],
+                    [52981912.0, 0.0],
+                ]
+            ),  # corrected order
+            "zeta_0": 0.0161350928,  # 0.0166734, # the comment is a refit to David's dataset
+            "xi": 0.34431043,  # 0.34431053, # the comment is a refit to David's dataset
+            "Tel_0": 1919.3553,  # 1921.6813, # the comment is a refit to David's dataset
+            "eta": 0.0127067110,  # 0.0127067, # the comment is a refit to David's dataset
+            "spin_a": [-0.00011134, 0.00010863],
+            "spin_b": [3.53793, -3.81421, 2.83703, -0.676241],
+            "n": sum(formula.values()),
+            "molar_mass": formula_mass(formula),
+        }
         Mineral.__init__(self)
```

### Comparing `burnman-1.1.0/burnman/minerals/SLB_2011_ZSB_2013.py` & `burnman-1.2.0/burnman/minerals/SLB_2011_ZSB_2013.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,159 +12,164 @@
 """
 from __future__ import absolute_import
 
 from ..classes import mineral_helpers as helpers
 from ..classes.mineral import Mineral
 
 
-class stishovite (Mineral):
-
+class stishovite(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 14.02e-6,
-            'K_0': 314.0e9,
-            'Kprime_0': 3.8,
-            'G_0': 220.0e9,
-            'Gprime_0': 1.9,
-            'molar_mass': .0601,
-            'n': 3,
-            'Debye_0': 1108.,
-            'grueneisen_0': 1.37,
-            'q_0': 2.8,
-            'eta_s_0': 4.6}
+            "equation_of_state": "slb3",
+            "V_0": 14.02e-6,
+            "K_0": 314.0e9,
+            "Kprime_0": 3.8,
+            "G_0": 220.0e9,
+            "Gprime_0": 1.9,
+            "molar_mass": 0.0601,
+            "n": 3,
+            "Debye_0": 1108.0,
+            "grueneisen_0": 1.37,
+            "q_0": 2.8,
+            "eta_s_0": 4.6,
+        }
 
         self.uncertainties = {
-            'err_K_0': 8.e9,
-            'err_Kprime_0': 0.1,
-            'err_G_0': 12.e9,
-            'err_Gprime_0': 0.1,
-            'err_Debye_0': 13.,
-            'err_grueneisen_0': .17,
-            'err_q_0': 2.2,
-            'err_eta_s_0': 1.0
+            "err_K_0": 8.0e9,
+            "err_Kprime_0": 0.1,
+            "err_G_0": 12.0e9,
+            "err_Gprime_0": 0.1,
+            "err_Debye_0": 13.0,
+            "err_grueneisen_0": 0.17,
+            "err_q_0": 2.2,
+            "err_eta_s_0": 1.0,
         }
 
         Mineral.__init__(self)
 
 
-class periclase (Mineral):
-
+class periclase(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 11.24e-6,
-            'K_0': 161.0e9,
-            'Kprime_0': 3.8,
-            'G_0': 131.0e9,
-            'Gprime_0': 2.1,
-            'molar_mass': .0403,
-            'n': 2,
-            'Debye_0': 767.,
-            'grueneisen_0': 1.36,
-            'q_0': 1.7,  # 1.7
-            'eta_s_0': 2.8}  # 2.8
+            "equation_of_state": "slb3",
+            "V_0": 11.24e-6,
+            "K_0": 161.0e9,
+            "Kprime_0": 3.8,
+            "G_0": 131.0e9,
+            "Gprime_0": 2.1,
+            "molar_mass": 0.0403,
+            "n": 2,
+            "Debye_0": 767.0,
+            "grueneisen_0": 1.36,
+            "q_0": 1.7,  # 1.7
+            "eta_s_0": 2.8,
+        }  # 2.8
 
         self.uncertainties = {
-            'err_K_0': 3.e9,
-            'err_Kprime_0': .2,
-            'err_G_0': 1.0e9,
-            'err_Gprime_0': .1,
-            'err_Debye_0': 9.,
-            'err_grueneisen_0': .05,
-            'err_q_0': .2,
-            'err_eta_s_0': .2}
+            "err_K_0": 3.0e9,
+            "err_Kprime_0": 0.2,
+            "err_G_0": 1.0e9,
+            "err_Gprime_0": 0.1,
+            "err_Debye_0": 9.0,
+            "err_grueneisen_0": 0.05,
+            "err_q_0": 0.2,
+            "err_eta_s_0": 0.2,
+        }
 
         Mineral.__init__(self)
 
 
-class wuestite (Mineral):
-
+class wuestite(Mineral):
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 12.26e-6,
-            'K_0': 179.0e9,
-            'Kprime_0': 4.9,
-            'G_0': 59.0e9,
-            'Gprime_0': 1.4,
-            'molar_mass': .0718,
-            'n': 2,
-            'Debye_0': 454.,
-            'grueneisen_0': 1.53,
-            'q_0': 1.7,  # 1.7
-            'eta_s_0': -0.1}
+            "equation_of_state": "slb3",
+            "V_0": 12.26e-6,
+            "K_0": 179.0e9,
+            "Kprime_0": 4.9,
+            "G_0": 59.0e9,
+            "Gprime_0": 1.4,
+            "molar_mass": 0.0718,
+            "n": 2,
+            "Debye_0": 454.0,
+            "grueneisen_0": 1.53,
+            "q_0": 1.7,  # 1.7
+            "eta_s_0": -0.1,
+        }
 
         self.uncertainties = {
-            'err_K_0': 1.e9,
-            'err_Kprime_0': .2,
-            'err_G_0': 1.e9,
-            'err_Gprime_0': .1,
-            'err_Debye_0': 21.,
-            'err_grueneisen_0': .13,
-            'err_q_0': 1.0,
-            'err_eta_s_0': 1.0}
+            "err_K_0": 1.0e9,
+            "err_Kprime_0": 0.2,
+            "err_G_0": 1.0e9,
+            "err_Gprime_0": 0.1,
+            "err_Debye_0": 21.0,
+            "err_grueneisen_0": 0.13,
+            "err_q_0": 1.0,
+            "err_eta_s_0": 1.0,
+        }
 
         Mineral.__init__(self)
 
 
 class mg_perovskite(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 24.45e-6,
-            'K_0': 250.5e9,
-            'Kprime_0': 4.01,
-            'G_0': 172.9e9,
-            'Gprime_0': 1.74,
-            'molar_mass': .1000,
-            'n': 5,
-            'Debye_0': 905.9,
-            'grueneisen_0': 1.44,
-            'q_0': 1.09,
-            'eta_s_0': 2.13}  # 2.6
+            "equation_of_state": "slb3",
+            "V_0": 24.45e-6,
+            "K_0": 250.5e9,
+            "Kprime_0": 4.01,
+            "G_0": 172.9e9,
+            "Gprime_0": 1.74,
+            "molar_mass": 0.1000,
+            "n": 5,
+            "Debye_0": 905.9,
+            "grueneisen_0": 1.44,
+            "q_0": 1.09,
+            "eta_s_0": 2.13,
+        }  # 2.6
 
         self.uncertainties = {
-            'err_K_0': 3.e9,
-            'err_Kprime_0': 0.1,
-            'err_G_0': 2.e9,
-            'err_Gprime_0': 0.0,
-            'err_Debye_0': 5.,
-            'err_grueneisen_0': .05,
-            'err_q_0': .3,
-            'err_eta_s_0': .3}
+            "err_K_0": 3.0e9,
+            "err_Kprime_0": 0.1,
+            "err_G_0": 2.0e9,
+            "err_Gprime_0": 0.0,
+            "err_Debye_0": 5.0,
+            "err_grueneisen_0": 0.05,
+            "err_q_0": 0.3,
+            "err_eta_s_0": 0.3,
+        }
 
         Mineral.__init__(self)
 
 
 class fe_perovskite(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 25.49e-6,
-            'K_0': 272.0e9,
-            'Kprime_0': 4.1,
-            'G_0': 133.0e9,
-            'Gprime_0': 1.4,
-            'molar_mass': .1319,
-            'n': 5,
-            'Debye_0': 871.,
-            'grueneisen_0': 1.57,
-            'q_0': 1.1,
-            'eta_s_0': 2.3}  # 2.3
+            "equation_of_state": "slb3",
+            "V_0": 25.49e-6,
+            "K_0": 272.0e9,
+            "Kprime_0": 4.1,
+            "G_0": 133.0e9,
+            "Gprime_0": 1.4,
+            "molar_mass": 0.1319,
+            "n": 5,
+            "Debye_0": 871.0,
+            "grueneisen_0": 1.57,
+            "q_0": 1.1,
+            "eta_s_0": 2.3,
+        }  # 2.3
 
         self.uncertainties = {
-            'err_K_0': 40e9,
-            'err_Kprime_0': 1.,
-            'err_G_0': 40e9,
-            'err_Gprime_0': 0.0,
-            'err_Debye_0': 26.,
-            'err_grueneisen_0': .3,
-            'err_q_0': 1.0,
-            'err_eta_s_0': 1.0}
+            "err_K_0": 40e9,
+            "err_Kprime_0": 1.0,
+            "err_G_0": 40e9,
+            "err_Gprime_0": 0.0,
+            "err_Debye_0": 26.0,
+            "err_grueneisen_0": 0.3,
+            "err_q_0": 1.0,
+            "err_eta_s_0": 1.0,
+        }
 
         Mineral.__init__(self)
 
+
 mg_bridgmanite = mg_perovskite
 fe_bridgmanite = fe_perovskite
```

### Comparing `burnman-1.1.0/burnman/minerals/__init__.py` & `burnman-1.2.0/burnman/minerals/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,14 +6,15 @@
 
 """
 Mineral database
 
   - :mod:`~burnman.minerals.SLB_2005`
   - :mod:`~burnman.minerals.SLB_2011_ZSB_2013`
   - :mod:`~burnman.minerals.SLB_2011`
+  - :mod:`~burnman.minerals.SLB_2022`
   - :mod:`~burnman.minerals.DKS_2013_liquids`
   - :mod:`~burnman.minerals.DKS_2013_solids`
   - :mod:`~burnman.minerals.RS_2014_liquids`
   - :mod:`~burnman.minerals.Murakami_etal_2012`
   - :mod:`~burnman.minerals.Murakami_2013`
   - :mod:`~burnman.minerals.Matas_etal_2007`
   - :mod:`~burnman.minerals.HP_2011_ds62`
@@ -22,14 +23,15 @@
   - :mod:`~burnman.minerals.HGP_2018_ds633`
   - :mod:`~burnman.minerals.SE_2015`
   - :mod:`~burnman.minerals.other`
 """
 from __future__ import absolute_import
 
 # Stixrude and Lithgow-Bertelloni
+from . import SLB_2022
 from . import SLB_2011
 from . import SLB_2011_ZSB_2013
 from . import SLB_2005
 
 # ab initio
 from . import RS_2014_liquids
 from . import DKS_2013_liquids
```

### Comparing `burnman-1.1.0/burnman/minerals/other.py` & `burnman-1.2.0/burnman/minerals/other.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,189 +13,195 @@
 from ..classes import mineral_helpers as helpers
 from ..classes.mineral import Mineral
 from ..utils.chemistry import dictionarize_formula, formula_mass
 
 from .SLB_2011 import periclase, wuestite, mg_perovskite, fe_perovskite
 
 
-
-class liquid_iron( Mineral ):
+class liquid_iron(Mineral):
     """
     Liquid iron equation of state from Anderson and Ahrens (1994)
     """
+
     def __init__(self):
-        formula='Fe1.0'
+        formula = "Fe1.0"
         formula = dictionarize_formula(formula)
         m = formula_mass(formula)
-        rho_0 = 7019.
-        V_0 = m/rho_0
-        D = 7766.
-        Lambda = 1146.
-        self.params = {
-            'name': 'liquid iron',
-            'formula': formula,
-            'equation_of_state': 'aa',
-            'P_0': 1.e5,
-            'T_0': 1811.,
-            'S_0': 100., # to fit
-            'molar_mass': m,
-            'V_0': V_0,
-            'E_0': 0.,
-            'K_S': 109.7e9,
-            'Kprime_S': 4.661,
-            'Kprime_prime_S': -0.043e-9,
-            'grueneisen_0': 1.735,
-            'grueneisen_prime': -0.130/m*1.e-6,
-            'grueneisen_n': -1.870,
-            'a': [248.92*m, 289.48*m],
-            'b': [0.4057*m, -1.1499*m],
-            'Theta': [1747.3, 1.537],
-            'theta': 5000.,
-            'lmda': [-325.23*m, 302.07*m, 30.45*m],
-            'xi_0': 282.67*m,
-            'F': [D/rho_0, Lambda/rho_0],
-            'n': sum(formula.values()),
-            'molar_mass': m}
+        rho_0 = 7019.0
+        V_0 = m / rho_0
+        D = 7766.0
+        Lambda = 1146.0
+        self.params = {
+            "name": "liquid iron",
+            "formula": formula,
+            "equation_of_state": "aa",
+            "P_0": 1.0e5,
+            "T_0": 1811.0,
+            "S_0": 100.0,  # to fit
+            "molar_mass": m,
+            "V_0": V_0,
+            "E_0": 0.0,
+            "K_S": 109.7e9,
+            "Kprime_S": 4.661,
+            "Kprime_prime_S": -0.043e-9,
+            "grueneisen_0": 1.735,
+            "grueneisen_prime": -0.130 / m * 1.0e-6,
+            "grueneisen_n": -1.870,
+            "a": [248.92 * m, 289.48 * m],
+            "b": [0.4057 * m, -1.1499 * m],
+            "Theta": [1747.3, 1.537],
+            "theta": 5000.0,
+            "lmda": [-325.23 * m, 302.07 * m, 30.45 * m],
+            "xi_0": 282.67 * m,
+            "F": [D / rho_0, Lambda / rho_0],
+            "n": sum(formula.values()),
+            "molar_mass": m,
+        }
         Mineral.__init__(self)
 
 
 class ZSB_2013_mg_perovskite(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 24.45e-6,
-            'K_0': 250.5e9,
-            'Kprime_0': 4.01,
-            'G_0': 172.9e9,
-            'Gprime_0': 1.74,
-            'molar_mass': .1000,
-            'n': 5,
-            'Debye_0': 905.9,
-            'grueneisen_0': 1.44,
-            'q_0': 1.09,
-            'eta_s_0': 2.13}  # 2.6
+            "equation_of_state": "slb3",
+            "V_0": 24.45e-6,
+            "K_0": 250.5e9,
+            "Kprime_0": 4.01,
+            "G_0": 172.9e9,
+            "Gprime_0": 1.74,
+            "molar_mass": 0.1000,
+            "n": 5,
+            "Debye_0": 905.9,
+            "grueneisen_0": 1.44,
+            "q_0": 1.09,
+            "eta_s_0": 2.13,
+        }  # 2.6
 
         self.uncertainties = {
-            'err_K_0': 3.e9,
-            'err_Kprime_0': 0.1,
-            'err_G_0': 2.e9,
-            'err_Gprime_0': 0.0,
-            'err_Debye_0': 5.,
-            'err_grueneisen_0': .05,
-            'err_q_0': .3,
-            'err_eta_s_0': .3}
+            "err_K_0": 3.0e9,
+            "err_Kprime_0": 0.1,
+            "err_G_0": 2.0e9,
+            "err_Gprime_0": 0.0,
+            "err_Debye_0": 5.0,
+            "err_grueneisen_0": 0.05,
+            "err_q_0": 0.3,
+            "err_eta_s_0": 0.3,
+        }
 
         Mineral.__init__(self)
 
 
 class ZSB_2013_fe_perovskite(Mineral):
-
     def __init__(self):
         self.params = {
-            'equation_of_state': 'slb3',
-            'V_0': 25.49e-6,
-            'K_0': 272.0e9,
-            'Kprime_0': 4.1,
-            'G_0': 133.0e9,
-            'Gprime_0': 1.4,
-            'molar_mass': .1319,
-            'n': 5,
-            'Debye_0': 871.,
-            'grueneisen_0': 1.57,
-            'q_0': 1.1,
-            'eta_s_0': 2.3}  # 2.3
+            "equation_of_state": "slb3",
+            "V_0": 25.49e-6,
+            "K_0": 272.0e9,
+            "Kprime_0": 4.1,
+            "G_0": 133.0e9,
+            "Gprime_0": 1.4,
+            "molar_mass": 0.1319,
+            "n": 5,
+            "Debye_0": 871.0,
+            "grueneisen_0": 1.57,
+            "q_0": 1.1,
+            "eta_s_0": 2.3,
+        }  # 2.3
 
         self.uncertainties = {
-            'err_K_0': 40e9,
-            'err_Kprime_0': 1.,
-            'err_G_0': 40e9,
-            'err_Gprime_0': 0.0,
-            'err_Debye_0': 26.,
-            'err_grueneisen_0': .3,
-            'err_q_0': 1.0,
-            'err_eta_s_0': 1.0}
+            "err_K_0": 40e9,
+            "err_Kprime_0": 1.0,
+            "err_G_0": 40e9,
+            "err_Gprime_0": 0.0,
+            "err_Debye_0": 26.0,
+            "err_grueneisen_0": 0.3,
+            "err_q_0": 1.0,
+            "err_eta_s_0": 1.0,
+        }
 
         Mineral.__init__(self)
 
 
 class Speziale_fe_periclase(helpers.HelperSpinTransition):
-
     def __init__(self):
         helpers.HelperSpinTransition.__init__(
-            self, 60.0e9, Speziale_fe_periclase_LS(), Speziale_fe_periclase_HS())
-        self.cite = 'Speziale et al. 2007'
+            self, 60.0e9, Speziale_fe_periclase_LS(), Speziale_fe_periclase_HS()
+        )
+        self.cite = "Speziale et al. 2007"
 
 
 class Speziale_fe_periclase_HS(Mineral):
 
     """
     Speziale et al. 2007, Mg#=83
     """
 
     def __init__(self):
         self.params = {
-            'equation_of_state': 'mgd3',
-            'V_0': 22.9e-6,
-            'K_0': 157.5e9,
-            'Kprime_0': 3.92,
-            'molar_mass': .04567,
-            'n': 2,
-            'Debye_0': 587,
-            'grueneisen_0': 1.46,
-            'q_0': 1.2}
+            "equation_of_state": "mgd3",
+            "V_0": 22.9e-6,
+            "K_0": 157.5e9,
+            "Kprime_0": 3.92,
+            "molar_mass": 0.04567,
+            "n": 2,
+            "Debye_0": 587,
+            "grueneisen_0": 1.46,
+            "q_0": 1.2,
+        }
         Mineral.__init__(self)
 
 
 class Speziale_fe_periclase_LS(Mineral):
 
     """
     Speziale et al. 2007, Mg#=83
     """
 
     def __init__(self):
         self.params = {
-            'equation_of_state': 'mgd3',
-            'V_0': 21.49e-6,
-            'K_0': 186.0e9,
-            'Kprime_0': 4.6,
-            'molar_mass': .04567,
-            'n': 2,
-            'Debye_0': 587.,
-            'grueneisen_0': 1.46,
-            'q_0': 1.2}
+            "equation_of_state": "mgd3",
+            "V_0": 21.49e-6,
+            "K_0": 186.0e9,
+            "Kprime_0": 4.6,
+            "molar_mass": 0.04567,
+            "n": 2,
+            "Debye_0": 587.0,
+            "grueneisen_0": 1.46,
+            "q_0": 1.2,
+        }
         Mineral.__init__(self)
 
 
 class Liquid_Fe_Anderson(Mineral):
 
     """
     Anderson & Ahrens, 1994 JGR
     """
 
     def __init__(self):
         self.params = {
-            'equation_of_state': 'bm4',
-            'V_0': 7.95626e-6,
-            'K_0': 109.7e9,
-            'Kprime_0': 4.66,
-            'Kprime_prime_0': -0.043e-9,
-            'molar_mass': 0.055845,
+            "equation_of_state": "bm4",
+            "V_0": 7.95626e-6,
+            "K_0": 109.7e9,
+            "Kprime_0": 4.66,
+            "Kprime_prime_0": -0.043e-9,
+            "molar_mass": 0.055845,
         }
         Mineral.__init__(self)
 
 
 class Fe_Dewaele(Mineral):
 
     """
     Dewaele et al., 2006, Physical Review Letters
     """
 
     def __init__(self):
         self.params = {
-            'equation_of_state': 'vinet',
-            'V_0': 6.75e-6,
-            'K_0': 163.4e9,
-            'Kprime_0': 5.38,
-            'molar_mass': 0.055845,
-            'n': 1}
+            "equation_of_state": "vinet",
+            "V_0": 6.75e-6,
+            "K_0": 163.4e9,
+            "Kprime_0": 5.38,
+            "molar_mass": 0.055845,
+            "n": 1,
+        }
         Mineral.__init__(self)
```

### Comparing `burnman-1.1.0/burnman/optimize/eos_fitting.py` & `burnman-1.2.0/burnman/optimize/eos_fitting.py`

 * *Files 11% similar despite different names*

```diff
@@ -10,544 +10,597 @@
 
 from . import nonlinear_fitting
 from ..utils.misc import flatten
 from ..utils.math import unit_normalize
 from .nonlinear_fitting import nonlinear_least_squares_fit
 
 
-def fit_PTp_data(mineral, fit_params, flags, data, data_covariances=[],
-                 mle_tolerances=[], param_tolerance=1.e-5,
-                 delta_params=None, bounds=None,
-                 max_lm_iterations=50, verbose=True):
+class MineralFit(object):
+    """
+    Class for fitting mineral parameters to experimental data.
+    Instances of this class are passed to
+    :func:`burnman.nonlinear_least_squares_fit`.
+
+    For attributes added to this model when fitting is done,
+    please see the documentation for that function.
+    """
+
+    def __init__(
+        self,
+        mineral,
+        data,
+        data_covariances,
+        flags,
+        fit_params,
+        mle_tolerances,
+        delta_params=None,
+        bounds=None,
+    ):
+        self.m = mineral
+        self.data = data
+        self.data_covariances = data_covariances
+        self.flags = flags
+        self.fit_params = fit_params
+        self.mle_tolerances = mle_tolerances
+        if delta_params is None:
+            self.delta_params = self.get_params() * 1.0e-5 + 1.0e-10
+        else:
+            self.delta_params = delta_params
+        self.bounds = bounds
+
+    def set_params(self, param_values):
+        i = 0
+
+        if self.bounds is not None:
+            param_values = np.clip(param_values, self.bounds[:, 0], self.bounds[:, 1])
+
+        for param in self.fit_params:
+            if isinstance(self.m.params[param], float):
+                self.m.params[param] = param_values[i]
+                i += 1
+            else:
+                for j in range(len(self.m.params[param])):
+                    self.m.params[param][j] = param_values[i]
+                    i += 1
+
+    def get_params(self):
+        params = []
+        for i, param in enumerate(self.fit_params):
+            params.append(self.m.params[param])
+        return np.array(flatten([self.m.params[prm] for prm in self.fit_params]))
+
+    def function(self, x, flag):
+        P, T, p = x
+        self.m.set_state(P, T)
+        return np.array([P, T, getattr(self.m, flag)])
+
+    def normal(self, x, flag):
+        P, T, p = x
+
+        if flag == "V":
+            self.m.set_state(P, T)
+            dPdp = -self.m.K_T / self.m.V
+            dpdT = self.m.alpha * self.m.V
+        elif flag == "H":
+            self.m.set_state(P, T)
+            dPdp = 1.0 / ((1.0 - T * self.m.alpha) * self.m.V)
+            dpdT = self.m.molar_heat_capacity_p
+        elif flag == "S":
+            self.m.set_state(P, T)
+            dPdp = -1.0 / (self.m.alpha * self.m.V)
+            dpdT = self.m.molar_heat_capacity_p / T
+        elif flag == "gibbs":
+            self.m.set_state(P, T)
+            dPdp = 1.0 / self.m.V
+            dpdT = -self.m.S
+        else:
+            dP = 1.0e5
+            dT = 1.0
+            dPdp = (2.0 * dP) / (
+                self.function([P + dP, T, 0.0], flag)[2]
+                - self.function([P - dP, T, 0.0], flag)[2]
+            )
+            dpdT = (
+                self.function([P, T + dT, 0.0], flag)[2]
+                - self.function([P, T - dT, 0.0], flag)[2]
+            ) / (2.0 * dT)
+        dPdT = -dPdp * dpdT
+        n = np.array([-1.0, dPdT, dPdp])
+        return unit_normalize(n)
+
+
+def fit_PTp_data(
+    mineral,
+    fit_params,
+    flags,
+    data,
+    data_covariances=[],
+    mle_tolerances=[],
+    param_tolerance=1.0e-5,
+    delta_params=None,
+    bounds=None,
+    max_lm_iterations=50,
+    verbose=True,
+):
     """
     Given a mineral of any type, a list of fit parameters
     and a set of P-T-property points and (optional) uncertainties,
     this function returns a list of optimized parameters
     and their associated covariances, fitted using the
     scipy.optimize.curve_fit routine.
 
-    Parameters
-    ----------
-    mineral : mineral
-        Mineral for which the parameters should be optimized.
+    :param mineral: Mineral for which the parameters should be optimized.
+    :type mineral: :class:`burnman.Mineral`
 
-    fit_params : list of strings
-        List of dictionary keys contained in mineral.params
+    :param fit_params: List of dictionary keys contained in mineral.params
         corresponding to the variables to be optimized
         during fitting. Initial guesses are taken from the existing
         values for the parameters
+    :type fit_params: list of str
 
-    flags : string or list of strings
-        Attribute names for the property to be fit for the whole
+    :param flags: Attribute names for the property to be fit for the whole
         dataset or each datum individually (e.g. 'V')
+    :type flags: string or list of strings
 
-    data : 2D numpy array of observed X-P-T-property values
+    :param data: Observed X-P-T-property values
+    :type data: 2D numpy.array
 
-    data_covariances : 3D numpy array of X-P-T-property covariances (optional)
+    :param data_covariances: X-P-T-property covariances (optional)
         If not given, all covariance matrices are chosen
         such that all data points have equal weight,
         with all error in the pressure.
+    :type data_covariances: 3D numpy.array
 
-    mle_tolerances : numpy array (optional)
-        Tolerances for termination of the maximum likelihood iterations.
+    :param mle_tolerances: Tolerances for termination of the
+        maximum likelihood iterations (optional).
+    :type mle_tolerances: numpy.array
 
-    param_tolerance : float (optional)
-        Fractional tolerance for termination of the nonlinear optimization.
+    :param param_tolerance: Fractional tolerance for termination
+        of the nonlinear optimization (optional).
+    :type param_tolerance: float
 
-    delta_params : numpy array (optional)
-        Initial values for the change in parameters.
+    :param delta_params: Initial values for the change in parameters (optional).
+    :type delta_params: numpy.array
 
-    bounds : 2D numpy array (optional)
-        Minimum and maximum bounds for the parameters. The shape must be
-        (n_parameters, 2).
-
-    max_lm_iterations : integer (default : 50)
-        Maximum number of Levenberg-Marquardt iterations.
-
-    verbose : boolean (default : True)
-        Whether to print detailed information about the optimization to screen.
-
-    Returns
-    -------
-    model : instance of fitted model
-        Fitting-related attributes are as follows:
-            n_dof : integer
-                Degrees of freedom of the system
-            data_mle : 2D numpy array
-                Maximum likelihood estimates of the observed data points
-                on the best-fit curve
-            jacobian : 2D numpy array
-                d(weighted_residuals)/d(parameter)
-            weighted_residuals : numpy array
-                Weighted residuals
-            weights : numpy array
-                1/(data variances normal to the best fit curve)
-            WSS : float
-                Weighted sum of squares residuals
-            popt : numpy array
-                Optimized parameters
-            pcov : 2D numpy array
-                Covariance matrix of optimized parameters
-            noise_variance : float
-                Estimate of the variance of the data normal to the curve
-    """
+    :param bounds: Minimum and maximum bounds for the parameters (optional).
+        The shape must be (n_parameters, 2).
+    :type bounds: 2D numpy.array
 
-    class Model(object):
-        def __init__(self, mineral, data, data_covariances, flags, fit_params,
-                     mle_tolerances, delta_params=None, bounds=None):
-            self.m = mineral
-            self.data = data
-            self.data_covariances = data_covariances
-            self.flags = flags
-            self.fit_params = fit_params
-            self.mle_tolerances = mle_tolerances
-            if delta_params is None:
-                self.delta_params = self.get_params()*1.e-5 + 1.e-10
-            else:
-                self.delta_params = delta_params
-            self.bounds = bounds
+    :param max_lm_iterations: Maximum number of Levenberg-Marquardt iterations.
+    :type max_lm_iterations: int
 
-        def set_params(self, param_values):
-            i = 0
+    :param verbose: Whether to print detailed information about the
+        optimization to screen.
+    :type verbose: bool
 
-            if self.bounds is not None:
-                param_values = np.clip(param_values,
-                                       self.bounds[:, 0],
-                                       self.bounds[:, 1])
-
-            for param in self.fit_params:
-                if isinstance(self.m.params[param], float):
-                    self.m.params[param] = param_values[i]
-                    i += 1
-                else:
-                    for j in range(len(self.m.params[param])):
-                        self.m.params[param][j] = param_values[i]
-                        i += 1
-
-        def get_params(self):
-            params = []
-            for i, param in enumerate(self.fit_params):
-                params.append(self.m.params[param])
-            return np.array(flatten([mineral.params[prm]
-                                     for prm in fit_params]))
-
-        def function(self, x, flag):
-            P, T, p = x
-            self.m.set_state(P, T)
-            return np.array([P, T, getattr(self.m, flag)])
-
-        def normal(self, x, flag):
-            P, T, p = x
-
-            if flag == 'V':
-                self.m.set_state(P, T)
-                dPdp = -self.m.K_T/self.m.V
-                dpdT = self.m.alpha*self.m.V
-            elif flag == 'H':
-                self.m.set_state(P, T)
-                dPdp = 1./((1.-T*self.m.alpha)*self.m.V)
-                dpdT = self.m.molar_heat_capacity_p
-            elif flag == 'S':
-                self.m.set_state(P, T)
-                dPdp = -1./(self.m.alpha*self.m.V)
-                dpdT = self.m.molar_heat_capacity_p/T
-            elif flag == 'gibbs':
-                self.m.set_state(P, T)
-                dPdp = 1./self.m.V
-                dpdT = -self.m.S
-            else:
-                dP = 1.e5
-                dT = 1.
-                dPdp = (2.*dP)/(self.function([P+dP, T, 0.], flag)[2]
-                                - self.function([P-dP, T, 0.], flag)[2])
-                dpdT = (self.function([P, T+dT, 0.], flag)[2]
-                        - self.function([P, T-dT, 0.], flag)[2])/(2.*dT)
-            dPdT = -dPdp*dpdT
-            n = np.array([-1., dPdT, dPdp])
-            return unit_normalize(n)
+    :returns: Model with optimized parameters.
+    :rtype: :class:`burnman.optimize.eos_fitting.MineralFit`
+    """
 
     # If only one property flag is given, assume it applies to all data
     if type(flags) is str:
         flags = np.array([flags] * len(data[:, 0]))
 
     if len(flags) != len(data):
-        raise Exception(f'The number of flags (n = {len(flags)}) must be equal '
-                        f'to the number of data (n = {len(data)}).')
+        raise Exception(
+            f"The number of flags (n = {len(flags)}) must be equal "
+            f"to the number of data (n = {len(data)})."
+        )
 
     # Apply mle tolerances if they dont exist
     if mle_tolerances == []:
-        mineral.set_state(1.e5, 300.)
-        mle_tolerance_factor = 1.e-5
+        mineral.set_state(1.0e5, 300.0)
+        mle_tolerance_factor = 1.0e-5
         mle_tolerances = np.empty(len(flags))
         for i, flag in enumerate(flags):
-            if flag in ['gibbs', 'enthalpy', 'H', 'helmholtz']:
-                mle_tolerances[i] = 1.  # 1 J
+            if flag in ["gibbs", "enthalpy", "H", "helmholtz"]:
+                mle_tolerances[i] = 1.0  # 1 J
             else:
-                mle_tolerances[i] = mle_tolerance_factor * getattr(mineral,
-                                                                   flag)
+                mle_tolerances[i] = mle_tolerance_factor * getattr(mineral, flag)
 
     # If covariance matrix is not given, apply unit weighting to all pressures
     # (with zero errors on T and p)
     covariances_defined = True
     if data_covariances == []:
         covariances_defined = False
-        data_covariances = np.zeros((len(data[:, 0]),
-                                     len(data[0]), len(data[0])))
+        data_covariances = np.zeros((len(data[:, 0]), len(data[0]), len(data[0])))
         for i in range(len(data_covariances)):
-            data_covariances[i][0][0] = 1.
+            data_covariances[i][0][0] = 1.0
 
-    model = Model(mineral=mineral,
-                  data=data,
-                  data_covariances=data_covariances,
-                  flags=flags,
-                  fit_params=fit_params,
-                  delta_params=delta_params,
-                  mle_tolerances=mle_tolerances,
-                  bounds=bounds)
-
-    nonlinear_least_squares_fit(model,
-                                max_lm_iterations=max_lm_iterations,
-                                param_tolerance=param_tolerance,
-                                verbose=verbose)
+    model = MineralFit(
+        mineral=mineral,
+        data=data,
+        data_covariances=data_covariances,
+        flags=flags,
+        fit_params=fit_params,
+        delta_params=delta_params,
+        mle_tolerances=mle_tolerances,
+        bounds=bounds,
+    )
+
+    nonlinear_least_squares_fit(
+        model,
+        max_lm_iterations=max_lm_iterations,
+        param_tolerance=param_tolerance,
+        verbose=verbose,
+    )
 
     if verbose is True and covariances_defined is True:
         confidence_interval = 0.9
-        d = nonlinear_fitting.extreme_values(model.weighted_residuals,
-                                             confidence_interval)
+        d = nonlinear_fitting.extreme_values(
+            model.weighted_residuals, confidence_interval
+        )
         confidence_bound, indices, probabilities = d
         if indices != []:
-            print('The function nonlinear_fitting.extreme_values'
-                  '(model.weighted_residuals, confidence_interval) '
-                  f'has determined that there are {len(indices):d} data points'
-                  ' which have residuals which are not expected at the '
-                  f'{confidence_interval*100.:.1f}% confidence level '
-                  f'(> {confidence_bound:.1f} s.d. away from the model fit).\n'
-                  'Their indices and the probabilities of finding '
-                  'such extreme values are:')
+            print(
+                "The function nonlinear_fitting.extreme_values"
+                "(model.weighted_residuals, confidence_interval) "
+                f"has determined that there are {len(indices):d} data points"
+                " which have residuals which are not expected at the "
+                f"{confidence_interval*100.:.1f}% confidence level "
+                f"(> {confidence_bound:.1f} s.d. away from the model fit).\n"
+                "Their indices and the probabilities of finding "
+                "such extreme values are:"
+            )
             for i, idx in enumerate(indices):
-                print(f'[{idx:d}]: {probabilities[i]:.4f} '
-                      f'({np.abs(model.weighted_residuals[idx]):.1f} s.d. '
-                      'from the model)')
-            print('You might consider removing them from your fit, '
-                  'or increasing the uncertainties in their '
-                  'measured values.\n')
+                print(
+                    f"[{idx:d}]: {probabilities[i]:.4f} "
+                    f"({np.abs(model.weighted_residuals[idx]):.1f} s.d. "
+                    "from the model)"
+                )
+            print(
+                "You might consider removing them from your fit, "
+                "or increasing the uncertainties in their "
+                "measured values.\n"
+            )
 
     return model
 
 
-def fit_PTV_data(mineral, fit_params,
-                 data, data_covariances=[],
-                 delta_params=None, bounds=None,
-                 param_tolerance=1.e-5, max_lm_iterations=50,
-                 verbose=True):
+def fit_PTV_data(
+    mineral,
+    fit_params,
+    data,
+    data_covariances=[],
+    delta_params=None,
+    bounds=None,
+    param_tolerance=1.0e-5,
+    max_lm_iterations=50,
+    verbose=True,
+):
     """
     A simple alias for the fit_PTp_data for when all the data is volume data
     """
 
-    return fit_PTp_data(mineral=mineral, flags='V',
-                        data=data, data_covariances=data_covariances,
-                        fit_params=fit_params, param_tolerance=param_tolerance,
-                        delta_params=delta_params, bounds=bounds,
-                        max_lm_iterations=max_lm_iterations, verbose=verbose)
+    return fit_PTp_data(
+        mineral=mineral,
+        flags="V",
+        data=data,
+        data_covariances=data_covariances,
+        fit_params=fit_params,
+        param_tolerance=param_tolerance,
+        delta_params=delta_params,
+        bounds=bounds,
+        max_lm_iterations=max_lm_iterations,
+        verbose=verbose,
+    )
+
 
+class SolutionFit(object):
+    """
+    Class for fitting mineral parameters to experimental data.
+    Instances of this class are passed to
+    :func:`burnman.nonlinear_least_squares_fit`.
 
-def fit_XPTp_data(solution, fit_params, flags, data, data_covariances=[],
-                  mle_tolerances=[], param_tolerance=1.e-5,
-                  delta_params=None, bounds=None,
-                  max_lm_iterations=50, verbose=True):
+    For attributes added to this model when fitting is done,
+    please see the documentation for that function.
+    """
+
+    def __init__(
+        self,
+        solution,
+        data,
+        data_covariances,
+        flags,
+        fit_params,
+        mle_tolerances,
+        delta_params=None,
+        bounds=None,
+    ):
+        self.m = solution
+        self.data = data
+        self.data_covariances = data_covariances
+        self.flags = flags
+        self.fit_params = fit_params
+        self.fit_params_strings = []
+        for p in fit_params:
+            if isinstance(p, list):
+                csv_list_mbrs = ",".join([str(i) for i in p[1:]])
+                self.fit_params_strings.append(f"{p[0]} ({csv_list_mbrs})")
+            else:
+                self.fit_params_strings.append(p)
+
+        self.mle_tolerances = mle_tolerances
+        if delta_params is None:
+            self.delta_params = self.get_params() * 1.0e-5 + 1.0e-10
+        else:
+            self.delta_params = delta_params
+        self.bounds = bounds
+
+    def set_params(self, param_values):
+        # fit_params is a list of lists
+        # if the list has length 2, the first item should be an integer
+        # indicating the endmember number in the solution
+        # if the list has length 3, the first two items should be endmember
+        # numbers, and the third should be the interaction parameter type
+        # (E, S or V).
+        i = 0
+
+        if self.bounds is not None:
+            param_values = np.clip(param_values, self.bounds[:, 0], self.bounds[:, 1])
+
+        for param in self.fit_params:
+            value = param_values[i]
+            if len(param) == 2:
+                key, imbr = param
+                if isinstance(self.m.endmembers[imbr][0].params[key], float):
+                    self.m.endmembers[imbr][0].params[key] = value
+                    i += 1
+                else:
+                    n_values = len(self.m.endmembers[imbr][0].params[key])
+                    for j in range(n_values):
+                        self.m.endmembers[imbr][0].params[key][j] = value
+                        i += 1
+            elif len(param) == 3:
+                key, imbr, jmbr = param
+                ai = self.m.solution_model.alphas[imbr]
+                aj = self.m.solution_model.alphas[jmbr]
+                if key == "E":
+                    self.m.solution_model.We[imbr, jmbr] = 2.0 * value / (ai * aj)
+                if key == "S":
+                    self.m.solution_model.Ws[imbr, jmbr] = 2.0 * value / (ai * aj)
+                if key == "V":
+                    self.m.solution_model.Wv[imbr, jmbr] = 2.0 * value / (ai * aj)
+
+                i += 1
+            else:
+                raise Exception("param length must be two or three")
+
+    def get_params(self):
+        params = []
+        for param in self.fit_params:
+            if len(param) == 2:
+                key, imbr = param
+                value = self.m.endmembers[imbr][0].params[key]
+                if isinstance(value, float):
+                    params.append(value)
+                else:
+                    params.extend(list(value))
+
+            elif len(param) == 3:
+                key, imbr, jmbr = param
+                ai = self.m.solution_model.alphas[imbr]
+                aj = self.m.solution_model.alphas[jmbr]
+                if key == "E":
+                    params.append(
+                        self.m.solution_model.We[imbr, jmbr] * (ai * aj) / 2.0
+                    )
+                if key == "S":
+                    params.append(
+                        self.m.solution_model.Ws[imbr, jmbr] * (ai * aj) / 2.0
+                    )
+                if key == "V":
+                    params.append(
+                        self.m.solution_model.Wv[imbr, jmbr] * (ai * aj) / 2.0
+                    )
+            else:
+                raise Exception("param length must be two or three")
+        return np.array(params)
+
+    def function(self, x, flag):
+        self.m.set_composition(x[: self.m.n_endmembers])
+        P, T, p = x[self.m.n_endmembers :]
+        self.m.set_state(P, T)
+
+        f = np.copy(x)
+        f[-1] = getattr(self.m, flag)
+        return f
+
+    def normal(self, x, flag):
+        self.m.set_composition(x[: self.m.n_endmembers])
+        P, T, p = x[self.m.n_endmembers :]
+
+        if flag == "V":
+            self.m.set_state(P, T)
+            dPdp = -self.m.K_T / self.m.V
+            dpdT = self.m.alpha * self.m.V
+        elif flag == "H":
+            self.m.set_state(P, T)
+            dPdp = 1.0 / ((1.0 - T * self.m.alpha) * self.m.V)
+            dpdT = self.m.molar_heat_capacity_p
+        elif flag == "S":
+            self.m.set_state(P, T)
+            dPdp = -1.0 / (self.m.alpha * self.m.V)
+            dpdT = self.m.molar_heat_capacity_p / T
+        elif flag == "gibbs":
+            self.m.set_state(P, T)
+            dPdp = 1.0 / self.m.V
+            dpdT = -self.m.S
+        else:
+            dP = 1.0e5
+            dT = 1.0
+            xP0 = np.copy(x)
+            xP1 = np.copy(x)
+            xT0 = np.copy(x)
+            xT1 = np.copy(x)
+            xP0[-3] = xP1[-3] - dP
+            xP1[-3] = xP1[-3] + dP
+            xT0[-2] = xP1[-2] - dT
+            xT1[-2] = xP1[-2] + dT
+
+            dPdp = (2.0 * dP) / (
+                self.function(xP1, flag)[2] - self.function(xP0, flag)[2]
+            )
+            dpdT = (self.function(xT1, flag)[2] - self.function(xT0, flag)[2]) / (
+                2.0 * dT
+            )
+        dPdT = -dPdp * dpdT
+        n = np.zeros(len(x))
+        n[-3:] = np.array([-1.0, dPdT, dPdp])
+        return unit_normalize(n)
+
+
+def fit_XPTp_data(
+    solution,
+    fit_params,
+    flags,
+    data,
+    data_covariances=[],
+    mle_tolerances=[],
+    param_tolerance=1.0e-5,
+    delta_params=None,
+    bounds=None,
+    max_lm_iterations=50,
+    verbose=True,
+):
     """
     Given a symmetric solution, a list of fit parameters
     and a set of P-T-property points and (optional) uncertainties,
     this function returns a list of optimized parameters
     and their associated covariances, fitted using the
     scipy.optimize.curve_fit routine.
 
-    Parameters
-    ----------
-    solution : Solution
-        Solution for which the parameters should be optimized.
+    :param solution: Solution for which the parameters should be optimized.
+    :type solution: :class:`burnman.Solution`
 
-    fit_params : list of lists
-        List of lists corresponding to the variables to be optimized
+    :param fit_params: Variables to be optimized
         during fitting. Each list is either of length two or three.
         The first item of length-2 lists should be a
         dictionary key contained in one of the endmember
         mineral.params, and the second item should be the index of
         the endmember in the solution (indexing starts from 0).
         The first item of length-3 lists should be one of 'E', 'S' or
         'V' (the excess energies, entropies or volumes in each binary).
         The second two items should be the indices of the pair of
         endmembers bounding the binary, in ascending order
         (indexing starts from 0). Initial guesses are taken from the existing
         values for the parameters.
+    :type fit_params: list of lists
 
-    flags : string or list of strings
-        Attribute names for the property to be fit for the whole
+    :param flags: Attribute names for the property to be fit for the whole
         dataset or each datum individually (e.g. 'V')
+    :type flags: string or list of strings
 
-    data : 2D numpy array of observed X-P-T-property values
+    :param data: Observed X-P-T-property values
+    :type data: 2D numpy.array
 
-    data_covariances : 3D numpy array of X-P-T-property covariances (optional)
+    :param data_covariances: X-P-T-property covariances (optional).
         If not given, all covariance matrices are chosen
         such that all data points have equal weight,
         with all error in the pressure.
+    :type data_covariances: 3D numpy.array
 
-    mle_tolerances : numpy array (optional)
-        Tolerances for termination of the maximum likelihood iterations.
+    :param mle_tolerances: Tolerances for termination of the
+        maximum likelihood iterations (optional).
+    :type mle_tolerances: numpy.array
 
-    param_tolerance : float (optional)
-        Fractional tolerance for termination of the nonlinear optimization.
+    :param param_tolerance: Fractional tolerance for termination
+        of the nonlinear optimization (optional).
+    :type param_tolerance: float
 
-    delta_params : numpy array (optional)
-        Initial values for the change in parameters.
+    :param delta_params: Initial values for the change in parameters (optional).
+    :type delta_params: numpy.array
 
-    bounds : 2D numpy array (optional)
-        Minimum and maximum bounds for the parameters. The shape must be
-        (n_parameters, 2).
-
-    max_lm_iterations : integer (default : 50)
-        Maximum number of Levenberg-Marquardt iterations.
-
-    verbose : boolean (default : True)
-        Whether to print detailed information about the optimization to screen.
-
-    Returns
-    -------
-    model : instance of fitted model
-        Fitting-related attributes are as follows:
-            n_dof : integer
-                Degrees of freedom of the system
-            data_mle : 2D numpy array
-                Maximum likelihood estimates of the observed data points
-                on the best-fit curve
-            jacobian : 2D numpy array
-                d(weighted_residuals)/d(parameter)
-            weighted_residuals : numpy array
-                Weighted residuals
-            weights : numpy array
-                1/(data variances normal to the best fit curve)
-            WSS : float
-                Weighted sum of squares residuals
-            fit_params : list of lists
-                The parameter lists in their original form
-            fit_params_strings : list of strings
-                The parameters in user-readable string form
-            popt : numpy array
-                Optimized parameters
-            pcov : 2D numpy array
-                Covariance matrix of optimized parameters
-            noise_variance : float
-                Estimate of the variance of the data normal to the curve
-    """
-
-    class Model(object):
-        def __init__(self, solution, data, data_covariances, flags, fit_params,
-                     mle_tolerances, delta_params=None, bounds=None):
-            self.m = solution
-            self.data = data
-            self.data_covariances = data_covariances
-            self.flags = flags
-            self.fit_params = fit_params
-            self.fit_params_strings = []
-            for p in fit_params:
-                if isinstance(p, list):
-                    csv_list_mbrs = ",".join([str(i) for i in p[1:]])
-                    self.fit_params_strings.append(f'{p[0]} ({csv_list_mbrs})')
-                else:
-                    self.fit_params_strings.append(p)
-
-            self.mle_tolerances = mle_tolerances
-            if delta_params is None:
-                self.delta_params = self.get_params()*1.e-5 + 1.e-10
-            else:
-                self.delta_params = delta_params
-            self.bounds = bounds
+    :param bounds: Minimum and maximum bounds for the parameters (optional).
+        The shape must be (n_parameters, 2).
+    :type bounds: 2D numpy.array
 
-        def set_params(self, param_values):
-            # fit_params is a list of lists
-            # if the list has length 2, the first item should be an integer
-            # indicating the endmember number in the solution
-            # if the list has length 3, the first two items should be endmember
-            # numbers, and the third should be the interaction parameter type
-            # (E, S or V).
-            i = 0
-
-            if self.bounds is not None:
-                param_values = np.clip(param_values,
-                                       self.bounds[:, 0],
-                                       self.bounds[:, 1])
-
-            for param in self.fit_params:
-                value = param_values[i]
-                if len(param) == 2:
-                    key, imbr = param
-                    if isinstance(self.m.endmembers[imbr][0].params[key],
-                                  float):
-                        self.m.endmembers[imbr][0].params[key] = value
-                        i += 1
-                    else:
-                        n_values = len(self.m.endmembers[imbr][0].params[key])
-                        for j in range(n_values):
-                            self.m.endmembers[imbr][0].params[key][j] = value
-                            i += 1
-                elif len(param) == 3:
-                    key, imbr, jmbr = param
-                    ai = self.m.solution_model.alphas[imbr]
-                    aj = self.m.solution_model.alphas[jmbr]
-                    if key == 'E':
-                        self.m.solution_model.We[imbr, jmbr] = 2.*value/(ai*aj)
-                    if key == 'S':
-                        self.m.solution_model.Ws[imbr, jmbr] = 2.*value/(ai*aj)
-                    if key == 'V':
-                        self.m.solution_model.Wv[imbr, jmbr] = 2.*value/(ai*aj)
+    :param max_lm_iterations: Maximum number of Levenberg-Marquardt iterations.
+    :type max_lm_iterations: int
 
-                    i += 1
-                else:
-                    raise Exception('param length must be two or three')
-
-        def get_params(self):
-            params = []
-            for param in self.fit_params:
-                if len(param) == 2:
-                    key, imbr = param
-                    value = self.m.endmembers[imbr][0].params[key]
-                    if isinstance(value, float):
-                        params.append(value)
-                    else:
-                        params.extend(list(value))
-
-                elif len(param) == 3:
-                    key, imbr, jmbr = param
-                    ai = self.m.solution_model.alphas[imbr]
-                    aj = self.m.solution_model.alphas[jmbr]
-                    if key == 'E':
-                        params.append(self.m.solution_model.We[imbr, jmbr]
-                                      * (ai * aj)/2.)
-                    if key == 'S':
-                        params.append(self.m.solution_model.Ws[imbr, jmbr]
-                                      * (ai * aj)/2.)
-                    if key == 'V':
-                        params.append(self.m.solution_model.Wv[imbr, jmbr]
-                                      * (ai * aj)/2.)
-                else:
-                    raise Exception('param length must be two or three')
-            return np.array(params)
-
-        def function(self, x, flag):
-            self.m.set_composition(x[:self.m.n_endmembers])
-            P, T, p = x[self.m.n_endmembers:]
-            self.m.set_state(P, T)
-
-            f = np.copy(x)
-            f[-1] = getattr(self.m, flag)
-            return f
-
-        def normal(self, x, flag):
-            self.m.set_composition(x[:self.m.n_endmembers])
-            P, T, p = x[self.m.n_endmembers:]
-
-            if flag == 'V':
-                self.m.set_state(P, T)
-                dPdp = -self.m.K_T/self.m.V
-                dpdT = self.m.alpha*self.m.V
-            elif flag == 'H':
-                self.m.set_state(P, T)
-                dPdp = 1./((1.-T*self.m.alpha)*self.m.V)
-                dpdT = self.m.molar_heat_capacity_p
-            elif flag == 'S':
-                self.m.set_state(P, T)
-                dPdp = -1./(self.m.alpha*self.m.V)
-                dpdT = self.m.molar_heat_capacity_p/T
-            elif flag == 'gibbs':
-                self.m.set_state(P, T)
-                dPdp = 1./self.m.V
-                dpdT = -self.m.S
-            else:
-                dP = 1.e5
-                dT = 1.
-                xP0 = np.copy(x)
-                xP1 = np.copy(x)
-                xT0 = np.copy(x)
-                xT1 = np.copy(x)
-                xP0[-3] = xP1[-3] - dP
-                xP1[-3] = xP1[-3] + dP
-                xT0[-2] = xP1[-2] - dT
-                xT1[-2] = xP1[-2] + dT
-
-                dPdp = (2.*dP)/(self.function(xP1, flag)[2]
-                                - self.function(xP0, flag)[2])
-                dpdT = (self.function(xT1, flag)[2]
-                        - self.function(xT0, flag)[2])/(2.*dT)
-            dPdT = -dPdp*dpdT
-            n = np.zeros(len(x))
-            n[-3:] = np.array([-1., dPdT, dPdp])
-            return unit_normalize(n)
+    :param verbose: Whether to print detailed information about the
+        optimization to screen.
+    :type verbose: bool
 
+    :returns: Model with optimized parameters.
+    :rtype: :class:`burnman.optimize.eos_fitting.SolutionFit`
+    """
     # If only one property flag is given, assume it applies to all data
     if type(flags) is str:
         flags = np.array([flags] * len(data[:, 0]))
 
     if len(flags) != len(data):
-        raise Exception(f'The number of flags (n = {len(flags)}) must be equal '
-                        f'to the number of data (n = {len(data)}).')
+        raise Exception(
+            f"The number of flags (n = {len(flags)}) must be equal "
+            f"to the number of data (n = {len(data)})."
+        )
 
     # Apply mle tolerances if they dont exist
     if mle_tolerances == []:
-        solution.set_state(1.e5, 300.)
-        mle_tolerance_factor = 1.e-5
+        solution.set_state(1.0e5, 300.0)
+        mle_tolerance_factor = 1.0e-5
         mle_tolerances = np.empty(len(flags))
         for i, flag in enumerate(flags):
-            if flag in ['gibbs', 'enthalpy', 'H', 'helmholtz']:
-                mle_tolerances[i] = 1.  # 1 J
+            if flag in ["gibbs", "enthalpy", "H", "helmholtz"]:
+                mle_tolerances[i] = 1.0  # 1 J
             else:
-                mle_tolerances[i] = mle_tolerance_factor*getattr(solution,
-                                                                 flag)
+                mle_tolerances[i] = mle_tolerance_factor * getattr(solution, flag)
 
     # If covariance matrix is not given, apply unit weighting to all pressures
     # (with zero errors on T and property)
     covariances_defined = True
     if data_covariances == []:
         covariances_defined = False
         nX = solution.n_endmembers
-        data_covariances = np.zeros((len(data[:, 0]),
-                                     len(data[0]), len(data[0])))
+        data_covariances = np.zeros((len(data[:, 0]), len(data[0]), len(data[0])))
         for i in range(len(data_covariances)):
-            data_covariances[i][nX][nX] = 1.
+            data_covariances[i][nX][nX] = 1.0
 
-    model = Model(solution=solution,
-                  data=data,
-                  data_covariances=data_covariances,
-                  flags=flags,
-                  fit_params=fit_params,
-                  mle_tolerances=mle_tolerances,
-                  delta_params=delta_params,
-                  bounds=bounds)
-
-    nonlinear_least_squares_fit(model,
-                                max_lm_iterations=max_lm_iterations,
-                                param_tolerance=param_tolerance,
-                                verbose=verbose)
+    model = SolutionFit(
+        solution=solution,
+        data=data,
+        data_covariances=data_covariances,
+        flags=flags,
+        fit_params=fit_params,
+        mle_tolerances=mle_tolerances,
+        delta_params=delta_params,
+        bounds=bounds,
+    )
+
+    nonlinear_least_squares_fit(
+        model,
+        max_lm_iterations=max_lm_iterations,
+        param_tolerance=param_tolerance,
+        verbose=verbose,
+    )
 
     if verbose is True and covariances_defined is True:
         confidence_interval = 0.9
-        v_extreme = nonlinear_fitting.extreme_values(model.weighted_residuals,
-                                                     confidence_interval)
+        v_extreme = nonlinear_fitting.extreme_values(
+            model.weighted_residuals, confidence_interval
+        )
         confidence_bound, indices, probabilities = v_extreme
         if indices != []:
-            print('The function nonlinear_fitting.extreme_values'
-                  '(model.weighted_residuals, confidence_interval) '
-                  f'has determined that there are {len(indices):d} '
-                  'data points which have residuals which are not '
-                  f'expected at the {confidence_interval*100.:.1f}% '
-                  'confidence level '
-                  f'(> {confidence_bound:.1f} s.d. away from the model fit).\n'
-                  'Their indices and the probabilities of '
-                  'finding such extreme values are:')
+            print(
+                "The function nonlinear_fitting.extreme_values"
+                "(model.weighted_residuals, confidence_interval) "
+                f"has determined that there are {len(indices):d} "
+                "data points which have residuals which are not "
+                f"expected at the {confidence_interval*100.:.1f}% "
+                "confidence level "
+                f"(> {confidence_bound:.1f} s.d. away from the model fit).\n"
+                "Their indices and the probabilities of "
+                "finding such extreme values are:"
+            )
             for i, idx in enumerate(indices):
-                print(f'[{idx:d}]: {probabilities[i]:.4f} '
-                      f'({np.abs(model.weighted_residuals[idx]):.1f} s.d. '
-                      'from the model)')
-            print('You might consider removing them from your fit, '
-                  'or increasing the uncertainties in '
-                  'their measured values.\n')
+                print(
+                    f"[{idx:d}]: {probabilities[i]:.4f} "
+                    f"({np.abs(model.weighted_residuals[idx]):.1f} s.d. "
+                    "from the model)"
+                )
+            print(
+                "You might consider removing them from your fit, "
+                "or increasing the uncertainties in "
+                "their measured values.\n"
+            )
 
     return model
```

### Comparing `burnman-1.1.0/burnman/optimize/linear_fitting.py` & `burnman-1.2.0/burnman/optimize/linear_fitting.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,100 +7,99 @@
 
 import importlib
 import numpy as np
 from scipy.linalg import inv, sqrtm
 import warnings
 
 try:
-    cp = importlib.import_module('cvxpy')
+    cp = importlib.import_module("cvxpy")
 except ImportError as err:
-    print(f'Warning: {err}. '
-          'For full functionality of BurnMan, please install cvxpy.')
+    print(
+        f"Warning: {err}. " "For full functionality of BurnMan, please install cvxpy."
+    )
 
 
-def weighted_constrained_least_squares(A, b, Cov_b=None,
-                                       equality_constraints=None,
-                                       inequality_constraints=None):
+def weighted_constrained_least_squares(
+    A, b, Cov_b=None, equality_constraints=None, inequality_constraints=None
+):
     """
     Solves a weighted, constrained least squares problem using cvxpy.
     The objective function is to minimize the following:
     sum_squares(Cov_b^(-1/2).A.x - Cov_b^(-1/2).b))
     subject to
     C.x == c
     D.x <= d
 
-    Parameters
-    ----------
-    A : 2D numpy array
-        The matrix A in the objective function above.
+    :param A: An array defining matrix A in the objective function above.
+    :type A: 2D numpy array
 
-    b : numpy array
-        The vector b in the objective function above.
+    :param b: An array defining vector b in the objective function above.
+    :type b: numpy array
 
-    Cov_b : 2D numpy array
-        The covariance matrix associated with b
+    :param Cov_b: A covariance matrix associated with b
+    :type Cov_b: 2D numpy array
 
-    equality_constraints : list containing a 2D array and 1D array
-        The list contains the matrices C and c in the objective function above.
-
-    inequality_constraints : list containing a 2D array and 1D array
-        The list contains the matrices D and d in the objective function above.
-
-
-    Returns
-    -------
-    popt : numpy array
-        Optimized phase amounts.
-
-    pcov : 2D numpy array
-        Covariance matrix corresponding to the optimized phase amounts.
-
-    res : float
-        The weighted residual of the fitting procedure.
+    :param equality_constraints: A list containing the matrices C and c
+        in the objective function above.
+    :type equality_constraints: list containing a 2D array and 1D array
+
+    :param inequality_constraints: A list containing the matrices D and d
+        in the objective function above.
+    :type inequality_constraints: list containing a 2D array and 1D array
+
+    :returns: Tuple containing the optimized phase amounts (1D numpy.array),
+        a covariance matrix corresponding to the optimized phase amounts
+        (2D numpy.array), and the weighted residual of the fitting procedure
+        (a float).
+    :rtype: tuple
     """
 
     if Cov_b is None:
         Cov_b = np.eye(len(b))
 
     # Create the standard weighted least squares objective function
     # (https://stats.stackexchange.com/a/333551)
     n_vars = A.shape[1]
     m = inv(sqrtm(Cov_b))
-    mA = m@A
-    mb = m@b
+    mA = m @ A
+    mb = m @ b
     x = cp.Variable(n_vars)
-    objective = cp.Minimize(cp.sum_squares(mA@x - mb))
+    objective = cp.Minimize(cp.sum_squares(mA @ x - mb))
 
     constraints = []
     if equality_constraints is not None:
         n_eq_csts = len(equality_constraints[0])
-        constraints = [equality_constraints[0][i]@x
-                       == equality_constraints[1][i]
-                       for i in range(n_eq_csts)]
+        constraints = [
+            equality_constraints[0][i] @ x == equality_constraints[1][i]
+            for i in range(n_eq_csts)
+        ]
 
     if inequality_constraints is not None:
         n_ineq_csts = len(inequality_constraints[0])
-        constraints.extend([inequality_constraints[0][i]@x
-                            <= inequality_constraints[1][i]
-                            for i in range(n_ineq_csts)])
+        constraints.extend(
+            [
+                inequality_constraints[0][i] @ x <= inequality_constraints[1][i]
+                for i in range(n_ineq_csts)
+            ]
+        )
 
     # Set up the problem and solve it
     warns = []
     if len(constraints) > 1:
         prob = cp.Problem(objective, constraints)
     else:
         prob = cp.Problem(objective)
 
     try:
         with warnings.catch_warnings(record=True) as w:
             res = prob.solve(solver=cp.ECOS)
             popt = np.array([x.value[i] for i in range(len(A.T))])
             warns.extend(w)
     except Exception:
-        print('ECOS Solver failed. Trying default solver.')
+        print("ECOS Solver failed. Trying default solver.")
         try:
             with warnings.catch_warnings(record=True) as w:
                 res = prob.solve()
                 popt = np.array([x.value[i] for i in range(len(A.T))])
                 warns.extend(w)
         except Exception as e:
             raise Exception(e)
```

### Comparing `burnman-1.1.0/burnman/optimize/nonlinear_fitting.py` & `burnman-1.2.0/burnman/optimize/nonlinear_fitting.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,265 +12,249 @@
 
 from ..utils.math import unit_normalize
 import matplotlib.pyplot as plt
 import matplotlib.colors as colors
 from matplotlib.patches import Ellipse
 
 
-def nonlinear_least_squares_fit(model,
-                                lm_damping=0.,
-                                param_tolerance=1.e-7,
-                                max_lm_iterations=100,
-                                verbose=False):
+def nonlinear_least_squares_fit(
+    model, lm_damping=0.0, param_tolerance=1.0e-7, max_lm_iterations=100, verbose=False
+):
     """
     Function to compute the "best-fit" parameters for a model
     by nonlinear least squares fitting.
 
     The nonlinear least squares algorithm closely follows the logic in
     Section 23.1 of Bayesian Probability Theory
     (von der Linden et al., 2014; Cambridge University Press).
 
     Parameters
     ----------
-    model : class instance
-        Must have the following attributes:
-            data : 2D numpy array.
-                Elements of x[i][j] contain the observed position of
-                data point i
-
-            data_covariances : 3D numpy array
-                Elements of cov[i][j][k] contain the covariance matrix
-                of data point i
-
-            mle_tolerances : numpy array
-                The iterations to find the maximum likelihood estimator
-                for each observed data point will stop when mle_tolerances[i] <
-                np.linalg.norm(data_mle[i] - model.function(data_mle[i], flag))
-
-            delta_params : numpy array
-                parameter perturbations used to compute the jacobian
-
-        Must also contain the following functions:
-            set_params(self, param_values):
-                Function to set parameters
-
-            get_params(self):
-                Function to get current model parameters
-
-            function(self, x):
-                Returns value of model function evaluated at x
-
-            normal(self, x):
-                Returns value of normal to the model function
-                evaluated at x
+    :param model: Model containing data to be fit, and functions to
+        aid in fitting.
+    :type model: object
 
-    lm_damping : float (optional, default: 0)
-        Levenberg-Marquardt parameter for least squares minimization
+    :param lm_damping: Levenberg-Marquardt parameter for least squares minimization.
+    :type lm_damping: float
 
-    param_tolerance : float (optional, default: 1.e-5)
-        Levenberg-Marquardt iterations are terminated when
+    :param param_tolerance: Levenberg-Marquardt iterations are terminated when
         the maximum fractional change in any of the parameters
         during an iteration drops below this value
+    :type param_tolerance: float
 
-    max_lm_iterations : integer (optional, default: 100)
-        Maximum number of Levenberg-Marquardt iterations
 
-    verbose : bool
-        Print some information to standard output
+    :param max_lm_iterations: Maximum number of Levenberg-Marquardt iterations
+    :type max_lm_iterations: int
 
+    :param verbose: Print some information to standard output
+    :type verbose: bool
 
-    Attributes added to model
-    ----------
-    n_dof : integer
-        Degrees of freedom of the system
-    data_mle : 2D numpy array
-        Maximum likelihood estimates of the observed data points
-        on the best-fit curve
-    jacobian : 2D numpy array
-        d(weighted_residuals)/d(parameter)
-    weighted_residuals : numpy array
-        Weighted residuals
-    weights : numpy array
-        1/(data variances normal to the best fit curve)
-    WSS : float
-        Weighted sum of squares residuals
-    popt : numpy array
-        Optimized parameters
-    pcov : 2D numpy array
-        Covariance matrix of optimized parameters
-    noise_variance : float
-        Estimate of the variance of the data normal to the curve
+    .. note:: The object passed as model must have the following attributes:
+        * data [2D numpy.array] - Elements of x[i][j] contain the
+            observed position of data point i.
+        * data_covariances [3D numpy.array] Elements of cov[i][j][k] contain
+            the covariance matrix of data point i.
+        * mle_tolerances [numpy.array] - The iterations to find the maximum likelihood
+            estimator for each observed data point will stop when mle_tolerances[i] <
+            np.linalg.norm(data_mle[i] - model.function(data_mle[i], flag))
+        * delta_params [numpy.array] - parameter perturbations used to compute the jacobian
+
+        Must also have the following methods:
+        * set_params(self, param_values) -  Function to set parameters.
+        * get_params(self) - Function to get current model parameters.
+        * function(self, x) - Returns value of model function evaluated at x.
+        * normal(self, x) - Returns value of normal to the model function evaluated at x.
+
+        After this function has been performed, the following attributes are added to model:
+
+        * n_dof [int] - Degrees of freedom of the system.
+        * data_mle [2D numpy array] - Maximum likelihood estimates of the observed data points
+            on the best-fit curve.
+        * jacobian [2D numpy array] - d(weighted_residuals)/d(parameter).
+        * weighted_residuals [numpy array] - Weighted residuals.
+        * weights [numpy array] - 1/(data variances normal to the best fit curve).
+        * WSS [float] - Weighted sum of squares residuals.
+        * popt [numpy array] - Optimized parameters.
+        * pcov [2D numpy array] - Covariance matrix of optimized parameters.
+        * noise_variance [float] - Estimate of the variance of the data normal to the curve.
 
     This function is available as ``burnman.nonlinear_least_squares_fit``.
     """
 
     def _mle_estimate(x, x_m, cov, flag):
         n = model.normal(x_m, flag)
         var_n = abs_line_project(cov, n)
         d = (x_m - x).dot(n)
-        x_mle = x + d*((n.dot(cov)).T)/var_n
+        x_mle = x + d * ((n.dot(cov)).T) / var_n
         return x_mle, d, var_n
 
     def _find_mle():
         x_mle_arr = np.empty_like(model.data)
         residual_arr = np.empty(n_data)
         var_arr = np.empty(n_data)
-        for i, (x, cov, flag) in enumerate(zip(*[model.data,
-                                                 model.data_covariances,
-                                                 model.flags])):
+        for i, (x, cov, flag) in enumerate(
+            zip(*[model.data, model.data_covariances, model.flags])
+        ):
             x_mle_arr[i] = model.function(x, flag)
             x_mle_est, residual_arr[i], var_arr[i] = _mle_estimate(
-                x, x_mle_arr[i], cov, flag)
+                x, x_mle_arr[i], cov, flag
+            )
             delta_x = x_mle_arr[i] - x
 
             while np.linalg.norm(delta_x) > model.mle_tolerances[i]:
                 x_mle_est, residual_arr[i], var_arr[i] = _mle_estimate(
-                    x, x_mle_arr[i], cov, flag)
+                    x, x_mle_arr[i], cov, flag
+                )
                 x_mle_arr[i] = model.function(x_mle_est, flag)
                 delta_x = x_mle_arr[i] - x_mle_est
 
-        return x_mle_arr, residual_arr/np.sqrt(var_arr), 1./var_arr
+        return x_mle_arr, residual_arr / np.sqrt(var_arr), 1.0 / var_arr
 
     def calculate_jacobian():
         model.jacobian = np.empty((n_data, n_params))
         diag_delta = np.diag(model.delta_params)
         param_values = model.get_params()
         for prm_i, value in enumerate(param_values):
-
             model.set_params(param_values - diag_delta[prm_i])
             x_mle_arr, residual_arr_0, weights_0 = _find_mle()
 
             model.set_params(param_values + diag_delta[prm_i])
             x_mle_arr, residual_arr_1, weights_1 = _find_mle()
 
-            model.jacobian[:, prm_i] = ((residual_arr_1 - residual_arr_0)
-                                        / (2.*diag_delta[prm_i][prm_i]))
+            model.jacobian[:, prm_i] = (residual_arr_1 - residual_arr_0) / (
+                2.0 * diag_delta[prm_i][prm_i]
+            )
         model.set_params(param_values)  # reset params
 
     def _update_beta(lmbda):
         # Performs a Levenberg-Marquardt iteration
         # Note that if lambda = 0, this is a simple Gauss-Newton iteration
         calculate_jacobian()
         model.data_mle, model.weighted_residuals, model.weights = _find_mle()
 
         J = model.jacobian  # this the weighted Jacobian
         JTJ = J.T.dot(J)
-        delta_beta = np.linalg.inv(
-            JTJ + lmbda*np.diag(JTJ)).dot(J.T).dot(model.weighted_residuals)
+        delta_beta = (
+            np.linalg.inv(JTJ + lmbda * np.diag(JTJ))
+            .dot(J.T)
+            .dot(model.weighted_residuals)
+        )
         old_params = np.copy(model.get_params())
         new_params = old_params - delta_beta
         # f_delta_beta = delta_beta/new_params
 
         model.set_params(new_params)
 
         # set_params may modify the step to satisfy bounds on the problem
         # We therefore need to get the params before
         # calculating the fractional change.
         new_params = model.get_params()
 
         # In case the new_params object returns a very small value,
         # modify to avoid a pointless comparison:
-        mod_params = np.where(np.abs(new_params) < param_tolerance,
-                              param_tolerance, new_params)
-        f_delta_beta = (old_params - new_params)/mod_params
+        mod_params = np.where(
+            np.abs(new_params) < param_tolerance, param_tolerance, new_params
+        )
+        f_delta_beta = (old_params - new_params) / mod_params
         return f_delta_beta
 
     n_data = len(model.data)
     params = model.get_params()
     n_params = len(params)
     model.dof = n_data - n_params
 
-    if not hasattr(model, 'flags'):
+    if not hasattr(model, "flags"):
         model.flags = [None] * n_data
 
     for n_it in range(max_lm_iterations):
         # update the parameters with a LM iteration
         f_delta_beta = _update_beta(lm_damping)
         max_f = np.max(np.abs(f_delta_beta))
         if verbose is True:
-            print('Iteration {0:d}: {1}. Max change in param: {2}'.format(
-                n_it, model.get_params(), max_f))
+            print(
+                "Iteration {0:d}: {1}. Max change in param: {2}".format(
+                    n_it, model.get_params(), max_f
+                )
+            )
         if max_f < param_tolerance:
             break
 
     J = model.jacobian
     r = model.weighted_residuals
     model.WSS = r.dot(r.T)
 
     model.popt = model.get_params()
-    model.pcov = np.linalg.inv(J.T.dot(J))*r.dot(r.T)/model.dof
+    model.pcov = np.linalg.inv(J.T.dot(J)) * r.dot(r.T) / model.dof
 
     # Estimate the noise variance normal to the curve
-    model.goodness_of_fit = model.WSS/model.dof
-    model.noise_variance = r.dot(np.diag(1./model.weights)).dot(r.T)/model.dof
+    model.goodness_of_fit = model.WSS / model.dof
+    model.noise_variance = r.dot(np.diag(1.0 / model.weights)).dot(r.T) / model.dof
 
     if verbose is True:
         if n_it == max_lm_iterations - 1:
-            print(f'Max iterations ({max_lm_iterations:d}) reached '
-                  f'(param tolerance = {param_tolerance:1e})')
+            print(
+                f"Max iterations ({max_lm_iterations:d}) reached "
+                f"(param tolerance = {param_tolerance:1e})"
+            )
         else:
-            print('Converged in {0:d} iterations'.format(n_it))
-        print('\nOptimised parameter values:')
+            print("Converged in {0:d} iterations".format(n_it))
+        print("\nOptimised parameter values:")
         print(model.popt)
-        print('\nParameter covariance matrix:')
+        print("\nParameter covariance matrix:")
         print(model.pcov)
-        print('')
+        print("")
 
 
-def confidence_prediction_bands(model, x_array, confidence_interval, f,
-                                flag=None):
+def confidence_prediction_bands(model, x_array, confidence_interval, f, flag=None):
     """
     This function calculates the confidence and prediction bands of
     the function f(x) from a best-fit model with uncertainties in its
     parameters as calculated (for example) by
     the function nonlinear_least_squares_fit().
 
     The values are calculated via the delta method, which estimates
     the variance of f evaluated at x as var(f(x)) = df(x)/dB var(B) df(x)/dB
     where df(x)/dB is the vector of partial derivatives of f(x)
-    with respect to B
+    with respect to B.
 
+    :param model: As modified (for example) by the function
+        :func:`burnman.nonlinear_least_squares_fit`.
+        Should contain the following functions: get_params, set_params, function, normal
+        And attributes: delta_params, pcov, dof, noise_variance
+    :type model: object
+
+    :param x_array: Coordinates at which to evaluate the bounds.
+    :type x_array: 2D numpy.array
+
+    :param confidence_interval: Probability level of finding the true model
+        (confidence bound) or any new data point (probability bound).
+        For example, the 95% confidence bounds should be calculated using a
+        confidence interval of 0.95.
+    :type confidence_interval: float
+
+    :param f: The function defining the variable y=f(x) for which the
+        confidence and prediction bounds are desired.
+    :type f: function
 
-    Parameters
-    ----------
-'    model : class instance
-        As modified (for example) by the function
-        nonlinear_least_squares_fit(). Should contain the following functions:
-            get_params, set_params, function, normal
-        And attributes:
-            delta_params, pcov, dof, noise_variance
-
-    x_array : 2D numpy array
-        coordinates at which to evaluate the bounds
-
-    confidence_interval : float
-        Probability level of finding the true model (confidence bound) or
-        any new data point (probability bound). For example, the 95% confidence
-        bounds should be calculated using a confidence interval of 0.95.
-
-    f : function
-        This is the function defining the variable y=f(x) for which the
-        confidence and prediction bounds are desired
-
-    flag : variable type
-        This (optional) flag is passed to model.function to control how the
+    :param flag: This (optional) flag is passed to model.function to control how the
         modified position of x is calculated. This value is then used by f(x)
+    :type flag: type informed by model object
 
-    Output
-    ------
-    bounds : 2D numpy array
-        An element of bounds[i][j] gives the lower and upper confidence
+    :returns: An element of bounds[i][j] gives the lower and upper confidence
         (i=0, i=1) and prediction (i=2, i=3) bounds for the jth data point.
+    :rtype: 2D numpy.array
     """
 
     # Check array dimensions
     n_dimensions = len(model.data[0])
     if len(x_array[0]) != n_dimensions:
-        raise Exception('Dimensions of each point must be the same as the '
-                        'total number of dimensions')
+        raise Exception(
+            "Dimensions of each point must be the same as the "
+            "total number of dimensions"
+        )
 
     param_values = model.get_params()
     x_m_0s = np.empty_like(x_array)
     f_m_0s = np.empty_like(x_array[:, 0])
     for i, x in enumerate(x_array):
         x_m_0s[i] = model.function(x, flag)
         f_m_0s[i] = f(x)
@@ -279,63 +263,69 @@
     dxdbeta = np.empty([len(param_values), len(x_array)])
 
     for i, value in enumerate(param_values):
         model.set_params(param_values + diag_delta[i])
 
         for j, x_m_0 in enumerate(x_m_0s):
             x_m_1 = model.function(x_m_0, flag)
-            dxdbeta[i][j] = (f(x_m_1) - f_m_0s[j])/diag_delta[i][i]
+            dxdbeta[i][j] = (f(x_m_1) - f_m_0s[j]) / diag_delta[i][i]
 
     model.set_params(param_values)  # reset params
 
     variance = np.empty(len(x_array))
     for i, Gprime in enumerate(dxdbeta.T):
         variance[i] = Gprime.T.dot(model.pcov).dot(Gprime)
 
-    critical_value = t.isf(0.5*(confidence_interval + 1.), model.dof)
+    critical_value = t.isf(0.5 * (confidence_interval + 1.0), model.dof)
 
-    confidence_half_widths = critical_value*np.sqrt(variance)
-    prediction_half_widths = critical_value*np.sqrt(variance
-                                                    + model.noise_variance)
+    confidence_half_widths = critical_value * np.sqrt(variance)
+    prediction_half_widths = critical_value * np.sqrt(variance + model.noise_variance)
 
     confidence_bound_0 = f_m_0s - confidence_half_widths
     confidence_bound_1 = f_m_0s + confidence_half_widths
     prediction_bound_0 = f_m_0s - prediction_half_widths
     prediction_bound_1 = f_m_0s + prediction_half_widths
 
-    return np.array([confidence_bound_0, confidence_bound_1,
-                     prediction_bound_0, prediction_bound_1])
+    return np.array(
+        [confidence_bound_0, confidence_bound_1, prediction_bound_0, prediction_bound_1]
+    )
 
 
 def abs_line_project(M, n):
     n = unit_normalize(n)
     return n.dot(M).dot(n.T)
 
 
 def plot_cov_ellipse(cov, pos, nstd=2, ax=None, **kwargs):
     """
     Plots an `nstd` sigma error ellipse based on the specified covariance
     matrix (`cov`). Additional keyword arguments are passed on to the
     ellipse patch artist.
 
-    Parameters
-    ----------
-        cov : The 2x2 covariance matrix to base the ellipse on
-        pos : The location of the center of the ellipse. Expects a 2-element
-            sequence of [x0, y0].
-        nstd : The radius of the ellipse in numbers of standard deviations.
-            Defaults to 2 standard deviations.
-        ax : The axis that the ellipse will be plotted on. Defaults to the
-            current axis.
-        Additional keyword arguments are pass on to the ellipse patch.
-
-    Returns
-    -------
-        A matplotlib ellipse artist
+    :param cov: The 2x2 covariance matrix to base the ellipse on.
+    :type cov: numpy.array
+
+    :param pos: The location of the center of the ellipse. Expects a 2-element
+        sequence of [x0, y0].
+    :type pos: list or numpy.array
+
+    :param nstd: The radius of the ellipse in numbers of standard deviations.
+        Defaults to 2 standard deviations.
+    :type nstd: float
+
+    :param ax: The axis that the ellipse will be plotted on. Defaults to the
+        current axis.
+    :type ax: matplotlib.pyplot.axes
+
+    :param kwargs: Additional keyword arguments are passed on to the ellipse patch.
+
+    :returns: The covariance ellipse (already applied to the desired axes object).
+    :rtype: matplotlib.patches.Ellipse
     """
+
     def eigsorted(cov):
         vals, vecs = np.linalg.eigh(cov)
         order = vals.argsort()[::-1]
         return vals[order], vecs[:, order]
 
     if ax is None:
         ax = plt.gca()
@@ -347,253 +337,260 @@
     width, height = 2 * nstd * np.sqrt(vals)
     ellip = Ellipse(xy=pos, width=width, height=height, angle=theta, **kwargs)
 
     ax.add_artist(ellip)
     return ellip
 
 
-def corner_plot(popt, pcov, param_names=[], n_std=1.):
+def corner_plot(popt, pcov, param_names=[], n_std=1.0):
     """
     Creates a corner plot of covariances
 
-    Parameters
-    ----------
-
-    popt : numpy array
-        Optimized parameters
-
-    pcov : 2D numpy array
-        Covariance matrix of the parameters
+    :param popt: Optimized parameters.
+    :type popt: numpy.array
 
-    param_names : optional list
-        Parameter names
+    :param pcov: Covariance matrix of the parameters.
+    :type pcov: 2D numpy.array
 
-    n_std : float
-        Number of standard deviations for ellipse
+    :param param_names: Parameter names.
+    :type param_names: list
 
-    Returns
-    -------
-    fig : matplotlib.pyplot.figure object
-
-    ax : list of matplotlib Axes objects
+    :param n_std: Number of standard deviations for ellipse.
+    :type n_std: float
 
+    :returns: ``matplotlib.pyplot.figure`` and list of ``matplotlib.pyplot.Axes``
+        objects.
+    :rtype: tuple
     """
 
     if len(pcov[0]) != len(pcov[:, 0]):
-        raise Exception('Covariance matrices must be square')
+        raise Exception("Covariance matrices must be square")
 
     n_params = len(pcov[0])
     if n_params < 2:
-        raise Exception('Covariance matrix must be at least 2x2 for '
-                        'a corner plot to be plotted')
+        raise Exception(
+            "Covariance matrix must be at least 2x2 for " "a corner plot to be plotted"
+        )
 
     # ellipse plotting is prone to rounding errors, so we scale the plots here
-    scaling = 1./np.power(10., np.around(np.log10(np.abs(popt)) - 0.5))
+    scaling = 1.0 / np.power(10.0, np.around(np.log10(np.abs(popt)) - 0.5))
     scaling = np.outer(scaling, scaling)
 
-    fig, ax = plt.subplots(n_params-1, n_params-1)
-    fig.set_size_inches(3.*(n_params-1), 3.*(n_params-1))
+    fig, ax = plt.subplots(n_params - 1, n_params - 1)
+    fig.set_size_inches(3.0 * (n_params - 1), 3.0 * (n_params - 1))
 
-    for j in range(n_params-1):
+    for j in range(n_params - 1):
         for i in range(j):
             fig.delaxes(ax[i][j])
 
-        for i in range(j, n_params-1):
+        for i in range(j, n_params - 1):
             ax[i][j].get_xaxis().get_major_formatter().set_useOffset(False)
             ax[i][j].get_yaxis().get_major_formatter().set_useOffset(False)
             ax[i][j].set_box_aspect(1)
 
             if j > 0:
                 ax[i][j].get_yaxis().set_visible(False)
             if i < n_params - 2:
                 ax[i][j].get_xaxis().set_visible(False)
 
-            indices = np.array([j, i+1])
-            projected_cov = (pcov*scaling)[indices[:, None], indices]
-
-            scaled_pos = np.array([popt[j]*np.sqrt(scaling[j][j]),
-                                   popt[i+1]*np.sqrt(scaling[i+1][i+1])])
+            indices = np.array([j, i + 1])
+            projected_cov = (pcov * scaling)[indices[:, None], indices]
 
-            plot_cov_ellipse(cov=projected_cov, pos=scaled_pos,
-                             nstd=n_std, ax=ax[i][j], color='grey')
-            maxx = 1.5*n_std*np.sqrt(projected_cov[0][0])
-            maxy = 1.5*n_std*np.sqrt(projected_cov[1][1])
-            ax[i][j].set_xlim(scaled_pos[0]-maxx, scaled_pos[0]+maxx)
-            ax[i][j].set_ylim(scaled_pos[1]-maxy, scaled_pos[1]+maxy)
+            scaled_pos = np.array(
+                [
+                    popt[j] * np.sqrt(scaling[j][j]),
+                    popt[i + 1] * np.sqrt(scaling[i + 1][i + 1]),
+                ]
+            )
+
+            plot_cov_ellipse(
+                cov=projected_cov, pos=scaled_pos, nstd=n_std, ax=ax[i][j], color="grey"
+            )
+            maxx = 1.5 * n_std * np.sqrt(projected_cov[0][0])
+            maxy = 1.5 * n_std * np.sqrt(projected_cov[1][1])
+            ax[i][j].set_xlim(scaled_pos[0] - maxx, scaled_pos[0] + maxx)
+            ax[i][j].set_ylim(scaled_pos[1] - maxy, scaled_pos[1] + maxy)
 
     if param_names != []:
-        for i in range(n_params-1):
-            ax[n_params-2][i].set_xlabel('{0:s} (x $10^{{{1:d}}}$)'.format(
-                param_names[i], -int(np.log10(np.sqrt(scaling[i][i])))))
+        for i in range(n_params - 1):
+            ax[n_params - 2][i].set_xlabel(
+                "{0:s} (x $10^{{{1:d}}}$)".format(
+                    param_names[i], -int(np.log10(np.sqrt(scaling[i][i])))
+                )
+            )
 
         for j in range(1, n_params):
-            ax[j-1][0].set_ylabel('{0:s} (x $10^{{{1:d}}}$)'.format(
-                param_names[j], -int(np.log10(np.sqrt(scaling[j][j])))))
+            ax[j - 1][0].set_ylabel(
+                "{0:s} (x $10^{{{1:d}}}$)".format(
+                    param_names[j], -int(np.log10(np.sqrt(scaling[j][j])))
+                )
+            )
 
     fig.set_tight_layout(True)
 
     return fig, ax
 
 
-def weighted_residual_plot(ax, model, flag=None, sd_limit=3,
-                           cmap=plt.cm.RdYlBu,
-                           plot_axes=[0, 1], scale_axes=[1., 1.]):
+def weighted_residual_plot(
+    ax,
+    model,
+    flag=None,
+    sd_limit=3,
+    cmap=plt.cm.RdYlBu,
+    plot_axes=[0, 1],
+    scale_axes=[1.0, 1.0],
+):
     """
     Creates a plot of the weighted residuals
     The user can choose the projection axes, and scaling to apply to those axes
     The chosen color palette (cmap) is discretised by standard deviation up
     to a cut off value of sd_limit.
 
-    Parameters
-    ----------
+    :param ax: Plot.
+    :param type: ``matplotlib.pyplot.Axes``
 
-    ax : matplotlib Axes object
-
-    model : user-defined object
-        A model as used by nonlinear_least_squares_fit
+    :param model: A model as used by
+        :func:`burnman.nonlinear_least_squares_fit`.
         Must contain the attributes model.data,
         model.weighted_residuals and
         model.flags (if flag is not None).
+    :type model: object
 
-    flag : string
-        String to determine which data to plot.
+    :param flag: String to determine which data to plot.
         Finds matches with model.flags.
+    :type flag: str
 
-    sd_limit : float
-        Data with weighted residuals exceeding this
-        limit are plotted in black
-
-    cmap : matplotlib color palette
+    :param sd_limit: Data with weighted residuals exceeding this
+        limit are plotted in black.
+    :type sd_limit: float
 
-    plot_axes : list of integers
-        Data axes to use as plot axes
+    :param cmap: Color palette.
+    :type cmap: matplotlib color palette
 
-    scale_axes : list of floats
-        Plot axes are scaled by multiplication of the data by these values
+    :param plot_axes: Data axes to use as plot axes.
+    :type plot_axes: list of int
 
-    Returns
-    -------
-    ax : matplotlib Axes object
+    :param scale_axes: Plot axes are scaled by multiplication
+        of the data by these values.
+    :type scale_axes: list of float
 
+    :returns: Coloured scatter plot of the weighted residuals in data space.
+    :rtype: matplotlib Axes object
     """
     if flag is None:
         mask = range(len(model.data[:, 0]))
     else:
         mask = [i for i, flg in enumerate(model.flags) if flg == flag]
 
     cmap_cp = copy.copy(cmap)
-    cmap_cp.set_under('k')
-    cmap_cp.set_over('k')
-    bounds = np.linspace(-sd_limit, sd_limit, sd_limit*2+1)
+    cmap_cp.set_under("k")
+    cmap_cp.set_over("k")
+    bounds = np.linspace(-sd_limit, sd_limit, sd_limit * 2 + 1)
     norm = colors.BoundaryNorm(bounds, cmap_cp.N)
 
-    im = ax.scatter(model.data[:, plot_axes[0]][mask] * scale_axes[0],
-                    model.data[:, plot_axes[1]][mask] * scale_axes[1],
-                    c=model.weighted_residuals[mask],
-                    cmap=cmap_cp, norm=norm, s=50)
-    plt.colorbar(im, ax=ax, label='Misfit (standard deviations)')
+    im = ax.scatter(
+        model.data[:, plot_axes[0]][mask] * scale_axes[0],
+        model.data[:, plot_axes[1]][mask] * scale_axes[1],
+        c=model.weighted_residuals[mask],
+        cmap=cmap_cp,
+        norm=norm,
+        s=50,
+    )
+    plt.colorbar(im, ax=ax, label="Misfit (standard deviations)")
 
 
 def extreme_values(weighted_residuals, confidence_interval):
-    '''
+    """
     This function uses extreme value theory to calculate the number of
     standard deviations away from the mean at which we should expect to bracket
     *all* of our n data points at a certain confidence level.
 
     It then uses that value to identify which (if any) of the data points
     lie outside that region, and calculates the corresponding probabilities
     of finding a data point at least that many standard deviations away.
 
 
-    Parameters
-    ----------
-
-    weighted_residuals : array of floats
-        Array of residuals weighted by the square root of their
-        variances wr_i = r_i/sqrt(var_i)
-
-    confidence_interval : float
-        Probability at which all the weighted residuals lie
-        within the confidence bounds
-
-    Returns
-    -------
-    confidence_bound : float
-        Number of standard deviations at which we should expect to encompass
-        all data at the user-defined confidence interval.
-
-    indices : array of floats
-        Indices of weighted residuals exceeding the confidence_interval
-        defined by the user
-
-    probabilities : array of floats
-        The probabilities that the extreme data point of the distribution lies
+    :param weighted_residuals: Array of residuals weighted by the square root
+        of their variances wr_i = r_i/sqrt(var_i).
+    :type weighted_residuals: array of float
+
+    :param confidence_interval: Probability at which all the weighted residuals lie
+        within the confidence bounds.
+    :type confidence_interval: float
+
+    :returns: Number of standard deviations at which we should expect to encompass
+        all data at the user-defined confidence interval, the indices of weighted
+        residuals exceeding the confidence_interval defined by the user, and
+        the probabilities that the extreme data point of the distribution lies
         further from the mean than the observed position wr_i for each i in
         the "indices" output array.
-    '''
+    :rtype: tuple of (float, numpy.array, numpy.array)
+    """
 
     n = len(weighted_residuals)
-    mean = norm.isf(1./n)
+    mean = norm.isf(1.0 / n)
     # good approximation for > 10 data points
-    scale = 0.8/np.power(np.log(n), 1./2.)
+    scale = 0.8 / np.power(np.log(n), 1.0 / 2.0)
     # good approximation for > 10 data points
-    c = 0.33/np.power(np.log(n), 3./4.)
+    c = 0.33 / np.power(np.log(n), 3.0 / 4.0)
 
     # We now need a 1-tailed probability from the given confidence_interval
     # p_total = 1. - confidence_interval = p_upper + p_lower - p_upper*p_lower
     # p_total = 1. - confidence_interval = 2p - p^2, therefore:
-    p = 1. - np.sqrt(confidence_interval)
+    p = 1.0 - np.sqrt(confidence_interval)
     confidence_bound = genextreme.isf(p, c, loc=mean, scale=scale)
 
-    indices = [i for i, r in enumerate(weighted_residuals)
-               if np.abs(r) > confidence_bound]
+    indices = [
+        i for i, r in enumerate(weighted_residuals) if np.abs(r) > confidence_bound
+    ]
     # Convert back to 2-tailed probabilities
-    probabilities = (1.
-                     - np.power(genextreme.sf(np.abs(weighted_residuals[indices]),
-                                              c, loc=mean, scale=scale) - 1., 2.))
+    probabilities = 1.0 - np.power(
+        genextreme.sf(np.abs(weighted_residuals[indices]), c, loc=mean, scale=scale)
+        - 1.0,
+        2.0,
+    )
 
     return confidence_bound, indices, probabilities
 
 
 def plot_residuals(ax, weighted_residuals, n_bins=None, flags=[]):
-
     if flags is []:
-        flags = [''] * len(weighted_residuals)
-        list_flags = ['']
+        flags = [""] * len(weighted_residuals)
+        list_flags = [""]
     else:
         list_flags = list(set(flags))
 
     if n_bins is None:
         try:  # Only works for recent versions of numpy
-            bin_heights, bin_bounds = np.histogram(weighted_residuals,
-                                                   bins='auto',
-                                                   density=True)
+            bin_heights, bin_bounds = np.histogram(
+                weighted_residuals, bins="auto", density=True
+            )
             n_bins = len(bin_heights)
         except:
-            n_bins = 11.
+            n_bins = 11.0
 
     mask = [i for i, f in enumerate(flags)]
     for flag in list_flags:
-        binwidth = np.ptp(weighted_residuals)/n_bins
+        binwidth = np.ptp(weighted_residuals) / n_bins
         dmin = min(weighted_residuals) - binwidth
         dmax = max(weighted_residuals) + binwidth
         bins = np.linspace(dmin, dmax, n_bins)
-        bin_heights, bin_bounds = np.histogram(weighted_residuals[mask],
-                                               bins=bins,
-                                               density=True)
-
-        normalisation = (float(len(weighted_residuals[mask]))
-                         / float(len(weighted_residuals)))
-        bin_centers = (bin_bounds[:-1] + bin_bounds[1:])/2.
-        bin_heights = bin_heights*normalisation
+        bin_heights, bin_bounds = np.histogram(
+            weighted_residuals[mask], bins=bins, density=True
+        )
+
+        normalisation = float(len(weighted_residuals[mask])) / float(
+            len(weighted_residuals)
+        )
+        bin_centers = (bin_bounds[:-1] + bin_bounds[1:]) / 2.0
+        bin_heights = bin_heights * normalisation
         bin_widths = bin_bounds[1] - bin_bounds[0]
-        plt.bar(bin_centers, bin_heights,
-                width=bin_widths, label=flag, alpha=0.2)
+        plt.bar(bin_centers, bin_heights, width=bin_widths, label=flag, alpha=0.2)
         mask = [i for i, f in enumerate(flags) if f != flag and i in mask]
 
         x = np.linspace(bin_bounds[0], bin_bounds[-1], 1001)
-        ax.plot(x, norm.pdf(x)*normalisation)
+        ax.plot(x, norm.pdf(x) * normalisation)
 
-    ax.set_title('Residual plot versus expected normal distribution')
-    ax.set_xlabel('Number of standard deviations from the mean')
-    ax.set_ylabel('Probability')
-    ax.legend(loc='upper right')
+    ax.set_title("Residual plot versus expected normal distribution")
+    ax.set_xlabel("Number of standard deviations from the mean")
+    ax.set_ylabel("Probability")
+    ax.legend(loc="upper right")
```

### Comparing `burnman-1.1.0/burnman/optimize/nonlinear_solvers.py` & `burnman-1.2.0/burnman/optimize/nonlinear_solvers.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,60 +6,60 @@
 def solve_constraint_lagrangian(x, jac_x, c_x, c_prime):
     """
     Function which solves the problem
     minimize || J.dot(x_mod - x) ||
     subject to C(x_mod) = 0
     via the method of Lagrange multipliers.
 
-    Parameters
-    ----------
-    x : 1D numpy array
-        Parameter values at x
-    jac_x : 2D numpy array.
-        The (estimated, approximate or exact)
-        value of the Jacobian J(x)
-    c_x : 1D numpy array
-        Values of the constraints at x
-    c_prime : 2D array of floats
-        The Jacobian of the constraints
-        (A, where A.x + b = 0)
-
-    Returns
-    -------
-    x_mod : 1D numpy array
-        The parameter values which minimizes the L2-norm
-        of any function which has the Jacobian jac_x.
-    lagrange_multipliers : 1D numpy array
-        The multipliers for each of the equality
-        constraints
+    :param x: Parameter values at x.
+    :type x: 1D numpy array
+
+    :param jac_x: The (estimated, approximate or exact) value of the Jacobian J(x).
+    :type jac_x: 2D numpy array.
+
+    :param c_x: Values of the constraints at x.
+    :type c_x: 1D numpy array
+
+    :param c_prime: The Jacobian of the constraints (A, where A.x + b = 0).
+    :type c_prime: 2D array of floats
+
+    :returns: An array containing the parameter values which minimize the L2-norm
+        of any function which has the Jacobian jac_x, and another array containing
+        the multipliers for each of the equality constraints.
+    :rtype: tuple
     """
     n_x = len(x)
     n = n_x + len(c_x)
     A = np.zeros((n, n))
     b = np.zeros(n)
 
     JTJ = jac_x.T.dot(jac_x)
-    A[:n_x, :n_x] = JTJ/np.linalg.norm(JTJ)*n*n  # includes scaling
+    A[:n_x, :n_x] = JTJ / np.linalg.norm(JTJ) * n * n  # includes scaling
     A[:n_x, n_x:] = c_prime.T
     A[n_x:, :n_x] = c_prime
     b[n_x:] = c_x
 
     luA = lu_factor(A)
     dx_m = lu_solve(luA, -b)  # lu_solve computes the solution of ax = b
 
     x_mod = x + dx_m[:n_x]
     lagrange_multipliers = dx_m[n_x:]
     return (x_mod, lagrange_multipliers)
 
 
-def damped_newton_solve(F, J, guess, tol=1.e-6,
-                        max_iterations=100,
-                        lambda_bounds=lambda dx, x: (1.e-8, 1.),
-                        linear_constraints=(0., np.array([-1.])),
-                        store_iterates=False):
+def damped_newton_solve(
+    F,
+    J,
+    guess,
+    tol=1.0e-6,
+    max_iterations=100,
+    lambda_bounds=lambda dx, x: (1.0e-8, 1.0),
+    linear_constraints=(0.0, np.array([-1.0])),
+    store_iterates=False,
+):
     """
     Solver for the multivariate nonlinear system F(x)=0
     with Jacobian J(x), using the damped affine invariant modification
     to Newton's method (Deuflhard, 1974;1975;2004).
     Here we follow the algorithm as described in Nowak and Weimann (1991):
     [Technical Report TR-91-10, Algorithm B], modified to accept
     linear inequality constraints.
@@ -71,282 +71,338 @@
 
     If a current iterate starting point (x_i) lies on one or more constraints
     and the Newton step violates one or more of those constraints, then
     the next step is calculated via the method of Lagrangian multipliers,
     minimizing the L2-norm of F(x_i+1) subject to the violated constraints.
 
     Successful termination of the solver is based on three criteria:
-    - all(np.abs(dx (simplified newton step) < tol))
-    - all(np.abs(dx (full Newton step) < sqrt(10*tol))) [avoiding pathological behaviour] and
-    - lambda = lambda_bounds(dx, x)[1] (lambda = 1 for a full Newton step).
+        - all(np.abs(dx (simplified newton step) < tol))
+        - all(np.abs(dx (full Newton step) < sqrt(10*tol))) (avoids pathology) and
+        - lambda = lambda_bounds(dx, x)[1] (lambda = 1 for a full Newton step).
 
     If these criteria are not satisfied, iterations continue until one of the following
     occurs:
-    - the value of lmda is reduced to its minimum value
-      (this happens if the problem is very nonlinear)
-    - successive iterations have descent vectors which violate the constraints
-    - the maximum number of iterations (given by max_iterations) is reached.
+        - the value of lmda is reduced to its minimum value (for v. nonlinear problems)
+        - successive iterations have descent vectors which violate the constraints
+        - the maximum number of iterations (given by max_iterations) is reached.
 
     Information on the root (or lack of root) obtained by the solver is provided
     in the returned namedtuple.
 
+    :param F: Function returning the system function F(x) as a 1D numpy array.
+    :type F: function of x
+
+    :param J: Function returning the Jacobian function J(x) as a 2D numpy array.
+    :type J: function of x
+
+    :param guess: Starting guess for the solver.
+    :type guess: 1D numpy.array
+
+    :param tol: Tolerance(s) for termination.
+    :type tol: float or array of floats
 
-    Parameters
-    ----------
-    F : function of x
-        Returns the system function F(x)
-        as a 1D numpy array.
-    J : function of x
-        Returns the Jacobian function J(x)
-        as a 2D numpy array.
-    guess : 1D numpy array
-        Starting guess for the solver.
-    tol : float or array of floats [1.e-6]
-        Tolerance(s) for termination.
-    max_iterations : integer [100]
-        Maximum number of iterations for solver.
-    lambda_bounds: function of dx and x
-        Returns a tuple of floats (1.e-8, 1.) corresponding
-        to the minimum and maximum allowed fractions of the
-        full newton step (dx).
-    linear_constraints : tuple of a 2D numpy array (A) and 1D numpy array (b)
+    :param max_iterations: Maximum number of iterations for the solver.
+    :type max_iterations: int
+
+    :param lambda_bounds: A function of dx and x that returns
+        a tuple of floats corresponding to the minimum and maximum
+        allowed fractions of the full newton step (dx).
+    :type lambda bounds: function of dx and x
+
+    :param linear_constraints: tuple of a 2D numpy array (A) and 1D numpy array (b)
         Constraints are satisfied if A.x + b < eps
+    :type linear_constraints: tuple of a 2D numpy.array (A) and 1D numpy.array (b)
 
+    :returns: A namedtuple with the following attributes:
 
-    Returns
-    -------
-    sol : namedtuple
-        Includes the following attributes:
-        x : 1D numpy array of floats
-            The solution vector.
-        F : 1D numpy array of floats
-            The evaluated function F(x).
-        F_norm : float
-            Euclidean norm of F(x).
-        J : 2D numpy array of floats
-            The evaluated Jacobian J(x).
-        n_it : integer
-            Number of iterations.
-        code : integer
-            Numerical description of the solver termination.
-                0 -> Successful convergence
-                1 -> Failure due to solver hitting lower lambda bound
-                2 -> Failure due to descent vector crossing constraints
-                3 -> Failure due to solver reaching maximum number of iterations
-        text : string
-            Description of the solver termination.
-        success : bool
-            Solution convergence boolean.
-        iterates : namedtuple
+        - x: The solution vector [1D numpy array].
+        - F: The evaluated function F(x) [1D numpy array].
+        - F_norm: Euclidean norm of F(x) [float].
+        - J: The evaluated Jacobian J(x) [2D numpy array].
+        - n_it: Number of iterations [int].
+        - code: Numerical description of the solver termination [int].
+            - 0: Successful convergence
+            - 1: Failure due to solver hitting lower lambda bound
+            - 2: Failure due to descent vector crossing constraints
+            - 3: Failure due to solver reaching maximum number of iterations
+        - text: Description of the solver termination [str].
+        - success: Solver convergence state [bool].
+        - iterates: [namedtuple]
             Only present if store_iterates=True
             Includes the following attributes:
-            x : list of 1D numpy arrays of floats
-                The parameters for each iteration
-            F : list of 2D numpy arrays of floats
-                The function for each iteration
-            lmda : list of floats
-                The value of the damping parameter for each iteration
-
-    This function is available as ``burnman.damped_newton_solve``.
+                - x: list of 1D numpy arrays of floats
+                    The parameters for each iteration
+                - F: list of 2D numpy arrays of floats
+                    The function for each iteration
+                - lmda: list of floats
+                    The value of the damping parameter for each iteration
+    :rtype: namedtuple
     """
 
     # Make sure damping factor is within bounds, and that the bounds are reasonable
     # Problem classes in Nowak and Weimann (1991); [lmda_min, lmda_max]:
     # linear: [0.1, 1.]
     # mildly nonlinear: [1.e-4, 1.]
     # highly nonlinear: [1.e-2, 1.e-4]
     # extremely nonlinear: [1.e-4, 1.e-8]
-    eps = 2.*np.finfo(float).eps
+    eps = 2.0 * np.finfo(float).eps
 
     def update_lmda(x, dx, h, lmda_bounds):
-        assert lmda_bounds[1] < 1. + eps, 'The highest upper bound for lambda is 1. (a full Newton step)'
-        assert lmda_bounds[0] > 1.e-8 - eps, 'The lowest lower bound for lambda is 1.e-8 (suitable only for extremely nonlinear systems)'
+        assert (
+            lmda_bounds[1] < 1.0 + eps
+        ), "The highest upper bound for lambda is 1. (a full Newton step)"
+        assert (
+            lmda_bounds[0] > 1.0e-8 - eps
+        ), "The lowest lower bound for lambda is 1.e-8 (suitable only for extremely nonlinear systems)"
 
-        lmda_j = min(1./(h + eps), lmda_bounds[1])  # this is lmda_j^0
+        lmda_j = min(1.0 / (h + eps), lmda_bounds[1])  # this is lmda_j^0
         return max(lmda_j, lmda_bounds[0])
 
     def constraints(x):
         return np.dot(linear_constraints[0], x) + linear_constraints[1]
 
-    assert np.all(constraints(guess) < eps), 'The starting guess is outside the supplied constraints.'
+    assert np.all(
+        constraints(guess) < eps
+    ), "The starting guess is outside the supplied constraints."
 
     if not isinstance(tol, float):
-        assert len(tol) < len(guess), 'tol must either be a float or an array like guess.'
-
-    sol = namedtuple('Solution', ['x', 'n_it', 'F', 'F_norm', 'J', 'code', 'text', 'success'])
+        assert len(tol) < len(
+            guess
+        ), "tol must either be a float or an array like guess."
+
+    sol = namedtuple(
+        "Solution", ["x", "n_it", "F", "F_norm", "J", "code", "text", "success"]
+    )
 
     # evaluate system
     sol.x = guess
     sol.F = F(sol.x)
 
     if store_iterates:
-        sol.iterates = namedtuple('iterates', ['x', 'F', 'lmda'])
+        sol.iterates = namedtuple("iterates", ["x", "F", "lmda"])
         sol.iterates.x = [sol.x]
         sol.iterates.F = [sol.F]
-        sol.iterates.lmda = [0.]
+        sol.iterates.lmda = [0.0]
 
     # Begin Newton loop
 
     # Some dummy variables for the first h calculation (h = 0)
-    lmda = 0.
-    dxprev = [1.]
-    dxbar = [1.]
+    lmda = 0.0
+    dxprev = [1.0]
+    dxbar = [1.0]
 
     sol.n_it = 0
     n_constraints = len(constraints(sol.x))
     minimum_lmda = False
     converged = False
     persistent_bound_violation = False
-    while (sol.n_it < max_iterations
-           and not minimum_lmda
-           and not persistent_bound_violation
-           and not converged):
-
+    while (
+        sol.n_it < max_iterations
+        and not minimum_lmda
+        and not persistent_bound_violation
+        and not converged
+    ):
         sol.J = J(sol.x)  # evaluate Jacobian
         luJ = lu_factor(sol.J)  # storing the factorisation saves time later
         dx = lu_solve(luJ, -sol.F)  # compute ordinary Newton step
         dx_norm = np.linalg.norm(dx, ord=2)
         lmda_bounds = lambda_bounds(dx, sol.x)
-        h = (lmda*np.linalg.norm((dxbar - dx), ord=2) * dx_norm
-             / (np.linalg.norm(dxprev, ord=2) * np.linalg.norm(dxbar, ord=2)))
+        h = (
+            lmda
+            * np.linalg.norm((dxbar - dx), ord=2)
+            * dx_norm
+            / (np.linalg.norm(dxprev, ord=2) * np.linalg.norm(dxbar, ord=2))
+        )
         lmda = update_lmda(sol.x, dx, h, lmda_bounds)
 
         # Create the (k+1)^0 values
-        x_j = sol.x + lmda*dx
+        x_j = sol.x + lmda * dx
 
         # Check that all constraints are satisfied. If not, adjust lambda.
-        # This must be done just before every call to F() *if* lambda has been increased:
+        # This must be done just before every call to F() *if* lambda
+        # has been increased:
         c_x_j = constraints(x_j)
-        if not np.all(c_x_j < eps):  # x allowed to lie on constraints but not in forbidden area
+        if not np.all(
+            c_x_j < eps
+        ):  # x allowed to lie on constraints but not in forbidden area
             c_x = constraints(sol.x)
-            violated_constraints = sorted([(i, c_x[i] / (c_x[i] - c_x_j[i])) for i in range(n_constraints) if c_x_j[i] >= eps], key=lambda x: x[1])
+            violated_constraints = sorted(
+                [
+                    (i, c_x[i] / (c_x[i] - c_x_j[i]))
+                    for i in range(n_constraints)
+                    if c_x_j[i] >= eps
+                ],
+                key=lambda x: x[1],
+            )
             lmda = lmda * violated_constraints[0][1]
-            x_j = sol.x + lmda*dx
+            x_j = sol.x + lmda * dx
 
         # If the same current iterate is on a constraint,
         # and a very small lambda causes the next iterate to leave the
         # feasible region, then a new step direction must be found,
         # along with a new guess for lmda
         # We do this here using Lagrange multipliers
         if lmda < eps:
-            active_constraint_indices = [i for i, vc in violated_constraints if vc < eps]
-            inactive_constraint_indices = [i for i, vc in violated_constraints if vc >= eps]
+            active_constraint_indices = [
+                i for i, vc in violated_constraints if vc < eps
+            ]
+            inactive_constraint_indices = [
+                i for i, vc in violated_constraints if vc >= eps
+            ]
             c_newton = constraints(sol.x + dx)[active_constraint_indices]
             c_A = linear_constraints[0][active_constraint_indices]
             x_n = sol.x + dx  # newton iterate
-            if np.linalg.matrix_rank(c_A) == len(dx):  # if true, we must leave a constraint here
+            if np.linalg.matrix_rank(c_A) == len(
+                dx
+            ):  # if true, we must leave a constraint here
                 n_act = len(active_constraint_indices)
                 for i_rm in range(n_act):
-                    potential_active_indices = [active_constraint_indices[i]
-                                                for i in range(n_act) if i != i_rm]
+                    potential_active_indices = [
+                        active_constraint_indices[i] for i in range(n_act) if i != i_rm
+                    ]
                     c_newton = constraints(sol.x + dx)[potential_active_indices]
                     c_A = linear_constraints[0][potential_active_indices]
                     x_m = solve_constraint_lagrangian(x_n, sol.J, c_newton, c_A)[0]
-                    if constraints(x_m)[active_constraint_indices[i_rm]] < 0.:
+                    if constraints(x_m)[active_constraint_indices[i_rm]] < 0.0:
                         break
             else:
                 x_m = solve_constraint_lagrangian(x_n, sol.J, c_newton, c_A)[0]
 
             dx = x_m - sol.x
             lmda_bounds = lambda_bounds(dx, sol.x)
             lmda = lmda_bounds[1]  # no a-priori maximum limit
-            x_j = sol.x + lmda*dx
+            x_j = sol.x + lmda * dx
 
             # Check that the solution is still able to converge, i.e.
             # that the constraints aren't stopping our approach to a potential root
-            x_j_min = sol.x + lmda_bounds[0]*dx  # because lmda must be getting smaller, no need to check constraints
+            x_j_min = (
+                sol.x + lmda_bounds[0] * dx
+            )  # because lmda must be getting smaller, no need to check constraints
             F_j_min = F(x_j_min)
             dxbar_j_min = lu_solve(luJ, -F_j_min)
             dxbar_j_min_norm = np.linalg.norm(dxbar_j_min, ord=2)
 
             # Newton step size must be decreasing and dx must be non-zero
             if dxbar_j_min_norm > dx_norm or np.linalg.norm(dx, ord=2) < eps:
                 persistent_bound_violation = True
 
             # Now we need to check for newly violated constraints
             n_inactive = len(inactive_constraint_indices)
             c_x_j = constraints(x_j)[inactive_constraint_indices]
-            if not np.all(c_x_j < eps):  # x allowed to lie on constraints but not in forbidden area
+            if not np.all(
+                c_x_j < eps
+            ):  # x allowed to lie on constraints but not in forbidden area
                 c_x = constraints(sol.x)[inactive_constraint_indices]
-                violated_constraints = sorted([(i, c_x[i] / (c_x[i] - c_x_j[i])) for i in range(n_inactive) if c_x_j[i] >= eps], key=lambda x: x[1])
+                violated_constraints = sorted(
+                    [
+                        (i, c_x[i] / (c_x[i] - c_x_j[i]))
+                        for i in range(n_inactive)
+                        if c_x_j[i] >= eps
+                    ],
+                    key=lambda x: x[1],
+                )
                 lmda = lmda * violated_constraints[0][1]
-                x_j = sol.x + lmda*dx
+                x_j = sol.x + lmda * dx
 
         F_j = F(x_j)
         dxbar_j = lu_solve(luJ, -F_j)  # this is the simplified newton step
         dxbar_j_norm = np.linalg.norm(dxbar_j, ord=2)
 
-        if ((all(np.abs(dxbar_j) < tol)                  # <- Success requirements
-             and all(np.abs(dx) < np.sqrt(10.*tol))      # <- avoids pathological cases
-             and np.abs(lmda - lmda_bounds[1]) < eps)):  # <- end on a maximal newton step
-            require_posteriori_loop = False              # <- No need for the a posteriori loop
-            converged = True                             # <- Successful convergence
+        if (
+            all(np.abs(dxbar_j) < tol)  # <- Success requirements
+            and all(np.abs(dx) < np.sqrt(10.0 * tol))  # <- avoids pathological cases
+            and np.abs(lmda - lmda_bounds[1]) < eps
+        ):  # <- end on a maximal newton step
+            require_posteriori_loop = False  # <- No need for the a posteriori loop
+            converged = True  # <- Successful convergence
         else:
             require_posteriori_loop = True
 
         # Begin the a posteriori loop
-        while (require_posteriori_loop and not minimum_lmda
-               and not persistent_bound_violation):
+        while (
+            require_posteriori_loop
+            and not minimum_lmda
+            and not persistent_bound_violation
+        ):
             # Monotonicity check
             # always based on the Newton step, even if on a constraint
             if dxbar_j_norm <= dx_norm:
-                if dxbar_j_norm < eps:  # <- occasionally the simplified newton step finds the exact solution
+                if (
+                    dxbar_j_norm < eps
+                ):  # <- occasionally the simplified newton step finds the exact solution
                     converged = True
                 dxbar = dxbar_j
                 sol.x = x_j
                 sol.F = F_j
 
                 require_posteriori_loop = False  # return to Newton step
                 sol.n_it += 1  # move to next iteration
                 dxprev = dx  # to calculate the next value of h
             else:
                 if np.abs(lmda - lmda_bounds[0]) < eps:
                     minimum_lmda = True
-                h_j = (2./lmda)*np.linalg.norm((dxbar_j - (1. - lmda)*dx), ord=2)/dx_norm
-                lmda_j = min(lmda_bounds[1], 1./h_j)
-                lmda = min(lmda_j, lmda/2.)
-                lmda = max(lmda, lmda_bounds[0])  # allows a check of monotonicity once at minimum lmda
-
-                x_j = sol.x + lmda*dx  # because lmda must be getting smaller, no need to check constraints
+                h_j = (
+                    (2.0 / lmda)
+                    * np.linalg.norm((dxbar_j - (1.0 - lmda) * dx), ord=2)
+                    / dx_norm
+                )
+                lmda_j = min(lmda_bounds[1], 1.0 / h_j)
+                lmda = min(lmda_j, lmda / 2.0)
+                lmda = max(
+                    lmda, lmda_bounds[0]
+                )  # allows a check of monotonicity once at minimum lmda
+
+                x_j = (
+                    sol.x + lmda * dx
+                )  # because lmda must be getting smaller, no need to check constraints
                 F_j = F(x_j)
                 dxbar_j = lu_solve(luJ, -F_j)
                 dxbar_j_norm = np.linalg.norm(dxbar_j, ord=2)
 
         if store_iterates:
             sol.iterates.x.append(sol.x)
             sol.iterates.F.append(sol.F)
             sol.iterates.lmda.append(lmda)
 
     if converged and not persistent_bound_violation:
         sol.x = x_j + dxbar_j
-        # Even if the solver succeeds, there may be a small chance that the last simplified Newton step
+        # Even if the solver succeeds, there may be a small chance
+        # that the last simplified Newton step
         # shifts the solution just outside the constraints.
         # If so, shift the solution back to the allowed region
         c_x = constraints(sol.x)
-        if not np.all(c_x <= 0.):  # x allowed to lie on constraints but not in forbidden area
+        if not np.all(
+            c_x <= 0.0
+        ):  # x allowed to lie on constraints but not in forbidden area
             sol.x -= dxbar_j
 
     sol.F = F(sol.x)
     sol.F_norm = np.linalg.norm(sol.F, ord=2)
     sol.J = J(sol.x)
 
     if store_iterates:
         sol.iterates.x = np.array(sol.iterates.x)
         sol.iterates.F = np.array(sol.iterates.F)
 
     sol.success = False
     if converged:
         sol.success = True
         sol.code = 0
-        sol.text = 'The solver successfully found a root after {0} iterations'.format(sol.n_it)
+        sol.text = "The solver successfully found a root after {0} iterations".format(
+            sol.n_it
+        )
     elif minimum_lmda:
         sol.code = 1
-        sol.text = 'The function is too non-linear for lower lambda bound ({0})'.format(lmda_bounds[0])
+        sol.text = "The function is too non-linear for lower lambda bound ({0})".format(
+            lmda_bounds[0]
+        )
     elif persistent_bound_violation:
         sol.code = 2
-        sol.text = 'The descent vector crosses the constraints with the following indices: {0}'.format([i for i, lmda in violated_constraints])
+        sol.text = "The descent vector crosses the constraints with the following indices: {0}".format(
+            [i for i, lmda in violated_constraints]
+        )
     elif sol.n_it == max_iterations:
         sol.code = 3
-        sol.text = 'The solver reached max_iterations ({0})'.format(max_iterations)
+        sol.text = "The solver reached max_iterations ({0})".format(max_iterations)
     else:
-        raise Exception('Unknown termination of solver')
+        raise Exception("Unknown termination of solver")
     return sol
```

### Comparing `burnman-1.1.0/burnman/tools/__init__.py` & `burnman-1.2.0/burnman/tools/__init__.py`

 * *Files identical despite different names*

### Comparing `burnman-1.1.0/burnman/tools/eos.py` & `burnman-1.2.0/burnman/tools/eos.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,195 +4,236 @@
 # GPL v2 or later.
 
 import numpy as np
 import warnings
 from scipy.linalg import logm
 
 
-def check_eos_consistency(m, P=1.e9, T=300., tol=1.e-4, verbose=False,
-                          including_shear_properties=True):
+def check_eos_consistency(
+    m, P=1.0e9, T=300.0, tol=1.0e-4, verbose=False, including_shear_properties=True
+):
     """
-    Compute numerical derivatives of the gibbs free energy of a mineral
-    under given conditions, and check these values against those provided
-    analytically by the equation of state
-
-    Parameters
-    ----------
-    m : mineral
-        The mineral for which the equation of state
-        is to be checked for consistency
-    P : float
-        The pressure at which to check consistency
-    T : float
-        The temperature at which to check consistency
-    tol : float
-        The fractional tolerance for each of the checks
-    verbose : boolean
-        Decide whether to print information about each
-        check
-    including_shear_properties : boolean
-        Decide whether to check shear information,
-        which is pointless for liquids and equations of state
-        without shear modulus parameterizations
+    Checks that numerical derivatives of the Gibbs energy of a mineral
+    under given conditions are equal to those provided
+    analytically by the equation of state.
+
+    :param m: The mineral for which the equation of state
+        is to be checked for consistency.
+    :type m: :class:`burnman.Mineral`
+
+    :param P: The pressure at which to check consistency.
+    :type P: float
+
+    :param T: The temperature at which to check consistency.
+    :type T: float
+
+    :param tol: The fractional tolerance for each of the checks.
+    :type tol: float
 
-    Returns
-    -------
-    consistency: boolean
-        If all checks pass, returns True
+    :param verbose: Decide whether to print information about each check.
+    :type verbose: bool
 
+    :param including_shear_properties: Decide whether to check shear information,
+        which is pointless for liquids and equations of state
+        without shear modulus parameterizations.
+    :type including_shear_properties: bool
+
+    :returns: Boolean stating whether all checks have passed.
+    :rtype: bool
     """
-    dT = 1.
-    dP = 1000.
+    dT = 1.0
+    dP = 1000.0
 
     m.set_state(P, T)
     G0 = m.gibbs
     S0 = m.S
     V0 = m.V
 
-    expr = ['G = F + PV', 'G = H - TS', 'G = E - TS + PV']
-    eq = [[m.gibbs, (m.helmholtz + P*m.V)],
-          [m.gibbs, (m.H - T*m.S)],
-          [m.gibbs, (m.molar_internal_energy - T*m.S + P*m.V)]]
+    expr = ["G = F + PV", "G = H - TS", "G = E - TS + PV"]
+    eq = [
+        [m.gibbs, (m.helmholtz + P * m.V)],
+        [m.gibbs, (m.H - T * m.S)],
+        [m.gibbs, (m.molar_internal_energy - T * m.S + P * m.V)],
+    ]
 
     m.set_state(P, T + dT)
     G1 = m.gibbs
     S1 = m.S
     V1 = m.V
 
     m.set_state(P + dP, T)
     G2 = m.gibbs
     V2 = m.V
 
     # T derivatives
-    m.set_state(P, T + 0.5*dT)
-    expr.extend(['S = -dG/dT', 'alpha = 1/V dV/dT', 'C_p = T dS/dT'])
-    eq.extend([[m.S, -(G1 - G0)/dT],
-               [m.alpha, (V1 - V0)/dT/m.V],
-               [m.molar_heat_capacity_p, (T + 0.5*dT)*(S1 - S0)/dT]])
+    m.set_state(P, T + 0.5 * dT)
+    expr.extend(["S = -dG/dT", "alpha = 1/V dV/dT", "C_p = T dS/dT"])
+    eq.extend(
+        [
+            [m.S, -(G1 - G0) / dT],
+            [m.alpha, (V1 - V0) / dT / m.V],
+            [m.molar_heat_capacity_p, (T + 0.5 * dT) * (S1 - S0) / dT],
+        ]
+    )
 
     # P derivatives
-    m.set_state(P + 0.5*dP, T)
-    expr.extend(['V = dG/dP', 'K_T = -V dP/dV'])
-    eq.extend([[m.V, (G2 - G0)/dP],
-               [m.K_T, -0.5*(V2 + V0)*dP/(V2 - V0)]])
-
-    expr.extend(['C_v = Cp - alpha^2*K_T*V*T', 'K_S = K_T*Cp/Cv',
-                 'gr = alpha*K_T*V/Cv'])
-    eq.extend([[m.molar_heat_capacity_v,
-                m.molar_heat_capacity_p - m.alpha*m.alpha*m.K_T*m.V*T],
-               [m.K_S, m.K_T*m.molar_heat_capacity_p/m.molar_heat_capacity_v],
-               [m.gr, m.alpha*m.K_T*m.V/m.molar_heat_capacity_v]])
+    m.set_state(P + 0.5 * dP, T)
+    expr.extend(["V = dG/dP", "K_T = -V dP/dV"])
+    eq.extend([[m.V, (G2 - G0) / dP], [m.K_T, -0.5 * (V2 + V0) * dP / (V2 - V0)]])
+
+    expr.extend(
+        ["C_v = Cp - alpha^2*K_T*V*T", "K_S = K_T*Cp/Cv", "gr = alpha*K_T*V/Cv"]
+    )
+    eq.extend(
+        [
+            [
+                m.molar_heat_capacity_v,
+                m.molar_heat_capacity_p - m.alpha * m.alpha * m.K_T * m.V * T,
+            ],
+            [m.K_S, m.K_T * m.molar_heat_capacity_p / m.molar_heat_capacity_v],
+            [m.gr, m.alpha * m.K_T * m.V / m.molar_heat_capacity_v],
+        ]
+    )
 
-    expr.append('Vphi = np.sqrt(K_S/rho)')
-    eq.append([m.bulk_sound_velocity, np.sqrt(m.K_S/m.rho)])
+    expr.append("Vphi = np.sqrt(K_S/rho)")
+    eq.append([m.bulk_sound_velocity, np.sqrt(m.K_S / m.rho)])
 
     if including_shear_properties:
-        expr.extend(['Vp = np.sqrt((K_S + 4G/3)/rho)',
-                     'Vs = np.sqrt(G_S/rho)'])
+        expr.extend(["Vp = np.sqrt((K_S + 4G/3)/rho)", "Vs = np.sqrt(G_S/rho)"])
 
         with warnings.catch_warnings(record=True) as w:
             warnings.simplefilter("always")
-            eq.extend([[m.p_wave_velocity, np.sqrt((m.K_S + 4.*m.G/3.)/m.rho)],
-                       [m.shear_wave_velocity, np.sqrt(m.G/m.rho)]])
+            eq.extend(
+                [
+                    [m.p_wave_velocity, np.sqrt((m.K_S + 4.0 * m.G / 3.0) / m.rho)],
+                    [m.shear_wave_velocity, np.sqrt(m.G / m.rho)],
+                ]
+            )
             if len(w) == 1:
                 print(w[0].message)
-                print('\nYou can suppress this message by setting the '
-                      'parameter\nincluding_shear_properties to False '
-                      'when calling check_eos_consistency.\n')
-        note = ''
+                print(
+                    "\nYou can suppress this message by setting the "
+                    "parameter\nincluding_shear_properties to False "
+                    "when calling check_eos_consistency.\n"
+                )
+        note = ""
     else:
-        note = ' (not including shear properties)'
+        note = " (not including shear properties)"
 
-    consistencies = [np.abs(e[0] - e[1])
-                     < np.abs(tol*e[1]) + np.finfo('float').eps for e in eq]
+    consistencies = [
+        np.abs(e[0] - e[1]) < np.abs(tol * e[1]) + np.finfo("float").eps for e in eq
+    ]
     eos_is_consistent = np.all(consistencies)
 
     if verbose:
-        print('Checking EoS consistency for {0:s}{1}'.format(m.to_string(),
-                                                             note))
-        print('Expressions within tolerance of {0:2f}'.format(tol))
+        print("Checking EoS consistency for {0:s}{1}".format(m.to_string(), note))
+        print("Expressions within tolerance of {0:2f}".format(tol))
         for i, c in enumerate(consistencies):
-            print('{0:10s} : {1:5s}'.format(expr[i], str(c)))
+            print("{0:10s} : {1:5s}".format(expr[i], str(c)))
         if eos_is_consistent:
-            print('All EoS consistency constraints satisfied for {0:s}'.format(m.to_string()))
+            print(
+                "All EoS consistency constraints satisfied for {0:s}".format(
+                    m.to_string()
+                )
+            )
         else:
-            print('Not satisfied all EoS consistency constraints for {0:s}'.format(m.to_string()))
+            print(
+                "Not satisfied all EoS consistency constraints for {0:s}".format(
+                    m.to_string()
+                )
+            )
 
     return eos_is_consistent
 
 
-def check_anisotropic_eos_consistency(m, P=1.e9, T=2000.,
-                                      tol=1.e-4, verbose=False):
+def check_anisotropic_eos_consistency(m, P=1.0e9, T=2000.0, tol=1.0e-4, verbose=False):
     """
-    Compute numerical derivatives of the gibbs free energy of a mineral
-    under given conditions, and check these values against those provided
-    analytically by the equation of state
-
-    Parameters
-    ----------
-    m : mineral
-        The mineral for which the equation of state
-        is to be checked for consistency
-    P : float
-        The pressure at which to check consistency
-    T : float
-        The temperature at which to check consistency
-    tol : float
-        The fractional tolerance for each of the checks
-    verbose : boolean
-        Decide whether to print information about each
-        check
-
-    Returns
-    -------
-    consistency: boolean
-        If all checks pass, returns True
+    Checks that numerical derivatives of the Gibbs energy of an anisotropic mineral
+    under given conditions are equal to those provided
+    analytically by the equation of state.
 
+    :param m: The anisotropic mineral for which the equation of state
+        is to be checked for consistency.
+    :type m: :class:`burnman.AnisotropicMineral`
+
+    :param P: The pressure at which to check consistency.
+    :type P: float
+
+    :param T: The temperature at which to check consistency.
+    :type T: float
+
+    :param tol: The fractional tolerance for each of the checks.
+    :type tol: float
+
+    :param verbose: Decide whether to print information about each check.
+    :type verbose: bool
+
+    :returns: Boolean stating whether all checks have passed.
+    :rtype: bool
     """
-    dT = 1.
-    dP = 1000.
+    dT = 1.0
+    dP = 1000.0
 
     m.set_state(P, T)
     G0 = m.gibbs
     S0 = m.S
     V0 = m.V
 
-    expr = ['G = F + PV', 'G = H - TS', 'G = E - TS + PV']
-    eq = [[m.gibbs, (m.helmholtz + P*m.V)],
-          [m.gibbs, (m.H - T*m.S)],
-          [m.gibbs, (m.molar_internal_energy - T*m.S + P*m.V)]]
+    expr = ["G = F + PV", "G = H - TS", "G = E - TS + PV"]
+    eq = [
+        [m.gibbs, (m.helmholtz + P * m.V)],
+        [m.gibbs, (m.H - T * m.S)],
+        [m.gibbs, (m.molar_internal_energy - T * m.S + P * m.V)],
+    ]
 
     m.set_state(P, T + dT)
     G1 = m.gibbs
     S1 = m.S
     V1 = m.V
 
     m.set_state(P + dP, T)
     G2 = m.gibbs
     V2 = m.V
 
     # T derivatives
-    m.set_state(P, T + 0.5*dT)
-    expr.extend(['S = -dG/dT', 'alpha = 1/V dV/dT', 'C_p = T dS/dT'])
-    eq.extend([[m.S, -(G1 - G0)/dT],
-               [m.alpha, (V1 - V0)/dT/m.V],
-               [m.molar_heat_capacity_p, (T + 0.5*dT)*(S1 - S0)/dT]])
+    m.set_state(P, T + 0.5 * dT)
+    expr.extend(["S = -dG/dT", "alpha = 1/V dV/dT", "C_p = T dS/dT"])
+    eq.extend(
+        [
+            [m.S, -(G1 - G0) / dT],
+            [m.alpha, (V1 - V0) / dT / m.V],
+            [m.molar_heat_capacity_p, (T + 0.5 * dT) * (S1 - S0) / dT],
+        ]
+    )
 
     # P derivatives
-    m.set_state(P + 0.5*dP, T)
-    expr.extend(['V = dG/dP', 'K_T = -V dP/dV'])
-    eq.extend([[m.V, (G2 - G0)/dP],
-               [m.isothermal_bulk_modulus_reuss, -0.5*(V2 + V0)*dP/(V2 - V0)]])
-
-    expr.extend(['C_v = Cp - alpha^2*K_T*V*T', 'K_S = K_T*Cp/Cv'])
-    eq.extend([[m.molar_heat_capacity_v,
-                m.molar_heat_capacity_p - m.alpha*m.alpha*m.K_T*m.V*T],
-               [m.isentropic_bulk_modulus_reuss,
+    m.set_state(P + 0.5 * dP, T)
+    expr.extend(["V = dG/dP", "K_T = -V dP/dV"])
+    eq.extend(
+        [
+            [m.V, (G2 - G0) / dP],
+            [m.isothermal_bulk_modulus_reuss, -0.5 * (V2 + V0) * dP / (V2 - V0)],
+        ]
+    )
+
+    expr.extend(["C_v = Cp - alpha^2*K_T*V*T", "K_S = K_T*Cp/Cv"])
+    eq.extend(
+        [
+            [
+                m.molar_heat_capacity_v,
+                m.molar_heat_capacity_p - m.alpha * m.alpha * m.K_T * m.V * T,
+            ],
+            [
+                m.isentropic_bulk_modulus_reuss,
                 m.isothermal_bulk_modulus_reuss
-                * m.molar_heat_capacity_p / m.molar_heat_capacity_v]])
+                * m.molar_heat_capacity_p
+                / m.molar_heat_capacity_v,
+            ],
+        ]
+    )
 
     # Third derivative
     m.set_state(P + 0.5 * dP, T)
     b0 = m.isothermal_compressibility_tensor
     F0 = m.deformation_gradient_tensor
 
     m.set_state(P + 0.5 * dP, T + dT)
@@ -205,79 +246,103 @@
 
     m.set_state(P + dP, T + 0.5 * dT)
     a1 = m.thermal_expansivity_tensor
     F3 = m.deformation_gradient_tensor
 
     m.set_state(P + 0.5 * dP, T + 0.5 * dT)
 
-    beta0 = -(logm(F3) - logm(F2))/dP
-    alpha0 = (logm(F1) - logm(F0))/dT
+    beta0 = -(logm(F3) - logm(F2)) / dP
+    alpha0 = (logm(F1) - logm(F0)) / dT
 
     Q = m.deformed_coordinate_frame
     beta1 = m.isothermal_compressibility_tensor
     alpha1 = m.thermal_expansivity_tensor
 
-    beta1 = np.einsum('mi, nj, ij->mn', Q, Q, beta1)
-    alpha1 = np.einsum('mi, nj, ij->mn', Q, Q, alpha1)
+    beta1 = np.einsum("mi, nj, ij->mn", Q, Q, beta1)
+    alpha1 = np.einsum("mi, nj, ij->mn", Q, Q, alpha1)
+
+    expr.extend([f"SI = -d(lnm(F))/dP ({i}{j})" for i in range(3) for j in range(i, 3)])
+    eq.extend([[beta0[i, j], beta1[i, j]] for i in range(3) for j in range(i, 3)])
 
-    expr.extend([f'SI = -d(lnm(F))/dP ({i}{j})'
-                 for i in range(3) for j in range(i, 3)])
-    eq.extend([[beta0[i, j], beta1[i, j]]
-               for i in range(3) for j in range(i, 3)])
-
-    expr.extend([f'alpha = d(lnm(F))/dT ({i}{j})'
-                 for i in range(3) for j in range(i, 3)])
-    eq.extend([[alpha0[i, j], alpha1[i, j]]
-               for i in range(3) for j in range(i, 3)])
-
-    expr.extend([f'd(alpha)/dP = -d(beta_T)/dT ({i}{j})'
-                 for i in range(3) for j in range(i, 3)])
-    eq.extend([[(a1[i, j] - a0[i, j])/dP, -(b1[i, j] - b0[i, j])/dT]
-               for i in range(3) for j in range(i, 3)])
+    expr.extend(
+        [f"alpha = d(lnm(F))/dT ({i}{j})" for i in range(3) for j in range(i, 3)]
+    )
+    eq.extend([[alpha0[i, j], alpha1[i, j]] for i in range(3) for j in range(i, 3)])
+
+    expr.extend(
+        [f"d(alpha)/dP = -d(beta_T)/dT ({i}{j})" for i in range(3) for j in range(i, 3)]
+    )
+    eq.extend(
+        [
+            [(a1[i, j] - a0[i, j]) / dP, -(b1[i, j] - b0[i, j]) / dT]
+            for i in range(3)
+            for j in range(i, 3)
+        ]
+    )
 
     # Consistent Phi
-    expr.extend(['dPsidf_Voigt[:3,:3] == 1'])
-    eq.extend([[np.sum(m.dPsidf_Voigt[:3,:3]), 1.]])
+    expr.extend(["dPsidf_Voigt[:3,:3] == 1"])
+    eq.extend(
+        [
+            [
+                np.sum(m.isothermal_compliance_tensor[:3, :3]),
+                m.isothermal_compressibility_reuss,
+            ]
+        ]
+    )
 
     # Consistent inverses
-    expr.extend([f'S_T = inv(C_T) ({i}{j})'
-                 for i in range(6) for j in range(i, 6)])
+    expr.extend([f"S_T = inv(C_T) ({i}{j})" for i in range(6) for j in range(i, 6)])
     S_T = m.isothermal_compliance_tensor
     S_T2 = np.linalg.inv(m.isothermal_stiffness_tensor)
-    eq.extend([[S_T[i,j], S_T2[i,j]]
-               for i in range(6) for j in range(i, 6)])
+    eq.extend([[S_T[i, j], S_T2[i, j]] for i in range(6) for j in range(i, 6)])
 
-    expr.extend([f'S_N = inv(C_N) ({i}{j})'
-                 for i in range(6) for j in range(i, 6)])
+    expr.extend([f"S_N = inv(C_N) ({i}{j})" for i in range(6) for j in range(i, 6)])
     S_N = m.isentropic_compliance_tensor
     S_N2 = np.linalg.inv(m.isentropic_stiffness_tensor)
-    eq.extend([[S_N[i,j], S_N2[i,j]]
-               for i in range(6) for j in range(i, 6)])
+    eq.extend([[S_N[i, j], S_N2[i, j]] for i in range(6) for j in range(i, 6)])
 
     # Consistent isotropic and anisotropic properties
-    expr.extend(['V = det(M)',
-                 'alpha_v = tr(alpha)',
-                 'beta_T = sum(S_T I)',
-                 'beta_S = sum(S_S I)'])
-    eq.extend([[m.V, np.linalg.det(m.cell_vectors)],
-               [m.alpha, np.trace(m.thermal_expansivity_tensor)],
-               [m.beta_T, np.sum(m.isothermal_compliance_tensor[:3, :3])],
-               [m.beta_S, np.sum(m.isentropic_compliance_tensor[:3, :3])]])
-
-    expr.append('Vphi = np.sqrt(K_S/rho)')
-    eq.append([m.bulk_sound_velocity, np.sqrt(m.K_S/m.rho)])
-
-    consistencies = [np.abs(e[0] - e[1]) < np.abs(tol*e[1])
-                     + np.finfo('float').eps for e in eq]
+    expr.extend(
+        [
+            "V = det(M)",
+            "alpha_v = tr(alpha)",
+            "beta_T = sum(S_T I)",
+            "beta_S = sum(S_S I)",
+        ]
+    )
+    eq.extend(
+        [
+            [m.V, np.linalg.det(m.cell_vectors)],
+            [m.alpha, np.trace(m.thermal_expansivity_tensor)],
+            [m.beta_T, np.sum(m.isothermal_compliance_tensor[:3, :3])],
+            [m.beta_S, np.sum(m.isentropic_compliance_tensor[:3, :3])],
+        ]
+    )
+
+    expr.append("Vphi = np.sqrt(K_S/rho)")
+    eq.append([m.bulk_sound_velocity, np.sqrt(m.K_S / m.rho)])
+
+    consistencies = [
+        np.abs(e[0] - e[1]) < np.abs(tol * e[1]) + np.finfo("float").eps for e in eq
+    ]
     eos_is_consistent = np.all(consistencies)
 
     if verbose:
-        print('Checking EoS consistency for {0:s}'.format(m.to_string()))
-        print('Expressions within tolerance of {0:2f}'.format(tol))
+        print("Checking EoS consistency for {0:s}".format(m.to_string()))
+        print("Expressions within tolerance of {0:2f}".format(tol))
         for i, c in enumerate(consistencies):
-            print('{0:10s} : {1:5s}'.format(expr[i], str(c)))
+            print("{0:10s} : {1:5s}".format(expr[i], str(c)))
         if eos_is_consistent:
-            print('All EoS consistency constraints satisfied for {0:s}'.format(m.to_string()))
+            print(
+                "All EoS consistency constraints satisfied for {0:s}".format(
+                    m.to_string()
+                )
+            )
         else:
-            print('Not satisfied all EoS consistency constraints for {0:s}'.format(m.to_string()))
+            print(
+                "Not satisfied all EoS consistency constraints for {0:s}".format(
+                    m.to_string()
+                )
+            )
 
     return eos_is_consistent
```

### Comparing `burnman-1.1.0/burnman/tools/equilibration.py` & `burnman-1.2.0/burnman/tools/equilibration.py`

 * *Files 27% similar despite different names*

```diff
@@ -25,60 +25,53 @@
       - All phase fractions must be positive
       - All site-species occupancies must be positive
 
     The constraints are stored in a vector (b) and matrix (A).
     The sign convention is chosen such that the constraint is satisfied
     if A.x + b < eps.
 
-    Parameters
-    ----------
-    assemblage : burnman.Composite object
-        The assemblage for which the constraints are calculated.
-
-    Returns
-    -------
-    c_vector :
-        The constraints vector.
+    :param assemblage: The assemblage for which the constraints are calculated.
+    :type assemblage: :class:`burnman.Composite`
 
-    c_matrix :
-        The constraints matrix.
+    :returns: The constraints vector and matrix.
+    :rtype: tuple
     """
     bounds = []
     n_constraints = 0
     for i, n in enumerate(assemblage.endmembers_per_phase):
         n_constraints += 1
         if n == 1:
             bounds.append(np.array([[]]))
         else:
             bounds.append(assemblage.phases[i].solution_model.endmember_occupancies)
             n_constraints += len(bounds[-1][0])
 
-    c_vector = np.zeros((n_constraints+2))
-    c_matrix = np.zeros((n_constraints+2,
-                         assemblage.n_endmembers
-                         + 2 + n_free_compositional_vectors))  # includes P, T
+    c_vector = np.zeros((n_constraints + 2))
+    c_matrix = np.zeros(
+        (n_constraints + 2, assemblage.n_endmembers + 2 + n_free_compositional_vectors)
+    )  # includes P, T
 
     c_matrix[0, 0] = -1  # P>0
     c_matrix[1, 1] = -1  # T>0
 
     cidx = 2  # index of current compositional constraint
     pidx = 0  # starting index of current phase
     for i, n in enumerate(assemblage.endmembers_per_phase):
         m = len(bounds[i][0])
         # The first endmember proportion is not a free variable
         # (all endmembers in any solution must sum to one)
         # Re-express the constraints without the first endmember
-        c_matrix[cidx, pidx+2] = -1.  # need phase proportions > 0
+        c_matrix[cidx, pidx + 2] = -1.0  # need phase proportions > 0
         cidx += 1
         if m != 0:
-            c_vector[cidx:cidx+m] = -bounds[i][0]
-            c_matrix[cidx:cidx+m,
-                     pidx+1+2:pidx+n+2] = (np.einsum('i, j', bounds[i][0],
-                                                     np.ones_like(bounds[i][1:, 0]))
-                                           - bounds[i].T[:, 1:])
+            c_vector[cidx : cidx + m] = -bounds[i][0]
+            c_matrix[cidx : cidx + m, pidx + 1 + 2 : pidx + n + 2] = (
+                np.einsum("i, j", bounds[i][0], np.ones_like(bounds[i][1:, 0]))
+                - bounds[i].T[:, 1:]
+            )
             cidx += m
         pidx += n
 
     return c_vector, c_matrix
 
 
 def get_parameters(assemblage, n_free_compositional_vectors=0):
@@ -89,285 +82,291 @@
       - pressure
       - temperature
       - absolute amount of each phase. if a phase is a solution
         with >1 endmember, the following parameters are the mole fractions
         of the independent endmembers in the solution, except for the first
         endmember (as the mole fractions must sum to one).
 
-    Parameters
-    ----------
-    assemblage : burnman.Composite object
-        The assemblage for which equilibrium is to be calculated.
-
-    Returns
-    -------
-    params : numpy array
-        An array containing the current parameter values.
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :returns: The current values of all the parameters.
+    :rtype: numpy.array
     """
-    params = np.zeros(assemblage.n_endmembers + 2
-                      + n_free_compositional_vectors)
+    params = np.zeros(assemblage.n_endmembers + 2 + n_free_compositional_vectors)
     n_moles_phase = assemblage.n_moles * np.array(assemblage.molar_fractions)
 
     try:
         params[:2] = [assemblage.pressure, assemblage.temperature]
     except AttributeError:
-        raise Exception('You need to set_state before getting parameters')
+        raise Exception("You need to set_state before getting parameters")
 
     j = 2
     for i, ph in enumerate(assemblage.phases):
         params[j] = n_moles_phase[i]
         if isinstance(ph, Solution):
-            params[j+1:j+assemblage.endmembers_per_phase[i]] = assemblage.phases[i].molar_fractions[1:]
+            params[j + 1 : j + assemblage.endmembers_per_phase[i]] = assemblage.phases[
+                i
+            ].molar_fractions[1:]
         j += assemblage.endmembers_per_phase[i]
 
     return params
 
 
 def get_endmember_amounts(assemblage):
     """
     Gets the absolute amounts of all the endmembers in the solution.
 
-    Parameters
-    ----------
-    assemblage : burnman.Composite object
-        The assemblage for which equilibrium is to be calculated.
-
-    Returns
-    -------
-    amounts : numpy array
-        An array containing the current amounts of all the endmembers.
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :returns: The current amounts of all the endmembers.
+    :rtype: numpy.array
     """
     phase_amounts = assemblage.n_moles * assemblage.molar_fractions
     amounts = np.empty(assemblage.n_endmembers)
     j = 0
     for i, ph in enumerate(assemblage.phases):
         if isinstance(ph, Solution):
-            amounts[j:j+assemblage.endmembers_per_phase[i]] = phase_amounts[i] * assemblage.phases[i].molar_fractions
+            amounts[j : j + assemblage.endmembers_per_phase[i]] = (
+                phase_amounts[i] * assemblage.phases[i].molar_fractions
+            )
         else:
             amounts[j] = phase_amounts[i]
         j += assemblage.endmembers_per_phase[i]
 
     return amounts
 
 
 def set_compositions_and_state_from_parameters(assemblage, parameters):
     """
     Sets the phase compositions, amounts and state of the assemblage
     from a list of parameter values.
 
-    Parameters
-    ----------
-    assemblage : burnman.Composite object
-        The assemblage for which equilibrium is to be calculated.
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
 
-    parameters : numpy array
-        An array containing the current parameter values.
+    :param parameters: The current parameter values.
+    :type parameters: numpy.array
     """
     assemblage.set_state(parameters[0], parameters[1])
     i = 2
     phase_amounts = np.zeros(len(assemblage.phases))
     for phase_idx, ph in enumerate(assemblage.phases):
         phase_amounts[phase_idx] = parameters[i]
         if isinstance(ph, Solution):
             n_mbrs = len(ph.endmembers)
-            f = [0.]*n_mbrs
-            f[1:] = parameters[i+1:i+n_mbrs]
-            f[0] = 1. - sum(f)
+            f = [0.0] * n_mbrs
+            f[1:] = parameters[i + 1 : i + n_mbrs]
+            f[0] = 1.0 - sum(f)
             ph.set_composition(f)
             i += n_mbrs
         else:
             i += 1
 
-    assert(np.all(phase_amounts > -1.e-8))
+    assert np.all(phase_amounts > -1.0e-8)
     phase_amounts = np.abs(phase_amounts)
     assemblage.n_moles = sum(phase_amounts)
-    assemblage.set_fractions(phase_amounts/assemblage.n_moles)
+    assemblage.set_fractions(phase_amounts / assemblage.n_moles)
     return None
 
 
-def F(x, assemblage, equality_constraints, reduced_composition_vector,
-      reduced_free_composition_vectors):
+def F(
+    x,
+    assemblage,
+    equality_constraints,
+    reduced_composition_vector,
+    reduced_free_composition_vectors,
+):
     """
-    Returns a vector of values which are zero at equilibrium.
+    The vector-valued function for which the root is sought.
     The first two vector values depend on the
     equality_constraints chosen. For example, if
       - eq[i][0] = 'P', F[i] = P - eq[i][1]
       - eq[i][0] = 'T', F[i] = T - eq[i][1]
       - eq[i][0] = 'S', F[i] = entropy - eq[i][1]
       - eq[i][0] = 'V', F[i] = volume - eq[i][1]
       - eq[i][0] = 'PT_ellipse', F[i] = norm(([P, T] - eq[i][1][0])/eq[i][1][1]) - 1
       - eq[i][0] = 'X', np.dot(eq[i][1][0], x) - eq[i][1][1]
 
     The next set of vector values correspond to the reaction affinities.
     The final set of vector values correspond to the bulk
     composition constraints.
 
-    Parameters
-    ----------
-    x : numpy array
-        Parameter values for the equilibrium problem to be solved.
+    :param x: Parameter values for the equilibrium problem to be solved.
+    :type x: numpy array
 
-    assemblage : burnman.Composite object
-        The assemblage for which equilibrium is to be calculated.
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
 
-    equality_constraints : list of lists
-        A list of the equality constraints (see above).
+    :param equality_constraints: A list of the equality constraints
+        (see above for valid formats).
+    :type equality_constraints: list of lists
 
-    reduced_composition_vector : numpy array
-        The vector corresponding to the amounts of the independent
+    :param reduced_composition_vector: The amounts of the independent
         elements.
+    :type reduced_composition_vector: numpy.array
 
-    reduced_free_composition_vectors : 2D numpy array
-        The amounts of the independent elements in each of the
-        free_compositional_vectors.
-
-    Returns
-    -------
-    eqns : numpy array
-        An array containing the vector values which
-        are equal to zero at equilibrium.
+    :param reduced_free_composition_vectors: The amounts of the
+        independent elements in each of the free_compositional_vectors.
+    :type reduced_free_composition_vectors: 2D numpy.array
+
+    :returns: The vector corresponding to F(x).
+    :rtype: numpy.array
     """
 
     set_compositions_and_state_from_parameters(assemblage, x)
     new_endmember_amounts = get_endmember_amounts(assemblage)
 
     # We want to find the root of the following equations
     n_equality_constraints = len(equality_constraints)
     eqns = np.zeros((assemblage.n_endmembers + n_equality_constraints))
     i = 0
     for i, (type_c, eq_c) in enumerate(equality_constraints):
-        if type_c == 'P':
+        if type_c == "P":
             eqns[i] = x[0] - eq_c
-        elif type_c == 'T':
+        elif type_c == "T":
             eqns[i] = x[1] - eq_c
-        elif type_c == 'S':
-            eqns[i] = assemblage.molar_entropy*assemblage.n_moles - eq_c
-        elif type_c == 'V':
-            eqns[i] = assemblage.molar_volume*assemblage.n_moles - eq_c
-        elif type_c == 'PT_ellipse':
-            v_scaled = (x[0:2] - eq_c[0])/eq_c[1]
-            eqns[i] = np.linalg.norm(v_scaled) - 1.
-        elif type_c == 'X':
+        elif type_c == "S":
+            eqns[i] = assemblage.molar_entropy * assemblage.n_moles - eq_c
+        elif type_c == "V":
+            eqns[i] = assemblage.molar_volume * assemblage.n_moles - eq_c
+        elif type_c == "PT_ellipse":
+            v_scaled = (x[0:2] - eq_c[0]) / eq_c[1]
+            eqns[i] = np.linalg.norm(v_scaled) - 1.0
+        elif type_c == "X":
             eqns[i] = np.dot(eq_c[0], x) - eq_c[1]  # i.e. Ax = b
         else:
-            raise Exception('constraint type not recognised')
+            raise Exception("constraint type not recognised")
     i += 1
     if n_equality_constraints > 2:
-        new_reduced_composition_vector = (reduced_composition_vector
-                                          + x[2-n_equality_constraints:].dot(reduced_free_composition_vectors))
+        new_reduced_composition_vector = reduced_composition_vector + x[
+            2 - n_equality_constraints :
+        ].dot(reduced_free_composition_vectors)
     else:
         new_reduced_composition_vector = reduced_composition_vector
-    eqns[i:i+assemblage.n_reactions] = assemblage.reaction_affinities
-    eqns[i+assemblage.n_reactions:] = (np.dot(assemblage.reduced_stoichiometric_array.T,
-                                              new_endmember_amounts)
-                                       - new_reduced_composition_vector)
+    eqns[i : i + assemblage.n_reactions] = assemblage.reaction_affinities
+    eqns[i + assemblage.n_reactions :] = (
+        np.dot(assemblage.reduced_stoichiometric_array.T, new_endmember_amounts)
+        - new_reduced_composition_vector
+    )
     return eqns
 
 
-def jacobian(x, assemblage, equality_constraints,
-             reduced_free_composition_vectors):
+def jacobian(x, assemblage, equality_constraints, reduced_free_composition_vectors):
     """
-    The Jacobian of the equilibrium problem (dF/dx).
-    See documentation for F and get_parameters
-    (which return F and x respectively) for more details.
-
-    Parameters
-    ----------
-    x : numpy array
-        Parameter values for the equilibrium problem to be solved.
-
-    assemblage : burnman.Composite object
-        The assemblage for which equilibrium is to be calculated.
-
-    equality_constraints : list of lists
-        A list of the equality constraints (see documentation for F).
-
-    reduced_free_composition_vectors : 2D numpy array
-        The amounts of the independent elements in each of the
-        free_compositional_vectors.
-
-    Returns
-    -------
-    jacobian : 2D numpy array
-        An array containing the Jacobian for the equilibrium problem.
+    The Jacobian of the vector-valued function :math:`F` for which the
+    root is sought (:math:`\\partial F / \\partial x`).
+    See documentation for :func:`F` and :func:`get_parameters`
+    (which return :math:`F` and :math:`x` respectively) for more details.
+
+    :param x: Parameter values for the equilibrium problem to be solved.
+    :type x: numpy.array
+
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :param equality_constraints: A list of the equality constraints
+        (see documentation for :func:`burnman.tools.equilbration.F`).
+    :type equality_constraints: list of lists
+
+    :param reduced_free_composition_vectors: The amounts of the
+        independent elements in each of the free_compositional_vectors.
+    :type reduced_free_composition_vectors: 2D numpy array
+
+    :returns: The Jacobian for the equilibrium problem.
+    :rtype: 2D numpy.array
+
     """
     # The solver always calls the Jacobian with the same
     # x parameters as used previously for the root functions
     # Therefore we don't need to set compositions or state again here.
 
     # First, we find out the effect of the two constraint parameters F[:2]
     # on the pressure (x[0]) and temperature (x[1]):
     n_equality_constraints = len(equality_constraints)
-    jacobian = np.zeros((assemblage.n_endmembers+n_equality_constraints,
-                         assemblage.n_endmembers+n_equality_constraints))
+    jacobian = np.zeros(
+        (
+            assemblage.n_endmembers + n_equality_constraints,
+            assemblage.n_endmembers + n_equality_constraints,
+        )
+    )
     ic = 0
     for ic, (type_c, eq_c) in enumerate(equality_constraints):
-        if type_c == 'P':  # dP/dx
-            jacobian[ic, 0] = 1.  # jacobian[i, j!=0] = 0
-        elif type_c == 'T':  # dT/dx
-            jacobian[ic, 1] = 1.  # jacobian[i, j!=1] = 0
-        elif type_c == 'S':  # dS/dx
+        if type_c == "P":  # dP/dx
+            jacobian[ic, 0] = 1.0  # jacobian[i, j!=0] = 0
+        elif type_c == "T":  # dT/dx
+            jacobian[ic, 1] = 1.0  # jacobian[i, j!=1] = 0
+        elif type_c == "S":  # dS/dx
             # dS/dP = -aV, dS/dT = Cp/T
-            jacobian[ic, 0:2] = [-assemblage.n_moles
-                                 * assemblage.alpha
-                                 * assemblage.molar_volume,
-                                 assemblage.n_moles
-                                 * assemblage.molar_heat_capacity_p / x[1]]
+            jacobian[ic, 0:2] = [
+                -assemblage.n_moles * assemblage.alpha * assemblage.molar_volume,
+                assemblage.n_moles * assemblage.molar_heat_capacity_p / x[1],
+            ]
             j = 2
             for k, n in enumerate(assemblage.endmembers_per_phase):
                 jacobian[ic, j] = assemblage.phases[k].molar_entropy
                 if n > 1:  # for solutions with >1 endmember
-                    jacobian[ic, j+1:j+n] = (assemblage.n_moles
-                                             * assemblage.molar_fractions[k]
-                                             * (assemblage.phases[k].partial_entropies[1:]
-                                                - assemblage.phases[k].partial_entropies[0]))
+                    jacobian[ic, j + 1 : j + n] = (
+                        assemblage.n_moles
+                        * assemblage.molar_fractions[k]
+                        * (
+                            assemblage.phases[k].partial_entropies[1:]
+                            - assemblage.phases[k].partial_entropies[0]
+                        )
+                    )
                 j += n
-        elif type_c == 'V':  # dV/dx
+        elif type_c == "V":  # dV/dx
             # dV/dP = -V/K_T, dV/dT = aV
-            jacobian[ic, 0:2] = [-assemblage.n_moles
-                                 * assemblage.molar_volume / assemblage.K_T,
-                                 assemblage.n_moles*assemblage.molar_volume]
+            jacobian[ic, 0:2] = [
+                -assemblage.n_moles * assemblage.molar_volume / assemblage.K_T,
+                assemblage.n_moles * assemblage.molar_volume,
+            ]
             j = 2
             for k, n in enumerate(assemblage.endmembers_per_phase):
                 jacobian[ic, j] = assemblage.phases[k].molar_volume
                 if n > 1:  # for solutions with >1 stable endmember
-                    jacobian[ic, j+1:j+n] = (assemblage.n_moles
-                                             * assemblage.molar_fractions[k]
-                                             * (assemblage.phases[k].partial_volumes[1:]
-                                                - assemblage.phases[k].partial_volumes[0]))
+                    jacobian[ic, j + 1 : j + n] = (
+                        assemblage.n_moles
+                        * assemblage.molar_fractions[k]
+                        * (
+                            assemblage.phases[k].partial_volumes[1:]
+                            - assemblage.phases[k].partial_volumes[0]
+                        )
+                    )
                 j += n
-        elif type_c == 'PT_ellipse':
-            v_scaled = (x[0:2] - eq_c[0])/eq_c[1]
-            jacobian[ic, 0:2] = v_scaled/(np.linalg.norm(v_scaled)*eq_c[1])
-        elif type_c == 'X':
+        elif type_c == "PT_ellipse":
+            v_scaled = (x[0:2] - eq_c[0]) / eq_c[1]
+            jacobian[ic, 0:2] = v_scaled / (np.linalg.norm(v_scaled) * eq_c[1])
+        elif type_c == "X":
             jacobian[ic, :] = eq_c[0]
         else:
-            raise Exception('constraint type not recognised')
+            raise Exception("constraint type not recognised")
     ic += 1
 
     # Next, let's get the effect of pressure and temperature
     # on each of the independent reactions
     # i.e. dF(i, reactions)/dx[0] and dF(i, reactions)/dx[1]
     partial_volumes_vector = np.zeros((assemblage.n_endmembers))
     partial_entropies_vector = np.zeros((assemblage.n_endmembers))
     j = 0
     for i, n in enumerate(assemblage.endmembers_per_phase):
         if n == 1:  # for endmembers
             partial_volumes_vector[j] = assemblage.phases[i].molar_volume
             partial_entropies_vector[j] = assemblage.phases[i].molar_entropy
         else:  # for solutions
-            partial_volumes_vector[j:j+n] = assemblage.phases[i].partial_volumes
-            partial_entropies_vector[j:j+n] = assemblage.phases[i].partial_entropies
+            partial_volumes_vector[j : j + n] = assemblage.phases[i].partial_volumes
+            partial_entropies_vector[j : j + n] = assemblage.phases[i].partial_entropies
         j += n
     reaction_volumes = np.dot(assemblage.reaction_basis, partial_volumes_vector)
     reaction_entropies = np.dot(assemblage.reaction_basis, partial_entropies_vector)
 
     # dGi/dP = deltaVi; dGi/dT = -deltaSi
-    jacobian[ic:ic+len(reaction_volumes), 0] = reaction_volumes
-    jacobian[ic:ic+len(reaction_volumes), 1] = -reaction_entropies
+    jacobian[ic : ic + len(reaction_volumes), 0] = reaction_volumes
+    jacobian[ic : ic + len(reaction_volumes), 1] = -reaction_entropies
 
     # Pressure and temperature have no effect on the bulk
     # compositional constraints
     # i.e. dF(i, bulk)/dx[0] and dF(i, bulk)/dx[1] = 0
 
     # Finally, let's build the compositional Hessian d2G/dfidfj = dmui/dfj
     # where fj is the fraction of endmember j in a phase
@@ -377,556 +376,656 @@
     dpi_dxj = np.zeros((assemblage.n_endmembers, assemblage.n_endmembers))
     j = 0
     for i, n in enumerate(assemblage.endmembers_per_phase):
         if n == 1:
             # changing the amount (p) of a pure phase
             # does not change its fraction in that phase,
             # so dfi_dxj remains unchanged
-            dpi_dxj[j, j] = 1.
+            dpi_dxj[j, j] = 1.0
         else:
-            comp_hessian[j:j+n, j:j+n] = assemblage.phases[i].gibbs_hessian
+            comp_hessian[j : j + n, j : j + n] = assemblage.phases[i].gibbs_hessian
 
             # x[0] = p(phase) and x[1:] = f[1:] - f[0]
             # Therefore
             # df[0]/dx[0] = 0
             # df[0]/dx[1:] = -1
             # (because changing the fraction of any endmember
             # depletes the fraction of the first endmember)
             # df[1:]/dx[1:] = 1 on diagonal, 0 otherwise
             # (because all other fractions are independent of each other)
-            dfi_dxj[j:j+n, j:j+n] = np.eye(n)
-            dfi_dxj[j, j:j+n] -= 1.
+            dfi_dxj[j : j + n, j : j + n] = np.eye(n)
+            dfi_dxj[j, j : j + n] -= 1.0
             # Total amounts of endmembers (p) are the fractions
             # multiplied by the amounts of their representative phases
-            dpi_dxj[j:j+n, j:j+n] = dfi_dxj[j:j+n, j:j+n] * phase_amounts[i]
+            dpi_dxj[j : j + n, j : j + n] = (
+                dfi_dxj[j : j + n, j : j + n] * phase_amounts[i]
+            )
             # The derivative of the amount of each endmember with respect
             # to the amount of each phase is equal to the molar fractions
             # of the endmembers.
-            dpi_dxj[j:j+n, j] = assemblage.phases[i].molar_fractions
+            dpi_dxj[j : j + n, j] = assemblage.phases[i].molar_fractions
         j += n
 
     # dfi_dxj converts the endmember hessian to the parameter hessian.
     reaction_hessian = assemblage.reaction_basis.dot(comp_hessian).dot(dfi_dxj)
     bulk_hessian = assemblage.reduced_stoichiometric_array.T.dot(dpi_dxj)
 
     if reaction_hessian.shape[0] > 0:
-        jacobian[ic:, 2:2+len(reaction_hessian[0])] = np.concatenate((reaction_hessian, bulk_hessian))
+        jacobian[ic:, 2 : 2 + len(reaction_hessian[0])] = np.concatenate(
+            (reaction_hessian, bulk_hessian)
+        )
     else:
-        jacobian[ic:, 2:2+len(bulk_hessian[0])] = bulk_hessian
+        jacobian[ic:, 2 : 2 + len(bulk_hessian[0])] = bulk_hessian
 
     if len(reduced_free_composition_vectors) > 0:
-        jacobian[-reduced_free_composition_vectors.shape[1]:, 2+len(reaction_hessian[0]):] = -reduced_free_composition_vectors.T
+        jacobian[
+            -reduced_free_composition_vectors.shape[1] :, 2 + len(reaction_hessian[0]) :
+        ] = -reduced_free_composition_vectors.T
 
     return jacobian
 
 
 def lambda_bounds(dx, x, endmembers_per_phase):
     """
     Returns the lambda bounds for the damped affine invariant modification
     to Newton's method for nonlinear problems (Deuflhard, 1974;1975;2004).
 
-    Parameters
-    ----------
-    dx : numpy array
-        The proposed newton step.
+    :param dx: The proposed newton step.
+    :type dx: numpy.array
 
-    x : numpy array
-        Parameter values for the equilibrium problem to be solved.
+    :param x: Parameter values for the equilibrium problem to be solved.
+    :type x: numpy.array
 
-    endmembers_per_phase : list of integers
-        A list of the number of endmembers in each phase.
+    :param endmembers_per_phase: A list of the number of endmembers in each phase.
+    :type endmembers_per_phase: list of int
 
-    Returns
-    -------
-    lmda_bounds : tuple of floats
-        minimum and maximum allowed fractions of the full newton step (dx).
+    :returns: Minimum and maximum allowed fractions of the full newton step (dx).
+    :rtype: tuple of floats
     """
 
-    max_steps = np.ones((len(x)))*100000.
+    max_steps = np.ones((len(x))) * 100000.0
 
     # first two constraints are P and T
-    max_steps[0:2] = [20.e9, 500.]  # biggest reasonable P and T steps
+    max_steps[0:2] = [20.0e9, 500.0]  # biggest reasonable P and T steps
 
     j = 2
     for i, n in enumerate(endmembers_per_phase):
         # if the phase fraction constraint would be broken,
         # set a step that is marginally smaller
-        if x[j] + dx[j] < 0.:
-            max_steps[j] = max(x[j]*0.999, 0.001)
-        max_steps[j+1:j+n] = [max(xi*0.99, 0.01) for xi in x[j+1:j+n]]  # maximum compositional step
+        if x[j] + dx[j] < 0.0:
+            max_steps[j] = max(x[j] * 0.999, 0.001)
+        max_steps[j + 1 : j + n] = [
+            max(xi * 0.99, 0.01) for xi in x[j + 1 : j + n]
+        ]  # maximum compositional step
         j += n
 
-    max_lmda = min([1. if step <= max_steps[i] else max_steps[i]/step
-                    for i, step in enumerate(np.abs(dx))])
+    max_lmda = min(
+        [
+            1.0 if step <= max_steps[i] else max_steps[i] / step
+            for i, step in enumerate(np.abs(dx))
+        ]
+    )
 
-    return (1.e-8, max_lmda)
+    return (1.0e-8, max_lmda)
 
 
 def phase_fraction_constraints(phase, assemblage, fractions, prm):
     """
     Converts a phase fraction constraint into standard linear form
     that can be processed by the root finding problem.
 
-    Parameters
-    ----------
-    phase : burnman.Solution or burnman.Mineral
-        The phase for which the fraction is to be constrained
+    We start with a single fraction or an array of fractions
+    for a particular phase (:math:`n_p / \\sum n = f`).
+    These are then converted into the "X" form of constraint
+    by multiplying by :math:`\\sum n` and moving all terms to
+    the LHS of the equation:
 
-    assemblage : burnman.Composite
-        The assemblage for which equilibrium is to be calculated.
+    :math:`-f n_0 - f n_1 - \\ldots + (1-f) n_p - \\ldots = 0`
+
+    This form is less readable, but easier to use as a constraint
+    in a nonlinear solve.
 
-    fractions : numpy array
-        The phase fractions to be satified at equilibrium.
+    :param phase: The phase for which the fraction is to be constrained
+    :type phase: :class:`burnman.Solution` or :class:`burnman.Mineral`
 
-    prm : namedtuple
-        A tuple with attributes n_parameters
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :param fractions: The phase fractions to be satified at equilibrium.
+    :type fractions: numpy.array
+
+    :param prm: A tuple with attributes n_parameters
         (the number of parameters for the current equilibrium problem)
         and phase_amount_indices (the indices of the parameters that
         correspond to phase amounts).
+    :type prm: namedtuple
 
-    Returns
-    -------
-    constraints : list
-        An list of the phase fraction constraints.
+    :returns: The phase fraction constraints.
+    :rtype: list
     """
     phase_idx = assemblage.phases.index(phase)
 
     constraints = []
     for fraction in fractions:
-        constraints.append(['X', [np.zeros((prm.n_parameters)), 0.]])
+        constraints.append(["X", [np.zeros((prm.n_parameters)), 0.0]])
         constraints[-1][-1][0][prm.phase_amount_indices] = -fraction
-        constraints[-1][-1][0][prm.phase_amount_indices[phase_idx]] += 1.
+        constraints[-1][-1][0][prm.phase_amount_indices[phase_idx]] += 1.0
 
     return constraints
 
 
 def phase_composition_constraints(phase, assemblage, constraints, prm):
     """
     Converts a phase composition constraint into standard linear form
     that can be processed by the root finding problem.
 
     We start with constraints in the form (site_names, n, d, v), where
-    n*x/d*x = v and n and d are fixed vectors of site coefficients.
-    So, one could for example choose a constraint
+    :math:`(n x)/ (d x) = v` and :math:`n` and :math:`d` are fixed vectors of
+    site coefficients. So, one could for example choose a constraint
     ([Mg_A, Fe_A], [1., 0.], [1., 1.], [0.5]) which would
     correspond to equal amounts Mg and Fe on the A site.
 
-    These are then converted by this function into endmember proportions
-    (n'*p/d'*p = v). Because the proportions must add up to zero,
-    we can reexpress this ratio as a linear constraint:
-    [(n'[1:] - n'[0]) - v*(d'[1:] - d'[0])]*xi = v*d0 - n0
-    which is less easy for a human to understand
-    (in terms of chemical constraints), but easier to use as a constraint
+    This function converts the user-defined vectors of site constraints
+    :math:`n` and :math:`d` into vectors of endmember proportion
+    constraints :math:`n'` and :math:`d'`, such that
+    :math:`(n' x)/ (d' x) = v`. This is done via linear transformation
+    using the site occupancy matrix provided by :class:`burnman.Solution`.
+    By multiplying by the denominator, we have the following scalar
+    comparison: :math:`(n' x) = v (d' x)`
+
+    The equilibration function does not use the proportion of
+    the first endmember (as the endmember proportions must sum to one),
+    and so we split :math:`x`, :math:`n'` and :math:`d'` into the first
+    element and following elements:
+    :math:`(n'_0 x_0 + n'_i x_i) = v (d'_0 x_0 + d'_i x_i)`
+    where :math:`i` is taken over all elements apart from the first.
+
+    With some more rearranging we can express the constraint in standard
+    linear form:
+    :math:`(n'_0 (1 - \\sum_j x_j) + n'_i x_i) = v (d'_0 (1 - \\sum_j x_j) + d'_i x_i)`
+
+    :math:`(n'_0 + (n'_i - 1_i n'_0) x_i) = v (d'_0 + (d'_i - 1_i d'_0) x_i)`
+
+    :math:`(((n'_i - 1_i n'_0) - v(d'_i - 1_i d'_0)) x_i) = (v d'_0 - n'_0)`
+
+    This form is less readable, but easier to use as a constraint
     in a nonlinear solve.
 
-    Parameters
-    ----------
-    phase : burnman.Solution
-        The phase for which the composition is to be constrained
-
-    assemblage : burnman.Composite
-        The assemblage for which equilibrium is to be calculated.
-
-    constraints : a 4-tuple (list of strings, numpy array * 3)
-        A tuple corresponding to the desired constraints, in the form
-        (site_names, numerator, denominator, values).
-
-    Returns
-    -------
-    x_constraints : list
-        An list of the phase composition constraints in standard form.
+    :param phase: The phase for which the composition is to be constrained.
+    :type phase: :class:`burnman.Solution`
+
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :param constraints: The desired constraints in the form:
+        site_names (list of strings), numerator (numpy.array),
+        denominator (numpy.array), values (numpy.array).
+    :type constraints: tuple
+
+    :returns: The phase composition constraints in standard form.
+    :rtype: list
     """
     phase_idx = assemblage.phases.index(phase)
 
     site_names, numerator, denominator, values = constraints
-    site_indices = [phase.solution_model.site_names.index(name)
-                    for name in site_names]
+    site_indices = [phase.solution_model.site_names.index(name) for name in site_names]
     noccs = phase.solution_model.endmember_noccupancies
 
     # Converts site constraints into endmember constraints
     # Ends up with shape (n_endmembers, 2)
-    endmembers = np.dot(noccs[:, site_indices],
-                        np.array([numerator, denominator]).T)
+    endmembers = np.dot(noccs[:, site_indices], np.array([numerator, denominator]).T)
 
     numer0, denom0 = endmembers[0]
     endmembers -= endmembers[0]
     numer, denom = endmembers.T[:, 1:]
 
     # We start from the correct index
     start_idx = sum(assemblage.endmembers_per_phase[:phase_idx]) + 3
     n_indices = assemblage.endmembers_per_phase[phase_idx] - 1
 
     x_constraints = []
     for v in values:
-        f = v*denom0 - numer0
-        x_constraints.append(['X', [np.zeros((prm.n_parameters)), f]])
-        x_constraints[-1][1][0][start_idx:start_idx+n_indices] = numer - v*denom
+        f = v * denom0 - numer0
+        x_constraints.append(["X", [np.zeros((prm.n_parameters)), f]])
+        x_constraints[-1][1][0][start_idx : start_idx + n_indices] = numer - v * denom
 
     return x_constraints
 
 
-def get_equilibration_parameters(assemblage, composition,
-                                 free_compositional_vectors):
+def get_equilibration_parameters(assemblage, composition, free_compositional_vectors):
     """
     Builds a named tuple containing the parameter names and
     various other parameters needed by the equilibrium solve.
 
-    Parameters
-    ----------
-    assemblage : burnman.Composite
-        The assemblage for which equilibrium is to be calculated.
-
-    composition : dictionary
-        The bulk composition for the equilibrium problem.
-
-    free_compositional_vectors : list of dictionaries
-        The bulk compositional degrees of freedom
-        for the equilibrium problem.
-
-    Returns
-    -------
-    prm : namedtuple
-        A tuple with attributes n_parameters
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :param composition: The bulk composition for the equilibrium problem.
+    :type composition: dict
+
+    :param free_compositional_vectors: The bulk compositional
+        degrees of freedom for the equilibrium problem.
+    :type free_compositional_vectors: list of dictionaries
+
+    :returns: A tuple with attributes n_parameters
         (the number of parameters for the current equilibrium problem)
         and phase_amount_indices (the indices of the parameters that
         correspond to phase amounts).
+    :rtype: namedtuple
     """
     # Initialize a named tuple for the equilibration parameters
-    prm = namedtuple('assemblage_parameters', [])
+    prm = namedtuple("assemblage_parameters", [])
 
     # Process parameter names
-    prm.parameter_names = ['Pressure (Pa)', 'Temperature (K)']
+    prm.parameter_names = ["Pressure (Pa)", "Temperature (K)"]
     for i, n in enumerate(assemblage.endmembers_per_phase):
-        prm.parameter_names.append('x({0})'.format(assemblage.phases[i].name))
+        prm.parameter_names.append("x({0})".format(assemblage.phases[i].name))
         if n > 1:
-            p_names = ['p({0} in {1})'.format(n, assemblage.phases[i].name)
-                       for n in assemblage.phases[i].endmember_names[1:]]
+            p_names = [
+                "p({0} in {1})".format(n, assemblage.phases[i].name)
+                for n in assemblage.phases[i].endmember_names[1:]
+            ]
             prm.parameter_names.extend(p_names)
 
     n_free_compositional_vectors = len(free_compositional_vectors)
     for i in range(n_free_compositional_vectors):
-        prm.parameter_names.append(f'v_{i}')
+        prm.parameter_names.append(f"v_{i}")
 
     prm.n_parameters = len(prm.parameter_names)
-    prm.phase_amount_indices = [i for i in range(len(prm.parameter_names))
-                                if 'x(' in prm.parameter_names[i]]
+    prm.phase_amount_indices = [
+        i for i in range(len(prm.parameter_names)) if "x(" in prm.parameter_names[i]
+    ]
 
     # Find the bulk composition vector
-    prm.bulk_composition_vector = np.array([composition[e]
-                                            for e in assemblage.elements])
+    prm.bulk_composition_vector = np.array(
+        [composition[e] for e in assemblage.elements]
+    )
 
     if n_free_compositional_vectors > 0:
-        prm.free_compositional_vectors = np.array([[free_compositional_vectors[i][e]
-                                                    if e in free_compositional_vectors[i]
-                                                    else 0. for e in assemblage.elements]
-                                                   for i in range(n_free_compositional_vectors)])
+        prm.free_compositional_vectors = np.array(
+            [
+                [
+                    free_compositional_vectors[i][e]
+                    if e in free_compositional_vectors[i]
+                    else 0.0
+                    for e in assemblage.elements
+                ]
+                for i in range(n_free_compositional_vectors)
+            ]
+        )
     else:
         prm.free_compositional_vectors = np.empty((0, len(assemblage.elements)))
 
     if assemblage.compositional_null_basis.shape[0] != 0:
-        if (np.abs(assemblage.compositional_null_basis.dot(prm.bulk_composition_vector)[0]) > 1.e-12):
-            raise Exception('The bulk composition is not within the '
-                            'compositional space of the assemblage')
-
-    prm.reduced_composition_vector = prm.bulk_composition_vector[assemblage.independent_element_indices]
-    prm.reduced_free_composition_vectors = prm.free_compositional_vectors[:, assemblage.independent_element_indices]
-    prm.constraint_vector, prm.constraint_matrix = calculate_constraints(assemblage, n_free_compositional_vectors)
+        if (
+            np.abs(
+                assemblage.compositional_null_basis.dot(prm.bulk_composition_vector)[0]
+            )
+            > 1.0e-12
+        ):
+            raise Exception(
+                "The bulk composition is not within the "
+                "compositional space of the assemblage"
+            )
+
+    prm.reduced_composition_vector = prm.bulk_composition_vector[
+        assemblage.independent_element_indices
+    ]
+    prm.reduced_free_composition_vectors = prm.free_compositional_vectors[
+        :, assemblage.independent_element_indices
+    ]
+    prm.constraint_vector, prm.constraint_matrix = calculate_constraints(
+        assemblage, n_free_compositional_vectors
+    )
     return prm
 
 
 def process_eq_constraints(equality_constraints, assemblage, prm):
     """
     A function that processes the equality constraints
     into a form that can be processed by the F and jacobian functions.
 
     This function has two main tasks: it turns phase_fraction and
     phase_composition constraints into standard linear constraints in the
     solution parameters. It also turns vector-valued constraints into a
     list of scalar-valued constraints.
 
-    Parameters
-    ----------
-    equality_constraints : list
-        A list of equality constraints as provided by the user. For the
-        types of constraints, please see the documentation for the
-        equilibrate function.
+    :param equality_constraints: A list of equality constraints.
+        For valid types of constraints, please see the documentation for
+        :func:`burnman.equilibrate`.
+    :type equality_constraints: list
 
-    assemblage : burnman.Composite
-        The assemblage for which equilibrium is to be calculated.
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
 
-    prm : namedtuple
-        A tuple with attributes n_parameters
+    :param prm: A tuple with attributes n_parameters
         (the number of parameters for the current equilibrium problem)
         and phase_amount_indices (the indices of the parameters that
         correspond to phase amounts).
+    :type prm: namedtuple
 
-    Returns
-    -------
-    eq_constraint_lists : list of lists
-        A list of lists of equality constraints in a form that can be processed
+    :returns: Equality constraints in a form that can be processed
         by the F and jacobian functions.
+    :rtype: list of lists
     """
     eq_constraint_lists = []
     for i in range(len(equality_constraints)):
-        if equality_constraints[i][0] == 'phase_fraction':
+        if equality_constraints[i][0] == "phase_fraction":
             phase = equality_constraints[i][1][0]
             fraction = equality_constraints[i][1][1]
             if isinstance(fraction, float):
                 fraction = np.array([fraction])
             if not isinstance(fraction, np.ndarray):
-                raise Exception('The constraint fraction in equality {0} '
-                                'should be a float or numpy array'.format(i+1))
-            eq_constraint_lists.append(phase_fraction_constraints(phase,
-                                                                  assemblage,
-                                                                  fraction,
-                                                                  prm))
-        elif equality_constraints[i][0] == 'phase_composition':
+                raise Exception(
+                    "The constraint fraction in equality {0} "
+                    "should be a float or numpy array".format(i + 1)
+                )
+            eq_constraint_lists.append(
+                phase_fraction_constraints(phase, assemblage, fraction, prm)
+            )
+        elif equality_constraints[i][0] == "phase_composition":
             phase = equality_constraints[i][1][0]
             constraint = equality_constraints[i][1][1]
             if isinstance(constraint[3], float):
-                constraint = (constraint[0], constraint[1], constraint[2],
-                              np.array([constraint[3]]))
+                constraint = (
+                    constraint[0],
+                    constraint[1],
+                    constraint[2],
+                    np.array([constraint[3]]),
+                )
             if not isinstance(constraint[3], np.ndarray):
-                raise Exception('The last constraint parameter in equality '
-                                '{0} should be a float '
-                                'or numpy array'.format(i+1))
-
-            eq_constraint_lists.append(phase_composition_constraints(phase,
-                                                                     assemblage,
-                                                                     constraint,
-                                                                     prm))
-        elif equality_constraints[i][0] == 'X':
+                raise Exception(
+                    "The last constraint parameter in equality "
+                    "{0} should be a float "
+                    "or numpy array".format(i + 1)
+                )
+
+            eq_constraint_lists.append(
+                phase_composition_constraints(phase, assemblage, constraint, prm)
+            )
+        elif equality_constraints[i][0] == "X":
             constraint = equality_constraints[i][1]
             if isinstance(constraint[-1], float):
                 constraint = (constraint[0], np.array([constraint[-1]]))
             if not isinstance(constraint[-1], np.ndarray):
-                raise Exception('The last constraint parameter in '
-                                'equality {0} should be '
-                                'a float or numpy array'.format(i+1))
-
-            eq_constraint_lists.append([['X', [constraint[0], p]]
-                                        for p in constraint[1]])
-
-        elif (equality_constraints[i][0] == 'P'
-              or equality_constraints[i][0] == 'T'
-              or equality_constraints[i][0] == 'PT_ellipse'
-              or equality_constraints[i][0] == 'S'
-              or equality_constraints[i][0] == 'V'):
+                raise Exception(
+                    "The last constraint parameter in "
+                    "equality {0} should be "
+                    "a float or numpy array".format(i + 1)
+                )
+
+            eq_constraint_lists.append(
+                [["X", [constraint[0], p]] for p in constraint[1]]
+            )
+
+        elif (
+            equality_constraints[i][0] == "P"
+            or equality_constraints[i][0] == "T"
+            or equality_constraints[i][0] == "PT_ellipse"
+            or equality_constraints[i][0] == "S"
+            or equality_constraints[i][0] == "V"
+        ):
             if isinstance(equality_constraints[i][1], float):
-                equality_constraints[i] = (equality_constraints[i][0],
-                                           np.array([equality_constraints[i][1]]))
+                equality_constraints[i] = (
+                    equality_constraints[i][0],
+                    np.array([equality_constraints[i][1]]),
+                )
             if not isinstance(equality_constraints[i][1], np.ndarray):
-                raise Exception('The last parameter in '
-                                f'equality_constraint[{i+1}] should be a '
-                                'float or numpy array')
-            eq_constraint_lists.append([[equality_constraints[i][0], p]
-                                        for p in equality_constraints[i][1]])
+                raise Exception(
+                    "The last parameter in "
+                    f"equality_constraint[{i+1}] should be a "
+                    "float or numpy array"
+                )
+            eq_constraint_lists.append(
+                [[equality_constraints[i][0], p] for p in equality_constraints[i][1]]
+            )
         else:
-            raise Exception('The type of equality_constraint is '
-                            'not recognised for constraint {0}.\n'
-                            'Should be one of P, T, S, V, X,\n'
-                            'PT_ellipse, phase_fraction, '
-                            'or phase_composition.'.format(i+1))
+            raise Exception(
+                "The type of equality_constraint is "
+                "not recognised for constraint {0}.\n"
+                "Should be one of P, T, S, V, X,\n"
+                "PT_ellipse, phase_fraction, "
+                "or phase_composition.".format(i + 1)
+            )
     return eq_constraint_lists
 
 
-def equilibrate(composition, assemblage, equality_constraints,
-                free_compositional_vectors=[],
-                tol=1.e-3,
-                store_iterates=False, store_assemblage=True,
-                max_iterations=100., verbose=False):
-    """
-    A function that equilibrates an assemblage subject to given
-    bulk composition and equality constraints by
-    solving the equilibrium relations
-    (chemical affinities for feasible reactions in the system
-    should be equal to zero).
-
-    Parameters
-    ----------
-    composition : dictionary
-        The bulk composition that the assemblage must satisfy
-
-    assemblage : burnman.Composite object
-        The assemblage to be equilibrated
-
-    equality_constraints : list
-        A list of equality constraints. Each constraint
-        should have the form: [<constraint type>, <constraint>], where
-        <constraint type> is one of P, T, S, V, X, PT_ellipse,
-        phase_fraction, or phase_composition. The <constraint> object should
-        either be a float or an array of floats for P, T, S, V
-        (representing the desired pressure, temperature,
-        entropy or volume of the material). If the constraint type is X
-        (a generic constraint on the solution vector) then the constraint c is
-        represented by the following equality:
-        np.dot(c[0], x) - c[1]. If the constraint type is
-        PT_ellipse, the equality is given by
-        norm(([P, T] - c[0])/c[1]) - 1.
-        The constraint_type phase_fraction assumes a tuple of the phase object
-        (which must be one of the phases in the burnman.Composite) and a float
-        or vector corresponding to the phase fractions. Finally, a
-        phase_composition constraint has the format (site_names, n, d, v),
-        where n*x/d*x = v and n and d are fixed vectors of site coefficients.
-        So, one could for example choose a constraint
-        ([Mg_A, Fe_A], [1., 0.], [1., 1.], [0.5]) which would
-        correspond to equal amounts Mg and Fe on the A site.
-
-    free_compositional_vectors : list of dictionaries
-        A list of dictionaries containing the compositional freedom of
-        the solution. For example, if the list contains the
-        vector {'Mg': 1., 'Fe': -1}, that implies that the bulk composition
-        is equal to composition + a * (n_Mg - n_Fe), where a is a constant
-        to be determined by the solve.
-
-    tol : float
-        The tolerance for the nonlinear solver.
-
-    store_iterates : boolean
-        Whether to store the parameter values for each iteration in
-        each solution object.
-
-    store_assemblage : boolean
-        Whether to store a copy of the assemblage object in each
-        solution object.
-
-    max_iterations : integer
-        The maximum number of iterations for the nonlinear solver.
+def equilibrate(
+    composition,
+    assemblage,
+    equality_constraints,
+    free_compositional_vectors=[],
+    tol=1.0e-3,
+    store_iterates=False,
+    store_assemblage=True,
+    max_iterations=100.0,
+    verbose=False,
+):
+    """
+    A function that finds the thermodynamic equilibrium state of an
+    assemblage subject to given equality constraints by solving a set of
+    nonlinear equations related to the chemical potentials and
+    other state variables of the system.
+
+    The user chooses an assemblage (e.g. olivine, garnet and orthopyroxene)
+    and :math:`2+n_c` equality constraints, where :math:`n_c` is the number of
+    bulk compositional degrees of freedom. The equilibrate function attempts to
+    find the remaining unknowns that satisfy those constraints.
+
+    There are a number of equality constraints implemented in burnman. These are
+    given as a list of lists. Each constraint should have the form:
+    [<constraint type>, <constraint>], where
+    <constraint type> is one of 'P', 'T', 'S', 'V', 'X', 'PT_ellipse',
+    'phase_fraction', or 'phase_composition'. The format of the
+    <constraint> object depends on the constraint type:
+        - P: float or numpy.array of
+            pressures [Pa]
+        - T: float or numpy.array of
+            temperatures [K]
+        - S: float or numpy.array of
+            entropies [J/K]
+        - V: float or numpy.array of
+            volumes [m:math:`^3`]
+        - PT_ellipse: list of two floats or numpy.arrays, where the equality
+            satifies the equation norm(([P, T] - arr[0])/arr[1]) = 1
+        - phase_fraction: tuple with the form (<phase> <fraction(s)>),
+            where <phase> is one of the phase objects in the assemblage
+            and <fraction(s)> is a float or numpy.array corresponding
+            to the desired phase fractions.
+        - phase_composition: tuple with the form (<phase> <constraint>),
+            where <phase> is one of the phase objects in the assemblage
+            and <constraint> has the form (site_names, n, d, v),
+            where :math:`(nx)/(dx) = v`, n and d are constant vectors of
+            site coefficients, and v is a float or numpy.array. For example,
+            a constraint of the form ([Mg_A, Fe_A], [1., 0.], [1., 1.], [0.5])
+            would correspond to equal amounts Mg and Fe on the A site
+            (Mg_A / (Mg_A + Fe_A) = 0.5).
+        - X: list of a numpy.array and a float or numpy.array,
+            where the equality satisfies the linear equation arr[0] x = arr[1].
+            The first numpy.array is fixed, and the second is to be looped over
+            by the equilibrate function.
+            This is a generic compositional equality constraint.
+
+    :param composition: The bulk composition that the assemblage must satisfy.
+    :type composition: dict
+
+    :param assemblage: The assemblage to be equilibrated.
+    :type assemblage: :class:`burnman.Composite`
+
+    :param equality_constraints: The list of equality constraints. See above
+        for valid formats.
+    :type equality_constraints: list of list
+
+    :param free_compositional_vectors: A list of dictionaries containing
+        the compositional freedom of the solution. For example, if the list
+        contains the vector {'Mg': 1., 'Fe': -1}, that implies that the bulk
+        composition is equal to composition + :math:`a` (n_Mg - n_Fe),
+        where the value of :math:`a` is to be determined by the solve.
+        Vector given in atomic (molar) units of elements.
+    :type free_compositional_vectors: list of dict
+
+    :param tol: The tolerance for the nonlinear solver.
+    :type tol: float
+
+    :param store_iterates: Whether to store the parameter values for
+        each iteration in each solution object.
+    :type store_iterates: bool
+
+    :param store_assemblage: Whether to store a copy of the assemblage
+        object in each solution object.
+    :type store_assemblage: bool
+
+    :param max_iterations: The maximum number of iterations for the
+        nonlinear solver.
+    :type max_iterations: int
 
-    verbose : boolean
-        Whether to print output updating the user on the status of
+    :param verbose: Whether to print output updating the user on the status of
         equilibration.
+    :type verbose: bool
 
-    Returns
-    -------
-    sol_array : single, list, or 2D list of solver solution objects
-
-    prm : namedtuple object
-        A tuple with attributes n_parameters
-        (the number of parameters for the current equilibrium problem)
-        and phase_amount_indices (the indices of the parameters that
-        correspond to phase amounts).
+    :returns: Solver solution object (or a list, or a 2D list of solution objects)
+        created by :func:`burnman.optimize.nonlinear_solvers.damped_newton_solve`,
+        and a namedtuple object created by
+        :func:`burnman.tools.equilibration.get_equilibration_parameters`. See
+        documentation of these functions for the return types. If store_assemblage
+        is True, each solution object also has an attribute called `assemblage`,
+        which contains a copy of the input assemblage with the equilibrated
+        properties. So, for a 2D grid of solution objects, one could call either
+        sols[0][1].x[0] or sols[0][1].assemblage.pressure to get the pressure.
+    :rtype: tuple
     """
     for ph in assemblage.phases:
-        if isinstance(ph, Solution) and not hasattr(ph, 'molar_fractions'):
-            raise Exception(f'set_composition for solution {ph} before running equilibrate.')
+        if isinstance(ph, Solution) and not hasattr(ph, "molar_fractions"):
+            raise Exception(
+                f"set_composition for solution {ph} before running equilibrate."
+            )
 
     if assemblage.molar_fractions is None:
         n_phases = len(assemblage.phases)
-        f = 1./float(n_phases)
+        f = 1.0 / float(n_phases)
         assemblage.set_fractions([f for i in range(n_phases)])
 
-    assemblage.n_moles = (sum(composition.values())
-                          / sum(assemblage.formula.values()))
+    assemblage.n_moles = sum(composition.values()) / sum(assemblage.formula.values())
 
     n_equality_constraints = len(equality_constraints)
     n_free_compositional_vectors = len(free_compositional_vectors)
 
     if n_equality_constraints != n_free_compositional_vectors + 2:
-        raise Exception('The number of equality constraints '
-                        f'(currently {n_equality_constraints}) '
-                        'must be two more than the number of '
-                        'free_compositional vectors '
-                        f'(currently {n_free_compositional_vectors}).')
+        raise Exception(
+            "The number of equality constraints "
+            f"(currently {n_equality_constraints}) "
+            "must be two more than the number of "
+            "free_compositional vectors "
+            f"(currently {n_free_compositional_vectors})."
+        )
 
     for v in free_compositional_vectors:
-        if np.abs(sum(v.values())) > 1.e-12:
-            raise Exception('The amounts of each free_compositional_vector'
-                            'must sum to zero')
+        if np.abs(sum(v.values())) > 1.0e-12:
+            raise Exception(
+                "The amounts of each free_compositional_vector" "must sum to zero"
+            )
 
     # Make parameter tuple
-    prm = get_equilibration_parameters(assemblage, composition,
-                                       free_compositional_vectors)
+    prm = get_equilibration_parameters(
+        assemblage, composition, free_compositional_vectors
+    )
 
     # Check equality constraints have the correct structure
     # Convert into the format readable by the function and jacobian functions
-    eq_constraint_lists = process_eq_constraints(equality_constraints,
-                                                 assemblage, prm)
+    eq_constraint_lists = process_eq_constraints(equality_constraints, assemblage, prm)
 
     # Set up solves
-    nc = [len(eq_constraint_list)
-          for eq_constraint_list in eq_constraint_lists]
+    nc = [len(eq_constraint_list) for eq_constraint_list in eq_constraint_lists]
 
     # Find the initial state (could be none here)
     initial_state = [assemblage.pressure, assemblage.temperature]
 
     # Reset initial state if equality constraints
     # are related to pressure or temperature
     for i in range(n_equality_constraints):
-        if eq_constraint_lists[i][0][0] == 'P':
+        if eq_constraint_lists[i][0][0] == "P":
             initial_state[0] = eq_constraint_lists[i][0][1]
-        elif eq_constraint_lists[i][0][0] == 'T':
+        elif eq_constraint_lists[i][0][0] == "T":
             initial_state[1] = eq_constraint_lists[i][0][1]
-        elif eq_constraint_lists[i][0][0] == 'PT_ellipse':
+        elif eq_constraint_lists[i][0][0] == "PT_ellipse":
             initial_state = eq_constraint_lists[i][0][1][1]
 
     if initial_state[0] is None:
-        initial_state[0] = 5.e9
+        initial_state[0] = 5.0e9
     if initial_state[1] is None:
-        initial_state[1] = 1200.
+        initial_state[1] = 1200.0
 
     assemblage.set_state(*initial_state)
     parameters = get_parameters(assemblage, n_free_compositional_vectors)
 
     # Solve the system of equations, loop over input parameters
     sol_array = np.empty(shape=tuple(nc), dtype="object")
 
     # Loop over problems
     problems = list(product(*[list(range(nc[i])) for i in range(len(nc))]))
     n_problems = len(problems)
     for i_problem, i_c in enumerate(problems):
         if verbose:
-            string = 'Processing solution'
+            string = "Processing solution"
             for i in range(len(i_c)):
-                string += ' {0}/{1}'.format(i_c[i]+1, nc[i])
+                string += " {0}/{1}".format(i_c[i] + 1, nc[i])
 
-            print(string+':')
+            print(string + ":")
 
-        equality_constraints = [eq_constraint_lists[i][i_c[i]]
-                                for i in range(len(nc))]
+        equality_constraints = [eq_constraint_lists[i][i_c[i]] for i in range(len(nc))]
 
         # Set the initial fractions and compositions
         # of the phases in the assemblage:
-        sol = damped_newton_solve(F=lambda x: F(x, assemblage,
-                                                equality_constraints,
-                                                prm.reduced_composition_vector,
-                                                prm.reduced_free_composition_vectors),
-                                  J=lambda x: jacobian(x, assemblage,
-                                                       equality_constraints,
-                                                       prm.reduced_free_composition_vectors),
-                                  lambda_bounds=lambda dx, x: lambda_bounds(dx, x, assemblage.endmembers_per_phase),
-                                  guess=parameters,
-                                  linear_constraints=(prm.constraint_matrix,
-                                                      prm.constraint_vector),
-                                  tol=tol,
-                                  store_iterates=store_iterates,
-                                  max_iterations=max_iterations)
+        sol = damped_newton_solve(
+            F=lambda x: F(
+                x,
+                assemblage,
+                equality_constraints,
+                prm.reduced_composition_vector,
+                prm.reduced_free_composition_vectors,
+            ),
+            J=lambda x: jacobian(
+                x,
+                assemblage,
+                equality_constraints,
+                prm.reduced_free_composition_vectors,
+            ),
+            lambda_bounds=lambda dx, x: lambda_bounds(
+                dx, x, assemblage.endmembers_per_phase
+            ),
+            guess=parameters,
+            linear_constraints=(prm.constraint_matrix, prm.constraint_vector),
+            tol=tol,
+            store_iterates=store_iterates,
+            max_iterations=max_iterations,
+        )
 
-        if sol.success and len(assemblage.reaction_affinities) > 0.:
-            maxres = np.max(np.abs(assemblage.reaction_affinities)) + 1.e-5
+        if sol.success and len(assemblage.reaction_affinities) > 0.0:
+            maxres = np.max(np.abs(assemblage.reaction_affinities)) + 1.0e-5
             assemblage.equilibrium_tolerance = maxres
 
         if store_assemblage:
             sol.assemblage = assemblage.copy()
-            if sol.success and len(assemblage.reaction_affinities) > 0.:
+            if sol.success and len(assemblage.reaction_affinities) > 0.0:
                 sol.assemblage.equilibrium_tolerance = maxres
 
         if verbose:
             print(sol.text)
 
         sol_array[i_c] = sol
 
         # Next, we use the solution values and Jacobian
         # to provide a starting guess for the next problem.
         # First, we find the equality constraints for the next problem
         if i_problem < n_problems - 1:
-            next_i_c = problems[i_problem+1]
+            next_i_c = problems[i_problem + 1]
 
-            next_equality_constraints = [eq_constraint_lists[i][next_i_c[i]]
-                                         for i in range(len(nc))]
+            next_equality_constraints = [
+                eq_constraint_lists[i][next_i_c[i]] for i in range(len(nc))
+            ]
 
             # We use the nearest solutions as potential starting points
             # to make the next guess
             prev_sols = []
             for i in range(len(nc)):
                 if next_i_c[i] != 0:
                     prev_i_c = np.copy(next_i_c)
@@ -935,31 +1034,43 @@
 
             updated_params = False
             for s in prev_sols:
                 if s.success and not updated_params:
                     # next guess based on a Newton step
                     # using the old solution vector and Jacobian
                     # with the new constraints.
-                    dF = F(s.x, assemblage, next_equality_constraints,
-                           prm.reduced_composition_vector,
-                           prm.reduced_free_composition_vectors)
+                    dF = F(
+                        s.x,
+                        assemblage,
+                        next_equality_constraints,
+                        prm.reduced_composition_vector,
+                        prm.reduced_free_composition_vectors,
+                    )
                     luJ = lu_factor(s.J)
                     new_parameters = s.x + lu_solve(luJ, -dF)
-                    c = (prm.constraint_matrix.dot(new_parameters)
-                         + prm.constraint_vector)
-                    if all(c <= 0.):  # accept new guess
+                    c = (
+                        prm.constraint_matrix.dot(new_parameters)
+                        + prm.constraint_vector
+                    )
+                    if all(c <= 0.0):  # accept new guess
                         parameters = new_parameters
                     else:  # use the parameters from this step
                         parameters = s.x
-                        exhausted_phases = [assemblage.phases[phase_idx].name
-                                            for phase_idx, v in
-                                            enumerate(new_parameters[prm.phase_amount_indices]) if v < 0.]
+                        exhausted_phases = [
+                            assemblage.phases[phase_idx].name
+                            for phase_idx, v in enumerate(
+                                new_parameters[prm.phase_amount_indices]
+                            )
+                            if v < 0.0
+                        ]
                         if len(exhausted_phases) > 0 and verbose:
-                            print('A phase might be exhausted before the '
-                                  f'next step: {exhausted_phases}')
+                            print(
+                                "A phase might be exhausted before the "
+                                f"next step: {exhausted_phases}"
+                            )
 
                     updated_params = True
 
     # Finally, make dimensions of sol_array equal the input dimensions
     if np.product(sol_array.shape) > 1:
         sol_array = np.squeeze(sol_array)
     else:
```

### Comparing `burnman-1.1.0/burnman/tools/output_seismo.py` & `burnman-1.2.0/burnman/tools/output_seismo.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,293 +10,351 @@
 import matplotlib.pyplot as plt
 import pkgutil
 
 from ..classes.planet import Planet
 from ..classes.layer import Layer
 
 
-def write_tvel_file(planet_or_layer, modelname='burnmanmodel',
-                    background_model=None):
+def write_tvel_file(planet_or_layer, modelname="burnmanmodel", background_model=None):
     """
     Function to write input file for obspy travel time calculations.
     Note: Because density isn't defined for most 1D seismic models, densities
     are output as zeroes.  The tvel format has a column for density,
     but this column is not used by obspy for travel time calculations.
 
-    Parameters
-    ----------
-    planet_or_layer  :  burnman.Planet() or burnman.Layer()
-        Planet or layer to write out to tvel file
-    filename : string
-        Filename to read to
-    background_model : burnman.seismic.Seismic1DModel()
-        1D seismic model to fill in parts of planet
+    :param planet_or_layer: Planet or layer to write out to tvel file
+    :type planet_or_layer: :class:`burnman.Planet` or :class:`burnman.Layer`.
+    :param filename: Filename to read to.
+    :type filename: str
+    :param background_model:  1D seismic model to fill in parts of planet
         (likely to be an earth model) that aren't defined by layer
-        (only need when using Layer())
+        (only need when using :class:`burnman.Layer`)
+    :type background_model: :class:`burnman.seismic.Seismic1DModel`
     """
 
     if not isinstance(planet_or_layer, (Planet, Layer)):
-        raise TypeError("Input must be a Planet() or Layer() ")
+        raise TypeError("Input must be a Planet() or Layer() object.")
 
     if isinstance(planet_or_layer, Layer):
-        assert(background_model)
+        assert background_model
         layer = planet_or_layer
         depths = background_model.internal_depth_list()
 
-        above_layer = np.where(
-            depths < (np.max(depths) - layer.outer_radius))[-1]
-        below_layer = np.where(
-            depths > (np.max(depths) - layer.inner_radius))[0]
-
-        data_above = list(zip(depths[above_layer] / 1.e3,
-                              background_model.v_p(depths[above_layer]) / 1.e3,
-                              background_model.v_s(depths[above_layer]) / 1.e3,
-                              np.zeros_like(depths[above_layer])))
-        data_layer = list(zip((np.max(depths) - layer.radii)[::- 1] / 1.e3,
-                              layer.v_p[::-1] / 1.e3,
-                              layer.v_s[::-1] / 1.e3,
-                              layer.density[::-1] / 1.e3))
-        data_below = list(zip(depths[below_layer] / 1.e3,
-                              background_model.v_p(depths[below_layer]) / 1.e3,
-                              background_model.v_s(depths[below_layer]) / 1.e3,
-                              np.zeros_like(depths[below_layer])))
+        above_layer = np.where(depths < (np.max(depths) - layer.outer_radius))[-1]
+        below_layer = np.where(depths > (np.max(depths) - layer.inner_radius))[0]
+
+        data_above = list(
+            zip(
+                depths[above_layer] / 1.0e3,
+                background_model.v_p(depths[above_layer]) / 1.0e3,
+                background_model.v_s(depths[above_layer]) / 1.0e3,
+                np.zeros_like(depths[above_layer]),
+            )
+        )
+        data_layer = list(
+            zip(
+                (np.max(depths) - layer.radii)[::-1] / 1.0e3,
+                layer.v_p[::-1] / 1.0e3,
+                layer.v_s[::-1] / 1.0e3,
+                layer.density[::-1] / 1.0e3,
+            )
+        )
+        data_below = list(
+            zip(
+                depths[below_layer] / 1.0e3,
+                background_model.v_p(depths[below_layer]) / 1.0e3,
+                background_model.v_s(depths[below_layer]) / 1.0e3,
+                np.zeros_like(depths[below_layer]),
+            )
+        )
 
         data = data_above + data_layer + data_below
 
-        header = (f'{layer.name}  model from BurnMan between a radius of '
-                  f'{str(layer.inner_radius)} and '
-                  f'{str(layer.outer_radius)} km \n'
-                  f'{background_model.__class__.__name__} '
-                  f'for the rest of the Earth')
-        with open(modelname + '.tvel', 'wb') as f:
-            np.savetxt(f, data, header=header, fmt='%5.2f', delimiter='\t')
+        header = (
+            f"{layer.name}  model from BurnMan between a radius of "
+            f"{str(layer.inner_radius)} and "
+            f"{str(layer.outer_radius)} km \n"
+            f"{background_model.__class__.__name__} "
+            f"for the rest of the Earth"
+        )
+        with open(modelname + ".tvel", "wb") as f:
+            np.savetxt(f, data, header=header, fmt="%5.2f", delimiter="\t")
 
     if isinstance(planet_or_layer, Planet):
         planet = planet_or_layer
-        data = list(zip((planet.radius_planet - planet.radii)[::-1] / 1.e3,
-                        planet.v_p[::-1] / 1.e3,
-                        planet.v_s[::-1] / 1.e3,
-                        planet.density[::- 1] / 1.e3))
-
-        header = (f'{planet.name} model from BurnMan with a radius of '
-                  f'{str(planet.radius_planet)} km \n'
-                  f'Layers of planet are '
-                  f'{", ".join(layer.name for layer in planet.layers)}')
-        with open(modelname + '.tvel', 'wb') as f:
-            np.savetxt(f, data, header=header, fmt='%5.2f', delimiter='\t')
-
-
-def write_axisem_input(layers, modelname='burnmanmodel_foraxisem',
-                       axisem_ref='axisem_prem_ani_noocean.txt',
-                       plotting=False):
+        data = list(
+            zip(
+                (planet.radius_planet - planet.radii)[::-1] / 1.0e3,
+                planet.v_p[::-1] / 1.0e3,
+                planet.v_s[::-1] / 1.0e3,
+                planet.density[::-1] / 1.0e3,
+            )
+        )
+
+        header = (
+            f"{planet.name} model from BurnMan with a radius of "
+            f"{str(planet.radius_planet)} km \n"
+            f"Layers of planet are "
+            f'{", ".join(layer.name for layer in planet.layers)}'
+        )
+        with open(modelname + ".tvel", "wb") as f:
+            np.savetxt(f, data, header=header, fmt="%5.2f", delimiter="\t")
+
+
+def write_axisem_input(
+    layers,
+    modelname="burnmanmodel_foraxisem",
+    axisem_ref="axisem_prem_ani_noocean.txt",
+    plotting=False,
+):
     """
     Writing velocities and densities to AXISEM (www.axisem.info) input file.
     The input can be a single layer, or a list of layers taken from a planet
     (planet.layers).
     Currently this function will implement explicit discontinuities between
     layers in the seismic model.
     Currently this function is only set for Earth.
 
-    Parameters
-    ----------
-    layers : list of one or more burnman.Layer()
-        List of layers to put in axisem file
-    modelname : string
-        Name of model, appears in name of output file
-    axisem_ref : string
-        Reference file, used to copy the header and for the rest of the planet,
-        in the case of a Layer(), default = 'axisem_prem_ani_noocean.txt'
-    plotting: Boolean
-        True means plot of the old model and replaced model will be shown
-        (default = False)
+    :param layers: List of layers to put in AXISEM file.
+    :type layers: list of one or more :class:`burnman.Layer`
+    :param modelname: Name of model, appears in name of output file.
+    :type modelname: str
+    :param axisem_ref: Reference file, used to copy the header
+        and for the rest of the planet, in the case of a :class:`burnman.Layer`.
+    :type axisem_ref: str
+    :param plotting: Choose whether to show plot of the old model and replaced model.
+    :type plotting: bool
     """
 
     if not isinstance(layers[0], Layer):
         raise TypeError("Input must be a list of Layer()")
     # Load reference input
-    datastream = pkgutil.get_data(
-        'burnman', 'data/input_seismic/' + axisem_ref)
-    lines = [line.strip()
-             for line in datastream.decode('ascii').split('\n')
-             if line.strip()]
+    datastream = pkgutil.get_data("burnman", "data/input_seismic/" + axisem_ref)
+    lines = [
+        line.strip() for line in datastream.decode("ascii").split("\n") if line.strip()
+    ]
     table = []
     for line in lines[18:]:
-        numbers = np.fromstring(line, sep=' ')
+        numbers = np.fromstring(line, sep=" ")
         if len(numbers) > 0:
             if line[0] != "#" and line[0] != "%":
                 table.append(numbers)
     table = np.array(table)
     # format is
     # radius density vpv vsv Qk Qmu vph vsh eta
 
     if plotting:
         plt.figure(figsize=(12, 6))
-        plt.plot(table[:, 0] / 1.e3, table[:, 2] / 1.e3,
-                 color='g', linestyle='--')
-        plt.plot(table[:, 0] / 1.e3, table[:, 3] / 1.e3,
-                 color='b', linestyle='--')
-        plt.plot(table[:, 0] / 1.e3, table[:, 1] / 1.e3,
-                 color='r', linestyle='--')
+        plt.plot(table[:, 0] / 1.0e3, table[:, 2] / 1.0e3, color="g", linestyle="--")
+        plt.plot(table[:, 0] / 1.0e3, table[:, 3] / 1.0e3, color="b", linestyle="--")
+        plt.plot(table[:, 0] / 1.0e3, table[:, 1] / 1.0e3, color="r", linestyle="--")
 
     for layer in layers:
         # Cutting out range to input in Axisem reference file, and adding in
         # model values at the top and bottom of Layer.
-        i_min = next(x[0] for x in enumerate(table[:, 0])
-                     if x[1] <= layer.outer_radius)
+        i_min = next(x[0] for x in enumerate(table[:, 0]) if x[1] <= layer.outer_radius)
         if table[i_min, 0] - layer.outer_radius < 0:
             table = np.insert(table, i_min, None, axis=0)
             table[i_min, 0] = layer.outer_radius
 
-        i_max = next(x[0] for x in enumerate(table[:, 0])
-                     if x[1] <= layer.inner_radius)
+        i_max = next(x[0] for x in enumerate(table[:, 0]) if x[1] <= layer.inner_radius)
 
         if table[i_max, 0] - layer.inner_radius < 0:
             table = np.insert(table, i_max, None, axis=0)
             table[i_max, 0] = layer.inner_radius
 
-        lvp, lvs, lrho = layer.evaluate(['v_p', 'v_s', 'density'],
-                                        radlist=table[i_min:i_max, 0],
-                                        radius_planet=np.max(table[:, 0]))
+        lvp, lvs, lrho = layer.evaluate(
+            ["v_p", "v_s", "density"],
+            radlist=table[i_min:i_max, 0],
+            radius_planet=np.max(table[:, 0]),
+        )
 
         table[i_min:i_max, 2] = lvp
         table[i_min:i_max, 6] = lvp
         table[i_min:i_max, 3] = lvs
         table[i_min:i_max, 7] = lvs
         table[i_min:i_max, 1] = lrho
 
     # WRITE OUT FILE
-    filename = 'axisem_' + modelname + '.txt'
-    f = open(filename, 'w')
-    print('Writing ' + filename + ' ...')
-    f.write(f'# Input file {modelname} for AXISEM created using BurnMan, '
-            f'replacing {axisem_ref} between '
-            f'{str(np.round(layer.inner_radius / 1.e3))} and '
-            f'{str(np.round(layer.outer_radius / 1.e3))} km\n')
+    filename = "axisem_" + modelname + ".txt"
+    f = open(filename, "w")
+    print("Writing " + filename + " ...")
+    f.write(
+        f"# Input file {modelname} for AXISEM created using BurnMan, "
+        f"replacing {axisem_ref} between "
+        f"{str(np.round(layer.inner_radius / 1.e3))} and "
+        f"{str(np.round(layer.outer_radius / 1.e3))} km\n"
+    )
 
     discontinuity = 0  # Number discontinuities
-    f.write('NAME ' + modelname + '\n')
+    f.write("NAME " + modelname + "\n")
     for line in lines[2:18]:
-        f.write(line[:] + '\n')
+        f.write(line[:] + "\n")
     for i in range(len(table[:, 0])):
         if i > 0 and table[i, 0] == table[i - 1, 0]:
             discontinuity = discontinuity + 1
-            f.write(f'#          Discontinuity   {str(discontinuity)}, '
-                    f'depth:    {str(np.round((6371.e3 - table[i, 0]) / 1.e3, decimals=2))} km \n')
-
-        f.write(f'{table[i, 0]:8.0f} {table[i, 1]:9.2f} {table[i, 2]:9.2f} '
-                f'{table[i, 3]:9.2f} {table[i, 4]:9.1f} {table[i, 5]:9.1f} '
-                f'{table[i, 6]:9.2f} {table[i, 7]:9.2f} {table[i, 8]:9.5f} \n')
+            f.write(
+                f"#          Discontinuity   {str(discontinuity)}, "
+                f"depth:    {str(np.round((6371.e3 - table[i, 0]) / 1.e3, decimals=2))}"
+                " km \n"
+            )
+
+        f.write(
+            f"{table[i, 0]:8.0f} {table[i, 1]:9.2f} {table[i, 2]:9.2f} "
+            f"{table[i, 3]:9.2f} {table[i, 4]:9.1f} {table[i, 5]:9.1f} "
+            f"{table[i, 6]:9.2f} {table[i, 7]:9.2f} {table[i, 8]:9.5f} \n"
+        )
 
     f.close()
 
     if plotting:
-
-        plt.plot(table[:, 0] / 1.e3, table[:, 2] / 1.e3,
-                 color='g', linestyle='-', label='V_p')
-        plt.plot(table[:, 0] / 1.e3, table[:, 3] / 1.e3,
-                 color='b', linestyle='-', label='V_s')
-        plt.plot(table[:, 0] / 1.e3, table[:, 1] / 1.e3,
-                 color='r', linestyle='-', label='density')
-
-        plt.title(f'{filename} = {axisem_ref} replaced between '
-                  f'{str(layer.inner_radius / 1.e3)} and '
-                  f'{str(layer.outer_radius / 1.e3)} km')
-        plt.legend(loc='lower right')
+        plt.plot(
+            table[:, 0] / 1.0e3,
+            table[:, 2] / 1.0e3,
+            color="g",
+            linestyle="-",
+            label="V_p",
+        )
+        plt.plot(
+            table[:, 0] / 1.0e3,
+            table[:, 3] / 1.0e3,
+            color="b",
+            linestyle="-",
+            label="V_s",
+        )
+        plt.plot(
+            table[:, 0] / 1.0e3,
+            table[:, 1] / 1.0e3,
+            color="r",
+            linestyle="-",
+            label="density",
+        )
+
+        plt.title(
+            f"{filename} = {axisem_ref} replaced between "
+            f"{str(layer.inner_radius / 1.e3)} and "
+            f"{str(layer.outer_radius / 1.e3)} km"
+        )
+        plt.legend(loc="lower right")
         plt.show()
 
 
-def write_mineos_input(layers, modelname='burnmanmodel_formineos',
-                       mineos_ref='mineos_prem_noocean.txt', plotting=False):
+def write_mineos_input(
+    layers,
+    modelname="burnmanmodel_formineos",
+    mineos_ref="mineos_prem_noocean.txt",
+    plotting=False,
+):
     """
     Writing velocities and densities to
     Mineos (https://geodynamics.org/cig/software/mineos/) input file
     Note: currently, this function only honors the discontinuities already
     in the synthetic input file, so it is best to only replace
     certain layers with burnman values
 
-    Parameters
-    ----------
-    layers : list of one or more burnman.Layer()
-        List of layers to put in axisem file
-    modelname : string
-        Name of model, appears in name of output file
-    mineos_ref : string
-        Reference file, used to copy the header and for the rest of the planet,
-        in the case of a Layer(), default = 'mineos_prem_noocean.txt'
-    plotting: Boolean
-        True means plot of the old model and replaced model will be shown
-        (default = False)
-
+    :param layers: List of layers to put in Mineos file.
+    :type layers: list of one or more :class:`burnman.Layer`
+    :param modelname: Name of model, appears in name of output file.
+    :type modelname: str
+    :param mineos_ref: Reference file, used to copy the header
+        and for the rest of the planet, in the case of a :class:`burnman.Layer`.
+    :type mineos_ref: str
+    :param plotting: Choose whether to show plot of the old model and replaced model.
+    :type plotting: bool
     """
 
     if not isinstance(layers[0], Layer):
         raise TypeError("Input must be a list of Layer()")
 
     # Load reference input
-    datastream = pkgutil.get_data(
-        'burnman', 'data/input_seismic/' + mineos_ref)
-    lines = [line.strip()
-             for line in datastream.decode('ascii').split('\n')
-             if line.strip()]
+    datastream = pkgutil.get_data("burnman", "data/input_seismic/" + mineos_ref)
+    lines = [
+        line.strip() for line in datastream.decode("ascii").split("\n") if line.strip()
+    ]
     table = []
     for line in lines[3:]:
-        numbers = np.fromstring(line, sep=' ')
+        numbers = np.fromstring(line, sep=" ")
         table.append(numbers)
     table = np.array(table)
 
     if plotting:
         plt.figure(figsize=(12, 6))
-        plt.plot(table[:, 0] / 1.e3, table[:, 2] / 1.e3,
-                 color='g', linestyle='--')
-        plt.plot(table[:, 0] / 1.e3, table[:, 3] / 1.e3,
-                 color='b', linestyle='--')
-        plt.plot(table[:, 0] / 1.e3, table[:, 1] / 1.e3,
-                 color='r', linestyle='--')
+        plt.plot(table[:, 0] / 1.0e3, table[:, 2] / 1.0e3, color="g", linestyle="--")
+        plt.plot(table[:, 0] / 1.0e3, table[:, 3] / 1.0e3, color="b", linestyle="--")
+        plt.plot(table[:, 0] / 1.0e3, table[:, 1] / 1.0e3, color="r", linestyle="--")
 
     for layer in layers:
-        i_min = next(x[0] for x in enumerate(table[:, 0])
-                     if x[1] >= layer.inner_radius)
+        i_min = next(x[0] for x in enumerate(table[:, 0]) if x[1] >= layer.inner_radius)
         if table[i_min, 0] - layer.inner_radius > 0:
             table[i_min, 0] = layer.inner_radius
 
-        i_max = next(x[0] for x in enumerate(table[:, 0])
-                     if x[1] >= layer.outer_radius)
+        i_max = next(x[0] for x in enumerate(table[:, 0]) if x[1] >= layer.outer_radius)
         if table[i_max, 0] - layer.outer_radius > 0:
             table[i_max, 0] = layer.outer_radius
 
-        lvp, lvs, lrho = layer.evaluate(['v_p', 'v_s', 'density'],
-                                        radlist=table[i_min:i_max, 0],
-                                        radius_planet=np.max(table[:, 0]))
+        lvp, lvs, lrho = layer.evaluate(
+            ["v_p", "v_s", "density"],
+            radlist=table[i_min:i_max, 0],
+            radius_planet=np.max(table[:, 0]),
+        )
 
         table[i_min:i_max, 2] = lvp
         table[i_min:i_max, 6] = lvp
         table[i_min:i_max, 3] = lvs
         table[i_min:i_max, 7] = lvs
         table[i_min:i_max, 1] = lrho
 
     # WRITE OUT FILE
-    filename = 'mineos_' + modelname + '.txt'
-    f = open(filename, 'w')
-    print('Writing ' + filename + ' ...')
-    f.write(lines[0][:-2] + ' +  ' + filename + '\n')
+    filename = "mineos_" + modelname + ".txt"
+    f = open(filename, "w")
+    print("Writing " + filename + " ...")
+    f.write(lines[0][:-2] + " +  " + filename + "\n")
     for line in lines[1:3]:
-        f.write(line[:-2] + '\n')
+        f.write(line[:-2] + "\n")
     for i in range(len(table[:, 0])):
-        f.write('%8.0f %9.2f %9.2f %9.2f %9.1f %9.1f %9.2f %9.2f %9.5f \n' % (
-            table[i, 0], table[i, 1], table[i, 2], table[i, 3], table[i, 4], table[i, 5], table[i, 6], table[i, 7], table[i, 8]))
+        f.write(
+            "%8.0f %9.2f %9.2f %9.2f %9.1f %9.1f %9.2f %9.2f %9.5f \n"
+            % (
+                table[i, 0],
+                table[i, 1],
+                table[i, 2],
+                table[i, 3],
+                table[i, 4],
+                table[i, 5],
+                table[i, 6],
+                table[i, 7],
+                table[i, 8],
+            )
+        )
 
     f.close()
 
     if plotting:
-
-        plt.plot(table[:, 0] / 1.e3, table[:, 2] / 1.e3,
-                 color='g', linestyle='-', label='V_p')
-        plt.plot(table[:, 0] / 1.e3, table[:, 3] / 1.e3,
-                 color='b', linestyle='-', label='V_s')
-        plt.plot(table[:, 0] / 1.e3, table[:, 1] / 1.e3,
-                 color='r', linestyle='-', label='density')
-
-        plt.title(f'{filename} = {mineos_ref} replaced between '
-                  f'{str(layer.inner_radius / 1.e3)} and '
-                  f'{str(layer.outer_radius / 1.e3)} km')
-        plt.legend(loc='lower right')
+        plt.plot(
+            table[:, 0] / 1.0e3,
+            table[:, 2] / 1.0e3,
+            color="g",
+            linestyle="-",
+            label="V_p",
+        )
+        plt.plot(
+            table[:, 0] / 1.0e3,
+            table[:, 3] / 1.0e3,
+            color="b",
+            linestyle="-",
+            label="V_s",
+        )
+        plt.plot(
+            table[:, 0] / 1.0e3,
+            table[:, 1] / 1.0e3,
+            color="r",
+            linestyle="-",
+            label="density",
+        )
+
+        plt.title(
+            f"{filename} = {mineos_ref} replaced between "
+            f"{str(layer.inner_radius / 1.e3)} and "
+            f"{str(layer.outer_radius / 1.e3)} km"
+        )
+        plt.legend(loc="lower right")
         plt.show()
```

### Comparing `burnman-1.1.0/burnman/tools/partitioning.py` & `burnman-1.2.0/burnman/tools/partitioning.py`

 * *Files 12% similar despite different names*

```diff
@@ -5,58 +5,60 @@
 
 
 from __future__ import absolute_import
 import numpy as np
 from .. import constants
 
 
-def calculate_nakajima_fp_pv_partition_coefficient(pressure, temperature,
-                                                   bulk_composition_mol, initial_distribution_coefficient):
+def calculate_nakajima_fp_pv_partition_coefficient(
+    pressure, temperature, bulk_composition_mol, initial_distribution_coefficient
+):
     """
     Calculate the partitioning of iron between periclase and bridgmanite as given
     by Nakajima et al., 2012.
 
-    Parameters
-    ----------
-    pressure : float
-        Equilibrium pressure [Pa]
-    temperature : float
-        Equilibrium temperature [K]
-    bulk_composition_mol : dictionary
-        Bulk composition [mol].
+    :param pressure: Equilibrium pressure [Pa]
+    :type pressure: float
+    :param temperature: Equilibrium temperature [K]
+    :type temperature: float
+    :param bulk_composition_mol: Bulk composition [mol].
         Only Mg, Fe, and Si are assumed to explicitly affect the partitioning
         with Al playing an implicit role.
-    initial_distribution_coefficient : float
-        The distribution coefficient (Kd_0) at 25 GPa and 0 K
+    :type bulk_composition_mol: dict
+    :param initial_distribution_coefficient: The distribution coefficient (Kd_0)
+        at 25 GPa and 0 K.
+    :type initial_distribution_coefficient: float
 
-    Returns
-    -------
-    partition_coefficient_array : tuple
-        The proportion of Fe in ferropericlase and perovskite, respectively
+    :returns: The proportion of Fe in ferropericlase and perovskite, respectively
+    :rtype: tuple
     """
 
-    norm = bulk_composition_mol['Mg'] + bulk_composition_mol['Fe']
-    f_FeO = bulk_composition_mol['Fe']/norm
-    f_SiO2 = bulk_composition_mol['Si']/norm
+    norm = bulk_composition_mol["Mg"] + bulk_composition_mol["Fe"]
+    f_FeO = bulk_composition_mol["Fe"] / norm
+    f_SiO2 = bulk_composition_mol["Si"] / norm
 
     Kd_0 = initial_distribution_coefficient
-    delV = 2.e-7  # in m^3/mol, average taken from Nakajima et al 2012, JGR
+    delV = 2.0e-7  # in m^3/mol, average taken from Nakajima et al 2012, JGR
 
     # eq 5 Nakajima et al 2012, JGR. Solved for ln(K(P,T,X))
-    rs = ((25.e9 - pressure) * delV
-          / (constants.gas_constant * temperature)) + np.log(Kd_0)
+    rs = ((25.0e9 - pressure) * delV / (constants.gas_constant * temperature)) + np.log(
+        Kd_0
+    )
 
     # The exchange coefficent at P and T. K(P,T,X) in eq 5 Nakajima et al 2012
     K = np.exp(rs)
 
     # Solving equation 6 in Nakajima et al., 2012 for X_Fe_fp and X_Fe_pv
-    # Solved using the definition of the distribution coefficient to define X_Fe_fp as a function of X_Fe_pv
+    # Solved using the definition of the distribution coefficient
+    # to define X_Fe_fp as a function of X_Fe_pv
 
-    num_to_sqrt = ((-4. * f_FeO * (K - 1.) * K * f_SiO2)
-                   + (pow(1. + (f_FeO * (K - 1)) + ((K - 1.) * f_SiO2), 2.)))
+    num_to_sqrt = (-4.0 * f_FeO * (K - 1.0) * K * f_SiO2) + (
+        pow(1.0 + (f_FeO * (K - 1)) + ((K - 1.0) * f_SiO2), 2.0)
+    )
+
+    X_Fe_pv = (
+        -1.0 + f_FeO - (f_FeO * K) + f_SiO2 - (f_SiO2 * K) + np.sqrt(num_to_sqrt)
+    ) / (2.0 * f_SiO2 * (1.0 - K))
 
-    X_Fe_pv = ((-1. + f_FeO - (f_FeO * K) + f_SiO2 - (f_SiO2 * K) + np.sqrt(num_to_sqrt))
-               / (2. * f_SiO2 * (1. - K)))
-
-    X_Fe_fp = X_Fe_pv / (((1. - X_Fe_pv) * K) + X_Fe_pv)
+    X_Fe_fp = X_Fe_pv / (((1.0 - X_Fe_pv) * K) + X_Fe_pv)
 
     return (X_Fe_fp, X_Fe_pv)
```

### Comparing `burnman-1.1.0/burnman/tools/polytope.py` & `burnman-1.2.0/burnman/tools/polytope.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,254 +13,250 @@
 import importlib
 from ..classes.polytope import MaterialPolytope, independent_row_indices
 from ..classes.solution import Solution
 from ..classes.composite import Composite
 from .solution import transform_solution_to_new_basis
 
 try:
-    cp = importlib.import_module('cvxpy')
+    cp = importlib.import_module("cvxpy")
 except ImportError as err:
-    print(f'Warning: {err}. '
-          'For full functionality of BurnMan, please install cvxpy.')
+    print(
+        f"Warning: {err}. " "For full functionality of BurnMan, please install cvxpy."
+    )
 
 
-def solution_polytope_from_charge_balance(charges, charge_total,
-                                          return_fractions=False):
+def solution_polytope_from_charge_balance(
+    charges, charge_total, return_fractions=False
+):
     """
     Creates a polytope object from a list of the charges for each species on
     each site and the total charge for all site-species.
 
-    Parameters
-    ----------
-    charges : 2D list of floats
-        2D list containing the total charge for species j on site i,
+    :param charges: 2D list containing the total charge for species j on site i,
         including the site multiplicity. So, for example,
         a solution with the site formula [Mg,Fe]3[Mg,Al,Si]2Si3O12 would
         have the following list: [[6., 6.], [4., 6., 8.]].
-
-    charge_total : float
-        The total charge for all site-species per formula unit.
+    :type charges: 2D list of floats
+    :param charge_total: The total charge for all site-species per formula unit.
         The example given above would have charge_total = 12.
-
-    return_fractions : boolean
-        Determines whether the created polytope object returns its
+    :type charge_total: float
+    :param return_fractions: Determines whether the created polytope object returns its
         attributes (such as endmember occupancies) as fractions or as floats.
         Default is False.
+    :type return_fractions: bool
 
-    Returns
-    -------
-    polytope : :class:`burnman.polytope.MaterialPolytope` object
-        A polytope object corresponding to the parameters provided.
+    :returns: A polytope object corresponding to the parameters provided.
+    :rtype: :class:`burnman.polytope.MaterialPolytope` object
     """
     n_sites = len(charges)
     all_charges = np.concatenate(charges)
     n_site_elements = len(all_charges)
-    equalities = np.empty((n_sites+1, n_site_elements+1))
+    equalities = np.empty((n_sites + 1, n_site_elements + 1))
     equalities[:-1, 0] = -1
     i = 0
     for i_site, site_charges in enumerate(charges):
-        equalities[i_site, 1:] = [1 if (j >= i and j < i+len(site_charges))
-                                  else 0 for j in range(n_site_elements)]
+        equalities[i_site, 1:] = [
+            1 if (j >= i and j < i + len(site_charges)) else 0
+            for j in range(n_site_elements)
+        ]
         i += len(site_charges)
 
     equalities[-1, 0] = -charge_total
     equalities[-1, 1:] = all_charges
 
-    pos_constraints = np.concatenate((np.zeros((len(equalities[0])-1, 1)),
-                                      np.identity(len(equalities[0]) - 1)),
-                                     axis=1)
-    return MaterialPolytope(equalities, pos_constraints,
-                            return_fractions=return_fractions)
+    pos_constraints = np.concatenate(
+        (np.zeros((len(equalities[0]) - 1, 1)), np.identity(len(equalities[0]) - 1)),
+        axis=1,
+    )
+    return MaterialPolytope(
+        equalities, pos_constraints, return_fractions=return_fractions
+    )
 
 
-def solution_polytope_from_endmember_occupancies(endmember_occupancies,
-                                                 return_fractions=False):
+def solution_polytope_from_endmember_occupancies(
+    endmember_occupancies, return_fractions=False
+):
     """
     Creates a polytope object from a list of independent endmember occupancies.
 
-    Parameters
-    ----------
-    endmember_occupancies : 2D numpy array
-        2D list containing the site-species occupancies j for endmember i.
+    :param endmember_occupancies: 2D list containing the
+        site-species occupancies j for endmember i.
         So, for example, a solution with independent endmembers
         [Mg]3[Al]2Si3O12, [Mg]3[Mg0.5Si0.5]2Si3O12, [Fe]3[Al]2Si3O12
         might have the following array:
         [[1., 0., 1., 0., 0.],
         [1., 0., 0., 0.5, 0.5],
         [0., 1., 1., 0., 0.]],
         where the order of site-species is Mg_A, Fe_A, Al_B, Mg_B, Si_B.
+    :type endmember_occupancies: 2D numpy array
 
-    return_fractions : boolean
-        Determines whether the created polytope object returns its
-        attributes (such as endmember occupancies) as fractions or as floats.
-        Default is False.
+    :param return_fractions: Determines whether the created polytope object
+        returns its attributes (such as endmember occupancies) as fractions
+        or as floats.
+    :type return_fractions: bool
 
-    Returns
-    -------
-    polytope : :class:`burnman.polytope.MaterialPolytope` object
-        A polytope object corresponding to the parameters provided.
+    :returns: A polytope object corresponding to the parameters provided.
+    :rtype: :class:`burnman.polytope.MaterialPolytope` object
     """
     n_sites = sum(endmember_occupancies[0])
     n_occs = endmember_occupancies.shape[1]
 
-    nullspace = np.array(Matrix(endmember_occupancies).nullspace(),
-                         dtype=float)
+    nullspace = np.array(Matrix(endmember_occupancies).nullspace(), dtype=float)
 
-    equalities = np.zeros((len(nullspace)+1, n_occs+1))
+    equalities = np.zeros((len(nullspace) + 1, n_occs + 1))
     equalities[0, 0] = -n_sites
     equalities[0, 1:] = 1
 
     if len(nullspace) > 0:
         try:
             equalities[1:, 1:] = nullspace
         except ValueError:
             equalities[1:, 1:] = nullspace[:, :, 0]
 
-    pos_constraints = np.concatenate((np.zeros((len(equalities[0])-1, 1)),
-                                      np.identity(len(equalities[0]) - 1)),
-                                     axis=1)
-
-    return MaterialPolytope(equalities, pos_constraints,
-                            return_fractions=return_fractions,
-                            independent_endmember_occupancies=endmember_occupancies)
-
-
-def composite_polytope_at_constrained_composition(composite, composition,
-                                                  return_fractions=False):
+    pos_constraints = np.concatenate(
+        (np.zeros((len(equalities[0]) - 1, 1)), np.identity(len(equalities[0]) - 1)),
+        axis=1,
+    )
+
+    return MaterialPolytope(
+        equalities,
+        pos_constraints,
+        return_fractions=return_fractions,
+        independent_endmember_occupancies=endmember_occupancies,
+    )
+
+
+def composite_polytope_at_constrained_composition(
+    composite, composition, return_fractions=False
+):
     """
     Creates a polytope object from a Composite object and a composition.
     This polytope describes the complete set of valid composite
     endmember amounts that satisfy the compositional constraints.
 
-    Parameters
-    ----------
-    composite : :class:`burnman.Composite` object
-        A composite containing one or more Solution and Mineral objects.
+    :param composite: A composite containing one or more Solution and Mineral objects.
+    :type composite: :class:`burnman.Composite` object
 
-    composition : dictionary
-        A dictionary containing the amounts of each element.
+    :param composition: A dictionary containing the amounts of each element.
+    :type composition: dict
 
-    return_fractions : boolean
-        Determines whether the created polytope object returns its
+    :param return_fractions: Determines whether the created polytope object returns its
         attributes (such as endmember occupancies) as fractions or as floats.
-        Default is False.
+    :type return_fractions: bool
+
 
-    Returns
-    -------
-    polytope : :class:`burnman.polytope.MaterialPolytope` object
-        A polytope object corresponding to the parameters provided.
+    :returns: A polytope object corresponding to the parameters provided.
+    :rtype: :class:`burnman.polytope.MaterialPolytope` object
     """
     c_array = np.empty((composite.n_elements, 1))
-    c_array[:, 0] = [-composition[e] if e in composition else 0.
-                     for e in composite.elements]
+    c_array[:, 0] = [
+        -composition[e] if e in composition else 0.0 for e in composite.elements
+    ]
 
-    equalities = np.concatenate((c_array, composite.stoichiometric_array.T),
-                                axis=1)
+    equalities = np.concatenate((c_array, composite.stoichiometric_array.T), axis=1)
 
     eoccs = []
     for i, ph in enumerate(composite.phases):
         if isinstance(ph, Solution):
             eoccs.append(ph.solution_model.endmember_occupancies.T)
         else:
             eoccs.append(np.ones((1, 1)))
 
     eoccs = block_diag(*eoccs)
-    inequalities = np.concatenate((np.zeros((len(eoccs), 1)), eoccs),
-                                  axis=1)
+    inequalities = np.concatenate((np.zeros((len(eoccs), 1)), eoccs), axis=1)
 
-    return MaterialPolytope(equalities, inequalities,
-                            number_type='float',
-                            return_fractions=return_fractions)
+    return MaterialPolytope(
+        equalities, inequalities, number_type="float", return_fractions=return_fractions
+    )
 
 
 def simplify_composite_with_composition(composite, composition):
     """
     Takes a composite and a composition, and returns the simplest composite
     object that spans the solution space at the given composition.
 
     For example, if the composition is given as {'Mg': 2., 'Si': 1.5, 'O': 5.},
     and the composite is given as a mix of Mg,Fe olivine and pyroxene
     solutions, this function will return a composite that only contains
     the Mg-bearing endmembers.
 
-    Parameters
-    ----------
-    composite : :class:`burnman.Composite` object
-        The initial Composite object
-
-    composition : dictionary
-        A dictionary containing the amounts of each element
-
-    Returns
-    -------
-    simple_composite : :class:`burnman.Composite` object
-        The simplified Composite object
-    """
-    polytope = composite_polytope_at_constrained_composition(composite,
-                                                             composition,
-                                                             return_fractions=True)
+    :param composite: The initial Composite object.
+    :type composite: :class:`burnman.Composite` object
+
+    :param composition: A dictionary containing the amounts of each element.
+    :type composition: dict
+
+    :returns: The simplified Composite object
+    :rtype: :class:`burnman.Composite` object
+    """
+    polytope = composite_polytope_at_constrained_composition(
+        composite, composition, return_fractions=True
+    )
 
     composite_changed = False
     new_phases = []
     mbr_amounts = polytope.endmember_occupancies
     i = 0
     for i_ph, n_mbrs in enumerate(composite.endmembers_per_phase):
         ph = composite.phases[i_ph]
 
-        amounts = mbr_amounts[:, i:i+n_mbrs].astype(float)
+        amounts = mbr_amounts[:, i : i + n_mbrs].astype(float)
         i += n_mbrs
 
-        rank = np.linalg.matrix_rank(amounts, tol=1.e-8)
+        rank = np.linalg.matrix_rank(amounts, tol=1.0e-8)
 
         if rank < n_mbrs:
-
             if isinstance(ph, Solution) and rank > 0:
-
                 if len(amounts) > 1:
                     c_mean = np.mean(amounts, axis=0)
                 else:
                     c_mean = amounts[0]
 
                 poly = solution_polytope_from_endmember_occupancies(
-                    ph.solution_model.endmember_occupancies)
+                    ph.solution_model.endmember_occupancies
+                )
                 dmbrs = poly.endmembers_as_independent_endmember_amounts
 
                 x = cp.Variable(dmbrs.shape[0])
                 objective = cp.Minimize(cp.sum_squares(x))
-                constraints = [dmbrs.T@x == c_mean, x >= 0]
+                constraints = [dmbrs.T @ x == c_mean, x >= 0]
 
                 prob = cp.Problem(objective, constraints)
                 prob.solve()
 
                 mbr_indices = np.argsort(x.value)[::-1]
-                ind_indices = [i for i in mbr_indices
-                               if x.value[i] > 1.e-6]
+                ind_indices = [i for i in mbr_indices if x.value[i] > 1.0e-6]
                 new_basis = dmbrs[ind_indices]
 
                 # And now reduce the new basis if necessary
                 new_basis = new_basis[independent_row_indices(new_basis)]
 
                 if len(new_basis) < ph.n_endmembers:
-                    logging.info(f'Phase {i_ph} ({ph.name}) is '
-                                 'rank-deficient ({rank} < {n_mbrs}). '
-                                 'The transformed solution is described '
-                                 f'using {len(new_basis)} endmembers.')
+                    logging.info(
+                        f"Phase {i_ph} ({ph.name}) is "
+                        "rank-deficient ({rank} < {n_mbrs}). "
+                        "The transformed solution is described "
+                        f"using {len(new_basis)} endmembers."
+                    )
 
                     composite_changed = True
                     soln = transform_solution_to_new_basis(ph, new_basis)
                     new_phases.append(soln)
                 else:
-                    logging.info('This solution is rank-deficient '
-                                 f'({rank} < {n_mbrs}), '
-                                 'but its composition requires all '
-                                 'independent endmembers.')
+                    logging.info(
+                        "This solution is rank-deficient "
+                        f"({rank} < {n_mbrs}), "
+                        "but its composition requires all "
+                        "independent endmembers."
+                    )
             else:
                 composite_changed = True
-                logging.info(f'Phase {i_ph} ({ph.name}) removed from '
-                             'composite (rank = 0).')
+                logging.info(
+                    f"Phase {i_ph} ({ph.name}) removed from " "composite (rank = 0)."
+                )
         else:
             new_phases.append(ph)
 
     if composite_changed:
         return Composite(new_phases)
     else:
         return composite
```

### Comparing `burnman-1.1.0/burnman/tools/solution.py` & `burnman-1.2.0/burnman/tools/solution.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,328 +6,383 @@
 
 from __future__ import absolute_import
 
 import numpy as np
 from sympy import Matrix
 from ..classes.combinedmineral import CombinedMineral
 from ..classes.solution import Solution
+from ..classes.solutionmodel import (
+    IdealSolution,
+    SymmetricRegularSolution,
+    AsymmetricRegularSolution,
+    SubregularSolution,
+)
 from ..utils.chemistry import site_occupancies_to_strings
 
 
 def _decompose_3D_matrix(W):
     """
     Decomposes a 3D matrix W_ijk where E = W_ijk p_i p_j p_k
     into a subregular form where
     E = G_i p_i + WB_ij (1 - p_j + p_i) / 2 + WT_ijk p_i p_j p_k,
     and i < j < k.
 
-    Parameters
-    ----------
-    W : 3D numpy array
-
-    Returns
-    -------
-    new_endmember_excesses : 1D numpy array
-        The array G_i
+    :param W: 3D interaction matrix.
+    :type W: numpy.array
 
-    new_binary_matrix : 2D numpy array
-        The upper triangular matrix WB_ij
-
-    new_ternary_terms : list of lists of length 4
-        A list where each item is in the form [i, j, k, WT_ijk]
+    :returns: The 1D array G_i, the 2D upper triangular array WB_ij and
+        the ternary terms in a list where each item is in the form [i, j, k, WT_ijk]
+    :rtype: tuple
     """
 
     n_mbrs = len(W)
     # New endmember components
     # W_iii needs to be copied, otherwise just a view onto W
-    new_endmember_excesses = np.copy(np.einsum('iii->i', W))
+    new_endmember_excesses = np.copy(np.einsum("iii->i", W))
 
     # Removal of endmember components from 3D representation
-    W -= (np.einsum('i, j, k->ijk',
-                    new_endmember_excesses, np.ones(n_mbrs),
-                    np.ones(n_mbrs))
-          + np.einsum('i, j, k->ijk',
-                      np.ones(n_mbrs), new_endmember_excesses,
-                      np.ones(n_mbrs))
-          + np.einsum('i, j, k->ijk',
-                      np.ones(n_mbrs), np.ones(n_mbrs),
-                      new_endmember_excesses))/3.
+    W -= (
+        np.einsum(
+            "i, j, k->ijk", new_endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)
+        )
+        + np.einsum(
+            "i, j, k->ijk", np.ones(n_mbrs), new_endmember_excesses, np.ones(n_mbrs)
+        )
+        + np.einsum(
+            "i, j, k->ijk", np.ones(n_mbrs), np.ones(n_mbrs), new_endmember_excesses
+        )
+    ) / 3.0
 
     # Transformed 2D components
     # (i=j, i=k, j=k)
-    new_binary_matrix = (np.einsum('jki, jk -> ij', W, np.identity(n_mbrs))
-                         + np.einsum('jik, jk -> ij', W, np.identity(n_mbrs))
-                         + np.einsum('ijk, jk -> ij', W,
-                                     np.identity(n_mbrs))).round(decimals=12)
+    new_binary_matrix = (
+        np.einsum("jki, jk -> ij", W, np.identity(n_mbrs))
+        + np.einsum("jik, jk -> ij", W, np.identity(n_mbrs))
+        + np.einsum("ijk, jk -> ij", W, np.identity(n_mbrs))
+    ).round(decimals=12)
 
     # Wb is the 3D matrix corresponding to the terms in the binary matrix,
     # such that the two following print statements produce the same answer
     # for a given array of endmember proportions
-    Wb = (np.einsum('ijk, ij->ijk', W, np.identity(n_mbrs))
-          + np.einsum('ijk, jk->ijk', W, np.identity(n_mbrs))
-          + np.einsum('ijk, ik->ijk', W, np.identity(n_mbrs)))
+    Wb = (
+        np.einsum("ijk, ij->ijk", W, np.identity(n_mbrs))
+        + np.einsum("ijk, jk->ijk", W, np.identity(n_mbrs))
+        + np.einsum("ijk, ik->ijk", W, np.identity(n_mbrs))
+    )
 
     # Remove binary component from 3D representation
     # The extra terms are needed because the binary term in the formulation
     # of a subregular solution model given by
     # Helffrich and Wood includes ternary components (the sum_k X_k part)..
-    W -= Wb + (np.einsum('ij, k', new_binary_matrix, np.ones(n_mbrs))
-               - np.einsum('ij, ik->ijk',
-                           new_binary_matrix, np.identity(n_mbrs))
-               - np.einsum('ij, jk->ijk',
-                           new_binary_matrix, np.identity(n_mbrs)))/2.
+    W -= (
+        Wb
+        + (
+            np.einsum("ij, k", new_binary_matrix, np.ones(n_mbrs))
+            - np.einsum("ij, ik->ijk", new_binary_matrix, np.identity(n_mbrs))
+            - np.einsum("ij, jk->ijk", new_binary_matrix, np.identity(n_mbrs))
+        )
+        / 2.0
+    )
 
     # Find the 3D components Wijk by adding the elements at
     # the six equivalent positions in the matrix
     new_ternary_terms = []
     for i in range(n_mbrs):
-        for j in range(i+1, n_mbrs):
-            for k in range(j+1, n_mbrs):
-                val = (W[i, j, k] + W[j, k, i]
-                       + W[k, i, j] + W[k, j, i]
-                       + W[j, i, k] + W[i, k, j]).round(decimals=12)
-                if np.abs(val) > 1.e-12:
+        for j in range(i + 1, n_mbrs):
+            for k in range(j + 1, n_mbrs):
+                val = (
+                    W[i, j, k]
+                    + W[j, k, i]
+                    + W[k, i, j]
+                    + W[k, j, i]
+                    + W[j, i, k]
+                    + W[i, k, j]
+                ).round(decimals=12)
+                if np.abs(val) > 1.0e-12:
                     new_ternary_terms.append([i, j, k, val])
 
     return (new_endmember_excesses, new_binary_matrix, new_ternary_terms)
 
 
-def _subregular_matrix_conversion(new_basis, binary_matrix,
-                                  ternary_terms=None, endmember_excesses=None):
+def _subregular_matrix_conversion(
+    new_basis, binary_matrix, ternary_terms=None, endmember_excesses=None
+):
     """
     Converts the arrays reguired to describe a subregular solution
     from one endmember basis to another.
 
     The excess nonconfigurational energies of the subregular solution model
     are described as follows:
     E = G_i p_i + WB_ij (1 - p_j + p_i) / 2 + WT_ijk p_i p_j p_k,
     and i < j < k.
 
-    Parameters
-    ----------
-    new_basis : 2D numpy array
-        The new endmember basis, given as amounts of the old endmembers.
-
-    binary_matrix : 2D numpy array
-        The upper triangular matrix WB_ij
-
-    ternary_terms : list of lists of length 4
-        A list where each item is in the form [i, j, k, WT_ijk]
-
-    endmember_excesses : 1D numpy array
-        The array G_i
-
-    Returns
-    -------
-    new_endmember_excesses : 1D numpy array
-        The array G_i
+    :param new_basis: The new endmember basis, given as amounts of the old endmembers.
+    :type new_basis: 2D numpy array
 
-    new_binary_matrix : 2D numpy array
-        The upper triangular matrix WB_ij
+    :param binary_matrix: The upper triangular matrix WB_ij.
+    :type binary_matrix: 2D numpy array
 
-    new_ternary_terms : list of lists of length 4
-        A list where each item is in the form [i, j, k, WT_ijk]
+    :param ternary_terms: The ternary terms in a list where each
+        item is in the form [i, j, k, WT_ijk]
+    :type ternary_terms: list of lists of length 4
+
+    :param endmember_excesses: The array G_i
+    :type endmember_excesses: 1D numpy array
+
+    :returns: The 1D array G_i, the 2D upper triangular array WB_ij and
+        the ternary terms in a list where each item is in the form [i, j, k, WT_ijk]
+    :rtype: tuple
     """
     n_mbrs = len(binary_matrix)
     # Compact 3D representation of original interactions
-    W = (np.einsum('i, jk -> ijk', np.ones(n_mbrs), binary_matrix)
-         + np.einsum('ij, jk -> ijk', binary_matrix, np.identity(n_mbrs))
-         - np.einsum('ij, ik -> ijk', binary_matrix, np.identity(n_mbrs)))/2.
+    W = (
+        np.einsum("i, jk -> ijk", np.ones(n_mbrs), binary_matrix)
+        + np.einsum("ij, jk -> ijk", binary_matrix, np.identity(n_mbrs))
+        - np.einsum("ij, ik -> ijk", binary_matrix, np.identity(n_mbrs))
+    ) / 2.0
 
     # Add endmember components to 3D representation
     if endmember_excesses is not None:
-        W += (np.einsum('i, j, k->ijk', endmember_excesses,
-                        np.ones(n_mbrs), np.ones(n_mbrs))
-              + np.einsum('j, i, k->ijk', endmember_excesses,
-                          np.ones(n_mbrs), np.ones(n_mbrs))
-              + np.einsum('k, i, j->ijk', endmember_excesses,
-                          np.ones(n_mbrs), np.ones(n_mbrs)))/3.
+        W += (
+            np.einsum(
+                "i, j, k->ijk", endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)
+            )
+            + np.einsum(
+                "j, i, k->ijk", endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)
+            )
+            + np.einsum(
+                "k, i, j->ijk", endmember_excesses, np.ones(n_mbrs), np.ones(n_mbrs)
+            )
+        ) / 3.0
 
     # Add ternary values to 3D representation
     if ternary_terms is not None:
         for i, j, k, val in ternary_terms:
             W[i, j, k] += val
 
     # Transformation to new 3D representation
     A = new_basis.T
-    Wn = np.einsum('il, jm, kn, ijk -> lmn', A, A, A, W)
+    Wn = np.einsum("il, jm, kn, ijk -> lmn", A, A, A, W)
 
     new_endmember_excesses, new_binary_terms, new_ternary_terms = _decompose_3D_matrix(
-        Wn)
+        Wn
+    )
 
     return (new_endmember_excesses, new_binary_terms, new_ternary_terms)
 
 
 def complete_basis(basis):
     """
     Creates a full basis by filling remaining rows with
     rows of the identity matrix with row indices not
     in the column pivot list of the basis RREF
     """
 
     n, m = basis.shape
     if n < m:
         pivots = list(Matrix(basis).rref()[1])
-        return np.concatenate((basis,
-                               np.identity(m)[[i for i in range(m)
-                                               if i not in pivots], :]),
-                              axis=0)
+        return np.concatenate(
+            (basis, np.identity(m)[[i for i in range(m) if i not in pivots], :]), axis=0
+        )
     else:
         return basis
 
 
-def transform_solution_to_new_basis(solution, new_basis, n_mbrs=None,
-                                    solution_name=None, endmember_names=None,
-                                    molar_fractions=None):
+def transform_solution_to_new_basis(
+    solution,
+    new_basis,
+    n_mbrs=None,
+    solution_name=None,
+    endmember_names=None,
+    molar_fractions=None,
+):
     """
     Transforms a solution model from one endmember basis to another.
     Returns a new Solution object.
 
-    Parameters
-    ----------
-    solution : :class:`burnman.Solution` object
-        The original solution object.
-
-    new_basis : 2D numpy array
-        The new endmember basis, given as amounts of the old endmembers.
-
-    n_mbrs : float (optional)
-        The number of endmembers in the new solution
-        (defaults to the length of new_basis)
-
-    solution_name : string (optional)
-        A name corresponding to the new solution
-
-    endmember_names : list of strings (optional)
-        A list corresponding to the names of the new endmembers.
-
-    molar_fractions : numpy array (optional)
-        Fractions of the new endmembers in the new solution.
-
-    Returns
-    -------
-    solution : :class:`burnman.Solution` object
-        The transformed solution
+    :param solution: The original solution object.
+    :type solution: :class:`burnman.Solution` object
+
+    :param new_basis: The new endmember basis, given as amounts of the old endmembers.
+    :type new_basis: 2D numpy array
+
+    :param n_mbrs: The number of endmembers in the new solution
+        (defaults to the length of new_basis).
+    :type n_mbrs: float, optional
+
+    :param solution_name: A name corresponding to the new solution.
+    :type solution_name: str, optional
+
+    :param endmember_names: A list corresponding to the names of the new endmembers.
+    :type endmember_names: list of str, optional
+
+    :param molar_fractions: Fractions of the new endmembers in the new solution.
+    :type molar_fractions: numpy.array, optional
+
+    :returns: The transformed solution.
+    :rtype: :class:`burnman.Solution` object
     """
     new_basis = np.array(new_basis)
     if n_mbrs is None:
         n_mbrs, n_all_mbrs = new_basis.shape
     else:
         _, n_all_mbrs = new_basis.shape
 
     if solution_name is None:
-        name = 'child solution'
+        name = "child solution"
     else:
         name = solution_name
 
-    solution_type = solution.solution_type
-    if solution_type == 'ideal':
-        ESV_modifiers = [[0., 0., 0.] for v in new_basis]
-
-    elif (solution_type == 'asymmetric'
-          or solution_type == 'symmetric'):
+    solution_model = solution.solution_model
 
+    # Use type here to avoid inheritance problems
+    solution_type = type(solution_model)
+    if solution_type == IdealSolution:
+        ESV_modifiers = [[0.0, 0.0, 0.0] for v in new_basis]
+
+    if (
+        solution_type == AsymmetricRegularSolution
+        or solution_type == SymmetricRegularSolution
+    ):
         A = complete_basis(new_basis).T
 
         old_alphas = solution.solution_model.alphas
-        alphas = np.einsum('i, ij', solution.solution_model.alphas, A)
-        inv_diag_alphas = np.diag(1./alphas)
-        B = np.einsum('ij, jk, kl->il',
-                      np.diag(old_alphas),
-                      A, inv_diag_alphas)
+        alphas = np.einsum("i, ij", solution.solution_model.alphas, A)
+        inv_diag_alphas = np.diag(1.0 / alphas)
+        B = np.einsum("ij, jk, kl->il", np.diag(old_alphas), A, inv_diag_alphas)
         alphas = list(alphas[0:n_mbrs])
-        Qe = np.einsum('ik, ij, kl->jl', solution.solution_model.We, B, B)
-        Qs = np.einsum('ik, ij, kl->jl', solution.solution_model.Ws, B, B)
-        Qv = np.einsum('ik, ij, kl->jl', solution.solution_model.Wv, B, B)
+        Qe = np.einsum("ik, ij, kl->jl", solution.solution_model.We, B, B)
+        Qs = np.einsum("ik, ij, kl->jl", solution.solution_model.Ws, B, B)
+        Qv = np.einsum("ik, ij, kl->jl", solution.solution_model.Wv, B, B)
 
         def new_interactions(Q, n_mbrs):
-            return [[float((Q[i, j] + Q[j, i] - Q[i, i] - Q[j, j])
-                           * (alphas[i] + alphas[j])/2.)
-                     for j in range(i+1, n_mbrs)]
-                    for i in range(n_mbrs-1)]
+            return [
+                [
+                    float(
+                        (Q[i, j] + Q[j, i] - Q[i, i] - Q[j, j])
+                        * (alphas[i] + alphas[j])
+                        / 2.0
+                    )
+                    for j in range(i + 1, n_mbrs)
+                ]
+                for i in range(n_mbrs - 1)
+            ]
 
         energy_interaction = new_interactions(Qe, n_mbrs)
         entropy_interaction = new_interactions(Qs, n_mbrs)
         volume_interaction = new_interactions(Qv, n_mbrs)
 
-        ESV_modifiers = [[Qe[i, i] * alphas[i],
-                          Qs[i, i] * alphas[i],
-                          Qv[i, i] * alphas[i]]
-                         for i in range(n_mbrs)]
+        ESV_modifiers = [
+            [Qe[i, i] * alphas[i], Qs[i, i] * alphas[i], Qv[i, i] * alphas[i]]
+            for i in range(n_mbrs)
+        ]
 
-    elif solution_type == 'subregular':
+    elif solution_type == SubregularSolution:
         full_basis = complete_basis(new_basis)
 
         def new_interactions(W, n_mbrs):
-            return [[[W[i, j], W[j, i]] for j in range(i+1, n_mbrs)]
-                    for i in range(n_mbrs-1)]
+            return [
+                [[W[i, j], W[j, i]] for j in range(i + 1, n_mbrs)]
+                for i in range(n_mbrs - 1)
+            ]
 
         # N.B. initial endmember_excesses are zero
-        Emod, We, ternary_e = _subregular_matrix_conversion(full_basis,
-                                                            solution.solution_model.We,
-                                                            solution.solution_model.ternary_terms_e)
-        Smod, Ws, ternary_s = _subregular_matrix_conversion(full_basis,
-                                                            solution.solution_model.Ws,
-                                                            solution.solution_model.ternary_terms_s)
-        Vmod, Wv, ternary_v = _subregular_matrix_conversion(full_basis,
-                                                            solution.solution_model.Wv,
-                                                            solution.solution_model.ternary_terms_v)
+        Emod, We, ternary_e = _subregular_matrix_conversion(
+            full_basis,
+            solution.solution_model.We,
+            solution.solution_model.ternary_terms_e,
+        )
+        Smod, Ws, ternary_s = _subregular_matrix_conversion(
+            full_basis,
+            solution.solution_model.Ws,
+            solution.solution_model.ternary_terms_s,
+        )
+        Vmod, Wv, ternary_v = _subregular_matrix_conversion(
+            full_basis,
+            solution.solution_model.Wv,
+            solution.solution_model.ternary_terms_v,
+        )
 
         energy_interaction = new_interactions(We, n_mbrs)
         entropy_interaction = new_interactions(Ws, n_mbrs)
         volume_interaction = new_interactions(Wv, n_mbrs)
 
         ESV_modifiers = [[Emod[i], Smod[i], Vmod[i]] for i in range(n_mbrs)]
 
     else:
-        raise Exception('The function to change basis for the '
-                        '{0} solution model has not yet been '
-                        'implemented.'.format(solution_type))
+        raise Exception(
+            "The function to change basis for the "
+            "{0} solution type has not yet been "
+            "implemented.".format(solution_type)
+        )
 
     # Create site formulae
     new_occupancies = np.array(new_basis).dot(
-        solution.solution_model.endmember_occupancies)
+        solution.solution_model.endmember_occupancies
+    )
     new_multiplicities = np.array(new_basis).dot(
-        solution.solution_model.site_multiplicities)
-    site_formulae = site_occupancies_to_strings(solution.solution_model.sites,
-                                                new_multiplicities,
-                                                new_occupancies)
+        solution.solution_model.site_multiplicities
+    )
+    site_formulae = site_occupancies_to_strings(
+        solution.solution_model.sites, new_multiplicities, new_occupancies
+    )
 
     # Create endmembers
     endmembers = []
     for i, vector in enumerate(new_basis):
         nonzero_indices = np.nonzero(vector)[0]
         if len(nonzero_indices) == 1:
-            endmembers.append([solution.endmembers[nonzero_indices[0]][0],
-                               site_formulae[i]])
+            endmembers.append(
+                [solution_model.endmembers[nonzero_indices[0]][0], site_formulae[i]]
+            )
         else:
-            mbr = CombinedMineral([solution.endmembers[idx][0]
-                                   for idx in nonzero_indices],
-                                  [vector[idx] for idx in nonzero_indices],
-                                  ESV_modifiers[i])
-            mbr.params['formula'] = {key: value for (key, value)
-                                     in mbr.params['formula'].items()
-                                     if value > 1.e-12}
+            mbr = CombinedMineral(
+                [solution_model.endmembers[idx][0] for idx in nonzero_indices],
+                [vector[idx] for idx in nonzero_indices],
+                ESV_modifiers[i],
+            )
+            mbr.params["formula"] = {
+                key: value
+                for (key, value) in mbr.params["formula"].items()
+                if value > 1.0e-12
+            }
             endmembers.append([mbr, site_formulae[i]])
 
     if endmember_names is not None:
         for i in range(n_mbrs):
-            endmembers[i][0].params['name'] = endmember_names[i]
+            endmembers[i][0].params["name"] = endmember_names[i]
             endmembers[i][0].name = endmember_names[i]
 
     if n_mbrs == 1:
         endmembers[0][0].name = name
         endmembers[0][0].parent = solution
         endmembers[0][0].basis = new_basis
         return endmembers[0][0]
     else:
-        new_solution = Solution(name=name,
-                                solution_type=solution_type,
-                                endmembers=endmembers,
-                                energy_interaction=energy_interaction,
-                                volume_interaction=volume_interaction,
-                                entropy_interaction=entropy_interaction,
-                                alphas=alphas,
-                                molar_fractions=molar_fractions)
+        if solution_type == IdealSolution:
+            new_solution_model = IdealSolution(endmembers=endmembers)
+        elif (
+            solution_type == SymmetricRegularSolution
+            or solution_type == SubregularSolution
+        ):
+            new_solution_model = type(solution_model)(
+                endmembers=endmembers,
+                energy_interaction=energy_interaction,
+                volume_interaction=volume_interaction,
+                entropy_interaction=entropy_interaction,
+            )
+        else:
+            new_solution_model = type(solution_model)(
+                endmembers=endmembers,
+                energy_interaction=energy_interaction,
+                volume_interaction=volume_interaction,
+                entropy_interaction=entropy_interaction,
+                alphas=alphas,
+            )
+        new_solution = Solution(
+            name=name,
+            solution_model=new_solution_model,
+            molar_fractions=molar_fractions,
+        )
         new_solution.parent = solution
         new_solution.basis = new_basis
         return new_solution
```

### Comparing `burnman-1.1.0/burnman/utils/__init__.py` & `burnman-1.2.0/burnman/utils/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -19,7 +19,8 @@
 
 from . import chemistry
 from . import math
 from . import misc
 from . import reductions
 from . import unitcell
 from . import geotherm
+from . import anisotropy
```

### Comparing `burnman-1.1.0/burnman/utils/chemistry.py` & `burnman-1.2.0/burnman/utils/chemistry.py`

 * *Files 20% similar despite different names*

```diff
@@ -21,19 +21,18 @@
 
 
 def read_masses():
     """
     A simple function to read a file with a two column list of
     elements and their masses into a dictionary
     """
-    datastream = pkgutil.get_data(
-        'burnman', 'data/input_masses/atomic_masses.dat')
-    datalines = [line.strip()
-                 for line in datastream.decode('ascii').split('\n')
-                 if line.strip()]
+    datastream = pkgutil.get_data("burnman", "data/input_masses/atomic_masses.dat")
+    datalines = [
+        line.strip() for line in datastream.decode("ascii").split("\n") if line.strip()
+    ]
     lookup = dict()
     for line in datalines:
         data = "%".join(line.split("%")[:1]).split()
         if data != []:
             lookup[data[0]] = float(data[1])
     return lookup
 
@@ -45,152 +44,244 @@
 
 """
 IUPAC_element_order provides a list of all the elements.
 Element order is based loosely on electronegativity,
 following the scheme suggested by IUPAC, except that H
 comes after the Group 16 elements, not before them.
 """
-IUPAC_element_order = ['v', 'Og', 'Rn', 'Xe', 'Kr', 'Ar', 'Ne', 'He',  # Group 18
-                       'Fr', 'Cs', 'Rb', 'K', 'Na', 'Li',  # Group 1 (not H)
-                       'Ra', 'Ba', 'Sr', 'Ca', 'Mg', 'Be',  # Group 2
-                       'Lr', 'No', 'Md', 'Fm', 'Es', 'Cf', 'Bk', 'Cm',
-                       'Am', 'Pu', 'Np', 'U', 'Pa', 'Th', 'Ac',  # Actinides
-                       'Lu', 'Yb', 'Tm', 'Er', 'Ho', 'Dy', 'Tb', 'Gd',
-                       'Eu', 'Sm', 'Pm', 'Nd', 'Pr', 'Ce', 'La',  # Lanthanides
-                       'Y', 'Sc',  # Group 3
-                       'Rf', 'Hf', 'Zr', 'Ti',  # Group 4
-                       'Db', 'Ta', 'Nb', 'V',  # Group 5
-                       'Sg', 'W', 'Mo', 'Cr',  # Group 6
-                       'Bh', 'Re', 'Tc', 'Mn',  # Group 7
-                       'Hs', 'Os', 'Ru', 'Fe',  # Group 8
-                       'Mt', 'Ir', 'Rh', 'Co',  # Group 9
-                       'Ds', 'Pt', 'Pd', 'Ni',  # Group 10
-                       'Rg', 'Au', 'Ag', 'Cu',  # Group 11
-                       'Cn', 'Hg', 'Cd', 'Zn',  # Group 12
-                       'Nh', 'Tl', 'In', 'Ga', 'Al', 'B',  # Group 13
-                       'Fl', 'Pb', 'Sn', 'Ge', 'Si', 'C',  # Group 14
-                       'Mc', 'Bi', 'Sb', 'As', 'P', 'N',  # Group 15
-                       'Lv', 'Po', 'Te', 'Se', 'S', 'O',  # Group 16
-                       'H',  # hydrogen
-                       'Ts', 'At', 'I', 'Br', 'Cl', 'F']  # Group 17
+IUPAC_element_order = [
+    "v",
+    "Og",
+    "Rn",
+    "Xe",
+    "Kr",
+    "Ar",
+    "Ne",
+    "He",  # Group 18
+    "Fr",
+    "Cs",
+    "Rb",
+    "K",
+    "Na",
+    "Li",  # Group 1 (not H)
+    "Ra",
+    "Ba",
+    "Sr",
+    "Ca",
+    "Mg",
+    "Be",  # Group 2
+    "Lr",
+    "No",
+    "Md",
+    "Fm",
+    "Es",
+    "Cf",
+    "Bk",
+    "Cm",
+    "Am",
+    "Pu",
+    "Np",
+    "U",
+    "Pa",
+    "Th",
+    "Ac",  # Actinides
+    "Lu",
+    "Yb",
+    "Tm",
+    "Er",
+    "Ho",
+    "Dy",
+    "Tb",
+    "Gd",
+    "Eu",
+    "Sm",
+    "Pm",
+    "Nd",
+    "Pr",
+    "Ce",
+    "La",  # Lanthanides
+    "Y",
+    "Sc",  # Group 3
+    "Rf",
+    "Hf",
+    "Zr",
+    "Ti",  # Group 4
+    "Db",
+    "Ta",
+    "Nb",
+    "V",  # Group 5
+    "Sg",
+    "W",
+    "Mo",
+    "Cr",  # Group 6
+    "Bh",
+    "Re",
+    "Tc",
+    "Mn",  # Group 7
+    "Hs",
+    "Os",
+    "Ru",
+    "Fe",  # Group 8
+    "Mt",
+    "Ir",
+    "Rh",
+    "Co",  # Group 9
+    "Ds",
+    "Pt",
+    "Pd",
+    "Ni",  # Group 10
+    "Rg",
+    "Au",
+    "Ag",
+    "Cu",  # Group 11
+    "Cn",
+    "Hg",
+    "Cd",
+    "Zn",  # Group 12
+    "Nh",
+    "Tl",
+    "In",
+    "Ga",
+    "Al",
+    "B",  # Group 13
+    "Fl",
+    "Pb",
+    "Sn",
+    "Ge",
+    "Si",
+    "C",  # Group 14
+    "Mc",
+    "Bi",
+    "Sb",
+    "As",
+    "P",
+    "N",  # Group 15
+    "Lv",
+    "Po",
+    "Te",
+    "Se",
+    "S",
+    "O",  # Group 16
+    "H",  # hydrogen
+    "Ts",
+    "At",
+    "I",
+    "Br",
+    "Cl",
+    "F",
+]  # Group 17
 
 
 def dictionarize_formula(formula):
     """
     A function to read a chemical formula string and
     convert it into a dictionary
 
-    Parameters
-    ----------
-    formula : string object
-        Chemical formula, written in the XnYm format, where
+    :param formula: Chemical formula, written in the XnYm format, where
         the formula has n atoms of element X and m atoms of element Y
+    :type formula: str
 
-    Returns
-    -------
-    f : dictionary object
-        The same chemical formula, but expressed as a dictionary.
+    :returns: The same chemical formula, but expressed as a dictionary.
+    :rtype: dict
     """
     f = dict()
-    elements = re.findall('[A-Z][^A-Z]*', formula)
+    elements = re.findall("[A-Z][^A-Z]*", formula)
     for element in elements:
-        element_name = re.split('[0-9][^A-Z]*', element)[0]
-        element_atoms = re.findall('[0-9][^A-Z]*', element)
+        element_name = re.split("[0-9][^A-Z]*", element)[0]
+        element_atoms = re.findall("[0-9][^A-Z]*", element)
         if len(element_atoms) == 0:
             element_atoms = Fraction(1.0)
         else:
             element_atoms = Fraction(element_atoms[0])
         f[element_name] = f.get(element_name, 0.0) + element_atoms
 
     return f
 
 
 def sum_formulae(formulae, amounts=None):
     """
     Adds together a set of formulae.
 
-    Parameters
-    ----------
-    formulae : list of dictionary or counter objects
-        List of chemical formulae
-    amounts : list of floats
-        List of amounts of each formula
-
-    Returns
-    -------
-    summed_formula : Counter object
-        The sum of the user-provided formulae
+    :param formulae: List of chemical formulae.
+    :type formulae: list of dictionary or counter objects
+    :param amounts: List of amounts of each formula.
+    :type amounts: list of floats
+
+    :returns: The sum of the user-provided formulae
+    :rtype: Counter object
     """
     if amounts is None:
-        amounts = [1. for formula in formulae]
+        amounts = [1.0 for formula in formulae]
     else:
-        assert (len(formulae) == len(amounts))
+        assert len(formulae) == len(amounts)
 
     summed_formula = Counter()
     for i, formula in enumerate(formulae):
-        summed_formula.update(Counter({element: amounts[i] * n_atoms
-                                       for (element, n_atoms)
-                                       in formula.items()}))
+        summed_formula.update(
+            Counter(
+                {
+                    element: amounts[i] * n_atoms
+                    for (element, n_atoms) in formula.items()
+                }
+            )
+        )
     return summed_formula
 
 
 def formula_mass(formula):
     """
     A function to take a chemical formula and compute the formula mass.
 
-    Parameters
-    ----------
-    formula : dictionary or counter object
-        A chemical formula
-
-    Returns
-    -------
-    mass : float
-        The mass per mole of formula
+    :param formula: A chemical formula
+    :type formula: dict or Counter object
+
+    :returns: The mass per mole of formula [kg]
+    :rtype: float
     """
-    mass = sum(formula[element] * atomic_masses[element]
-               for element in formula)
+    mass = sum(formula[element] * atomic_masses[element] for element in formula)
     return mass
 
 
-def convert_formula(formula, to_type='mass', normalize=False):
+def convert_formula(formula, to_type="mass", normalize=False):
     """
     Converts a chemical formula from one type (mass or molar)
-    into the other. Renormalises amounts if normalize=True
+    into the other. Renormalises amounts if normalize=True.
+
+    :param formula: A chemical formula.
+    :type formula: dict or Counter object
 
-    Parameters
-    ----------
-    formula : dictionary or counter object
-        A chemical formula
-
-    to_type : string, one of 'mass' or 'molar'
-        Conversion type
-
-    normalize : boolean
-        Whether or not to normalize the converted formula to 1
-
-    Returns
-    -------
-    f : dictionary
-        The converted formula
-    """
-
-    if to_type == 'mass':
-        f = {element: n_atoms * atomic_masses[element]
-             for (element, n_atoms) in formula.items()}
-    elif to_type == 'molar':
-        f = {element: n_atoms / atomic_masses[element]
-             for (element, n_atoms) in formula.items()}
+    :param to_type: Conversion type, one of 'mass' or 'molar'.
+    :type to_type: str
+
+    :param normalize: Whether or not to normalize the converted formula to 1.
+    :type normalize: bool
+
+    :returns: The converted formula.
+    :rtype: dict
+    """
+
+    if to_type == "mass":
+        f = {
+            element: n_atoms * atomic_masses[element]
+            for (element, n_atoms) in formula.items()
+        }
+    elif to_type == "molar":
+        f = {
+            element: n_atoms / atomic_masses[element]
+            for (element, n_atoms) in formula.items()
+        }
     else:
-        raise Exception('Value of parameter to_type not recognised. '
-                        'Should be either "mass" or "molar".')
+        raise Exception(
+            "Value of parameter to_type not recognised. "
+            'Should be either "mass" or "molar".'
+        )
 
     if normalize:
         s = np.sum([n for (element, n) in f.items()])
-        f = {element: n/s for (element, n) in f.items()}
+        f = {element: n / s for (element, n) in f.items()}
 
     return f
 
 
 def process_solution_chemistry(solution_model):
     """
     This function parses a class instance with a "formulas"
@@ -202,199 +293,206 @@
     (removing the site information), and also a set of
     variables and arrays which contain the site information.
     These are output in a format that can easily be used to
     calculate activities and gibbs free energies, given
     molar fractions of the phases and pressure
     and temperature where necessary.
 
-    Parameters
-    ----------
-    solution_model : instance of class
-        Class must have a "formulas" attribute, containing a
-        list of chemical formulae with site information
-
-    Returns
-    -------
-    none
-        Nothing is returned from this function, but the solution_model
-        object gains the following attributes.
-
-    solution_formulae : list of dictionaries
-        List of endmember formulae is output from site formula strings
-
-    n_sites : integer
-        Number of sites in the solution.
-        Should be the same for all endmembers.
-
-    sites : list of lists of strings
-        A list of species for each site in the solution
-
-    site_names : list of strings
-        A list of species_site pairs in the solution, where
-        each distinct site is given by a unique uppercase letter
-        e.g. ['Mg_A', 'Fe_A', 'Al_A', 'Al_B', 'Si_B']
-
-    n_occupancies : integer
-        Sum of the number of possible species on each of the sites
-        in the solution.
-        Example: A binary solution [[A][B],[B][C1/2D1/2]] would have
-        n_occupancies = 5, with two possible species on
-        Site 1 and three on Site 2
-
-    site_multiplicities : 2D array of floats
-        A 1D array for each endmember in the solution,
-        containing the multiplicities of each site per formula unit.
-        To simplify computations later, the multiplicities
-        are repeated for each species on each site, so the shape of
-        this attribute is (n_endmembers, n_site_species).
-
-    endmember_occupancies : 2d array of floats
-        A 1D array for each endmember in the solution,
-        containing the fraction of atoms of each species on each site.
-
-    endmember_noccupancies : 2d array of floats
-        A 1D array for each endmember in the solution,
-        containing the number of atoms of each species on each site
-        per mole of endmember.
+    :param solution_model: Class must have a "formulas" attribute,
+        containing a list of chemical formulae with site information
+    :type solution model: instance of class
+
+    :rtype: None
+
+    .. note:: Nothing is returned from this function, but the solution_model
+        object gains the following attributes:
+
+        * solution_formulae [list of dictionaries]
+            List of endmember formulae in dictionary form.
+        * empty_formula [string]
+            Abbreviated chemical formula with sites denoted by empty
+            square brackets.
+        * general_formula [string]
+            General chemical formula with sites denoted by
+            square brackets filled with a comma-separated list of species
+        * n_sites [integer]
+            Number of sites in the solution.
+            Should be the same for all endmembers.
+        * sites [list of lists of strings]
+            A list of species for each site in the solution.
+        * site_names [list of strings]
+            A list of species_site pairs in the solution, where
+            each distinct site is given by a unique uppercase letter
+            e.g. ['Mg_A', 'Fe_A', 'Al_A', 'Al_B', 'Si_B'].
+        * n_occupancies [integer]
+            Sum of the number of possible species on each of the sites
+            in the solution.
+            Example: A binary solution [[A][B],[B][C1/2D1/2]] would have
+            n_occupancies = 5, with two possible species on
+            Site 1 and three on Site 2.
+        * site_multiplicities [2D array of floats]
+            A 1D array for each endmember in the solution,
+            containing the multiplicities of each site per formula unit.
+            To simplify computations later, the multiplicities
+            are repeated for each species on each site, so the shape of
+            this attribute is (n_endmembers, n_site_species).
+        * endmember_occupancies [2d array of floats]
+            A 1D array for each endmember in the solution,
+            containing the fraction of atoms of each species on each site.
+        * endmember_noccupancies [2d array of floats]
+            A 1D array for each endmember in the solution,
+            containing the number of atoms of each species on each site
+            per mole of endmember.
     """
     formulae = solution_model.formulas
-    n_sites = formulae[0].count('[')
+    n_sites = formulae[0].count("[")
     n_endmembers = len(formulae)
 
     # Check the number of sites is the same for all endmembers
-    if not np.all(np.array([f.count('[') for f in formulae]) == n_sites):
-        raise Exception('All formulae must have the same '
-                        'number of distinct sites.')
+    if not np.all(np.array([f.count("[") for f in formulae]) == n_sites):
+        raise Exception("All formulae must have the same " "number of distinct sites.")
 
     solution_formulae = [{} for i in range(n_endmembers)]
     sites = [[] for i in range(n_sites)]
     list_occupancies = []
     list_multiplicities = np.empty(shape=(n_endmembers, n_sites))
     n_occupancies = 0
 
     # Number of unique site occupancies (e.g.. Mg on X etc.)
     for i_mbr in range(n_endmembers):
-        list_occupancies.append([[0] * len(sites[site])
-                                for site in range(n_sites)])
-        s = re.split(r'\[', formulae[i_mbr])[1:]
+        list_occupancies.append([[0] * len(sites[site]) for site in range(n_sites)])
+        s = re.split(r"\[", formulae[i_mbr])[1:]
 
         for i_site, site_string in enumerate(s):
-            site_split = re.split(r'\]', site_string)
+            site_split = re.split(r"\]", site_string)
             site_occupancy = site_split[0]
 
-            mult = re.split('[A-Z][^A-Z]*', site_split[1])[0]
-            if mult == '':
+            mult = re.split("[A-Z][^A-Z]*", site_split[1])[0]
+            if mult == "":
                 list_multiplicities[i_mbr][i_site] = Fraction(1.0)
             else:
                 list_multiplicities[i_mbr][i_site] = Fraction(mult)
 
             # Loop over species on a site
-            species = re.findall('[A-Z][^A-Z]*', site_occupancy)
+            species = re.findall("[A-Z][^A-Z]*", site_occupancy)
 
             for sp in species:
                 # Find the species and its proportion on the site
-                species_split = re.split('([0-9][^A-Z]*)', sp)
+                species_split = re.split("([0-9][^A-Z]*)", sp)
                 name_of_species = species_split[0]
                 if len(species_split) == 1:
                     proportion_species_on_site = Fraction(1.0)
                 else:
                     proportion_species_on_site = Fraction(species_split[1])
 
-                solution_formulae[i_mbr][name_of_species] = solution_formulae[i_mbr].get(
-                    name_of_species, 0.0) + (list_multiplicities[i_mbr][i_site]
-                                             * proportion_species_on_site)
+                solution_formulae[i_mbr][name_of_species] = solution_formulae[
+                    i_mbr
+                ].get(name_of_species, 0.0) + (
+                    list_multiplicities[i_mbr][i_site] * proportion_species_on_site
+                )
 
                 if name_of_species not in sites[i_site]:
                     n_occupancies += 1
                     sites[i_site].append(name_of_species)
                     i_el = sites[i_site].index(name_of_species)
                     for parsed_mbr in range(len(list_occupancies)):
                         list_occupancies[parsed_mbr][i_site].append(0)
                 else:
                     i_el = sites[i_site].index(name_of_species)
                 list_occupancies[i_mbr][i_site][i_el] = proportion_species_on_site
 
             # Loop over species after site
             if len(site_split) != 1:
                 not_in_site = str(filter(None, site_split[1]))
-                not_in_site = not_in_site.replace(mult, '', 1)
-                for enamenumber in re.findall('[A-Z][^A-Z]*', not_in_site):
-                    sp = list(filter(None, re.split(r'(\d+)', enamenumber)))
+                not_in_site = not_in_site.replace(mult, "", 1)
+                for enamenumber in re.findall("[A-Z][^A-Z]*", not_in_site):
+                    sp = list(filter(None, re.split(r"(\d+)", enamenumber)))
                     # Look up number of atoms of element
                     if len(sp) == 1:
-                        nel = 1.
+                        nel = 1.0
                     else:
                         nel = float(float(sp[1]))
-                    solution_formulae[i_mbr][sp[0]] = solution_formulae[i_mbr].get(sp[0], 0.0) + nel
+                    solution_formulae[i_mbr][sp[0]] = (
+                        solution_formulae[i_mbr].get(sp[0], 0.0) + nel
+                    )
 
     # Site occupancies and multiplicities
     endmember_occupancies = np.empty(shape=(n_endmembers, n_occupancies))
     site_multiplicities = np.empty(shape=(n_endmembers, n_occupancies))
 
     for i_mbr in range(n_endmembers):
         n_species = 0
         for i_site in range(n_sites):
             for i_el in range(len(list_occupancies[i_mbr][i_site])):
-                endmember_occupancies[i_mbr][n_species] = list_occupancies[i_mbr][i_site][i_el]
-                site_multiplicities[i_mbr][n_species] = list_multiplicities[i_mbr][i_site]
+                endmember_occupancies[i_mbr][n_species] = list_occupancies[i_mbr][
+                    i_site
+                ][i_el]
+                site_multiplicities[i_mbr][n_species] = list_multiplicities[i_mbr][
+                    i_site
+                ]
                 n_species += 1
 
     # Site names
     solution_model.site_names = []
     for i, species in enumerate(sites):
         for sp in species:
-            solution_model.site_names.append('{0}_{1}'.format(sp, ucase[i]))
+            solution_model.site_names.append("{0}_{1}".format(sp, ucase[i]))
 
     # Finally, make attributes for solution model instance:
     solution_model.solution_formulae = solution_formulae
     solution_model.n_sites = n_sites
     solution_model.sites = sites
     solution_model.site_multiplicities = site_multiplicities
     solution_model.n_occupancies = n_occupancies
     solution_model.endmember_occupancies = endmember_occupancies
-    solution_model.endmember_noccupancies = np.einsum('ij, ij->ij',
-                                                      endmember_occupancies,
-                                                      site_multiplicities)
-
-
-def site_occupancies_to_strings(site_species_names, site_multiplicities,
-                                endmember_occupancies):
+    solution_model.endmember_noccupancies = np.einsum(
+        "ij, ij->ij", endmember_occupancies, site_multiplicities
+    )
+
+    solution_model.empty_formula = re.sub(
+        "([\[]).*?([\]])", "\g<1>\g<2>", solution_model.formulas[0]
+    )
+    split_empty = solution_model.empty_formula.split("[")
+    solution_model.general_formula = split_empty[0]
+    for i in range(n_sites):
+        solution_model.general_formula += f"[{','.join(sites[i])}{split_empty[i+1]}"
+
+
+def site_occupancies_to_strings(
+    site_species_names, site_multiplicities, endmember_occupancies
+):
     """
     Converts a list of endmember site occupancies into a list
     of string representations of those occupancies.
 
-    Parameters
-    ----------
-    site_species_names : 2D list of strings
-        A list of list of strings, giving the names of the species
-        which reside on each site.
+    :param site_species_names: A list of list of strings,
+        giving the names of the species which reside on each site.
         List of sites, each of which contains a list of the species
         occupying each site.
+    :type site_species_names: 2D list of strings
 
-    site_multiplicities : 1D or 2D numpy array of floats
-        List of floats giving the multiplicity of each site.
-        If 2D, must have the same shape as endmember_occupancies.
+    :param site_multiplicities: List of floats giving the multiplicity
+        of each site. If 2D, must have the same shape as endmember_occupancies.
         If 1D, must be either the same length as the number of sites, or
         the same length as site_species_names
         (with an implied repetition of the same
         number for each species on a given site).
+    :type site_multiplicities: 1D or 2D numpy array of floats
 
-    endmember_occupancies : 2D numpy array of floats
-        A list of site-species occupancies for each endmember.
-        The first dimension loops over the endmembers, and the
+    :param endmember_occupancies: A list of site-species occupancies
+        for each endmember. The first dimension loops over the endmembers, and the
         second dimension loops over the site-species occupancies for that endmember.
         The total number and order of occupancies must
         be the same as the strings in site_species_names.
+    :type endmember_occupancies: 2D numpy array of floats
 
-    Returns
-    -------
-    site_formulae : list of strings
-        A list of strings in standard burnman format.
+    :returns: A list of strings in standard burnman format.
         For example, [Mg]3[Al]2 would correspond to the
         classic two-site pyrope garnet.
+    :rtype: list of strings
     """
 
     site_multiplicities = np.array(site_multiplicities)
     endmember_occupancies = np.array(endmember_occupancies)
     n_endmembers = endmember_occupancies.shape[0]
 
     if len(site_multiplicities.shape) == 1:
@@ -406,144 +504,130 @@
             for i, site in enumerate(site_species_names):
                 for species in site:
                     site_mults.append(site_multiplicities[i])
 
             site_multiplicities = np.array(site_mults)
 
         elif len(endmember_occupancies[0]) != len(site_multiplicities):
-            raise Exception('Site multiplicities should either be given '
-                            'on a per-site basis or a per-species basis')
-
-        site_multiplicities = np.einsum('i, j->ij', np.ones(n_endmembers),
-                                        site_multiplicities)
+            raise Exception(
+                "Site multiplicities should either be given "
+                "on a per-site basis or a per-species basis"
+            )
+
+        site_multiplicities = np.einsum(
+            "i, j->ij", np.ones(n_endmembers), site_multiplicities
+        )
     elif len(site_multiplicities.shape) == 2:
         if site_multiplicities.shape != endmember_occupancies.shape:
-            raise Exception('If site_multiplicities is 2D, it should have '
-                            'the same shape as endmember_occupancies. '
-                            'They currently have shapes '
-                            f'{site_multiplicities.shape} and '
-                            f'{endmember_occupancies.shape}.')
+            raise Exception(
+                "If site_multiplicities is 2D, it should have "
+                "the same shape as endmember_occupancies. "
+                "They currently have shapes "
+                f"{site_multiplicities.shape} and "
+                f"{endmember_occupancies.shape}."
+            )
     else:
-        raise Exception('Site multiplicities should either be 1D or 2D.')
+        raise Exception("Site multiplicities should either be 1D or 2D.")
 
     site_formulae = []
     for i_mbr, mbr_occupancies in enumerate(endmember_occupancies):
         i = 0
-        site_formulae.append('')
+        site_formulae.append("")
         for site in site_species_names:
-            amounts = mbr_occupancies[i:i+len(site)]
-            mult = site_multiplicities[i_mbr,i]
-            if np.abs(mult - 1.) < 1.e-12:
-                mult = ''
+            amounts = mbr_occupancies[i : i + len(site)]
+            mult = site_multiplicities[i_mbr, i]
+            if np.abs(mult - 1.0) < 1.0e-12:
+                mult = ""
             else:
                 mult = str(nsimplify(mult))
             amounts /= sum(amounts)
             site_occupancy = formula_to_string(dict(zip(site, amounts)))
-            site_formulae[-1] += '[{0}]{1}'.format(site_occupancy, mult)
+            site_formulae[-1] += "[{0}]{1}".format(site_occupancy, mult)
             i += len(site)
 
     return site_formulae
 
 
 def compositional_array(formulae):
     """
-    Parameters
-    ----------
-    formulae : list of dictionaries
-        List of chemical formulae
-
-    Returns
-    -------
-    formula_array : 2D array of floats
-        Array of endmember formulae
+    :param formulae: List of chemical formulae
+    :type formulae: list of dicts
 
-    elements : List of strings
-        List of elements
+    :returns: Array of endmember formulae and a list of elements.
+    :rtype: 2D numpy.array of floats and a list of strs
     """
     elements = []
     for formula in formulae:
         for element in formula:
             if element not in elements:
                 elements.append(element)
 
     formula_array = ordered_compositional_array(formulae, elements)
 
     return formula_array, elements
 
 
 def ordered_compositional_array(formulae, elements):
     """
-    Parameters
-    ----------
-    formulae : list of dictionaries
-        List of chemical formulae
-
-    elements : List of strings
-        List of elements
-
-    Returns
-    -------
-    formula_array : 2D array of floats
-        Array of endmember formulae
+    :param formulae: List of chemical formulae
+    :type formulae: list of dicts
+
+    :param elements : List of elements
+    :type elements: list of strings
+
+    :returns: Array of endmember formulae
+    :rtype: 2D array of floats
     """
     formula_array = np.zeros(shape=(len(formulae), len(elements)))
     for idx, formula in enumerate(formulae):
         for element in formula:
-            assert(element in elements)
+            assert element in elements
             formula_array[idx][elements.index(element)] = formula[element]
 
     return formula_array
 
 
 def formula_to_string(formula):
     """
-    Parameters
-    ----------
-    formula : dictionary or counter
-        Chemical formula
-
-    Returns
-    -------
-    formula_string : string
-        A formula string, with element order as given in the list
+    :param formula: Chemical formula
+    :type formula: dict or Counter
+
+    :returns: A formula string, with element order as given in the list
         IUPAC_element_order.
         If one or more keys in the dictionary are not one of the elements
         in the periodic table, then they are added at the end of the string.
+    :rtype: str
     """
 
-    formula_string = ''
+    formula_string = ""
     for e in IUPAC_element_order:
-        if e in formula and np.abs(formula[e]) > 1.e-12:
-            if np.abs(formula[e] - 1.) < 1.e-12:
+        if e in formula and np.abs(formula[e]) > 1.0e-12:
+            if np.abs(formula[e] - 1.0) < 1.0e-12:
                 formula_string += e
             else:
                 formula_string += e + str(nsimplify(formula[e]))
 
     for e in formula:
         if e not in IUPAC_element_order:
-            if e in formula and np.abs(formula[e]) > 1.e-12:
-                if np.abs(formula[e] - 1.) < 1.e-12:
+            if e in formula and np.abs(formula[e]) > 1.0e-12:
+                if np.abs(formula[e] - 1.0) < 1.0e-12:
                     formula_string += e
                 else:
                     formula_string += e + str(nsimplify(formula[e]))
 
     return formula_string
 
 
 def sort_element_list_to_IUPAC_order(element_list):
     """
-    Parameters
-    ----------
-    element_list : list
-        List of elements
-
-    Returns
-    -------
-    sorted_list : list
-        List of elements sorted into IUPAC order
+    :param element_list : List of elements.
+    :type element_list: list
+
+    :returns: List of elements sorted into IUPAC order
+    :rtype: list
     """
     sorted_list = [e for e in IUPAC_element_order if e in element_list]
     assert len(sorted_list) == len(element_list)
     return sorted_list
 
 
 def convert_fractions(composite, phase_fractions, input_type, output_type):
@@ -553,60 +637,105 @@
     currently associated with the composite) and
     converts the fractions to molar, mass or volume.
 
     Conversions to and from mass require a molar mass to be
     defined for all phases. Conversions to and from volume
     require set_state to have been called for the composite.
 
-    Parameters
-    ----------
-    composite : Composite
-        Composite for which fractions are to be defined.
-
-    phase_fractions : list of floats
-        List of input phase fractions (of type input_type)
-
-    input_type : string
-        Input fraction type: 'molar', 'mass' or 'volume'
-
-    output_type : string
-        Output fraction type: 'molar', 'mass' or 'volume'
-
-    Returns
-    -------
-    output_fractions : list of floats
-        List of output phase fractions (of type output_type)
+    :param composite: Composite for which fractions are to be defined.
+    :type composite: :class:`~burnman.Composite`
+
+    :param phase_fractions: List of input phase fractions
+        (of type input_type).
+    :type phase_fractions: list of floats
+
+    :param input_type: Input fraction type. One of 'molar', 'mass' or 'volume'.
+    :type input_type: str
+
+    :param output_type: Output fraction type. One of 'molar', 'mass' or 'volume'.
+    :type output_type: str
+
+    :returns: List of output phase fractions (of type output_type)
+    :rtype: list of floats
     """
-    if input_type == 'volume' or output_type == 'volume':
+    if input_type == "volume" or output_type == "volume":
         if composite.temperature is None:
             raise Exception(
-                composite.to_string() + ".set_state(P, T) has not been called, so volume fractions are currently undefined. Exiting.")
+                composite.to_string()
+                + ".set_state(P, T) has not been called, so volume fractions are currently undefined. Exiting."
+            )
 
-    if input_type == 'molar':
+    if input_type == "molar":
         molar_fractions = phase_fractions
-    if input_type == 'volume':
+    if input_type == "volume":
+        total_moles = sum(
+            volume_fraction / phase.molar_volume
+            for volume_fraction, phase in zip(phase_fractions, composite.phases)
+        )
+        molar_fractions = [
+            volume_fraction / (phase.molar_volume * total_moles)
+            for volume_fraction, phase in zip(phase_fractions, composite.phases)
+        ]
+    if input_type == "mass":
         total_moles = sum(
-            volume_fraction / phase.molar_volume for volume_fraction,
-            phase in zip(phase_fractions, composite.phases))
-        molar_fractions = [volume_fraction / (phase.molar_volume * total_moles)
-                           for volume_fraction, phase in zip(phase_fractions, composite.phases)]
-    if input_type == 'mass':
-        total_moles = sum(mass_fraction / phase.molar_mass for mass_fraction,
-                          phase in zip(phase_fractions, composite.phases))
-        molar_fractions = [mass_fraction / (phase.molar_mass * total_moles)
-                           for mass_fraction, phase in zip(phase_fractions, composite.phases)]
+            mass_fraction / phase.molar_mass
+            for mass_fraction, phase in zip(phase_fractions, composite.phases)
+        )
+        molar_fractions = [
+            mass_fraction / (phase.molar_mass * total_moles)
+            for mass_fraction, phase in zip(phase_fractions, composite.phases)
+        ]
 
-    if output_type == 'volume':
+    if output_type == "volume":
         total_volume = sum(
-            molar_fraction * phase.molar_volume for molar_fraction,
-            phase in zip(molar_fractions, composite.phases))
-        output_fractions = [molar_fraction * phase.molar_volume
-                            / total_volume for molar_fraction, phase in zip(molar_fractions, composite.phases)]
-    elif output_type == 'mass':
-        total_mass = sum(molar_fraction * phase.molar_mass for molar_fraction,
-                         phase in zip(molar_fractions, composite.phases))
-        output_fractions = [molar_fraction * phase.molar_mass
-                            / total_mass for molar_fraction, phase in zip(molar_fractions, composite.phases)]
-    elif output_type == 'molar':
+            molar_fraction * phase.molar_volume
+            for molar_fraction, phase in zip(molar_fractions, composite.phases)
+        )
+        output_fractions = [
+            molar_fraction * phase.molar_volume / total_volume
+            for molar_fraction, phase in zip(molar_fractions, composite.phases)
+        ]
+    elif output_type == "mass":
+        total_mass = sum(
+            molar_fraction * phase.molar_mass
+            for molar_fraction, phase in zip(molar_fractions, composite.phases)
+        )
+        output_fractions = [
+            molar_fraction * phase.molar_mass / total_mass
+            for molar_fraction, phase in zip(molar_fractions, composite.phases)
+        ]
+    elif output_type == "molar":
         output_fractions = molar_fractions
 
     return output_fractions
+
+
+def reaction_matrix_as_strings(reaction_matrix, compound_names):
+    """
+    Returns a list of string representations of all the reactions in
+    reaction_matrix.
+
+    :param reaction_matrix: Matrix of stoichiometric amounts
+        of each compound j in reaction i.
+    :type reaction_matrix: 2D numpy array
+
+    :param compound_names: List of compound names.
+    :type compound_names: list of strings
+
+    :returns: List of strings corresponding to each reaction.
+    :rtype: list of strings
+    """
+    reaction_strings = []
+    for reaction in reaction_matrix:
+        lhs, rhs = ("", "")
+        for i, coefficient in enumerate(reaction):
+            if coefficient < -1.0e-10:
+                if len(lhs) > 0:
+                    lhs += " + "
+                lhs += f"{-coefficient} {compound_names[i]}"
+            if coefficient > 1.0e-10:
+                if len(rhs) > 0:
+                    rhs += " + "
+                rhs += f"{coefficient} {compound_names[i]}"
+        reaction_strings.append(f"{lhs} = {rhs}")
+
+    return reaction_strings
```

### Comparing `burnman-1.1.0/burnman/utils/geotherm.py` & `burnman-1.2.0/burnman/utils/geotherm.py`

 * *Files 8% similar despite different names*

```diff
@@ -10,100 +10,92 @@
 from ..utils.math import bracket
 
 
 def brown_shankland(depths):
     """
     Geotherm from :cite:`Brown1981`. NOTE: Valid only above 270 km
 
-    Parameters
-    ----------
-    depths : list of floats
-        The list of depths at which to evaluate the geotherm. :math:`[m]`
-
-    Returns
-    -------
-    temperature : list of floats
-        The list of temperatures for each of the pressures. :math:`[K]`
+    :param depths: The list of depths at which to evaluate the geotherm.
+        :math:`[m]`
+    :type depths: list of floats
+
+    :returns: The list of temperatures for each of the pressures. :math:`[K]`
+    :rtype: list of floats
     """
 
-    assert(min(depths) >= min(table_brown_depth))
-    assert(max(depths) <= max(table_brown_depth))
+    assert min(depths) >= min(table_brown_depth)
+    assert max(depths) <= max(table_brown_depth)
     temperature = np.empty_like(depths)
     for i, depth in enumerate(depths):
         temperature[i] = lookup_and_interpolate(
-            table_brown_depth, table_brown_temperature, depth)
+            table_brown_depth, table_brown_temperature, depth
+        )
     return temperature
 
 
 def anderson(depths):
     """
     Geotherm from :cite:`anderson1982earth`.
 
-    Parameters
-    ----------
-    depths : list of floats
-        The list of depths at which to evaluate the geotherm. :math:`[m]`
-
-    Returns
-    -------
-    temperature : list of floats
-        The list of temperatures for each of the pressures. :math:`[K]`
+    :param depths: The list of depths at which to evaluate the geotherm.
+        :math:`[m]`
+    :type depths: list of floats
+
+    :returns: The list of temperatures for each of the pressures. :math:`[K]`
+    :rtype: list of floats
     """
-    assert(min(depths) >= min(table_anderson_depth))
-    assert(max(depths) <= max(table_anderson_depth))
+    assert min(depths) >= min(table_anderson_depth)
+    assert max(depths) <= max(table_anderson_depth)
     temperature = np.empty_like(depths)
     for i, depth in enumerate(depths):
         temperature[i] = lookup_and_interpolate(
-                table_anderson_depth, table_anderson_temperature, depth)
+            table_anderson_depth, table_anderson_temperature, depth
+        )
     return temperature
 
 
 def stacey_continental(depths):
     """
     Continental geotherm from :cite:`stacey1977`.
 
-    Parameters
-    ----------
-    depths : list of floats
-        The list of depths at which to evaluate the geotherm. :math:`[m]`
-
-    Returns
-    -------
-    temperature : list of floats
-        The list of temperatures for each of the pressures. :math:`[K]`
+    :param depths: The list of depths at which to evaluate the geotherm.
+        :math:`[m]`
+    :type depths: list of floats
+
+    :returns: The list of temperatures for each of the pressures. :math:`[K]`
+    :rtype: list of floats
     """
-    assert(min(depths) >= min(table_stacey_c_depth))
-    assert(max(depths) <= max(table_stacey_c_depth))
+    assert min(depths) >= min(table_stacey_c_depth)
+    assert max(depths) <= max(table_stacey_c_depth)
     temperature = np.empty_like(depths)
     for i, depth in enumerate(depths):
         temperature[i] = lookup_and_interpolate(
-                table_stacey_c_depth, table_stacey_c_temperature, depth)
+            table_stacey_c_depth, table_stacey_c_temperature, depth
+        )
     return temperature
 
 
 def stacey_oceanic(depths):
     """
     Oceanic geotherm from :cite:`stacey1977`.
 
-    Parameters
-    ----------
-    depths : list of floats
-        The list of depths at which to evaluate the geotherm. :math:`[m]`
-
-    Returns
-    -------
-    temperature : list of floats
-        The list of temperatures for each of the pressures. :math:`[K]`
+    :param depths: The list of depths at which to evaluate the geotherm.
+        :math:`[m]`
+    :type depths: list of floats
+
+    :returns: The list of temperatures for each of the pressures. :math:`[K]`
+    :rtype: list of floats
     """
-    assert(min(depths) >= min(table_stacey_o_depth))
-    assert(max(depths) <= max(table_stacey_o_depth))
+    assert min(depths) >= min(table_stacey_o_depth)
+    assert max(depths) <= max(table_stacey_o_depth)
     temperature = np.empty_like(depths)
     for i, depth in enumerate(depths):
         temperature[i] = lookup_and_interpolate(
-                table_stacey_o_depth, table_stacey_o_temperature, depth)
+            table_stacey_o_depth, table_stacey_o_temperature, depth
+        )
     return temperature
 
 
 def adiabatic(pressures, T0, rock):
     """
     This calculates a geotherm based on an anchor temperature and a rock,
     assuming that the rock's temperature follows an adiabatic gradient with
@@ -111,51 +103,50 @@
 
     .. math::
         \\frac{\partial T}{\partial P} = \\frac{ \\gamma  T}{ K_s }
 
     where :math:`\\gamma` is the Grueneisen parameter and :math:`K_s` is
     the adiabatic bulk modulus.
 
-    Parameters
-    ----------
-
-    pressures : list of floats
-        The list of pressures in :math:`[Pa]` at which
+    :param pressures: The list of pressures in :math:`[Pa]` at which
         to evaluate the geotherm.
+    :type pressures: list of floats
 
-    T0 : float
-        An anchor temperature, corresponding to the temperature of the first
+    :param T0: An anchor temperature, corresponding to the temperature of the first
         pressure in the list. :math:`[K]`
+    :type T0: float
 
-    rock : :class:`burnman.composite`
-        Material for which we compute the adiabat.  From this material we
+    :param rock: Composite for which we compute the adiabat.  From this material we
         must compute average Grueneisen parameters and adiabatic bulk moduli
         for each pressure/temperature.
+    :type rock: :class:`burnman.composite`
 
-    Returns
-    -------
-
-    temperature: list of floats
-        The list of temperatures for each pressure. :math:`[K]`
+    :returns: The list of temperatures for each pressure. :math:`[K]`
+    :rtype: numpy.array of floats
     """
 
     rock.set_state(pressures[0], T0)
     S0 = rock.S
 
-    delta_S = lambda T, P, rock, S0: S0 - rock.evaluate(['S'], [P], [T])[0]
+    delta_S = lambda T, P, rock, S0: S0 - rock.evaluate(["S"], [P], [T])[0]
 
     temperatures = np.empty_like(pressures)
     temperatures[0] = T0
     for i in range(1, len(pressures)):
         args = (pressures[i], rock, S0)
-        sol = bracket(fn=delta_S,
-                      x0=(temperatures[i-1]
-                          + (rock.gr*temperatures[i-1]/rock.K_S)
-                          * (pressures[i] - pressures[i-1])),
-                      dx=1., args=args)
+        sol = bracket(
+            fn=delta_S,
+            x0=(
+                temperatures[i - 1]
+                + (rock.gr * temperatures[i - 1] / rock.K_S)
+                * (pressures[i] - pressures[i - 1])
+            ),
+            dx=1.0,
+            args=args,
+        )
         temperatures[i] = brentq(delta_S, sol[0], sol[1], args=args)
 
     return temperatures
 
 
 table_brown = read_table("input_geotherm/brown_81.txt")
 table_brown_depth = np.array(table_brown)[:, 0]
```

### Comparing `burnman-1.1.0/burnman/utils/math.py` & `burnman-1.2.0/burnman/utils/math.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 # GPL v2 or later.
 
 from __future__ import absolute_import
 from __future__ import print_function
 
 import numpy as np
 from scipy.ndimage.filters import gaussian_filter
-from scipy.interpolate import interp2d
+from scipy.interpolate import RegularGridInterpolator
 from sympy import Matrix, Rational
 import scipy.integrate as integrate
 from collections import Counter
 import itertools
 
 from .reductions import row_reduce
 
@@ -40,293 +40,321 @@
 
 
 def linear_interpol(x, x1, x2, y1, y2):
     """
     Linearly interpolate to point x, between
     the points (x1,y1), (x2,y2)
     """
-    assert(x1 <= x)
-    assert(x2 >= x)
-    assert(x1 <= x2)
+    assert x1 <= x
+    assert x2 >= x
+    assert x1 <= x2
 
     alpha = (x - x1) / (x2 - x1)
-    return (1. - alpha) * y1 + alpha * y2
+    return (1.0 - alpha) * y1 + alpha * y2
 
 
 def bracket(fn, x0, dx, args=(), ratio=1.618, maxiter=100):
     """
     Given a function and a starting guess, find two
     inputs for the function that bracket a root.
 
-    Parameters
-    ----------
-    fn : function
-        The function to bracket
-    x0 : float
-        The starting guess
-    dx : float
-        Small step for starting the search
-    args : parameter list
-        Additional arguments to give to fn
-    ratio :
-        The step size increases by this ratio
+    :param fn: The function to bracket.
+    :type fn: function
+    :param x0: The starting guess.
+    :type x0: float
+    :param dx: Small step for starting the search.
+    :type dx: float
+    :param args: Additional arguments to give to fn.
+    :type args: tuple
+    :param ratio: The step size increases by this ratio
         every step in the search. Defaults to
         the golden ratio.
-    maxiter : int
-        The maximum number of steps before giving up.
-
-    Returns
-    -------
-    xa, xb, fa, fb: floats
-        xa and xb are the inputs which bracket a root of fn.
-        fa and fb are the values of the function at those points.
+    :type ratio: float
+    :param maxiter: The maximum number of steps before giving up.
+    :type maxiter: int
+
+    :returns: xa, xb, fa, fb. xa and xb are the inputs which
+        bracket a root of fn. fa and fb are the values of the
+        function at those points.
         If the bracket function takes more than maxiter steps,
         it raises a ValueError.
+    :rtype: tuple of floats
+
     """
     niter = 0
     dx = np.abs(dx)
-    assert(ratio > 1.0)
+    assert ratio > 1.0
 
     # Get the starting positions
     f0 = fn(x0, *args)
     x_left = x0 - dx
     x_right = x0 + dx
     f_left = fn(x_left, *args)
     f_right = fn(x_right, *args)
 
     # Overshot zero, try making dx smaller
-    if (f0 - f_left) * (f_right - f0) < 0.:
-        while (f0 - f_left) * (f_right - f0) < 0. and dx > np.finfo('float').eps and niter < maxiter:
+    if (f0 - f_left) * (f_right - f0) < 0.0:
+        while (
+            (f0 - f_left) * (f_right - f0) < 0.0
+            and dx > np.finfo("float").eps
+            and niter < maxiter
+        ):
             dx /= ratio
             x_left = x0 - dx
             x_right = x0 + dx
             f_left = fn(x_left, *args)
             f_right = fn(x_right, *args)
             niter += 1
-        if niter == maxiter:  # Couldn't find something with same slope in both directions
-            raise ValueError('Cannot find zero.')
+        if (
+            niter == maxiter
+        ):  # Couldn't find something with same slope in both directions
+            raise ValueError("Cannot find zero.")
 
     niter = 0
     slope = f_right - f0
-    if slope > 0. and f0 > 0.:  # Walk left
+    if slope > 0.0 and f0 > 0.0:  # Walk left
         dx = -dx
         x1 = x_left
         f1 = f_left
-    elif slope > 0. and f0 < 0.:  # Walk right
+    elif slope > 0.0 and f0 < 0.0:  # Walk right
         x1 = x_right
         f1 = f_right
-    elif slope < 0. and f0 > 0:  # Walk right
+    elif slope < 0.0 and f0 > 0:  # Walk right
         x1 = x_right
         f1 = f_right
     else:  # Walk left
         dx = -dx
         x1 = x_left
         f1 = f_left
 
     # Do the walking
-    while f0 * f1 > 0. and niter < maxiter:
+    while f0 * f1 > 0.0 and niter < maxiter:
         dx *= ratio
         xnew = x1 + dx
         fnew = fn(xnew, *args)
         x0 = x1
         f0 = f1
         x1 = xnew
         f1 = fnew
         niter += 1
 
-    if f0 * f1 > 0.:
-        raise ValueError('Cannot find zero.')
+    if f0 * f1 > 0.0:
+        raise ValueError("Cannot find zero.")
     else:
         return x0, x1, f0, f1
 
 
 def _pad_ndarray_inverse_mirror(array, padding):
     """
     Pads an ndarray according to an inverse mirror
     scheme. For example, for a 1D array
     [2, 4, 6, 7, 8] padded by 3 cells, we have:
 
      padding  |  original array |  padding
 
     -3 -2  0  |  2  4  6  7  8  |  9 10 12
 
-    Parameters
-    ----------
-    array : numpy ndarray
-        The array to be padded
-    padding : tuple
-        The number of elements with which to pad the
-        array in each dimension.
+    :param array: The array to be padded
+    :type array: numpy.ndarray
 
-    Returns
-    -------
-    padded_array: numpy ndarray
-        The padded array
+    :param padding: The number of elements with which to pad the
+        array in each dimension.
+    :type padding: tuple
 
+    :returns: The padded array.
+    :type: numpy.ndarray
     """
-    padded_shape = [n + 2*padding[i] for i, n in enumerate(array.shape)]
+    padded_shape = [n + 2 * padding[i] for i, n in enumerate(array.shape)]
     padded_array = np.zeros(padded_shape)
 
-    slices = tuple([slice(padding[i], padding[i] + l)
-                    for i, l in enumerate(array.shape)])
+    slices = tuple(
+        [slice(padding[i], padding[i] + l) for i, l in enumerate(array.shape)]
+    )
     padded_array[slices] = array
 
-    padded_array_indices = list(itertools.product(*[range(n + 2*padding[i])
-                                                    for i, n
-                                                    in enumerate(array.shape)]))
-    inserted_indices = list(itertools.product(*[range(padding[i], padding[i] + l)
-                                                for i, l
-                                                in enumerate(array.shape)]))
+    padded_array_indices = list(
+        itertools.product(
+            *[range(n + 2 * padding[i]) for i, n in enumerate(array.shape)]
+        )
+    )
+    inserted_indices = list(
+        itertools.product(
+            *[range(padding[i], padding[i] + l) for i, l in enumerate(array.shape)]
+        )
+    )
     padded_array_indices.extend(inserted_indices)
 
     counter = Counter(padded_array_indices)
     keys = list(counter.keys())
-    padded_indices = [keys[i] for i, value in enumerate(counter.values())
-                      if value == 1]
-    edge_indices = tuple([tuple([np.min([np.max([axis_idx, padding[dimension]]),
-                                         padded_array.shape[dimension] - padding[dimension] - 1])
-                                 for dimension, axis_idx in enumerate(idx)]) for idx in padded_indices])
-    mirror_indices = tuple([tuple([2*edge_indices[i][j] - padded_indices[i][j]
-                                   for j in range(len(array.shape))])
-                            for i in range(len(padded_indices))])
+    padded_indices = [keys[i] for i, value in enumerate(counter.values()) if value == 1]
+    edge_indices = tuple(
+        [
+            tuple(
+                [
+                    np.min(
+                        [
+                            np.max([axis_idx, padding[dimension]]),
+                            padded_array.shape[dimension] - padding[dimension] - 1,
+                        ]
+                    )
+                    for dimension, axis_idx in enumerate(idx)
+                ]
+            )
+            for idx in padded_indices
+        ]
+    )
+    mirror_indices = tuple(
+        [
+            tuple(
+                [
+                    2 * edge_indices[i][j] - padded_indices[i][j]
+                    for j in range(len(array.shape))
+                ]
+            )
+            for i in range(len(padded_indices))
+        ]
+    )
 
     for i, idx in enumerate(padded_indices):
-        padded_array[idx] = (2.*padded_array[edge_indices[i]]
-                             - padded_array[mirror_indices[i]])
+        padded_array[idx] = (
+            2.0 * padded_array[edge_indices[i]] - padded_array[mirror_indices[i]]
+        )
 
     return padded_array
 
 
-def smooth_array(array, grid_spacing,
-                 gaussian_rms_widths, truncate=4.0,
-                 mode='inverse_mirror'):
+def smooth_array(
+    array, grid_spacing, gaussian_rms_widths, truncate=4.0, mode="inverse_mirror"
+):
     """
     Creates a smoothed array by convolving it with a gaussian filter.
     Grid resolutions and gaussian RMS widths are required for each of
     the axes of the numpy array. The smoothing is truncated at a
     user-defined number of standard deviations. The edges of the array
     can be padded in a number of different ways given by the
     'mode' parameter.
 
-    Parameters
-    ----------
-    array : numpy ndarray
-        The array to smooth
-    grid_spacing : numpy array of floats
-        The spacing of points along each axis
-    gaussian_rms_widths : numpy array of floats
-        The Gaussian RMS widths/standard deviations for the
+    :param array: The array to smooth.
+    :type array: numpy.ndarray
+    :param grid_spacing: The spacing of points along each axis.
+    :type grid_spacing: numpy.array of floats
+    :param gaussian_rms_widths: The Gaussian RMS widths/standard deviations for the
         Gaussian convolution.
-    truncate : float (default=4.)
-        The number of standard deviations at which to truncate
+    :type gaussian_rms_widths: numpy.array of floats
+    :param truncate: The number of standard deviations at which to truncate
         the smoothing.
-    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap', 'inverse_mirror'}
+    :type truncate: float
+    :param mode: {'reflect', 'constant', 'nearest', 'mirror', 'wrap', 'inverse_mirror'}
         The mode parameter determines how the array borders are handled
         either by scipy.ndimage.filters.gaussian_filter.
         Default is 'inverse_mirror', which uses
         :func:`burnman.tools.math._pad_ndarray_inverse_mirror`.
+    :type mode: str
 
-    Returns
-    -------
-    smoothed_array: numpy ndarray
-       The smoothed array
-
+    :returns: The smoothed array
+    :rtype: numpy.ndarray
     """
 
     # gaussian_filter works with standard deviations normalised to
     # the grid spacing.
-    sigma = tuple(np.array(gaussian_rms_widths)/np.array(grid_spacing))
+    sigma = tuple(np.array(gaussian_rms_widths) / np.array(grid_spacing))
 
-    if mode == 'inverse_mirror':
-        padding = tuple([int(np.ceil(truncate*s)) for s in sigma])
+    if mode == "inverse_mirror":
+        padding = tuple([int(np.ceil(truncate * s)) for s in sigma])
         padded_array = _pad_ndarray_inverse_mirror(array, padding)
-        smoothed_padded_array = gaussian_filter(padded_array,
-                                                sigma=sigma)
-        slices = tuple([slice(padding[i], padding[i] + l)
-                        for i, l in enumerate(array.shape)])
+        smoothed_padded_array = gaussian_filter(padded_array, sigma=sigma)
+        slices = tuple(
+            [slice(padding[i], padding[i] + l) for i, l in enumerate(array.shape)]
+        )
         smoothed_array = smoothed_padded_array[slices]
     else:
         smoothed_array = gaussian_filter(array, sigma=sigma, mode=mode)
 
     return smoothed_array
 
 
-def interp_smoothed_array_and_derivatives(array,
-                                          x_values, y_values,
-                                          x_stdev=0., y_stdev=0.,
-                                          truncate=4.,
-                                          mode='inverse_mirror',
-                                          indexing='xy'):
+def interp_smoothed_array_and_derivatives(
+    array,
+    x_values,
+    y_values,
+    x_stdev=0.0,
+    y_stdev=0.0,
+    truncate=4.0,
+    mode="inverse_mirror",
+    indexing="xy",
+):
     """
     Creates a smoothed array on a regular 2D grid. Smoothing
     is achieved using :func:`burnman.tools.math.smooth_array`.
-    Outputs scipy.interpolate.interp2d() interpolators
+    Outputs scipy.interpolate.RegularGridInterpolator() interpolators
     which can be used to query the array, or its derivatives in the
     x- and y- directions.
 
-    Parameters
-    ----------
-    array : 2D numpy array
-        The array to smooth. Each element array[i][j]
+    :param array: The array to smooth. Each element array[i][j]
         corresponds to the position x_values[i], y_values[j]
-    x_values : 1D numpy array
-        The gridded x values over which to create the smoothed grid
-    y_values : 1D numpy array
-        The gridded y_values over which to create the smoothed grid
-    x_stdev : float
-        The standard deviation for the Gaussian filter along the x axis
-    y_stdev : float
-        The standard deviation for the Gaussian filter along the x axis
-    truncate : float (optional)
-        The number of standard deviations at which to truncate
-        the smoothing (default = 4.).
-    mode : {'reflect', 'constant', 'nearest', 'mirror', 'wrap', 'inverse_mirror'}
+    :type array: numpy.array (2D)
+    :param x_values: The gridded x values over which to create the smoothed grid
+    :type x_values: numpy.array (1D)
+    :param y_values: The gridded y_values over which to create the smoothed grid
+    :type y_values: numpy.array (1D)
+    :param x_stdev: The standard deviation for the Gaussian filter along the x axis
+    :type x_stdev: float
+    :param y_stdev: The standard deviation for the Gaussian filter along the y axis
+    :type y_stdev: float
+    :param truncate: The number of standard deviations at which to truncate
+        the smoothing.
+    :type truncate: float
+    :param mode: {'reflect', 'constant', 'nearest', 'mirror', 'wrap', 'inverse_mirror'}
         The mode parameter determines how the array borders are handled
         either by scipy.ndimage.filters.gaussian_filter.
         Default is 'inverse_mirror', which uses
         :func:`burnman.tools.math._pad_ndarray_inverse_mirror`.
-    indexing : {'xy', 'ij'}, optional
+    :type mode: str
+    :param indexing: {'xy', 'ij'}, optional
         Cartesian ('xy', default) or matrix ('ij') indexing of output.
         See numpy.meshgrid for more details.
+    :type indexing: str
 
-    Returns
-    -------
-    interps: tuple of three interp2d functors
+    :returns: Three RegularGridInterpolator functors
         interpolation functions for the smoothed property and
         the first derivatives with respect to x and y.
-
+    :rtype: tuple
     """
 
     dx = x_values[1] - x_values[0]
     dy = y_values[1] - y_values[0]
 
-    if indexing == 'xy':
-        smoothed_array = smooth_array(array=array,
-                                      grid_spacing=np.array([dy, dx]),
-                                      gaussian_rms_widths=np.array([y_stdev,
-                                                                    x_stdev]),
-                                      truncate=truncate,
-                                      mode=mode)
-
-    elif indexing == 'ij':
-        smoothed_array = smooth_array(array=array,
-                                      grid_spacing=np.array([dx, dy]),
-                                      gaussian_rms_widths=np.array([x_stdev,
-                                                                    y_stdev]),
-                                      truncate=truncate,
-                                      mode=mode).T
+    if indexing == "xy":
+        smoothed_array = smooth_array(
+            array=array,
+            grid_spacing=np.array([dy, dx]),
+            gaussian_rms_widths=np.array([y_stdev, x_stdev]),
+            truncate=truncate,
+            mode=mode,
+        ).T
+
+    elif indexing == "ij":
+        smoothed_array = smooth_array(
+            array=array,
+            grid_spacing=np.array([dx, dy]),
+            gaussian_rms_widths=np.array([x_stdev, y_stdev]),
+            truncate=truncate,
+            mode=mode,
+        )
 
     else:
-        raise Exception('Indexing scheme not recognised. Should be ij or xy.')
+        raise Exception("Indexing scheme not recognised. Should be ij or xy.")
 
-    dSAdydy, dSAdxdx = np.gradient(smoothed_array)
+    dSAdxdx, dSAdydy = np.gradient(smoothed_array)
 
-    interps = (interp2d(x_values, y_values, smoothed_array, kind='linear'),
-               interp2d(x_values, y_values, dSAdxdx/dx, kind='linear'),
-               interp2d(x_values, y_values, dSAdydy/dy, kind='linear'))
+    interps = (
+        RegularGridInterpolator((x_values, y_values), smoothed_array, method="linear"),
+        RegularGridInterpolator((x_values, y_values), dSAdxdx / dx, method="linear"),
+        RegularGridInterpolator((x_values, y_values), dSAdydy / dy, method="linear"),
+    )
 
     return interps
 
 
 def compare_l2(depth, calc, obs):
     """
     Computes the L2 norm for N profiles at a time (assumed to be linear between points).
@@ -396,15 +424,14 @@
     :type funca: list of arrays of float
     :param funca: array calculated values
     :type funcb: list of arrays of float
     :param funcb: array of values (observed or calculated) to compare to
 
     :returns: RMS error
     :rtype: array of floats
-
     """
     diff = np.array(funca - funcb)
     diff = diff * diff
     rmse = np.sqrt(np.sum(diff) / x)
     nrmse = rmse / (np.max(funca) - np.min(funca))
 
     return nrmse
@@ -416,115 +443,113 @@
     :type calc: list of arrays of float
     :param calc: array calculated values
     :type obs: list of arrays of float
     :param obs: array of reference values to compare to
 
     :returns: :math:`\\chi` factor
     :rtype: array of floats
-
     """
 
     err = np.empty_like(calc)
     for i in range(len(calc)):
-        err[i] = pow((calc[i] - obs[i]) / (0.01 * np.mean(obs)), 2.)
+        err[i] = pow((calc[i] - obs[i]) / (0.01 * np.mean(obs)), 2.0)
 
     err_tot = np.sum(err) / len(err)
 
     return err_tot
 
 
 def independent_row_indices(array):
     """
     Returns the indices corresponding to an independent set of rows
     for a given array. The independent rows are determined from the pivots
     used during row reduction/Gaussian elimination.
 
-    Parameters
-    ----------
-    array : 2D numpy array of floats
-        The input array
-
-    Returns
-    -------
-    indices : 1D numpy array of integers
-        The indices corresponding to a set of independent rows
+    :param array: The input array.
+    :type array: 2D numpy.array of floats
+
+    :returns: The indices corresponding to a set of independent rows
         of the input array.
+    :rtype: 1D numpy array of integers
     """
-    m = Matrix(array.shape[0], array.shape[1],
-               lambda i, j: Rational(array[i, j]).limit_denominator(1000))
-    _, pivots, swaps = row_reduce(m, iszerofunc=lambda x: x.is_zero,
-                                  simpfunc=lambda x: Rational(x).limit_denominator(1000))
+    m = Matrix(
+        array.shape[0],
+        array.shape[1],
+        lambda i, j: Rational(array[i, j]).limit_denominator(1000),
+    )
+    _, pivots, swaps = row_reduce(
+        m,
+        iszerofunc=lambda x: x.is_zero,
+        simpfunc=lambda x: Rational(x).limit_denominator(1000),
+    )
     indices = np.array(range(len(array)))
     for swap in np.array(swaps):
         indices[swap] = indices[swap[::-1]]
-    return sorted(indices[:len(pivots)])
+    return sorted(indices[: len(pivots)])
 
 
 def array_to_rational_matrix(array):
     """
     Converts a numpy array into a sympy matrix
     filled with rationals
     """
-    return Matrix([[Rational(v).limit_denominator(1000)
-                    for v in row]
-                   for row in array])
+    return Matrix([[Rational(v).limit_denominator(1000) for v in row] for row in array])
 
 
 def generate_complete_basis(incomplete_basis, array):
     """
     Given a 2D array with independent rows and a second 2D array that spans a
     larger space, creates a complete basis for the combined array using all
     the rows of the first array, followed by any required rows of the
     second array. So, for example, if the first array is:
     [[1, 0, 0], [1, 1, 0]] and the second array is:
     [[1, 0, 0], [0, 1, 0], [0, 0, 1]], the complete basis will be:
     [[1, 0, 0], [1, 1, 0], [0, 0, 1]].
 
-    Parameters
-    ----------
-    incomplete_basis : 2D numpy array
-        An array containing the basis to be completed.
-
-    array : 2D numpy array
-        An array spanning the full space for which a basis is required.
-
-    Returns
-    -------
-    complete_basis : 2D numpy array
-        An array containing the basis vectors spanning both of the
+    :param incomplete_basis: An array containing the basis to be completed.
+    :type incomplete_basis: 2D numpy.array
+
+    :param array: An array spanning the full space for which a basis is required.
+    :type array: 2D numpy.array
+
+    :returns: An array containing the basis vectors spanning both of the
         input arrays.
+    :rtype: 2D numpy array
     """
 
     incomplete_rank = array_to_rational_matrix(incomplete_basis).rank()
     if incomplete_rank < len(incomplete_basis):
-        raise Exception('The incomplete basis is rank-deficient. '
-                        'Remove one or more endmembers.')
+        raise Exception(
+            "The incomplete basis is rank-deficient. " "Remove one or more endmembers."
+        )
 
     a = np.concatenate((incomplete_basis, array))
-    complete_basis = np.array(a[independent_row_indices(a)],
-                              dtype=float)
+    complete_basis = np.array(a[independent_row_indices(a)], dtype=float)
 
     # Store the rank of the matrix for later comparison
     len_basis = array_to_rational_matrix(complete_basis).rank()
 
     # This next step ensures that all of the original
     # rows are contained in the new basis in their original order
-    c = np.linalg.lstsq(np.array(complete_basis).astype(float).T,
-                        np.array(incomplete_basis).astype(float).T,
-                        rcond=None)[0].T
+    c = np.linalg.lstsq(
+        np.array(complete_basis).astype(float).T,
+        np.array(incomplete_basis).astype(float).T,
+        rcond=None,
+    )[0].T
 
     for row in np.eye(len(c[0])):
         old_rank = array_to_rational_matrix(c).rank()
         c2 = np.concatenate((c, [row]))
         new_rank = array_to_rational_matrix(c2).rank()
 
         if new_rank > old_rank:
             c = c2
 
     complete_basis = c.dot(complete_basis)
 
     # Check that the matrix rank has not changed
     if len_basis != array_to_rational_matrix(complete_basis).rank():
-        raise Exception('Basis length changed during conversion. '
-                        'Report this bug to developers.')
+        raise Exception(
+            "Basis length changed during conversion. " "Report this bug to developers."
+        )
 
-    return complete_basis.round(decimals=12) + 0.
+    return complete_basis.round(decimals=12) + 0.0
```

### Comparing `burnman-1.1.0/burnman/utils/misc.py` & `burnman-1.2.0/burnman/utils/misc.py`

 * *Files 9% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 
 class OrderedCounter(Counter, OrderedDict):
     """
     Counter that remembers the order elements are first encountered
     """
 
     def __repr__(self):
-        return '%s(%r)' % (self.__class__.__name__, OrderedDict(self))
+        return "%s(%r)" % (self.__class__.__name__, OrderedDict(self))
 
     def __reduce__(self):
         return self.__class__, (OrderedDict(self),)
 
 
 def copy_documentation(copy_from):
     """
@@ -32,61 +32,71 @@
     function (for example from a base class). The docstring applied to some function a() will be ::
 
         (copied from BaseClass.some_function):
         <documentation from BaseClass.some_function>
         <optionally the documentation found in a()>
 
     """
+
     def mydecorator(func):
         def wrapper(*args):
             return func(*args)
+
         old = ""
         if func.__doc__:
             old = "\n" + func.__doc__
 
         copied_from = ""
         if hasattr(copy_from, "__name__"):
             copied_from = "(copied from " + copy_from.__name__ + "):\n"
         wrapper.__doc__ = copied_from + copy_from.__doc__ + old
         wrapper.__name__ = func.__name__
         return wrapper
+
     return mydecorator
 
 
 def merge_two_dicts(x, y):
     """Given two dicts, merge them into a new dict as a shallow copy."""
     z = x.copy()
     z.update(y)
     return z
 
 
 def flatten(arr):
-    return (flatten(arr[0]) + (flatten(arr[1:]) if len(arr) > 1 else [])
-            if type(arr) is list or type(arr) is np.ndarray else [arr])
+    return (
+        flatten(arr[0]) + (flatten(arr[1:]) if len(arr) > 1 else [])
+        if type(arr) is list or type(arr) is np.ndarray
+        else [arr]
+    )
 
 
 def pretty_print_values(popt, pcov, params):
     """
     Takes a numpy array of parameters, the corresponding covariance matrix
     and a set of parameter names and prints the parameters and
     principal 1-s.d.uncertainties (np.sqrt(pcov[i][i]))
     in a nice text based format.
     """
     for i, p in enumerate(params):
         p_rnd = round_to_n(popt[i], np.sqrt(pcov[i][i]), 1)
         c_rnd = round_to_n(np.sqrt(pcov[i][i]), np.sqrt(pcov[i][i]), 1)
 
-        if p_rnd != 0.:
+        if p_rnd != 0.0:
             p_expnt = np.floor(np.log10(np.abs(p_rnd)))
         else:
-            p_expnt = 0.
+            p_expnt = 0.0
 
-        scale = np.power(10., p_expnt)
+        scale = np.power(10.0, p_expnt)
         nd = p_expnt - np.floor(np.log10(np.abs(c_rnd)))
-        print('{0:s}: ({1:{4}{5}f} +/- {2:{4}{5}f}) x {3:.0e}'.format(p, p_rnd/scale, c_rnd/scale, scale, 0, (nd)/10.))
+        print(
+            "{0:s}: ({1:{4}{5}f} +/- {2:{4}{5}f}) x {3:.0e}".format(
+                p, p_rnd / scale, c_rnd / scale, scale, 0, (nd) / 10.0
+            )
+        )
 
 
 def pretty_print_table(table, use_tabs=False):
     """
     Takes a 2d table and prints it in a nice text based format. If
     use_tabs=True then only \t is used as a separator. This is useful for
     importing the data into other apps (Excel, ...). The default is to pad
@@ -100,52 +110,58 @@
 
     def col_width(table, colidx):
         return max([len(str(row[colidx])) for row in table])
 
     # create a format string with the first column left aligned, the others right
     # example:   {:<27}{:>11}{:>6}{:>8}
     frmt = "".join(
-        [('{:<' if i == 0 else '{:>') + str(1 + col_width(table, i)) + '}' for i in range(len(table[0]))])
+        [
+            ("{:<" if i == 0 else "{:>") + str(1 + col_width(table, i)) + "}"
+            for i in range(len(table[0]))
+        ]
+    )
     for r in table:
         print(frmt.format(*r))
 
 
 def sort_table(table, col=0):
     """
     Sort the table according to the column number
     """
     return sorted(table, key=operator.itemgetter(col))
 
 
 def read_table(filename):
-    datastream = pkgutil.get_data('burnman', 'data/' + filename)
-    datalines = [line.strip()
-                 for line in datastream.decode('ascii').split('\n') if line.strip()]
+    datastream = pkgutil.get_data("burnman", "data/" + filename)
+    datalines = [
+        line.strip() for line in datastream.decode("ascii").split("\n") if line.strip()
+    ]
     table = []
 
     for line in datalines:
-        if (line[0] != '#'):
-            numbers = np.fromstring(line, sep=' ')
+        if line[0] != "#":
+            numbers = np.fromstring(line, sep=" ")
             table.append(numbers)
     return np.array(table)
 
 
 def array_from_file(filename):
     """
     Generic function to read a file containing floats and commented lines
     into a 2D numpy array.
 
     Commented lines are prefixed by the characters # or %.
     """
-    f = open(filename, 'r')
+    f = open(filename, "r")
     data = []
     datastream = f.read()
     f.close()
-    datalines = [line.strip().split()
-                 for line in datastream.split('\n') if line.strip()]
+    datalines = [
+        line.strip().split() for line in datastream.split("\n") if line.strip()
+    ]
     for line in datalines:
         if line[0] != "#" and line[0] != "%":
             data.append(map(float, line))
 
     data = np.array(zip(*data))
     return data
 
@@ -155,19 +171,20 @@
     for i in range(min_value, max_value, 1):
         tablen.append(table[i, :])
     return tablen
 
 
 def lookup_and_interpolate(table_x, table_y, x_value):
     idx = bisect.bisect_left(table_x, x_value) - 1
-    if (idx < 0):
+    if idx < 0:
         return table_y[0]
-    elif (idx < len(table_x) - 1):
-        return linear_interpol(x_value, table_x[idx], table_x[idx + 1],
-                               table_y[idx], table_y[idx + 1])
+    elif idx < len(table_x) - 1:
+        return linear_interpol(
+            x_value, table_x[idx], table_x[idx + 1], table_y[idx], table_y[idx + 1]
+        )
     else:
         return table_y[idx]
 
 
 def attribute_function(m, attributes, powers=[]):
     """
     Function which returns a function which can be used to
@@ -176,36 +193,36 @@
     as a string. The function can itself be passed to another
     function
     (such as nonlinear_fitting.confidence_prediction_bands()).
 
     Properties can either be simple attributes (e.g. K_T) or
     a product of attributes, each raised to some power.
 
-    Parameters
-    ----------
-    m : Material
-        The material instance evaluated by the output function.
-    attributes : list of strings
-        The list of material attributes / properties to
-        be evaluated in the product
-    powers : list of floats
-        The powers to which each attribute should be raised
-        during evaluation
-    Returns
-    -------
-    f : function(x)
-        Function which returns the value of product(a_i**p_i)
-        as a function of condition (x = [P, T, V])
+    :param m: The material instance evaluated by the output function.
+    :type m: :class:`burnman.Material`
+
+    :param attributes: The list of material attributes / properties to
+        be evaluated in the product.
+    :type attributes: list of str
+
+    :param powers: The powers to which each attribute should be raised
+        during evaluation.
+    :type powers: list of floats
+
+    :returns: Function which returns the value of product(a_i**p_i)
+        as a function of condition (x = [P, T, V]).
+    :rtype: function
     """
     if type(attributes) is str:
         attributes = [attributes]
     if powers == []:
-        powers = [1. for a in attributes]
+        powers = [1.0 for a in attributes]
 
     def f(x):
         P, T, V = x
         m.set_state(P, T)
-        value = 1.
+        value = 1.0
         for a, p in zip(*[attributes, powers]):
             value *= np.power(getattr(m, a), p)
         return value
+
     return f
```

### Comparing `burnman-1.1.0/burnman/utils/reductions.py` & `burnman-1.2.0/burnman/utils/reductions.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,19 +7,20 @@
 # and sympy.matrices.determinant and sympy.matrices.reductions.
 # This bit of sympy appears to be in a high state of flux,
 # so we copy the functions here for the time being.
 
 
 def _iszero(x):
     """Returns True if x is zero."""
-    return getattr(x, 'is_zero', None)
+    return getattr(x, "is_zero", None)
 
 
 def _find_reasonable_pivot(col, iszerofunc=_iszero, simpfunc=_simplify):
-    """ Find the lowest index of an item in ``col`` that is
+    """
+    Find the lowest index of an item in ``col`` that is
     suitable for a pivot.  If ``col`` consists only of
     Floats, the pivot with the largest norm is returned.
     Otherwise, the first element where ``iszerofunc`` returns
     False is used.  If ``iszerofunc`` doesn't return false,
     items are simplified and retested until a suitable
     pivot is found.
 
@@ -33,25 +34,25 @@
     finding."""
 
     newly_determined = []
     col = list(col)
     # a column that contains a mix of floats and integers
     # but at least one float is considered a numerical
     # column, and so we do partial pivoting
-    if ((all(isinstance(x, (Float, Integer)) for x in col)
-         and any(isinstance(x, Float) for x in col))):
+    if all(isinstance(x, (Float, Integer)) for x in col) and any(
+        isinstance(x, Float) for x in col
+    ):
         col_abs = [abs(x) for x in col]
         max_value = max(col_abs)
         if iszerofunc(max_value):
             # just because iszerofunc returned True, doesn't
             # mean the value is numerically zero.  Make sure
             # to replace all entries with numerical zeros
             if max_value != 0:
-                newly_determined = [(i, 0) for i, x in enumerate(col)
-                                    if x != 0]
+                newly_determined = [(i, 0) for i, x in enumerate(col) if x != 0]
             return (None, None, False, newly_determined)
         index = col_abs.index(max_value)
         return (index, col[index], False, newly_determined)
 
     # PASS 1 (iszerofunc directly)
     possible_zeros = []
     for i, x in enumerate(col):
@@ -115,133 +116,172 @@
     # be a pivot.  To maintain compatibility with existing
     # behavior, we'll assume that an illdetermined thing is
     # non-zero.  We should probably raise a warning in this case
     i = possible_zeros.index(None)
     return (i, col[i], True, newly_determined)
 
 
-def _row_reduce_list(mat, rows, cols, iszerofunc, simpfunc,
-                     normalize_last=True, normalize=True, zero_above=True):
-    """Row reduce a flat list representation of a matrix and return a tuple
+def _row_reduce_list(
+    mat,
+    rows,
+    cols,
+    iszerofunc,
+    simpfunc,
+    normalize_last=True,
+    normalize=True,
+    zero_above=True,
+):
+    """
+    Row reduce a flat list representation of a matrix and return a tuple
     (rref_matrix, pivot_cols, swaps) where ``rref_matrix`` is a flat list,
     ``pivot_cols`` are the pivot columns and ``swaps`` are any row swaps that
     were used in the process of row reduction.
-    Parameters
-    ==========
-    mat : list
-        list of matrix elements, must be ``rows`` * ``cols`` in length
-    rows, cols : integer
-        number of rows and columns in flat list representation
-    iszerofunc : determines if an entry can be used as a pivot
-    simpfunc : used to simplify elements and test if they are
-        zero if ``iszerofunc`` returns `None`
-    normalize_last : indicates where all row reduction should
+
+    :param mat: list of matrix elements, must be ``rows`` * ``cols`` in length.
+    :type mat: list
+
+    :param rows: number of rows in flat list representation.
+    :type rows: integer
+
+    :param cols: number of columns in flat list representation.
+    :type cols: integer
+
+    :param iszerofunc: determines if an entry can be used as a pivot.
+    :type iszerofunc: function
+
+    :param simpfunc: used to simplify elements and test if they are
+        zero if ``iszerofunc`` returns `None`.
+    :type simpfunc: function
+
+    :param normalize_last: indicates where all row reduction should
         happen in a fraction-free manner and then the rows are
         normalized (so that the pivots are 1), or whether
         rows should be normalized along the way (like the naive
-        row reduction algorithm)
-    normalize : whether pivot rows should be normalized so that
+        row reduction algorithm).
+    :type normalize_last: bool
+
+    :param normalize: whether pivot rows should be normalized so that
         the pivot value is 1
-    zero_above : whether entries above the pivot should be zeroed.
+    :type normalize: bool
+
+    :param zero_above: whether entries above the pivot should be zeroed.
         If ``zero_above=False``, an echelon matrix will be returned.
+    :type zero_above: bool
     """
 
     def get_col(i):
         return mat[i::cols]
 
     def row_swap(i, j):
-        mat[i*cols:(i + 1)*cols], mat[j*cols:(j + 1)*cols] = \
-            mat[j*cols:(j + 1)*cols], mat[i*cols:(i + 1)*cols]
+        mat[i * cols : (i + 1) * cols], mat[j * cols : (j + 1) * cols] = (
+            mat[j * cols : (j + 1) * cols],
+            mat[i * cols : (i + 1) * cols],
+        )
 
     def cross_cancel(a, i, b, j):
         """Does the row op row[i] = a*row[i] - b*row[j]"""
-        q = (j - i)*cols
-        for p in range(i*cols, (i + 1)*cols):
-            mat[p] = isimp(a*mat[p] - b*mat[p + q])
+        q = (j - i) * cols
+        for p in range(i * cols, (i + 1) * cols):
+            mat[p] = isimp(a * mat[p] - b * mat[p + q])
 
     def isimp(x):
         return x
+
     piv_row, piv_col = 0, 0
     pivot_cols = []
     swaps = []
 
     # use a fraction free method to zero above and below each pivot
     while piv_col < cols and piv_row < rows:
-        pivot_offset, pivot_val, assumed_nonzero, newly_determined = _find_reasonable_pivot(
-            get_col(piv_col)[piv_row:], iszerofunc, simpfunc)
+        (
+            pivot_offset,
+            pivot_val,
+            assumed_nonzero,
+            newly_determined,
+        ) = _find_reasonable_pivot(get_col(piv_col)[piv_row:], iszerofunc, simpfunc)
 
         # _find_reasonable_pivot may have simplified some things
         # in the process.  Let's not let them go to waste
-        for (offset, val) in newly_determined:
+        for offset, val in newly_determined:
             offset += piv_row
-            mat[offset*cols + piv_col] = val
+            mat[offset * cols + piv_col] = val
 
         if pivot_offset is None:
             piv_col += 1
             continue
 
         pivot_cols.append(piv_col)
         if pivot_offset != 0:
             row_swap(piv_row, pivot_offset + piv_row)
             swaps.append((piv_row, pivot_offset + piv_row))
 
         # if we aren't normalizing last, we normalize
         # before we zero the other rows
         if normalize_last is False:
             i, j = piv_row, piv_col
-            mat[i*cols + j] = S.One
-            for p in range(i*cols + j + 1, (i + 1)*cols):
+            mat[i * cols + j] = S.One
+            for p in range(i * cols + j + 1, (i + 1) * cols):
                 mat[p] = isimp(mat[p] / pivot_val)
             # after normalizing, the pivot value is 1
             pivot_val = S.One
 
         # zero above and below the pivot
         for row in range(rows):
             # don't zero our current row
             if row == piv_row:
                 continue
             # don't zero above the pivot unless we're told.
             if zero_above is False and row < piv_row:
                 continue
             # if we're already a zero, don't do anything
-            val = mat[row*cols + piv_col]
+            val = mat[row * cols + piv_col]
             if iszerofunc(val):
                 continue
 
             cross_cancel(pivot_val, row, val, piv_row)
         piv_row += 1
 
     # normalize each row
     if normalize_last is True and normalize is True:
         for piv_i, piv_j in enumerate(pivot_cols):
-            pivot_val = mat[piv_i*cols + piv_j]
-            mat[piv_i*cols + piv_j] = S.One
-            for p in range(piv_i*cols + piv_j + 1, (piv_i + 1)*cols):
+            pivot_val = mat[piv_i * cols + piv_j]
+            mat[piv_i * cols + piv_j] = S.One
+            for p in range(piv_i * cols + piv_j + 1, (piv_i + 1) * cols):
                 mat[p] = isimp(mat[p] / pivot_val)
 
     return mat, tuple(pivot_cols), tuple(swaps)
 
 
 # This functions is a candidate for caching
 # if it gets implemented for matrices.
-def row_reduce(M, iszerofunc=lambda x: x.is_zero,
-               simpfunc=lambda x: Rational(x).limit_denominator(1000),
-               normalize_last=True,
-               normalize=True, zero_above=True):
-
-    mat, pivot_cols, swaps = _row_reduce_list(list(M), M.rows, M.cols,
-                                              iszerofunc, simpfunc,
-                                              normalize_last=normalize_last,
-                                              normalize=normalize,
-                                              zero_above=zero_above)
+def row_reduce(
+    M,
+    iszerofunc=lambda x: x.is_zero,
+    simpfunc=lambda x: Rational(x).limit_denominator(1000),
+    normalize_last=True,
+    normalize=True,
+    zero_above=True,
+):
+    mat, pivot_cols, swaps = _row_reduce_list(
+        list(M),
+        M.rows,
+        M.cols,
+        iszerofunc,
+        simpfunc,
+        normalize_last=normalize_last,
+        normalize=normalize,
+        zero_above=zero_above,
+    )
 
     return M._new(M.rows, M.cols, mat), pivot_cols, swaps
 
 
-def independent_row_indices(m, iszerofunc=lambda x: x.is_zero,
-                            simpfunc=lambda x: Rational(x).limit_denominator(1000)):
-
+def independent_row_indices(
+    m,
+    iszerofunc=lambda x: x.is_zero,
+    simpfunc=lambda x: Rational(x).limit_denominator(1000),
+):
     _, pivots, swaps = row_reduce(m, iszerofunc, simpfunc)
     indices = np.array(range(len(m)))
     for swap in np.array(swaps):
         indices[swap] = indices[swap[::-1]]
-    return indices[:len(pivots)]
+    return indices[: len(pivots)]
```

