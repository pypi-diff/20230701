# Comparing `tmp/cirq_superstaq-0.4.0-py3-none-any.whl.zip` & `tmp/cirq_superstaq-0.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 52535 bytes, number of entries: 23
--rw-r--r--  2.0 unx     2495 b- defN 23-Jun-27 19:52 cirq_superstaq/__init__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Jun-27 19:52 cirq_superstaq/_version.py
--rw-r--r--  2.0 unx      288 b- defN 23-Jun-27 19:52 cirq_superstaq/_version_test.py
--rw-r--r--  2.0 unx    11725 b- defN 23-Jun-27 19:52 cirq_superstaq/compiler_output.py
--rw-r--r--  2.0 unx    13819 b- defN 23-Jun-27 19:52 cirq_superstaq/compiler_output_test.py
--rw-r--r--  2.0 unx     9741 b- defN 23-Jun-27 19:52 cirq_superstaq/daily_integration_test.py
--rw-r--r--  2.0 unx     6815 b- defN 23-Jun-27 19:52 cirq_superstaq/job.py
--rw-r--r--  2.0 unx     6680 b- defN 23-Jun-27 19:52 cirq_superstaq/job_test.py
--rw-r--r--  2.0 unx       68 b- defN 23-Jun-27 19:52 cirq_superstaq/py.typed
--rw-r--r--  2.0 unx     3087 b- defN 23-Jun-27 19:52 cirq_superstaq/sampler.py
--rw-r--r--  2.0 unx     1398 b- defN 23-Jun-27 19:52 cirq_superstaq/serialization.py
--rw-r--r--  2.0 unx     1580 b- defN 23-Jun-27 19:52 cirq_superstaq/serialization_test.py
--rw-r--r--  2.0 unx    28103 b- defN 23-Jun-27 19:52 cirq_superstaq/service.py
--rw-r--r--  2.0 unx    23104 b- defN 23-Jun-27 19:52 cirq_superstaq/service_test.py
--rw-r--r--  2.0 unx     1297 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/__init__.py
--rw-r--r--  2.0 unx    31937 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qubit_gates.py
--rw-r--r--  2.0 unx    38554 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qubit_gates_test.py
--rw-r--r--  2.0 unx    19196 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qudit_gates.py
--rw-r--r--  2.0 unx    16965 b- defN 23-Jun-27 19:52 cirq_superstaq/ops/qudit_gates_test.py
--rw-r--r--  2.0 unx     2329 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       15 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1995 b- defN 23-Jun-27 19:53 cirq_superstaq-0.4.0.dist-info/RECORD
-23 files, 221305 bytes uncompressed, 49287 bytes compressed:  77.7%
+Zip file size: 53287 bytes, number of entries: 23
+-rw-r--r--  2.0 unx     2495 b- defN 23-Jun-30 22:00 cirq_superstaq/__init__.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-30 22:00 cirq_superstaq/_version.py
+-rw-r--r--  2.0 unx      312 b- defN 23-Jun-30 22:00 cirq_superstaq/_version_test.py
+-rw-r--r--  2.0 unx    12248 b- defN 23-Jun-30 22:00 cirq_superstaq/compiler_output.py
+-rw-r--r--  2.0 unx    13843 b- defN 23-Jun-30 22:00 cirq_superstaq/compiler_output_test.py
+-rw-r--r--  2.0 unx     9766 b- defN 23-Jun-30 22:00 cirq_superstaq/daily_integration_test.py
+-rw-r--r--  2.0 unx     6815 b- defN 23-Jun-30 22:00 cirq_superstaq/job.py
+-rw-r--r--  2.0 unx     6704 b- defN 23-Jun-30 22:00 cirq_superstaq/job_test.py
+-rw-r--r--  2.0 unx       68 b- defN 23-Jun-30 22:00 cirq_superstaq/py.typed
+-rw-r--r--  2.0 unx     3067 b- defN 23-Jun-30 22:00 cirq_superstaq/sampler.py
+-rw-r--r--  2.0 unx     1430 b- defN 23-Jun-30 22:00 cirq_superstaq/serialization.py
+-rw-r--r--  2.0 unx     1604 b- defN 23-Jun-30 22:00 cirq_superstaq/serialization_test.py
+-rw-r--r--  2.0 unx    28607 b- defN 23-Jun-30 22:00 cirq_superstaq/service.py
+-rw-r--r--  2.0 unx    23128 b- defN 23-Jun-30 22:00 cirq_superstaq/service_test.py
+-rw-r--r--  2.0 unx     1297 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/__init__.py
+-rw-r--r--  2.0 unx    33936 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qubit_gates.py
+-rw-r--r--  2.0 unx    38578 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qubit_gates_test.py
+-rw-r--r--  2.0 unx    19243 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qudit_gates.py
+-rw-r--r--  2.0 unx    16989 b- defN 23-Jun-30 22:00 cirq_superstaq/ops/qudit_gates_test.py
+-rw-r--r--  2.0 unx     2304 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1995 b- defN 23-Jun-30 22:01 cirq_superstaq-0.4.1.dist-info/RECORD
+23 files, 224558 bytes uncompressed, 50039 bytes compressed:  77.7%
```

## zipnote {}

```diff
@@ -51,20 +51,20 @@
 
 Filename: cirq_superstaq/ops/qudit_gates.py
 Comment: 
 
 Filename: cirq_superstaq/ops/qudit_gates_test.py
 Comment: 
 
-Filename: cirq_superstaq-0.4.0.dist-info/METADATA
+Filename: cirq_superstaq-0.4.1.dist-info/METADATA
 Comment: 
 
-Filename: cirq_superstaq-0.4.0.dist-info/WHEEL
+Filename: cirq_superstaq-0.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: cirq_superstaq-0.4.0.dist-info/top_level.txt
+Filename: cirq_superstaq-0.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: cirq_superstaq-0.4.0.dist-info/RECORD
+Filename: cirq_superstaq-0.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cirq_superstaq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.4.0"
+__version__ = "0.4.1"
```

## cirq_superstaq/_version_test.py

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 import packaging.version
 
 import cirq_superstaq as css
 
 
 def test_version() -> None:
     assert (
```

## cirq_superstaq/compiler_output.py

```diff
@@ -13,17 +13,29 @@
 try:
     import qtrl.sequence_utils.readout
 except ModuleNotFoundError:
     pass
 
 
 def active_qubit_indices(circuit: cirq.AbstractCircuit) -> List[int]:
-    """Returns the indices of the non-idle qubits in a quantum circuit, where "index" refers to the
-    argument of a LineQubit (so e.g. cirq.LineQubit(5) has index 5 regardless of the total number
-    of qubits in the circuit)."""
+    """Returns the indices of the non-idle qubits in a quantum circuit.
+
+    Note:
+        The "index" refers to the argument of a LineQubit (so e.g. `cirq.LineQubit(5)`
+        has index 5 regardless of the total number of qubits in the circuit.
+
+    Args:
+        circuit: The input quantum circuit.
+
+    Returns:
+        A list of active qubit indicies.
+
+    Raises:
+        ValueError: If qubit indices are requested for non-line qubits.
+    """
 
     all_qubits: Set[cirq.Qid] = set()
     for op in circuit.all_operations():
         if not isinstance(op.gate, css.Barrier):
             all_qubits.update(op.qubits)
 
     qubit_indices: List[int] = []
@@ -32,17 +44,29 @@
             raise ValueError("Qubit indices can only be determined for line qubits")
         qubit_indices.append(int(q))
 
     return qubit_indices
 
 
 def measured_qubit_indices(circuit: cirq.AbstractCircuit) -> List[int]:
-    """Returns the indices of the measured qubits in a quantum circuit, where "index" refers to the
-    argument of a LineQubit (so e.g. cirq.LineQubit(5) has index 5 regardless of the total number
-    of qubits in the circuit)."""
+    """Returns the indices of the measured qubits in a quantum circuit.
+
+    Note:
+        The "index" refers to the argument of a `cirq.LineQubit` (so e.g. `cirq.LineQubit(5)`
+        has index 5 regardless of the total number of qubits in the circuit).
+
+    Args:
+        circuit: The input quantum circuit.
+
+    Returns:
+        A list of the measurement qubit indicies.
+
+    Raises:
+        ValueError: If qubit indices are requested for non-line qubits.
+    """
 
     unrolled_circuit = cirq.unroll_circuit_op(circuit, deep=True, tags_to_check=None)
 
     measured_qubits: Set[cirq.Qid] = set()
     for _, op in unrolled_circuit.findall_operations(cirq.is_measurement):
         measured_qubits.update(op.qubits)
 
@@ -67,22 +91,22 @@
             List[List[Dict[cirq.Qid, cirq.Qid]]],
         ],
         pulse_sequences: Optional[Any] = None,
         seq: Optional[qtrl.sequencer.Sequence] = None,
         jaqal_programs: Optional[Union[List[str], str]] = None,
         pulse_lists: Optional[Union[List[List[List[Any]]], List[List[List[List[Any]]]]]] = None,
     ) -> None:
-        """Initializes class attributes.
+        """Initializes the `CompilerOutput` attributes.
 
         Args:
             circuits: A list (of at most 2 dimensions) containing `cirq.Circuit` objects.
             final_logical_to_physicals: Post-compilation mapping of logical qubits to physical
                 qubits.
-            pulse_sequences: Qiskit pulse schedules for the compiled circuit(s).
-            seq: Qtrl pulse sequence, if qtrl is available locally.
+            pulse_sequences: The qiskit pulse schedules for the compiled circuit(s).
+            seq: A `qtrl` pulse sequence, if `qtrl` is available locally.
             jaqal_programs: The Jaqal program (resp. programs) as a string (resp. list of
                 strings).
             pulse_lists: Either 3 or 4 dimensional lists of pulse cycles.
         """
         if isinstance(circuits, cirq.Circuit):
             self.circuit = circuits
             self.final_logical_to_physical = final_logical_to_physicals
@@ -95,18 +119,21 @@
             self.pulse_lists = pulse_lists
             self.pulse_sequences = pulse_sequences
             self.jaqal_programs = jaqal_programs
 
         self.seq = seq
 
     def has_multiple_circuits(self) -> bool:
-        """Returns True if this object represents multiple circuits.
+        """Checks if an object has .circuits and .pulse_lists attributes.
+
+        Otherwise, the object represents a single circuit, and has .circuit
+        and .pulse_list attributes.
 
-        If so, this object has .circuits and .pulse_lists attributes. Otherwise, this object
-        represents a single circuit, and has .circuit and .pulse_list attributes.
+        Returns:
+            `True` if this object represents multiple circuits; `False` otherwise.
         """
         return hasattr(self, "circuits")
 
     def __repr__(self) -> str:
         if not self.has_multiple_circuits():
             return (
                 f"CompilerOutput({self.circuit!r}, {self.final_logical_to_physical!r}, "
@@ -120,21 +147,23 @@
         )
 
 
 def read_json(json_dict: Dict[str, Any], circuits_is_list: bool) -> CompilerOutput:
     """Reads out returned JSON from Superstaq API's IBMQ compilation endpoint.
 
     Args:
-        json_dict: a JSON dictionary matching the format returned by /ibmq_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
+        json_dict: A JSON dictionary matching the format returned by /ibmq_compile endpoint
+        circuits_is_list: A bool flag that controls whether the returned object has a .circuits
+            attribute (if `True`) or a .circuit attribute (`False`).
+
     Returns:
-        a CompilerOutput object with the compiled circuit(s). If qiskit is available locally,
+        A `CompilerOutput` object with the compiled circuit(s). If qiskit is available locally,
         the returned object also stores the pulse sequences in the .pulse_sequence(s) attribute.
     """
+
     compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
     final_logical_to_physicals: List[Dict[cirq.Qid, cirq.Qid]] = list(
         map(dict, cirq.read_json(json_text=json_dict["final_logical_to_physicals"]))
     )
     pulses = None
 
     if "pulses" in json_dict:
@@ -157,27 +186,28 @@
     if circuits_is_list:
         return CompilerOutput(compiled_circuits, final_logical_to_physicals, pulse_sequences=pulses)
     return CompilerOutput(
         compiled_circuits[0], final_logical_to_physicals[0], pulse_sequences=pulses and pulses[0]
     )
 
 
-def read_json_aqt(  # pylint: disable=missing-param-doc
+def read_json_aqt(
     json_dict: Dict[str, Any], circuits_is_list: bool, num_eca_circuits: Optional[int] = None
 ) -> CompilerOutput:
     """Reads out returned JSON from Superstaq API's AQT compilation endpoint.
 
     Args:
-        json_dict: JSON dictionary matching the format returned by aqt_compile endpoint.
-        circuits_is_list: Bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False).
+        json_dict: A JSON dictionary matching the format returned by aqt_compile endpoint.
+        circuits_is_list: A bool flag that controls whether the returned object has a .circuits
+            attribute (if `True`) or a .circuit attribute (`False`).
         num_eca_circuits: Number of logically equivalent random circuits to generate for each
             input circuit.
+
     Returns:
-        A CompilerOutput object with the compiled circuit(s). If qtrl is available locally,
+        A `CompilerOutput` object with the compiled circuit(s). If `qtrl` is available locally,
         the returned object also stores the pulse sequence in the .seq attribute and the
         list(s) of cycles in the .pulse_list(s) attribute.
     """
 
     compiled_circuits: Union[List[cirq.Circuit], List[List[cirq.Circuit]]]
     compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
 
@@ -252,20 +282,21 @@
     )
 
 
 def read_json_qscout(json_dict: Dict[str, Any], circuits_is_list: bool) -> CompilerOutput:
     """Reads out returned JSON from Superstaq API's QSCOUT compilation endpoint.
 
     Args:
-        json_dict: a JSON dictionary matching the format returned by /qscout_compile endpoint
-        circuits_is_list: bool flag that controls whether the returned object has a .circuits
-            attribute (if True) or a .circuit attribute (False)
+        json_dict: A JSON dictionary matching the format returned by /qscout_compile endpoint.
+        circuits_is_list: A bool flag that controls whether the returned object has a .circuits
+            attribute (if `True`) or a .circuit attribute (`False`).
+
     Returns:
-        a CompilerOutput object with the compiled circuit(s) and a list jaqal programs
-        represented as strings
+        A `CompilerOutput` object with the compiled circuit(s) and a list of jaqal programs
+        represented as strings.
     """
 
     compiled_circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
     final_logical_to_physicals: List[Dict[cirq.Qid, cirq.Qid]] = list(
         map(dict, cirq.read_json(json_text=json_dict["final_logical_to_physicals"]))
     )
```

## cirq_superstaq/compiler_output_test.py

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 import importlib
 import pickle
 import textwrap
 from typing import Dict
 from unittest import mock
 
 import cirq
```

## cirq_superstaq/daily_integration_test.py

```diff
@@ -1,9 +1,10 @@
+# pylint: disable=missing-function-docstring,missing-class-docstring
 """Integration checks that run daily (via Github action) between client and prod server."""
-# pylint: disable=missing-function-docstring
+
 
 import os
 
 import cirq
 import pytest
 from general_superstaq import ResourceEstimate, SuperstaqException
```

## cirq_superstaq/job_test.py

```diff
@@ -7,15 +7,15 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 from __future__ import annotations
 
 from typing import Any, Dict
 from unittest import mock
 
 import cirq
 import general_superstaq as gss
```

## cirq_superstaq/sampler.py

```diff
@@ -46,40 +46,39 @@
     """
 
     def __init__(
         self,
         service: css.service.Service,
         target: str,
     ) -> None:
-        """Constructs the sampler. Uers should get a sampler from the `sampler` method on
-        `css.Service`.
+        """Constructs the sampler, accessed from the `sampler` method on `css.Service`.
 
         Args:
             service: The service used to create this sample.
-            target: Backend on which to run the job.
-
-        Returns:
-            None.
+            target: The backend on which to run the job.
         """
         self._service = service
         self._target = target
 
     def run_sweep(
         self,
         program: cirq.AbstractCircuit,
         params: cirq.Sweepable,
         repetitions: int = 1,
     ) -> List[cirq.ResultDict]:
-        """Runs a sweep for the given Circuit. Note that this creates jobs for each of the sweeps in
-        the given sweepable, and then blocks until all of jobs are complete.
+        """Runs a sweep for the given circuit.
 
-        Ags:
+        Note:
+            This creates jobs for each of the sweeps in the given sweepable, and then
+            blocks until all of jobs are complete.
+
+        Args:
             program: The circuit to sample from.
             params: The parameters to run with program.
-            repetitions: The number of times to sample.
+            repetitions: The number of times to sample. Defaults to 1.
 
         Returns:
             A list of Cirq results, one for each parameter resolver.
         """
         resolvers = [resolver for resolver in cirq.to_resolvers(params)]
         jobs = [
             self._service.create_job(
```

## cirq_superstaq/serialization.py

```diff
@@ -10,41 +10,41 @@
     css.ops.qubit_gates.custom_resolver,
 ]
 
 
 def serialize_circuits(
     circuits: Union[cirq.AbstractCircuit, Sequence[cirq.AbstractCircuit]]
 ) -> str:
-    """Serialize Circuit(s) into a json string
+    """Serialize circuit(s) into a json string.
 
     Args:
-        circuits: a Circuit or list of Circuits to be serialized
+        circuits: A `cirq.Circuit` or list of `cirq.Circuits` to be serialized.
 
     Returns:
-        str representing the serialized circuit(s)
+        A string representing the serialized circuit(s).
     """
     dt = json.loads(cirq.to_json(circuits))
     if isinstance(dt, list):
         for circuit_dt in dt:
             if "device" not in circuit_dt:
                 circuit_dt["device"] = {"cirq_type": "_UnconstrainedDevice"}
     else:
         if "device" not in dt:
             dt["device"] = {"cirq_type": "_UnconstrainedDevice"}
 
     return json.dumps(dt)
 
 
 def deserialize_circuits(serialized_circuits: str) -> List[cirq.Circuit]:
-    """Deserialize serialized Circuit(s)
+    """Deserialize serialized circuit(s).
 
     Args:
-        serialized_circuits: json str generated via serialization.serialize_circuit()
+        serialized_circuits: A json string generated via `serialization.serialize_circuit()`.
 
     Returns:
-        the Circuit or list of Circuits that was serialized
+        The circuit or list of circuits that was serialized.
     """
     resolvers = [*SUPERSTAQ_RESOLVERS, *cirq.DEFAULT_RESOLVERS]
     circuits = cirq.read_json(json_text=serialized_circuits, resolvers=resolvers)
     if isinstance(circuits, cirq.Circuit):
         return [circuits]
     return circuits
```

## cirq_superstaq/serialization_test.py

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 from unittest import mock
 
 import cirq
 
 import cirq_superstaq as css
```

## cirq_superstaq/service.py

```diff
@@ -21,52 +21,53 @@
 import numpy.typing as npt
 from general_superstaq import ResourceEstimate, superstaq_client, user_config
 
 import cirq_superstaq as css
 
 
 def _to_matrix_gate(matrix: npt.ArrayLike) -> cirq.MatrixGate:
-    """Convert a unitary matrix into a cirq.MatrixGate acting either on qubits or on qutrits.
+    """Convert a unitary matrix into a `cirq.MatrixGate` acting either on qubits or on qutrits.
 
     Args:
         matrix: The (unitary) matrix to be converted.
 
     Returns:
-        A cirq.MatrixGate with the given unitary.
+        A `cirq.MatrixGate` with the given unitary.
 
     Raises:
-        ValueError: If `matrix` could not be interpreted as a unitary gate acting on either qubits
-            or qutrits.
+        ValueError: If `matrix` could not be interpreted as a unitary gate acting on either
+            qubits or qutrits.
     """
 
     matrix = np.asarray(matrix, dtype=complex)
 
     for dimension in (2, 3):
         num_qids = int(round(np.log(matrix.size) / np.log(dimension**2)))
         if matrix.shape == (dimension**num_qids, dimension**num_qids):
             qid_shape = (dimension,) * num_qids
             return cirq.MatrixGate(matrix, qid_shape=qid_shape)
 
     raise ValueError(
-        "Could not determine qid_shape from array shape, consider using a cirq.MatrixGate instead."
+        "Could not determine qid_shape from array shape, consider using a `cirq.MatrixGate` "
+        "instead."
     )
 
 
 def counts_to_results(
     counter: Dict[str, int], circuit: cirq.AbstractCircuit, param_resolver: cirq.ParamResolver
 ) -> cirq.ResultDict:
-    """Converts a collections.Counter to a cirq.ResultDict.
+    """Converts a `collections.Counter` to a `cirq.ResultDict`.
 
     Args:
-            counter: The collections.Counter of counts for the run.
-            circuit: The circuit to run.
-            param_resolver: A `cirq.ParamResolver` to resolve parameters in `circuit`.
+        counter: The `collections.Counter` of counts for the run.
+        circuit: The circuit to run.
+        param_resolver: A `cirq.ParamResolver` to resolve parameters in `circuit`.
 
-        Returns:
-            A `cirq.ResultDict` for the given circuit and counter.
+    Returns:
+        A `cirq.ResultDict` for the given circuit and counter.
 
     """
     measurement_key_names = list(circuit.all_measurement_key_names())
     measurement_key_names.sort()
     # Combines all the measurement key names into a string: {'0', '1'} -> "01"
     combine_key_names = "".join(measurement_key_names)
 
@@ -196,15 +197,15 @@
         repetitions: int,
         target: Optional[str] = None,
         param_resolver: cirq.ParamResolverOrSimilarType = cirq.ParamResolver({}),
         method: Optional[str] = None,
         **kwargs: Any,
     ) -> Dict[str, int]:
         """Runs the given circuit on the Superstaq API and returns the result
-        of the ran circuit as a collections.Counter
+        of the ran circuit as a `collections.Counter`.
 
         Args:
             circuit: The circuit to run.
             repetitions: The number of times to run the circuit.
             target: Where to run the job.
             param_resolver: A `cirq.ParamResolver` to resolve parameters in  `circuit`.
             method: Optional execution method.
@@ -225,21 +226,21 @@
         repetitions: int,
         target: Optional[str] = None,
         param_resolver: cirq.ParamResolver = cirq.ParamResolver({}),
         method: Optional[str] = None,
         **kwargs: Any,
     ) -> cirq.ResultDict:
         """Run the given circuit on the Superstaq API and returns the result
-        of the ran circut as a cirq.ResultDict.
+        of the ran circut as a `cirq.ResultDict`.
 
         Args:
             circuit: The circuit to run.
             repetitions: The number of times to run the circuit.
             target: Where to run the job.
-            param_resolver: A `cirq.ParamResolver` to resolve parameters in  `circuit`.
+            param_resolver: A `cirq.ParamResolver` to resolve parameters in `circuit`.
             method: Execution method.
             kwargs: Other optimization and execution parameters.
 
         Returns:
             A `cirq.ResultDict` for running the circuit.
         """
         counts = self.get_counts(circuit, repetitions, target, param_resolver, method, **kwargs)
@@ -324,15 +325,15 @@
     def get_balance(self, pretty_output: bool = True) -> Union[str, float]:
         """Get the querying user's account balance in USD.
 
         Args:
             pretty_output: Whether to return a pretty string or a float of the balance.
 
         Returns:
-            If pretty_output is True, returns the balance as a nicely formatted string ($-prefix,
+            If pretty_output is `True`, returns the balance as a nicely formatted string ($-prefix,
                 commas on LHS every three digits, and two digits after period). Otherwise, simply
                 returns a float of the balance.
         """
         balance = self._client.get_balance()["balance"]
         if pretty_output:
             return f"${balance:,.2f}"
         return balance
@@ -343,18 +344,19 @@
 
     def resource_estimate(
         self, circuits: Union[cirq.Circuit, Sequence[cirq.Circuit]], target: Optional[str] = None
     ) -> Union[ResourceEstimate, List[ResourceEstimate]]:
         """Generates resource estimates for circuit(s).
 
         Args:
-            circuits: Cirq Circuit(s).
-            target: String of target representing target device
+            circuits:  The cirq circuit(s) to generate resource estimate.
+            target: String of target representing target device.
+
         Returns:
-            ResourceEstimate(s) containing resource costs (after compilation)
+            `ResourceEstimate`(s) containing resource costs (after compilation).
         """
         _validate_cirq_circuits(circuits)
         circuit_is_list = not isinstance(circuits, cirq.Circuit)
         serialized_circuit = css.serialization.serialize_circuits(circuits)
 
         target = self._resolve_target(target)
 
@@ -541,15 +543,15 @@
                 https://doi.org/10.1109/TQE.2021.3096480.
             [2] B. Morrison, et al., *Just Another Quantum Assembly Language (Jaqal)*, 2020 IEEE
                 International Conference on Quantum Computing and Engineering (QCE), 402-408 (2020).
                 https://arxiv.org/abs/2008.08042.
 
         Args:
             circuits: The circuit(s) to compile.
-            target: String of target representing target device
+            target: String of target representing target device.
             mirror_swaps: Whether to use mirror swapping to reduce two-qubit gate overhead.
             base_entangling_gate: The base entangling gate to use (either "xx" or "zz").
             kwargs: Other desired qscout_compile options.
 
         Returns:
             Object whose .circuit(s) attribute contains optimized `cirq.Circuit`(s), and
             `.jaqal_program(s)` attribute contains the corresponding Jaqal program(s).
@@ -592,15 +594,15 @@
         **kwargs: Any,
     ) -> css.compiler_output.CompilerOutput:
         """Compiles and optimizes the given circuit(s) to the target CQ device.
 
         Args:
             circuits: The circuit(s) to compile.
             target: String of target CQ device.
-            kwargs: Other desired cq_compile options.
+            kwargs: Other desired `cq_compile` options.
 
         Returns:
             Object whose .circuit(s) attribute contains the compiled `cirq.Circuit`(s).
 
         Raises:
             ValueError: If `target` is not a valid IBMQ target.
         """
@@ -671,18 +673,34 @@
         json_dict = self._client.compile(request_json)
 
         return css.compiler_output.read_json(json_dict, circuits_is_list)
 
     def supercheq(
         self, files: List[List[int]], num_qubits: int, depth: int
     ) -> Tuple[List[cirq.Circuit], npt.NDArray[np.float_]]:
-        """Returns the randomly generated circuits and the fidelity matrix for inputted files."""
+        """Returns the randomly generated circuits and the fidelity matrix for inputted files.
+
+        Args:
+            files: Input files from which to generate random circuits and fidelity matrix.
+            num_qubits: Number of qubits for the circuits.
+            depth: The circuit depth for Supercheq.
+
+        Returns:
+            A tuple containing the circuits and fidelities.
+        """
 
         json_dict = self._client.supercheq(files, num_qubits, depth, "cirq_circuits")
         circuits = css.serialization.deserialize_circuits(json_dict["cirq_circuits"])
         fidelities = gss.serialization.deserialize(json_dict["fidelities"])
         return circuits, fidelities
 
     def target_info(self, target: str) -> Dict[str, Any]:
-        """Returns information about device specified by `target`."""
+        """Returns information about device specified by `target`.
+
+        Args:
+            target: A string corresponding to a device.
+
+        Returns:
+            The corresponding device information.
+        """
         target = self._resolve_target(target)
         return self._client.target_info(target)["target_info"]
```

## cirq_superstaq/service_test.py

```diff
@@ -6,15 +6,15 @@
 #     https://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 
 import collections
 import json
 import os
 import textwrap
 from unittest import mock
```

## cirq_superstaq/ops/qubit_gates.py

```diff
@@ -39,16 +39,18 @@
         \end{bmatrix}
 
     where '.' means '0'.
     For :math:`\theta = 0`, the ZZ-SWAP gate is just an ordinary SWAP.
     """
 
     def __init__(self, theta: cirq.TParamVal) -> None:
-        """Args:
-        theta: ZZ-interaction angle in radians
+        """Initializes a ZZ-SWAP gate.
+
+        Args:
+            theta: The ZZ-interaction angle in radians.
         """
         self.theta = theta
 
     def _num_qubits_(self) -> int:
         return 2
 
     def _unitary_(self) -> Optional[npt.NDArray[np.complex_]]:
@@ -223,24 +225,29 @@
 @cirq.value_equality(approximate=True)
 class AceCR(cirq.Gate):
     """Active Cancellation Echoed Cross Resonance (AceCR) gate, parametrized (e.g., supporting
     polarity switches) and supporting sandwiches.
 
     The typical AceCR in literature is a positive half-CR, then X on "Z side", then negative
     half-CR ("Z side" and "X side" refer to the two sides of the underlying ZX interactions).
-
-    Args:
-        rads: Angle of rotation for CR gate (i.e., twice the angle for each echoed half-CR).
-        sandwich_rx_rads: Angle of rotation for an rx gate applied to the "X side" simultaneously
-            with the X gate on the "Z side".
     """
 
     def __init__(
         self, rads: Union[str, cirq.TParamVal] = np.pi / 2, sandwich_rx_rads: cirq.TParamVal = 0
     ) -> None:
+        """Initializes an AceCR gate.
+
+        Args:
+            rads: Angle of rotation for CR gate (i.e., twice the angle for each echoed half-CR).
+            sandwich_rx_rads: Angle of rotation for an rx gate applied to the "X side"
+                simultaneously with the X gate on the "Z side".
+
+        Raises:
+            ValueError: If the polarity of `rads` is a string other than '+-' or '-+'.
+        """
         # Polarity should be "+-" or "-+", specifying if positive or negative half-CR is first.
         if rads == "+-":
             rads = np.pi / 2
         elif rads == "-+":
             rads = -np.pi / 2
         elif isinstance(rads, str):
             raise ValueError("Polarity must be either '+-' or '-+'")
@@ -356,15 +363,16 @@
 AceCRMinusPlus = AceCR("-+")
 
 AceCRPlusMinus = AceCR("+-")
 
 
 @cirq.value_equality
 class Barrier(cirq.ops.IdentityGate, cirq.InterchangeableQubitsGate):
-    """Barrier: temporal boundary restricting circuit compilation and pulse scheduling.
+    """A temporal boundary restricting circuit compilation and pulse scheduling.
+
     Otherwise equivalent to the identity gate.
     """
 
     def _decompose_(self, qubits: Tuple[cirq.Qid, ...]) -> cirq.type_workarounds.NotImplementedType:
         return NotImplemented
 
     def _trace_distance_bound_(self) -> float:
@@ -385,26 +393,40 @@
 
     def _circuit_diagram_info_(self, args: cirq.CircuitDiagramInfoArgs) -> Tuple[str, ...]:
         if args.use_unicode_characters:
             return ("│",) * self.num_qubits()
         return ("|",) * self.num_qubits()
 
 
-def barrier(*qubits: cirq.Qid) -> cirq.Operation:  # pylint: disable=missing-function-docstring
+def barrier(*qubits: cirq.Qid) -> cirq.Operation:
+    """Equivalent to https://qiskit.org/documentation/stubs/qiskit.circuit.library.Barrier.html.
+
+    Args:
+        qubits: The qubits that the barrier will cover.
+
+    Returns:
+        A barrier `cirq.Operation` on the provided qubits.
+    """
     qid_shape = tuple(q.dimension for q in qubits)
     return css.Barrier(qid_shape=qid_shape).on(*qubits)
 
 
 @cirq.value_equality(approximate=True)
 class ParallelGates(cirq.Gate, cirq.InterchangeableQubitsGate):
-    """A single Gate combining a collection of concurrent Gate(s) acting on different qubits."""
+    """A single gate combining a collection of concurrent gate(s) acting on different qubits."""
 
     def __init__(self, *component_gates: cirq.Gate) -> None:
-        """Args:
-        component_gates: Gate(s) to be collected into single gate
+        """Initializes the `ParallelGates` class.
+
+        Args:
+            component_gates: Gate(s) to be collected into a single gate.
+
+        Raises:
+            ValueError: If `component_gates` are not `cirq.Gate` instances.
+            ValueError: If `component_gates` contains measurements.
         """
 
         self.component_gates: Tuple[cirq.Gate, ...] = ()
 
         # unroll any ParallelGate(s) instances in component_gates
         for gate in component_gates:
             if not isinstance(gate, cirq.Gate):
@@ -414,25 +436,34 @@
             elif isinstance(gate, ParallelGates):
                 self.component_gates += gate.component_gates
             elif isinstance(gate, cirq.ParallelGate):
                 self.component_gates += gate.num_copies * (gate.sub_gate,)
             else:
                 self.component_gates += (gate,)
 
-    def qubit_index_to_gate_and_index(  # pylint: disable=missing-function-docstring
-        self, index: int
-    ) -> Tuple[cirq.Gate, int]:
+    def _qubit_index_to_gate_and_index(self, index: int) -> Tuple[cirq.Gate, int]:
         for gate in self.component_gates:
             if gate.num_qubits() > index >= 0:
                 return gate, index
             index -= gate.num_qubits()
         raise ValueError("index out of range")
 
     def qubit_index_to_equivalence_group_key(self, index: int) -> int:
-        indexed_gate, index_in_gate = self.qubit_index_to_gate_and_index(index)
+        """Returns a key that differs between qubits.
+
+        Does it by different component gates and non-interchangeable qubits in the same component
+        gate.
+
+        Args:
+            index: The qubit index.
+
+        Returns:
+            Equivalence group key.
+        """
+        indexed_gate, index_in_gate = self._qubit_index_to_gate_and_index(index)
         if indexed_gate.num_qubits() == 1:
             # find the first instance of the same gate
             first_instance = self.component_gates.index(indexed_gate)
             return sum(map(cirq.num_qubits, self.component_gates[:first_instance]))
         if isinstance(indexed_gate, cirq.InterchangeableQubitsGate):
             gate_key = indexed_gate.qubit_index_to_equivalence_group_key(index_in_gate)
             for i in range(index_in_gate):
@@ -542,25 +573,29 @@
         return f"ParallelGates({component_gates_str})"
 
     def __repr__(self) -> str:
         component_gates_repr = ", ".join(repr(gate) for gate in self.component_gates)
         return f"css.ParallelGates({component_gates_repr})"
 
 
-def parallel_gates_operation(  # pylint: disable=missing-raises-doc
-    *ops: cirq.Operation,
-) -> cirq.Operation:
-    """Given operations acting on disjoint qubits, constructs a single css.ParallelGates instance
-    and applies it such that each operation's .gate is applied to its .qubits.
+def parallel_gates_operation(*ops: cirq.Operation) -> cirq.Operation:
+    """Constructs a parallel gates operation.
+
+    Given operations acting on disjoint qubits, constructs a single `css.ParallelGates` instance
+    and applies it such that each operation's `.gate` is applied to its `.qubits`.
 
     Args:
-        ops: operations to pack into a single ParallelGates operation
+        ops: Operations to pack into a single `ParallelGates` operation.
 
     Returns:
         ParallelGates(op.gate, op2.gate, ...).on(*op.qubits, *op2.qubits, ...)
+
+    Raises:
+        ValueError: If the operation has no `.gate` attribute.
+        ValueError: If the operation has tags.
     """
     gates: List[cirq.Gate] = []
     qubits: List[cirq.Qid] = []
     for op in ops:
         if not op.gate:
             raise ValueError(f"Invalid operation: {op} has no .gate attribute")
         if op.tags:
@@ -569,33 +604,36 @@
         gates.append(op.gate)
         qubits.extend(op.qubits)
 
     return ParallelGates(*gates).on(*qubits)
 
 
 class RGate(cirq.PhasedXPowGate):
-    """A single-qubit gate that rotates about an axis in the X-Y plane."""
+    """A single-qubit gate that rotates about an axis in the `X`-`Y` plane."""
 
     def __init__(self, theta: cirq.TParamVal, phi: cirq.TParamVal) -> None:
-        """Args:
-        phi: Angle (in radians) defining the axis of rotation in the `X`-`Y` plane:
-             `cos(phi) X + sin(phi) Y` (i.e. `phi` radians from `X` to `Y`).
+        """Initializes an RGate.
 
-        theta: Angle (in radians) by which to rotate.
+        Args:
+            theta: The angle (in radians) by which to rotate.
+            phi: The angle (in radians) defining the axis of rotation in the `X`-`Y` plane:
+                `cos(phi) X + sin(phi) Y` (i.e. `phi` radians from `X` to `Y`).
         """
         super().__init__(
             exponent=theta / _pi(theta), phase_exponent=phi / _pi(phi), global_shift=-0.5
         )
 
     @property
-    def phi(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def phi(self) -> cirq.TParamVal:
+        """Angle (in radians) defining the axis of rotation in the `X`-`Y` plane."""
         return self.phase_exponent * _pi(self.phase_exponent)
 
     @property
-    def theta(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def theta(self) -> cirq.TParamVal:
+        """Angle (in radians) by which to rotate."""
         return self.exponent * _pi(self.exponent)
 
     def __pow__(self, power: cirq.TParamVal) -> "RGate":
         return RGate(power * self.theta, self.phi)
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         """Implemented here because it isn't in cirq.PhasedXPowGate"""
@@ -636,35 +674,47 @@
 
 
 @cirq.value_equality(approximate=True)
 class ParallelRGate(cirq.ParallelGate, cirq.InterchangeableQubitsGate):
     """Wrapper class to define a ParallelGate of identical RGate gates."""
 
     def __init__(self, theta: cirq.TParamVal, phi: cirq.TParamVal, num_copies: int) -> None:
+        """Initializes the `ParallelRGate` class.
+
+        Args:
+            theta: The RGate angle (in radians) by which to rotate.
+            phi: The RGate angle (in radians) defining the axis of rotation in the `X`-`Y` plane:
+                `cos(phi) X + sin(phi) Y` (i.e. `phi` radians from `X` to `Y`).
+            num_copies: Number of copies to be used.
+        """
         super().__init__(css.RGate(theta, phi), num_copies)
         self._sub_gate: RGate
 
     @property
     def sub_gate(self) -> RGate:
         return self._sub_gate
 
     @property
-    def phase_exponent(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def phase_exponent(self) -> cirq.TParamVal:
+        """The `phase_exponent` property of each `RGate`."""
         return self.sub_gate.phase_exponent
 
     @property
-    def exponent(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def exponent(self) -> cirq.TParamVal:
+        """The `exponent` property of `ParallelRGate`."""
         return self.sub_gate.exponent
 
     @property
-    def phi(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def phi(self) -> cirq.TParamVal:
+        """The `phi` property of `ParallelRGate`."""
         return self.sub_gate.phi
 
     @property
-    def theta(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def theta(self) -> cirq.TParamVal:
+        """The `theta` property of `ParallelRGate`."""
         return self.sub_gate.theta
 
     def __pow__(self, power: cirq.TParamVal) -> "ParallelRGate":
         return ParallelRGate(power * self.theta, self.phi, self.num_copies)
 
     def _equal_up_to_global_phase_(self, other: Any, atol: float) -> Optional[bool]:
         """Implemented here because it isn't in cirq.ParallelGate"""
@@ -697,17 +747,18 @@
         return f"css.ParallelRGate({self.theta}, {self.phi}, {self.num_copies})"
 
     def _json_dict_(self) -> Dict[str, Any]:
         return cirq.obj_to_dict_helper(self, ["theta", "phi", "num_copies"])
 
 
 class IXGate(cirq.XPowGate):
-    """Thin wrapper of Rx(-pi) to improve iToffoli circuit diagrams"""
+    r"""Thin wrapper of :math:`RX(-\pi)` to improve iToffoli circuit diagrams"""
 
     def __init__(self) -> None:
+        """Initializes an iXGate."""
         super().__init__(exponent=1, global_shift=0.5)
 
     def _with_exponent(self, exponent: cirq.value.TParamVal) -> Union[cirq.Rx, "IXGate"]:
         if approx_eq_mod(exponent, 1.0, 4):
             return IXGate()
         return cirq.rx(-exponent * _pi(exponent))
 
@@ -734,25 +785,31 @@
 
 # Open-control iToffoli gate
 AQTICCX = AQTITOFFOLI = IX.controlled(2, [0, 0])
 
 
 @cirq.value_equality(approximate=True)
 class StrippedCZGate(cirq.Gate):
-    """The Stripped CZ Gate is the gate that is actually being performed by Hilbert,
-    which is just a regular CZ gate when the rz angle = 0, and is corrected into a CZ
-    gate by RZ gates afterwards if the rz angle is nonzero.
+    """The Stripped CZ gate is a regular CZ gate when the rz angle = 0.
+
+    It is the gate that is actually being performed by Hilbert, and it is corrected
+    into a CZ gate by RZ gates afterwards if the rz angle is nonzero.
     """
 
     def __init__(self, rz_rads: cirq.TParamVal = 0) -> None:
-        """Args: rz_rads: RZ-rotation angle in radians"""
+        """Initializes a Stripped CZ gate.
+
+        Args:
+            rz_rads: The RZ-rotation angle in radians.
+        """
         self._rz_rads = rz_rads
 
     @property
-    def rz_rads(self) -> cirq.TParamVal:  # pylint: disable=missing-function-docstring
+    def rz_rads(self) -> cirq.TParamVal:
+        """The RZ-rotation angle for the gate."""
         return self._rz_rads
 
     def _num_qubits_(self) -> int:
         return 2
 
     def _unitary_(self) -> Optional[npt.NDArray[np.complex_]]:
         if self._is_parameterized_():
@@ -825,17 +882,26 @@
         p = args.format_radians(self.rz_rads)
         return cirq.CircuitDiagramInfo(wire_symbols=(f"@({p})", f"@({p})"))
 
     def _json_dict_(self) -> Dict[str, Any]:
         return cirq.obj_to_dict_helper(self, ["rz_rads"])
 
 
-def custom_resolver(  # pylint: disable=missing-function-docstring
-    cirq_type: str,
-) -> Union[Type[cirq.Gate], None]:
+def custom_resolver(cirq_type: str) -> Union[Type[cirq.Gate], None]:
+    """Tells `cirq.read_json` how to deserialize `cirq-superstaq`'s custom gates.
+
+    Changes to gate names in this file should be reflected in this resolver.
+    See quantumai.google/cirq/dev/serialization for more information about (de)serialization.
+
+    Args:
+        cirq_type: The string of the gate type for the serializer to resolve.
+
+    Returns:
+        The resolved `cirq.Gate` matching the input, or None if no match.
+    """
     type_to_gate_map: Dict[str, Type[cirq.Gate]] = {
         "ZZSwapGate": ZZSwapGate,
         "Barrier": Barrier,
         "ZXPowGate": ZXPowGate,
         "AceCR": AceCR,
         "ParallelGates": ParallelGates,
         "MSGate": cirq.ops.MSGate,
```

## cirq_superstaq/ops/qubit_gates_test.py

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 import itertools
 import textwrap
 
 import cirq
 import numpy as np
 import pytest
 import sympy
```

## cirq_superstaq/ops/qudit_gates.py

```diff
@@ -313,26 +313,28 @@
 
     def __init__(
         self,
         sub_gate: cirq.Gate,
         qid_shape: Sequence[int],
         subspaces: Optional[Sequence[Tuple[int, int]]] = None,
     ) -> None:
-        """Initializes a QubitSubspaceGate.
+        """Initializes a `QubitSubspaceGate`.
 
         Args:
             sub_gate: The qubit gate to promote to a higher dimension.
             qid_shape: The shape of the new gate (that is, the dimension of each Qid it acts upon).
             subspaces: If provided, the subspace (in the computational basis) of each Qid to act
                 upon. By default applies to the first two levels of each Qid.
 
         Examples:
-            QubitSubspaceGate(cirq.X, (3,)): X gate acting on levels 0 and 1 of a dimension-3 Qid.
-            QubitSubspaceGate(cirq.X, (3,), [(0, 2)]): the same gate acting on levels 0 and 2.
-            QubitSubspaceGate(cirq.CX, (3, 3)): CX gate on the 0-1 subspace of two dimension-3 Qids.
+            `QubitSubspaceGate(cirq.X, (3,))`: An X gate acting on levels 0 and 1 of a dimension-3
+                Qid.
+            `QubitSubspaceGate(cirq.X, (3,), [(0, 2)])`: The same gate acting on levels 0 and 2.
+            `QubitSubspaceGate(cirq.CX, (3, 3))`: A CX gate on the 0-1 subspace of two dimension-3
+                Qids.
         """
 
         if subspaces is None:
             subspaces = [(0, 1)] * cirq.num_qubits(sub_gate)
 
         if not all(d == 2 for d in cirq.qid_shape(sub_gate)):
             raise ValueError("Only qubit gates are supported for sub_gate.")
@@ -490,15 +492,15 @@
 
 def qubit_subspace_op(
     sub_op: cirq.Operation,
     qid_shape: Sequence[int],
     subspaces: Optional[Sequence[Tuple[int, int]]] = None,
 ) -> cirq.Operation:
     """Embed a qubit Operation into a given subspace of a higher-dimensional Operation using
-    QubitSubspaceGate.
+    `QubitSubspaceGate`.
     """
     if not sub_op.gate:
         raise ValueError(f"{sub_op} has no gate.")
 
     qudits = [qubit.with_dimension(d) for qubit, d in zip(sub_op.qubits, qid_shape)]
     return QubitSubspaceGate(sub_op.gate, qid_shape, subspaces=subspaces).on(*qudits)
```

## cirq_superstaq/ops/qudit_gates_test.py

```diff
@@ -1,8 +1,8 @@
-# pylint: disable=missing-function-docstring
+# pylint: disable=missing-function-docstring,missing-class-docstring
 import textwrap
 from typing import List, Optional, Tuple, Type
 from unittest import mock
 
 import cirq
 import numpy as np
 import pytest
```

## Comparing `cirq_superstaq-0.4.0.dist-info/METADATA` & `cirq_superstaq-0.4.1.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,50 +1,46 @@
 Metadata-Version: 2.1
 Name: cirq-superstaq
-Version: 0.4.0
+Version: 0.4.1
 Summary: The Cirq module that provides tools and access to Superstaq
 Home-page: https://github.com/Infleqtion/client-superstaq
 Author: Superstaq development team
 Author-email: superstaq@infleqtion.com
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.8.0
 Description-Content-Type: text/markdown
 Requires-Dist: cirq (>=1.0.0)
-Requires-Dist: general-superstaq (~=0.4.0)
+Requires-Dist: general-superstaq (~=0.4.1)
 Requires-Dist: qubovert (>=1.2.3)
 Provides-Extra: dev
-Requires-Dist: general-superstaq[dev] (~=0.4.0) ; extra == 'dev'
+Requires-Dist: general-superstaq[dev] (~=0.4.1) ; extra == 'dev'
 Requires-Dist: qiskit-terra (~=0.24.0) ; extra == 'dev'
 Requires-Dist: symengine (<0.10.0) ; extra == 'dev'
 Provides-Extra: examples
 Requires-Dist: notebook (~=6.4.12) ; extra == 'examples'
 Requires-Dist: qiskit-terra (~=0.24.0) ; extra == 'examples'
 Requires-Dist: symengine (<0.10.0) ; extra == 'examples'
 
+# `cirq-superstaq`
+
 ![cirq-superstaq's default workflow](https://github.com/Infleqtion/client-superstaq/actions/workflows/ci.yml/badge.svg)
 
 This package is used to access Superstaq via a Web API through [Cirq](https://github.com/quantumlib/Cirq).
 Cirq programmers can take advantage of the applications, pulse level optimizations, and write-once-target-all
 features of Superstaq with this package.
 
-
-Please note that Python version `3.8` or higher is required. `cirq-superstaq` and all of its
-dependencies can be installed via:
+`cirq-superstaq` is [available on PyPI](https://pypi.org/project/cirq-superstaq) and can be installed with:
 
 ```
-python3 -m venv venv_cirq_superstaq
-source venv_cirq_superstaq/bin/activate
 pip install cirq-superstaq
-
-# Run the following to install dev requirements (required if you intend to run checks locally)
-pip install .[dev]
-
 ```
 
+Please note that Python version `3.8` or higher is required. For further installation instructions, see [here](https://github.com/Infleqtion/client-superstaq#readme).
+
 ### Creating and submitting a circuit through cirq-superstaq
 ```python
 import cirq
 import cirq_superstaq as css
 
 q0 = cirq.LineQubit(0)
 q1 = cirq.LineQubit(1)
```

## Comparing `cirq_superstaq-0.4.0.dist-info/RECORD` & `cirq_superstaq-0.4.1.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 cirq_superstaq/__init__.py,sha256=3k89ggq-UI0faFssu36Dy2uKUIgEYnOW7M9IKlPuGJ4,2495
-cirq_superstaq/_version.py,sha256=42STGor_9nKYXumfeV5tiyD_M8VdcddX7CEexmibPBk,22
-cirq_superstaq/_version_test.py,sha256=0cQRR-VB1raAtsIFR9JganIC2qJXbmSDQ-OAr5F8alg,288
-cirq_superstaq/compiler_output.py,sha256=9CqLbna8So1fopvRnZRiWDvyjtb0TXZmNszWvpVeP-k,11725
-cirq_superstaq/compiler_output_test.py,sha256=8N9m6h0m2hv9o_oLIf8nBuPJUmTaTLgzR-_XMDMkqaY,13819
-cirq_superstaq/daily_integration_test.py,sha256=DAWmO7sGPKmyDnOFiIFWk5er5J52qTd0AinvzZhSBt4,9741
+cirq_superstaq/_version.py,sha256=pMtTmSUht-XtbR_7Doz6bsQqopJJd8rZ8I8zy2HwwoA,22
+cirq_superstaq/_version_test.py,sha256=-Wmzugc_ZE6bKbzU36HmcZ49msf9VSrGPqUCAUS72EY,312
+cirq_superstaq/compiler_output.py,sha256=TpLpR3fvPvOls71fRNMsp7spRiLK9KC5_R1KjgaqtII,12248
+cirq_superstaq/compiler_output_test.py,sha256=aQZP7Alaat33CCIS4f1b3NWnFWvink7PSO3FM2jthjw,13843
+cirq_superstaq/daily_integration_test.py,sha256=emBKmE9l5Z9vNOpqENygZJs4tvQKvNLjsjBMM6kfypY,9766
 cirq_superstaq/job.py,sha256=XyTsLr9E-pNnkHQTFsLrxuD0INfLtulXPuc80lYP2Jk,6815
-cirq_superstaq/job_test.py,sha256=iDSdFLfw1iHWE7hDyUqNL9AA8g6r92G07xjhTRYHOzw,6680
+cirq_superstaq/job_test.py,sha256=fMEIHVMm_bR2WiaH9pBtNUsyvaAxdT606pr7LPFpFqY,6704
 cirq_superstaq/py.typed,sha256=2DnKRKK8fmvD_m6TmNUqVJZBNb2xKGaCjcHkkVpRsMc,68
-cirq_superstaq/sampler.py,sha256=EsP6psotyN6t-QIQJwcPm5XQAIt1ZH5QRhRVulkmlHY,3087
-cirq_superstaq/serialization.py,sha256=rdd4cwqOGmvp7X8WKNUPpd8OD2Rr6rI_kAa2PX4lDW0,1398
-cirq_superstaq/serialization_test.py,sha256=SuJYOvuizF75nEi6PD6OdZhKwAc5T1K7u3fi15RFFts,1580
-cirq_superstaq/service.py,sha256=wTkw7mYM1jWN-ob1gCH2BpcBMFghBWkz19FDxzV5xyw,28103
-cirq_superstaq/service_test.py,sha256=gty5KctoGCj0c1S5GKryJ6NgcWR_6vx5lIaZZJb3nAQ,23104
+cirq_superstaq/sampler.py,sha256=_rFeY-uP6DxXNwmsODu7JfwyBImRp4zGKNVyR8b0lWI,3067
+cirq_superstaq/serialization.py,sha256=SnSJNJhGeQMyOF28QRC1IdiRMs649ibuHSNzMcIg34c,1430
+cirq_superstaq/serialization_test.py,sha256=MqQeiYXqAeU99NKg6jezNzxQL2DSpi8Vjl0nZaG333o,1604
+cirq_superstaq/service.py,sha256=G6Y0he8uIAQZ6C_FMKWrTL9ywoz_9SDIJvHhi4LCO_E,28607
+cirq_superstaq/service_test.py,sha256=v0k3Hn1QX7ZRq_S-gq_K-yNf_XD7Ik-0DXDEHamlM8Q,23128
 cirq_superstaq/ops/__init__.py,sha256=CsW8WwyPL4jSfiUG3CrukZW-6YR7uOJvTVxiO5e4uiU,1297
-cirq_superstaq/ops/qubit_gates.py,sha256=9rVqcBJg-9ZCMaQiQJpZe3ES--nsgLfVYdTdzNNMeZk,31937
-cirq_superstaq/ops/qubit_gates_test.py,sha256=_G_RQ_ImXnUxMZ47QTz1X-xhqsgVOb-Z9Ulr-GPrN60,38554
-cirq_superstaq/ops/qudit_gates.py,sha256=htPb2_MiVuDkvKgzp2isNMrhLScO0VgcK5SFmRZqMnc,19196
-cirq_superstaq/ops/qudit_gates_test.py,sha256=OaGNeEpAyBdKTJQTK9e-nNVvndNAB0Dwa9NewzbfDYU,16965
-cirq_superstaq-0.4.0.dist-info/METADATA,sha256=azvhia6AByjpb7DtAm64Sr-K1oJlo_6uVBPBuLSojEk,2329
-cirq_superstaq-0.4.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-cirq_superstaq-0.4.0.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
-cirq_superstaq-0.4.0.dist-info/RECORD,,
+cirq_superstaq/ops/qubit_gates.py,sha256=DPtVT8GQzhjVb_Q4UHQqNkQFf14m_iHGqm1PF2f2p_8,33936
+cirq_superstaq/ops/qubit_gates_test.py,sha256=8v3YyJsK23uscIu5S93YjPk3h9TRirrIgwGsVb_1Tvs,38578
+cirq_superstaq/ops/qudit_gates.py,sha256=ES9zw1SqNGnQeBQi44qqn4pHcWjOPBr5s0R4HzgkiTQ,19243
+cirq_superstaq/ops/qudit_gates_test.py,sha256=pkQAviY-GsYRUyRVjfK1dWlQ5VjlX_3U3c4VU64y8co,16989
+cirq_superstaq-0.4.1.dist-info/METADATA,sha256=uIOMkFPWKpZg39ciEE4GvGgiP-M0oft0RqsInPGCeTc,2304
+cirq_superstaq-0.4.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+cirq_superstaq-0.4.1.dist-info/top_level.txt,sha256=x5zxwcSj8lK-JlK4DsVnr_uEeiPoaZG2wokltTJQrJY,15
+cirq_superstaq-0.4.1.dist-info/RECORD,,
```

